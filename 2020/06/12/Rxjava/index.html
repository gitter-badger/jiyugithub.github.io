
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rxjava只看这一篇文章就够了 - Apocalypse&#39;s Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Android Kotlin Java,"> 
    <meta name="description" content="0. 简介RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。
RxJava 有以下三个基本的元,"> 
    <meta name="author" content="Apocalypse"> 
    <link rel="alternative" href="atom.xml" title="Apocalypse&#39;s Blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link href="https://fonts.loli.net/css?family=Roboto+Mono|Rubik&display=swap" rel="stylesheet">
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

<meta name="generator" content="Hexo 4.2.1"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">Apocalypse&#39;s Blog</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://jiyugithub.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">Rxjava只看这一篇文章就够了</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(/assets/title.jpg);">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="javascript:;"><b>「 </b>Article<b> 」</b></a>
                
                June 12, 2020
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2020/06/12/Rxjava/" title="Rxjava只看这一篇文章就够了" class="">Rxjava只看这一篇文章就够了</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    138k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    2:06
                </span>
                
                
                <span id="/2020/06/12/Rxjava/" class="leancloud_visitors" data-flag-title="Rxjava只看这一篇文章就够了">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <i class="leancloud-visitors-count">1000000</i>
                </span>
                
                
            </p>
            
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p>RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。</p>
<p>RxJava 有以下三个基本的元素：</p>
<ol>
<li>被观察者（Observable）</li>
<li>观察者（Observer）</li>
<li>订阅（subscribe）</li>
</ol>
<p>下面来说说以上三者是如何协作的：</p>
<p>首先在 gradle 文件中添加依赖：</p>
<pre><code>implementation &#39;io.reactivex.rxjava2:rxjava:2.1.4&#39;
implementation &#39;io.reactivex.rxjava2:rxandroid:2.0.2&#39;
</code></pre><ol>
<li>创建被观察者：</li>
</ol>
<pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
});
</code></pre><ol>
<li>创建观察者：</li>
</ol>
<pre><code>Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
};
</code></pre><ol>
<li>订阅</li>
</ol>
<pre><code>observable.subscribe(observer);
</code></pre><p>这里其实也可以使用链式调用：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>被观察者发送的事件有以下几种，总结如下表：</p>
<table>
<thead>
<tr>
<th>事件种类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>onNext()</td>
<td>发送该事件时，观察者会回调 onNext() 方法</td>
</tr>
<tr>
<td>onError()</td>
<td>发送该事件时，观察者会回调 onError() 方法，当发送该事件之后，其他事件将不会继续发送</td>
</tr>
<tr>
<td>onComplete()</td>
<td>发送该事件时，观察者会回调 onComplete() 方法，当发送该事件之后，其他事件将不会继续发送</td>
</tr>
</tbody></table>
<p>其实可以把 RxJava 比喻成一个做果汁，家里有很多种水果（要发送的原始数据），你想榨点水果汁喝一下，这时候你就要想究竟要喝什么水果汁呢？如果你想喝牛油果雪梨柠檬汁，那你就要把这三种水果混在一起榨汁（使用各种操作符变换你想发送给观察者的数据），榨完后，你就可以喝上你想要的果汁了（把处理好的数据发送给观察者）。</p>
<p>总结如下图：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="737" height="188"></svg>)</p>
<p>下面就来讲解 RxJava 各种常见的操作符。</p>
<h1 id="1-创建操作符"><a href="#1-创建操作符" class="headerlink" title="1. 创建操作符"></a>1. 创建操作符</h1><p>以下就是讲解创建被观察者的各种操作符。</p>
<h2 id="1-1-create"><a href="#1-1-create" class="headerlink" title="1.1 create()"></a>1.1 create()</h2><h4 id="方法预览："><a href="#方法预览：" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)
</code></pre><h4 id="有什么用："><a href="#有什么用：" class="headerlink" title="有什么用："></a>有什么用：</h4><p>创建一个被观察者</p>
<h4 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h4><pre><code>Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception {
        e.onNext(&quot;Hello Observer&quot;);
        e.onComplete();
    }
});
</code></pre><p>上面的代码非常简单，创建 ObservableOnSubscribe 并重写其 subscribe 方法，就可以通过 ObservableEmitter 发射器向观察者发送事件。</p>
<p>以下创建一个观察者，来验证这个被观察者是否成功创建。</p>
<pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(&quot;chan&quot;,&quot;=============onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        Log.d(&quot;chan&quot;,&quot;=============onComplete &quot;);
    }
};

observable.subscribe(observer);

</code></pre><p>打印结果：</p>
<pre><code>05-20 16:16:50.654 22935-22935/com.example.louder.rxjavademo D/chan: =============onNext Hello Observer
=============onComplete
</code></pre><h2 id="1-2-just"><a href="#1-2-just" class="headerlink" title="1.2 just()"></a>1.2 just()</h2><h4 id="方法预览：-1"><a href="#方法预览：-1" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; just(T item) 
......
public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10)
</code></pre><h4 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p>
<h4 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});

</code></pre><p>上面的代码直接使用链式调用，代码也非常简单，这里就不细说了，看看打印结果：</p>
<pre><code>05-20 16:27:26.938 23281-23281/? D/chan: =================onSubscribe
=================onNext 1
=================onNext 2
=================onNext 3
=================onComplete 
</code></pre><h2 id="1-3-From-操作符"><a href="#1-3-From-操作符" class="headerlink" title="1.3 From 操作符"></a>1.3 From 操作符</h2><h2 id="1-3-1-fromArray"><a href="#1-3-1-fromArray" class="headerlink" title="1.3.1  fromArray()"></a>1.3.1  fromArray()</h2><h4 id="方法预览：-2"><a href="#方法预览：-2" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items)
</code></pre><h4 id="有什么用？-1"><a href="#有什么用？-1" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p>
<h4 id="怎么用？-1"><a href="#怎么用？-1" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Integer array[] = {1, 2, 3, 4};
Observable.fromArray(array)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});
</code></pre><p>代码和 just() 基本上一样，直接看打印结果：</p>
<pre><code>05-20 16:35:23.797 23574-23574/com.example.louder.rxjavademo D/chan: =================onSubscribe
=================onNext 1
=================onNext 2
=================onNext 3
=================onNext 4
=================onComplete 
</code></pre><h2 id="1-3-2-fromCallable"><a href="#1-3-2-fromCallable" class="headerlink" title="1.3.2 fromCallable()"></a>1.3.2 fromCallable()</h2><h4 id="方法预览：-3"><a href="#方法预览：-3" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier)
</code></pre><h4 id="有什么用？-2"><a href="#有什么用？-2" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p>
<h4 id="怎么用？-2"><a href="#怎么用？-2" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.fromCallable(new Callable &lt; Integer &gt; () {

    @Override
    public Integer call() throws Exception {
        return 1;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 13:01:43.009 6890-6890/? D/chan: ================accept 1
</code></pre><h2 id="1-3-3-fromFuture"><a href="#1-3-3-fromFuture" class="headerlink" title="1.3.3 fromFuture()"></a>1.3.3 fromFuture()</h2><h4 id="方法预览：-4"><a href="#方法预览：-4" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)
</code></pre><h4 id="有什么用？-3"><a href="#有什么用？-3" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p>
<h4 id="怎么用？-3"><a href="#怎么用？-3" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>FutureTask &lt; String &gt; futureTask = new FutureTask &lt; &gt; (new Callable &lt; String &gt; () {
    @Override
    public String call() throws Exception {
        Log.d(TAG, &quot;CallableDemo is Running&quot;);
        return &quot;返回结果&quot;;
    }
});

Observable.fromFuture(futureTask)
    .doOnSubscribe(new Consumer &lt; Disposable &gt; () {
    @Override
    public void accept(Disposable disposable) throws Exception {
        futureTask.run();
    }
})
.subscribe(new Consumer &lt; String &gt; () {
    @Override
    public void accept(String s) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + s);
    }
});
</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件，具体会在下面讲解。</p>
<p>打印结果：</p>
<pre><code>05-26 13:54:00.470 14429-14429/com.example.rxjavademo D/chan: CallableDemo is Running
================accept 返回结果
</code></pre><h2 id="1-3-4-fromIterable"><a href="#1-3-4-fromIterable" class="headerlink" title="1.3.4 fromIterable()"></a>1.3.4 fromIterable()</h2><h4 id="方法预览：-5"><a href="#方法预览：-5" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source)
</code></pre><h4 id="有什么用？-4"><a href="#有什么用？-4" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>直接发送一个 List 集合数据给观察者</p>
<h4 id="怎么用？-4"><a href="#怎么用？-4" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(0);
list.add(1);
list.add(2);
list.add(3);
Observable.fromIterable(list)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});
</code></pre><p>打印结果如下：</p>
<pre><code>05-20 16:43:28.874 23965-23965/? D/chan: =================onSubscribe
=================onNext 0
=================onNext 1
=================onNext 2
=================onNext 3
=================onComplete 

</code></pre><h2 id="1-4-defer"><a href="#1-4-defer" class="headerlink" title="1.4 defer()"></a>1.4 defer()</h2><h4 id="方法预览：-6"><a href="#方法预览：-6" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)
</code></pre><h4 id="有什么用？-5"><a href="#有什么用？-5" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p>
<h4 id="怎么用？-5"><a href="#怎么用？-5" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>// i 要定义为成员变量
Integer i = 100;

Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; call() throws Exception {
        return Observable.just(i);
    }
});

i = 200;

Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
};

observable.subscribe(observer);

i = 300;

observable.subscribe(observer);
</code></pre><p>打印结果如下：</p>
<pre><code>05-20 20:05:01.443 26622-26622/? D/chan: ================onNext 200
================onNext 300
</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p>
<h2 id="1-5-timer"><a href="#1-5-timer" class="headerlink" title="1.5 timer()"></a>1.5 timer()</h2><h4 id="方法预览：-7"><a href="#方法预览：-7" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) 
......
</code></pre><h4 id="有什么用？-6"><a href="#有什么用？-6" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当到指定时间后就会发送一个 0L 的值给观察者。</p>
<h4 id="怎么用？-6"><a href="#怎么用？-6" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.timer(2, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;===============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-20 20:27:48.004 27204-27259/com.example.louder.rxjavademo D/chan: ===============onNext 0
</code></pre><h2 id="1-6-interval"><a href="#1-6-interval" class="headerlink" title="1.6 interval()"></a>1.6 interval()</h2><h4 id="方法预览：-8"><a href="#方法预览：-8" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)
public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)
......
</code></pre><h4 id="有什么用？-7"><a href="#有什么用？-7" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p>
<h4 id="怎么用？-7"><a href="#怎么用？-7" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.interval(4, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-20 20:48:10.321 28723-28723/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-20 20:48:14.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 0
05-20 20:48:18.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 1
05-20 20:48:22.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-20 20:48:26.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-20 20:48:30.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-20 20:48:34.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 5
</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p>
<h2 id="1-7-intervalRange"><a href="#1-7-intervalRange" class="headerlink" title="1.7 intervalRange()"></a>1.7 intervalRange()</h2><h4 id="方法预览：-9"><a href="#方法预览：-9" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)
public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)
</code></pre><h4 id="有什么用？-8"><a href="#有什么用？-8" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p>
<h4 id="怎么用？-8"><a href="#怎么用？-8" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.intervalRange(2, 5, 2, 1, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 00:03:01.672 2504-2504/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-21 00:03:03.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-21 00:03:04.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-21 00:03:05.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-21 00:03:06.673 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 5
05-21 00:03:07.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 6
</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p>
<h2 id="1-8-range"><a href="#1-8-range" class="headerlink" title="1.8 range()"></a>1.8 range()</h2><h4 id="方法预览：-10"><a href="#方法预览：-10" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static Observable&lt;Integer&gt; range(final int start, final int count)
</code></pre><h4 id="有什么用？-9"><a href="#有什么用？-9" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>同时发送一定范围的事件序列。</p>
<h4 id="怎么用？-9"><a href="#怎么用？-9" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.range(2, 5)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 00:09:17.202 2921-2921/? D/chan: ==============onSubscribe 
==============onNext 2
==============onNext 3
==============onNext 4
==============onNext 5
==============onNext 6
</code></pre><h2 id="1-9-rangeLong"><a href="#1-9-rangeLong" class="headerlink" title="1.9 rangeLong()"></a>1.9 rangeLong()</h2><h4 id="方法预览：-11"><a href="#方法预览：-11" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static Observable&lt;Long&gt; rangeLong(long start, long count)
</code></pre><h4 id="有什么用？-10"><a href="#有什么用？-10" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>作用与 range() 一样，只是数据类型为 Long</p>
<h4 id="怎么用？-10"><a href="#怎么用？-10" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>用法与 range() 一样，这里就不再赘述了。</p>
<h2 id="1-10-empty-amp-never-amp-error"><a href="#1-10-empty-amp-never-amp-error" class="headerlink" title="1.10 empty() &amp; never() &amp; error()"></a>1.10 empty() &amp; never() &amp; error()</h2><h4 id="方法预览：-12"><a href="#方法预览：-12" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; empty()
public static &lt;T&gt; Observable&lt;T&gt; never()
public static &lt;T&gt; Observable&lt;T&gt; error(final Throwable exception)
</code></pre><h4 id="有什么用？-11"><a href="#有什么用？-11" class="headerlink" title="有什么用？"></a>有什么用？</h4><ol>
<li>empty() ： 直接发送 onComplete() 事件</li>
<li>never()：不发送任何事件</li>
<li>error()：发送 onError() 事件</li>
</ol>
<h4 id="怎么用？-11"><a href="#怎么用？-11" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.empty()
.subscribe(new Observer &lt; Object &gt; () {

    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe&quot;);
    }

    @Override
    public void onNext(Object o) {
        Log.d(TAG, &quot;==================onNext&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 14:06:11.881 15798-15798/com.example.rxjavademo D/chan: ==================onSubscribe
==================onComplete
</code></pre><p>换成 never() 的打印结果：</p>
<pre><code>05-26 14:12:17.554 16805-16805/com.example.rxjavademo D/chan: ==================onSubscribe
</code></pre><p>换成 error() 的打印结果：</p>
<pre><code>05-26 14:12:58.483 17817-17817/com.example.rxjavademo D/chan: ==================onSubscribe
==================onError java.lang.NullPointerException
</code></pre><h1 id="2-转换操作符"><a href="#2-转换操作符" class="headerlink" title="2. 转换操作符"></a>2. 转换操作符</h1><h2 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1 map()"></a>2.1 map()</h2><h4 id="方法预览：-13"><a href="#方法预览：-13" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)
</code></pre><h4 id="有什么用？-12"><a href="#有什么用？-12" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>map 可以将被观察者发送的数据类型转变成其他的类型</p>
<h4 id="怎么用？-12"><a href="#怎么用？-12" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>以下代码将 Integer 类型的数据转换成 String。</p>
<pre><code>Observable.just(1, 2, 3)
.map(new Function &lt; Integer, String &gt; () {
    @Override
    public String apply(Integer integer) throws Exception {
        return &quot;I&#39;m &quot; + integer;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.e(TAG, &quot;===================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.e(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 09:16:03.490 5700-5700/com.example.rxjavademo E/chan: ===================onSubscribe
===================onNext I&#39;m 1
===================onNext I&#39;m 2
===================onNext I&#39;m 3
</code></pre><h2 id="2-2-flatMap"><a href="#2-2-flatMap" class="headerlink" title="2.2 flatMap()"></a>2.2 flatMap()</h2><h4 id="方法预览：-14"><a href="#方法预览：-14" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
......
</code></pre><h4 id="有什么用？-13"><a href="#有什么用？-13" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。</p>
<h4 id="怎么用？-13"><a href="#怎么用？-13" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。现在用一个例子来说明 flatMap() 的用法。</p>
<p>假设一个有一个 Person 类，这个类的定义如下：</p>
<pre><code>public class Person {

    private String name;
    private List&lt;Plan&gt; planList = new ArrayList&lt;&gt;();

    public Person(String name, List&lt;Plan&gt; planList) {
        this.name = name;
        this.planList = planList;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List&lt;Plan&gt; getPlanList() {
        return planList;
    }

    public void setPlanList(List&lt;Plan&gt; planList) {
        this.planList = planList;
    }

}
</code></pre><p>Person 类有一个 name 和 planList 两个变量，分别代表的是人名和计划清单。</p>
<p>Plan 类的定义如下：</p>
<pre><code>public class Plan {

    private String time;
    private String content;
    private List&lt;String&gt; actionList = new ArrayList&lt;&gt;();

    public Plan(String time, String content) {
        this.time = time;
        this.content = content;
    }

    public String getTime() {
        return time;
    }

    public void setTime(String time) {
        this.time = time;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public List&lt;String&gt; getActionList() {
        return actionList;
    }

    public void setActionList(List&lt;String&gt; actionList) {
        this.actionList = actionList;
    }
}
</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。 首先用 map() 来实现这个需求看看：</p>
<pre><code>Observable.fromIterable(personList)
.map(new Function &lt; Person, List &lt; Plan &gt;&gt; () {
    @Override
    public List &lt; Plan &gt; apply(Person person) throws Exception {
        return person.getPlanList();
    }
})
.subscribe(new Observer &lt; List &lt; Plan &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Plan &gt; plans) {
        for (Plan plan: plans) {
            List &lt; String &gt; planActionList = plan.getActionList();
            for (String action: planActionList) {
                Log.d(TAG, &quot;==================action &quot; + action);
            }
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。</p>
<p>现在看下使用 flatMap() 实现：</p>
<pre><code>Observable.fromIterable(personList)
.flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {
    @Override
    public ObservableSource &lt; Plan &gt; apply(Person person) {
        return Observable.fromIterable(person.getPlanList());
    }
})
.flatMap(new Function &lt; Plan, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Plan plan) throws Exception {
        return Observable.fromIterable(plan.getActionList());
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================action: &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p>
<h2 id="2-3-concatMap"><a href="#2-3-concatMap" class="headerlink" title="2.3 concatMap()"></a>2.3 concatMap()</h2><h4 id="方法预览：-15"><a href="#方法预览：-15" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch)
</code></pre><h4 id="有什么用？-14"><a href="#有什么用？-14" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>concatMap() 和 flatMap() 基本上是一样的，只不过 concatMap() 转发出来的事件是有序的，而 flatMap() 是无序的。</p>
<h4 id="怎么用？-14"><a href="#怎么用？-14" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>还是使用上面 flatMap() 的例子来讲解，首先来试下 flatMap() 来验证发送的事件是否是无序的，代码如下：</p>
<pre><code>Observable.fromIterable(personList)
.flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {
    @Override
    public ObservableSource &lt; Plan &gt; apply(Person person) {
        if (&quot;chan&quot;.equals(person.getName())) {
            return Observable.fromIterable(person.getPlanList()).delay(10, TimeUnit.MILLISECONDS);
        }
        return Observable.fromIterable(person.getPlanList());
    }
})
.subscribe(new Observer &lt; Plan &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Plan plan) {
        Log.d(TAG, &quot;==================plan &quot; + plan.getContent());
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>为了更好的验证 flatMap 是无序的，使用了一个 delay() 方法来延迟，直接看打印结果：</p>
<pre><code>05-21 13:57:14.031 21616-21616/com.example.rxjavademo D/chan: ==================plan chan 上课
==================plan chan 写作业
==================plan chan 打篮球
05-21 13:57:14.041 21616-21641/com.example.rxjavademo D/chan: ==================plan Zede 开会
==================plan Zede 写代码
==================plan Zede 写文章
</code></pre><p>可以看到本来 Zede 的事件发送顺序是排在 chan 事件之前，但是经过延迟后， 这两个事件序列发送顺序互换了。</p>
<p>现在来验证下 concatMap() 是否是有序的，使用上面同样的代码，只是把 flatMap() 换成 concatMap()，打印结果如下：</p>
<pre><code>05-21 13:58:42.917 21799-21823/com.example.rxjavademo D/chan: ==================plan Zede 开会
==================plan Zede 写代码
==================plan Zede 写文章
==================plan chan 上课
==================plan chan 写作业
==================plan chan 打篮球
</code></pre><p>这就代表 concatMap() 转换后发送的事件序列是有序的了。</p>
<h2 id="2-4-buffer"><a href="#2-4-buffer" class="headerlink" title="2.4 buffer()"></a>2.4 buffer()</h2><h4 id="方法预览：-16"><a href="#方法预览：-16" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip)
......
</code></pre><h4 id="有什么用？-15"><a href="#有什么用？-15" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p>
<h4 id="怎么用？-15"><a href="#怎么用？-15" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>buffer 有两个参数，一个是 count，另一个 skip。count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素。这样说可能还是有点抽象，直接看代码：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.buffer(2, 1)
.subscribe(new Observer &lt; List &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Integer &gt; integers) {
        Log.d(TAG, &quot;================缓冲区大小： &quot; + integers.size());
        for (Integer i: integers) {
            Log.d(TAG, &quot;================元素： &quot; + i);
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 14:09:34.015 22421-22421/com.example.rxjavademo D/chan: ================缓冲区大小： 2
================元素： 1
================元素： 2
================缓冲区大小： 2
================元素： 2
================元素： 3
================缓冲区大小： 2
================元素： 3
================元素： 4
================缓冲区大小： 2
================元素： 4
================元素： 5
================缓冲区大小： 1
================元素： 5
</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p>
<h2 id="2-5-groupBy"><a href="#2-5-groupBy" class="headerlink" title="2.5 groupBy()"></a>2.5 groupBy()</h2><h4 id="方法预览：-17"><a href="#方法预览：-17" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector)
</code></pre><h4 id="有什么用？-16"><a href="#有什么用？-16" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p>
<h4 id="怎么用？-16"><a href="#怎么用？-16" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(5, 2, 3, 4, 1, 6, 8, 9, 7, 10)
.groupBy(new Function &lt; Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer) throws Exception {
        return integer % 3;
    }
})
.subscribe(new Observer &lt; GroupedObservable &lt; Integer, Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;====================onSubscribe &quot;);
    }

    @Override
    public void onNext(GroupedObservable &lt; Integer, Integer &gt; integerIntegerGroupedObservable) {
        Log.d(TAG, &quot;====================onNext &quot;);
        integerIntegerGroupedObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;====================GroupedObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;====================GroupedObservable onNext  groupName: &quot; + integerIntegerGroupedObservable.getKey() + &quot; value: &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;====================GroupedObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;====================GroupedObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;====================onComplete &quot;);
    }
});
</code></pre><p>在 groupBy() 方法返回的参数是分组的名字，每返回一个值，那就代表会创建一个组，以上的代码就是将1~10的数据分成3组，来看看打印结果：</p>
<pre><code>05-26 14:38:02.062 21451-21451/com.example.rxjavademo D/chan: ====================onSubscribe 
05-26 14:38:02.063 21451-21451/com.example.rxjavademo D/chan: ====================onNext 
====================GroupedObservable onSubscribe     ====================GroupedObservable onNext  groupName: 2 value: 5
====================GroupedObservable onNext  groupName: 2 value: 2
====================onNext 
====================GroupedObservable onSubscribe 
====================GroupedObservable onNext  groupName: 0 value: 3
05-26 14:38:02.064 21451-21451/com.example.rxjavademo D/chan: ====================onNext 
====================GroupedObservable onSubscribe 
====================GroupedObservable onNext  groupName: 1 value: 4
====================GroupedObservable onNext  groupName: 1 value: 1
====================GroupedObservable onNext  groupName: 0 value: 6
====================GroupedObservable onNext  groupName: 2 value: 8
====================GroupedObservable onNext  groupName: 0 value: 9
====================GroupedObservable onNext  groupName: 1 value: 7
====================GroupedObservable onNext  groupName: 1 value: 10
05-26 14:38:02.065 21451-21451/com.example.rxjavademo D/chan: ====================GroupedObservable onComplete 
====================GroupedObservable onComplete 
====================GroupedObservable onComplete 
====================onComplete 
</code></pre><p>可以看到返回的结果中是有3个组的。</p>
<h2 id="2-6-scan"><a href="#2-6-scan" class="headerlink" title="2.6 scan()"></a>2.6 scan()</h2><h4 id="方法预览：-18"><a href="#方法预览：-18" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator)
</code></pre><h4 id="有什么用？-17"><a href="#有什么用？-17" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将数据以一定的逻辑聚合起来。</p>
<h4 id="怎么用？-17"><a href="#怎么用？-17" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4, 5)
.scan(new BiFunction &lt; Integer, Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer, Integer integer2) throws Exception {
        Log.d(TAG, &quot;====================apply &quot;);
        Log.d(TAG, &quot;====================integer &quot; + integer);
        Log.d(TAG, &quot;====================integer2 &quot; + integer2);
        return integer + integer2;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 14:45:27.784 22519-22519/com.example.rxjavademo D/chan: ====================accept 1
====================apply 
====================integer 1
====================integer2 2
====================accept 3
====================apply 
05-26 14:45:27.785 22519-22519/com.example.rxjavademo D/chan: ====================integer 3
====================integer2 3
====================accept 6
====================apply 
====================integer 6
====================integer2 4
====================accept 10
====================apply 
====================integer 10
====================integer2 5
====================accept 15
</code></pre><h2 id="2-7-window"><a href="#2-7-window" class="headerlink" title="2.7 window()"></a>2.7 window()</h2><h4 id="方法预览：-19"><a href="#方法预览：-19" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;Observable&lt;T&gt;&gt; window(long count)
......
</code></pre><h4 id="有什么用？-18"><a href="#有什么用？-18" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p>
<h4 id="怎么用？-18"><a href="#怎么用？-18" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4, 5)
.window(2)
.subscribe(new Observer &lt; Observable &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=====================onSubscribe &quot;);
    }

    @Override
    public void onNext(Observable &lt; Integer &gt; integerObservable) {
        integerObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;=====================integerObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;=====================integerObservable onNext &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;=====================integerObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;=====================integerObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=====================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 15:02:20.654 25838-25838/com.example.rxjavademo D/chan: =====================onSubscribe 
05-26 15:02:20.655 25838-25838/com.example.rxjavademo D/chan: =====================integerObservable onSubscribe 
05-26 15:02:20.656 25838-25838/com.example.rxjavademo D/chan: =====================integerObservable onNext 1
=====================integerObservable onNext 2
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 3
=====================integerObservable onNext 4
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 5
=====================integerObservable onComplete 
=====================onComplete 
</code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p>
<h1 id="3-组合操作符"><a href="#3-组合操作符" class="headerlink" title="3. 组合操作符"></a>3. 组合操作符</h1><h2 id="3-1-concat"><a href="#3-1-concat" class="headerlink" title="3.1 concat()"></a>3.1 concat()</h2><h4 id="方法预览：-20"><a href="#方法预览：-20" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
......
</code></pre><h4 id="有什么用？-19"><a href="#有什么用？-19" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p>
<h4 id="怎么用？-19"><a href="#怎么用？-19" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.concat(Observable.just(1, 2),
Observable.just(3, 4),
Observable.just(5, 6),
Observable.just(7, 8))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印如下：</p>
<pre><code>05-21 15:40:26.738 7477-7477/com.example.rxjavademo D/chan: ================onNext 1
================onNext 2
05-21 15:40:26.739 7477-7477/com.example.rxjavademo D/chan: ================onNext 3
================onNext 4
================onNext 5
================onNext 6
================onNext 7
================onNext 8
</code></pre><h2 id="3-2-concatArray"><a href="#3-2-concatArray" class="headerlink" title="3.2 concatArray()"></a>3.2 concatArray()</h2><h4 id="方法预览：-21"><a href="#方法预览：-21" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource&lt;? extends T&gt;... sources)
</code></pre><h4 id="有什么用？-20"><a href="#有什么用？-20" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 concat()  作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p>
<h4 id="怎么用？-20"><a href="#怎么用？-20" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.concatArray(Observable.just(1, 2),
Observable.just(3, 4),
Observable.just(5, 6),
Observable.just(7, 8),
Observable.just(9, 10))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 15:47:18.581 9129-9129/com.example.rxjavademo D/chan: ================onNext 1
================onNext 2
================onNext 3
================onNext 4
================onNext 5
================onNext 6
================onNext 7
================onNext 8
================onNext 9
================onNext 10
</code></pre><h2 id="3-3-merge"><a href="#3-3-merge" class="headerlink" title="3.3 merge()"></a>3.3 merge()</h2><h4 id="方法预览：-22"><a href="#方法预览：-22" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code> public static &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
......
</code></pre><h4 id="有什么用？-21"><a href="#有什么用？-21" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法月 concat() 作用基本一样，知识 concat() 是串行发送事件，而 merge() 并行发送事件。</p>
<h4 id="怎么用？-21"><a href="#怎么用？-21" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>现在来演示 concat() 和 merge() 的区别。</p>
<pre><code>Observable.merge(
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;A&quot; + aLong;
    }
}),
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;B&quot; + aLong;
    }
}))
    .subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;=====================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果如下：</p>
<pre><code>05-21 16:10:31.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B0
05-21 16:10:31.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:10:32.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:10:32.126 12801-12850/com.example.rxjavademo D/chan: =====================onNext B1
05-21 16:10:33.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:10:33.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B2
05-21 16:10:34.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:10:34.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B3
05-21 16:10:35.124 12801-12849/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:10:35.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B4
05-21 16:10:36.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A5
05-21 16:10:36.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B5
......
</code></pre><p>从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：</p>
<pre><code>05-21 16:17:52.352 14597-14621/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:17:53.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:17:54.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:17:55.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:17:56.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:17:57.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A5
......
</code></pre><p>从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。</p>
<p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者，这里就不再赘述了。</p>
<h2 id="3-4-concatArrayDelayError-amp-mergeArrayDelayError"><a href="#3-4-concatArrayDelayError-amp-mergeArrayDelayError" class="headerlink" title="3.4 concatArrayDelayError() &amp; mergeArrayDelayError()"></a>3.4 concatArrayDelayError() &amp; mergeArrayDelayError()</h2><h4 id="方法预览：-23"><a href="#方法预览：-23" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
public static &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
</code></pre><h4 id="有什么用？-22"><a href="#有什么用？-22" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 onError() 事件延迟到所有被观察者都发送完事件后再执行的话，就可以使用  concatArrayDelayError() 和 mergeArrayDelayError()</p>
<h4 id="怎么用？-22"><a href="#怎么用？-22" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>首先使用 concatArray() 来验证一下发送 onError() 事件是否会中断其他被观察者发送事件，代码如下：</p>
<pre><code>Observable.concatArray(
Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onError(new NumberFormatException());
    }
}), Observable.just(2, 3, 4))
    .subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 16:38:59.725 17985-17985/com.example.rxjavademo D/chan: ===================onNext 1
===================onError 
</code></pre><p>从结果可以知道，确实中断了，现在换用 concatArrayDelayError()，代码如下：</p>
<pre><code>Observable.concatArrayDelayError(
Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onError(new NumberFormatException());
    }
}), Observable.just(2, 3, 4))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果如下：</p>
<pre><code>05-21 16:40:59.329 18199-18199/com.example.rxjavademo D/chan: ===================onNext 1
===================onNext 2
===================onNext 3
===================onNext 4
===================onError 
</code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用，这里不再赘述。</p>
<h2 id="3-5-zip"><a href="#3-5-zip" class="headerlink" title="3.5 zip()"></a>3.5 zip()</h2><h4 id="方法预览：-24"><a href="#方法预览：-24" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper)
......
</code></pre><h4 id="有什么用？-23"><a href="#有什么用？-23" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p>
<h4 id="怎么用？-23"><a href="#怎么用？-23" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.zip(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS)
    .map(new Function&lt;Long, String&gt;() {
        @Override
        public String apply(Long aLong) throws Exception {
            String s1 = &quot;A&quot; + aLong;
            Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
            return s1;
        }}),
        Observable.intervalRange(1, 6, 1, 1, TimeUnit.SECONDS)
            .map(new Function&lt;Long, String&gt;() {
            @Override
            public String apply(Long aLong) throws Exception {
                String s2 = &quot;B&quot; + aLong;
                Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
                return s2;
            }
        }),
        new BiFunction&lt;String, String, String&gt;() {
            @Override
            public String apply(String s, String s2) throws Exception {
                String res = s + s2;
                return res;
            }
        })
.subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：</p>
<pre><code>05-22 09:10:39.952 5338-5338/com.example.rxjavademo D/chan: ===================onSubscribe 
05-22 09:10:40.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 09:10:40.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
===================onNext A1B1
05-22 09:10:41.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 09:10:41.954 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
===================onNext A2B2
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
05-22 09:10:42.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================onNext A3B3
05-22 09:10:43.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 09:10:43.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 09:10:43.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A4B4
05-22 09:10:44.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A5
05-22 09:10:44.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 09:10:44.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A5B5
===================onComplete 
</code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p>
<h2 id="3-6-combineLatest-amp-combineLatestDelayError"><a href="#3-6-combineLatest-amp-combineLatestDelayError" class="headerlink" title="3.6 combineLatest() &amp;  combineLatestDelayError()"></a>3.6 combineLatest() &amp;  combineLatestDelayError()</h2><h4 id="方法预览：-25"><a href="#方法预览：-25" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner)
....... 
</code></pre><h4 id="有什么用？-24"><a href="#有什么用？-24" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送，这样可能还是比较抽象，看看以下例子代码。</p>
<h4 id="怎么用？-24"><a href="#怎么用？-24" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.combineLatest(
Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s1 = &quot;A&quot; + aLong;
        Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
        return s1;
    }
}),
Observable.intervalRange(1, 5, 2, 2, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s2 = &quot;B&quot; + aLong;
        Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
        return s2;
    }
}),
new BiFunction &lt; String, String, String &gt; () {@Override
    public String apply(String s, String s2) throws Exception {
        String res = s + s2;
        return res;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================最终接收到的事件 &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：</p>
<pre><code>05-22 11:41:20.859 15104-15104/? D/chan: ===================onSubscribe 
05-22 11:41:21.859 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 11:41:22.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 11:41:22.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
05-22 11:41:22.862 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1
05-22 11:41:23.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
===================最终接收到的事件 A3B1
05-22 11:41:24.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
05-22 11:41:24.861 15104-15128/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2
05-22 11:41:26.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 11:41:26.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3
05-22 11:41:28.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 11:41:28.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4
05-22 11:41:30.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 11:41:30.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5
===================onComplete 
</code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p>
<p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p>
<h2 id="3-7-reduce"><a href="#3-7-reduce" class="headerlink" title="3.7 reduce()"></a>3.7 reduce()</h2><h4 id="方法预览：-26"><a href="#方法预览：-26" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer)
</code></pre><h4 id="有什么用？-25"><a href="#有什么用？-25" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</p>
<h4 id="怎么用？-25"><a href="#怎么用？-25" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(0, 1, 2, 3)
.reduce(new BiFunction &lt; Integer, Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer, Integer integer2) throws Exception {
        int res = integer + integer2;
        Log.d(TAG, &quot;====================integer &quot; + integer);
        Log.d(TAG, &quot;====================integer2 &quot; + integer2);
        Log.d(TAG, &quot;====================res &quot; + res);
        return res;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;==================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 14:21:46.042 17775-17775/? D/chan: ====================integer 0
====================integer2 1
====================res 1
====================integer 1
====================integer2 2
====================res 3
====================integer 3
====================integer2 3
====================res 6
==================accept 6
</code></pre><p>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p>
<h2 id="3-8-collect"><a href="#3-8-collect" class="headerlink" title="3.8 collect()"></a>3.8 collect()</h2><h4 id="方法预览：-27"><a href="#方法预览：-27" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector)
</code></pre><h4 id="有什么用？-26"><a href="#有什么用？-26" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将数据收集到数据结构当中。</p>
<h4 id="怎么用？-26"><a href="#怎么用？-26" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4)
.collect(new Callable &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public ArrayList &lt; Integer &gt; call() throws Exception {
        return new ArrayList &lt; &gt; ();
    }
},
new BiConsumer &lt; ArrayList &lt; Integer &gt; , Integer &gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers, Integer integer) throws Exception {
        integers.add(integer);
    }
})
.subscribe(new Consumer &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers) throws Exception {
        Log.d(TAG, &quot;===============accept &quot; + integers);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 16:47:18.257 31361-31361/com.example.rxjavademo D/chan: ===============accept [1, 2, 3, 4]
</code></pre><h2 id="3-9-startWith-amp-startWithArray"><a href="#3-9-startWith-amp-startWithArray" class="headerlink" title="3.9 startWith() &amp; startWithArray()"></a>3.9 startWith() &amp; startWithArray()</h2><h4 id="方法预览：-28"><a href="#方法预览：-28" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; startWith(T item)
public final Observable&lt;T&gt; startWithArray(T... items)
</code></pre><h4 id="有什么用？-27"><a href="#有什么用？-27" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p>
<h4 id="怎么用？-27"><a href="#怎么用？-27" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(5, 6, 7)
.startWithArray(2, 3, 4)
.startWith(1)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 17:08:21.282 4505-4505/com.example.rxjavademo D/chan: ================accept 1
================accept 2
================accept 3
================accept 4
================accept 5
================accept 6
================accept 7
</code></pre><h2 id="3-10-count"><a href="#3-10-count" class="headerlink" title="3.10 count()"></a>3.10 count()</h2><h4 id="方法预览：-29"><a href="#方法预览：-29" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Single&lt;Long&gt; count()
</code></pre><h4 id="有什么用？-28"><a href="#有什么用？-28" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>返回被观察者发送事件的数量。</p>
<h4 id="怎么用？-28"><a href="#怎么用？-28" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3)
.count()
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;=======================aLong &quot; + aLong);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 20:41:25.025 14126-14126/? D/chan: =======================aLong 3
</code></pre><h1 id="4-功能操作符"><a href="#4-功能操作符" class="headerlink" title="4. 功能操作符"></a>4. 功能操作符</h1><h2 id="4-1-delay"><a href="#4-1-delay" class="headerlink" title="4.1 delay()"></a>4.1 delay()</h2><h4 id="方法预览：-30"><a href="#方法预览：-30" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; delay(long delay, TimeUnit unit)
</code></pre><h4 id="有什么用？-29"><a href="#有什么用？-29" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>延迟一段事件发送事件。</p>
<h4 id="怎么用？-29"><a href="#怎么用？-29" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3)
.delay(2, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=======================onSubscribe&quot;);
    }
});
</code></pre><p>这里延迟了两秒才发送事件，来看看打印结果：</p>
<pre><code>05-22 20:53:43.618 16880-16880/com.example.rxjavademo D/chan: =======================onSubscribe
05-22 20:53:45.620 16880-16906/com.example.rxjavademo D/chan: =======================onNext 1
05-22 20:53:45.621 16880-16906/com.example.rxjavademo D/chan: =======================onNext 2
=======================onNext 3
=======================onSubscribe
</code></pre><p>从打印结果可以看出 onSubscribe 回调2秒之后 onNext 才会回调。</p>
<h2 id="4-2-doOnEach"><a href="#4-2-doOnEach" class="headerlink" title="4.2 doOnEach()"></a>4.2 doOnEach()</h2><h4 id="方法预览：-31"><a href="#方法预览：-31" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification)
</code></pre><h4 id="有什么用？-30"><a href="#有什么用？-30" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送一件事件之前都会先回调这个方法。</p>
<h4 id="怎么用？-30"><a href="#怎么用？-30" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        //      e.onError(new NumberFormatException());
        e.onComplete();
    }
})
.doOnEach(new Consumer &lt; Notification &lt; Integer &gt;&gt; () {
    @Override
    public void accept(Notification &lt; Integer &gt; integerNotification) throws Exception {
        Log.d(TAG, &quot;==================doOnEach &quot; + integerNotification.getValue());
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:07:05.547 19867-19867/? D/chan: ==================onSubscribe 
==================doOnEach 1
==================onNext 1
==================doOnEach 2
==================onNext 2
==================doOnEach 3
==================onNext 3
==================doOnEach null
==================onComplete 
</code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p>
<h2 id="4-3-doOnNext"><a href="#4-3-doOnNext" class="headerlink" title="4.3 doOnNext()"></a>4.3 doOnNext()</h2><h4 id="方法预览：-32"><a href="#方法预览：-32" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)
</code></pre><h4 id="有什么用？-31"><a href="#有什么用？-31" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onNext() 之前都会先回调这个方法。</p>
<h4 id="怎么用？-31"><a href="#怎么用？-31" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnNext(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;==================doOnNext &quot; + integer);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:09:36.769 20020-20020/com.example.rxjavademo D/chan: ==================onSubscribe 
==================doOnNext 1
==================onNext 1
==================doOnNext 2
==================onNext 2
==================doOnNext 3
==================onNext 3
==================onComplete 
</code></pre><h2 id="4-4-doAfterNext"><a href="#4-4-doAfterNext" class="headerlink" title="4.4 doAfterNext()"></a>4.4 doAfterNext()</h2><h4 id="方法预览：-33"><a href="#方法预览：-33" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext)
</code></pre><h4 id="有什么用？-32"><a href="#有什么用？-32" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onNext() 之后都会回调这个方法。</p>
<h4 id="怎么用？-32"><a href="#怎么用？-32" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doAfterNext(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;==================doAfterNext &quot; + integer);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});

</code></pre><p>打印结果：</p>
<pre><code>05-23 09:15:49.215 20432-20432/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================doAfterNext 1
==================onNext 2
==================doAfterNext 2
==================onNext 3
==================doAfterNext 3
==================onComplete 
</code></pre><h2 id="4-5-doOnComplete"><a href="#4-5-doOnComplete" class="headerlink" title="4.5 doOnComplete()"></a>4.5 doOnComplete()</h2><h4 id="方法预览：-34"><a href="#方法预览：-34" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnComplete(Action onComplete)
</code></pre><h4 id="有什么用？-33"><a href="#有什么用？-33" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onComplete() 之前都会回调这个方法。</p>
<h4 id="怎么用？-33"><a href="#怎么用？-33" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnComplete(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnComplete &quot;);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:32:18.031 20751-20751/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================doOnComplete 
==================onComplete 
</code></pre><h2 id="4-6-doOnError"><a href="#4-6-doOnError" class="headerlink" title="4.6 doOnError()"></a>4.6 doOnError()</h2><h4 id="方法预览：-35"><a href="#方法预览：-35" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)
</code></pre><h4 id="有什么用？-34"><a href="#有什么用？-34" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onError() 之前都会回调这个方法。</p>
<h4 id="怎么用？-34"><a href="#怎么用？-34" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.doOnError(new Consumer &lt; Throwable &gt; () {
    @Override
    public void accept(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================doOnError &quot; + throwable);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:35:04.150 21051-21051/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================doOnError java.lang.NullPointerException
==================onError 

</code></pre><h2 id="4-7-doOnSubscribe"><a href="#4-7-doOnSubscribe" class="headerlink" title="4.7 doOnSubscribe()"></a>4.7 doOnSubscribe()</h2><h4 id="方法预览：-36"><a href="#方法预览：-36" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe)
</code></pre><h4 id="有什么用？-35"><a href="#有什么用？-35" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p>
<h4 id="怎么用？-35"><a href="#怎么用？-35" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnSubscribe(new Consumer &lt; Disposable &gt; () {
    @Override
    public void accept(Disposable disposable) throws Exception {
        Log.d(TAG, &quot;==================doOnSubscribe &quot;);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:39:25.778 21245-21245/? D/chan: ==================doOnSubscribe 
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><h2 id="4-8-doOnDispose"><a href="#4-8-doOnDispose" class="headerlink" title="4.8 doOnDispose()"></a>4.8 doOnDispose()</h2><h4 id="方法预览：-37"><a href="#方法预览：-37" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnDispose(Action onDispose)
</code></pre><h4 id="有什么用？-36"><a href="#有什么用？-36" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当调用 Disposable 的 dispose() 之后回调该方法。</p>
<h4 id="怎么用？-36"><a href="#怎么用？-36" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnDispose(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnDispose &quot;);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    private Disposable d;

    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:55:48.122 22023-22023/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================doOnDispose 
</code></pre><h2 id="4-9-doOnLifecycle"><a href="#4-9-doOnLifecycle" class="headerlink" title="4.9 doOnLifecycle()"></a>4.9 doOnLifecycle()</h2><h4 id="方法预览：-38"><a href="#方法预览：-38" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose)
</code></pre><h4 id="有什么用？-37"><a href="#有什么用？-37" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。</p>
<h4 id="怎么用？-37"><a href="#怎么用？-37" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>doOnLifecycle() 第二个参数的回调方法的作用与  doOnDispose() 是一样的，现在用下面的例子来讲解：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnLifecycle(new Consumer&lt;Disposable&gt;() {
    @Override
    public void accept(Disposable disposable) throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle accept&quot;);
    }
}, new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle Action&quot;);
    }
})
.doOnDispose(
    new Action() {
        @Override
        public void run() throws Exception {
            Log.d(TAG, &quot;==================doOnDispose Action&quot;);
        }
})
.subscribe(new Observer&lt;Integer&gt;() {
    private Disposable d;
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }

});
</code></pre><p>打印结果：</p>
<pre><code>05-23 10:20:36.345 23922-23922/? D/chan: ==================doOnLifecycle accept
==================onSubscribe 
==================onNext 1
==================doOnDispose Action
==================doOnLifecycle Action
</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。</p>
<p>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p>
<pre><code>05-23 10:32:20.014 24652-24652/com.example.rxjavademo D/chan: ==================doOnLifecycle accept
==================onSubscribe 
</code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p>
<h2 id="4-10-doOnTerminate-amp-doAfterTerminate"><a href="#4-10-doOnTerminate-amp-doAfterTerminate" class="headerlink" title="4.10 doOnTerminate() &amp; doAfterTerminate()"></a>4.10 doOnTerminate() &amp; doAfterTerminate()</h2><h4 id="方法预览：-39"><a href="#方法预览：-39" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doOnTerminate(final Action onTerminate)
public final Observable&lt;T&gt; doAfterTerminate(Action onFinally)
</code></pre><h4 id="有什么用？-38"><a href="#有什么用？-38" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p>
<h4 id="怎么用？-38"><a href="#怎么用？-38" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
//      e.onError(new NullPointerException());
        e.onComplete();
    }
})
.doOnTerminate(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnTerminate &quot;);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }

});
</code></pre><p>打印结果：</p>
<pre><code>05-23 10:00:39.503 22398-22398/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
05-23 10:00:39.504 22398-22398/com.example.rxjavademo D/chan: ==================onNext 3
==================doOnTerminate 
==================onComplete 
</code></pre><p>doAfterTerminate 也是差不多，这里就不再赘述。</p>
<h2 id="4-11-doFinally"><a href="#4-11-doFinally" class="headerlink" title="4.11 doFinally()"></a>4.11 doFinally()</h2><h4 id="方法预览：-40"><a href="#方法预览：-40" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; doFinally(Action onFinally)
</code></pre><h4 id="有什么用？-39"><a href="#有什么用？-39" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在所有事件发送完毕之后回调该方法。</p>
<h4 id="怎么用？-39"><a href="#怎么用？-39" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 doFinally() 无论怎么样都会被回调，且都会在事件序列的最后。</p>
<p>现在用以下例子说明下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doFinally(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doFinally &quot;);
    }
})
.doOnDispose(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnDispose &quot;);
    }
})
.doAfterTerminate(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doAfterTerminate &quot;);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    private Disposable d;
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 10:10:10.469 23196-23196/? D/chan: ==================onSubscribe 
05-23 10:10:10.470 23196-23196/? D/chan: ==================onNext 1
==================doOnDispose 
==================doFinally 
</code></pre><p>可以看到如果调用了 dispose() 方法，doAfterTerminate() 不会被回调。</p>
<p>现在试试把 dispose() 注释掉看看，看看打印结果：</p>
<pre><code>05-23 10:13:34.537 23439-23439/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
==================doAfterTerminate 
==================doFinally 
</code></pre><p>doAfterTerminate() 已经成功回调，doFinally() 还是会在事件序列的最后。</p>
<h2 id="4-12-onErrorReturn"><a href="#4-12-onErrorReturn" class="headerlink" title="4.12 onErrorReturn()"></a>4.12 onErrorReturn()</h2><h4 id="方法预览：-41"><a href="#方法预览：-41" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier)
</code></pre><h4 id="有什么用？-40"><a href="#有什么用？-40" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p>
<h4 id="怎么用？-40"><a href="#怎么用？-40" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorReturn(new Function&lt;Throwable, Integer&gt;() {
    @Override
    public Integer apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorReturn &quot; + throwable);
        return 404;
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 18:35:18.175 19239-19239/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorReturn java.lang.NullPointerException
==================onNext 404
==================onComplete 
</code></pre><h2 id="4-13-onErrorResumeNext"><a href="#4-13-onErrorResumeNext" class="headerlink" title="4.13 onErrorResumeNext()"></a>4.13 onErrorResumeNext()</h2><h4 id="方法预览：-42"><a href="#方法预览：-42" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction)
</code></pre><h4 id="有什么用？-41"><a href="#有什么用？-41" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p>
<h4 id="怎么用？-41"><a href="#怎么用？-41" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorResumeNext &quot; + throwable);
        return Observable.just(4, 5, 6);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 18:43:10.910 26469-26469/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorResumeNext java.lang.NullPointerException
==================onNext 4
==================onNext 5
==================onNext 6
==================onComplete 
</code></pre><h2 id="4-14-onExceptionResumeNext"><a href="#4-14-onExceptionResumeNext" class="headerlink" title="4.14 onExceptionResumeNext()"></a>4.14 onExceptionResumeNext()</h2><h4 id="方法预览：-43"><a href="#方法预览：-43" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next)
</code></pre><h4 id="有什么用？-42"><a href="#有什么用？-42" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p>
<h4 id="怎么用？-42"><a href="#怎么用？-42" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>先来试试 onExceptionResumeNext() 是否能捕捉 Error。</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Error(&quot;404&quot;));
    }
})
.onExceptionResumeNext(new Observable&lt;Integer&gt;() {
    @Override
    protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
        observer.onNext(333);
        observer.onComplete();
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 22:23:08.873 1062-1062/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
05-23 22:23:08.874 1062-1062/com.example.louder.rxjavademo D/chan: ==================onNext 1
==================onNext 2
==================onNext 3
==================onError 
</code></pre><p>从打印结果可以知道，观察者收到 onError() 事件，证明 onErrorResumeNext() 不能捕捉 Error 事件。</p>
<p>将被观察者的 e.onError(new Error(“404”)) 改为 e.onError(new Exception(“404”))，现在看看是否能捕捉 Exception 事件：</p>
<pre><code>05-23 22:32:14.563 10487-10487/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 333
==================onComplete 
</code></pre><p>从打印结果可以知道，这个方法成功捕获 Exception 事件。</p>
<h2 id="4-15-retry"><a href="#4-15-retry" class="headerlink" title="4.15 retry()"></a>4.15 retry()</h2><h4 id="方法预览：-44"><a href="#方法预览：-44" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; retry(long times)
......
</code></pre><h4 id="有什么用？-43"><a href="#有什么用？-43" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p>
<h4 id="怎么用？-43"><a href="#怎么用？-43" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Exception(&quot;404&quot;));
    }
})
.retry(2)
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 22:46:18.537 22239-22239/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
05-23 22:46:18.538 22239-22239/com.example.louder.rxjavademo D/chan: ==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 1
==================onNext 2
==================onNext 3
==================onError 
</code></pre><h2 id="4-16-retryUntil"><a href="#4-16-retryUntil" class="headerlink" title="4.16 retryUntil()"></a>4.16 retryUntil()</h2><h4 id="方法预览：-45"><a href="#方法预览：-45" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop)
</code></pre><h4 id="有什么用？-44"><a href="#有什么用？-44" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。</p>
<h4 id="怎么用？-44"><a href="#怎么用？-44" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Exception(&quot;404&quot;));
    }
})
.retryUntil(new BooleanSupplier() {
    @Override
    public boolean getAsBoolean() throws Exception {
        if (i == 6) {
            return true;
        }
        return false;
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 22:57:32.905 23063-23063/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
05-23 22:57:32.906 23063-23063/com.example.louder.rxjavademo D/chan: ==================onNext 1
==================onNext 2
==================onNext 3
==================onError 

</code></pre><h2 id="4-17-retryWhen"><a href="#4-17-retryWhen" class="headerlink" title="4.17 retryWhen()"></a>4.17 retryWhen()</h2><h4 id="方法预览：-46"><a href="#方法预览：-46" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final void safeSubscribe(Observer&lt;? super T&gt; s)
</code></pre><h4 id="有什么用？-45"><a href="#有什么用？-45" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</p>
<h4 id="怎么用？-45"><a href="#怎么用？-45" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; String &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; String &gt; e) throws Exception {
        e.onNext(&quot;chan&quot;);
        e.onNext(&quot;ze&quot;);
        e.onNext(&quot;de&quot;);
        e.onError(new Exception(&quot;404&quot;));
        e.onNext(&quot;haha&quot;);
    }
})
.retryWhen(new Function &lt; Observable &lt; Throwable &gt; , ObservableSource &lt;? &gt;&gt; () {
    @Override
    public ObservableSource &lt;? &gt; apply(Observable &lt; Throwable &gt; throwableObservable) throws Exception {
        return throwableObservable.flatMap(new Function &lt; Throwable, ObservableSource &lt;? &gt;&gt; () {
            @Override
            public ObservableSource &lt;? &gt; apply(Throwable throwable) throws Exception {
                if(!throwable.toString().equals(&quot;java.lang.Exception: 404&quot;)) {
                    return Observable.just(&quot;可以忽略的异常&quot;);
                } else {
                    return Observable.error(new Throwable(&quot;终止啦&quot;));
                }
            }
        });
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e.toString());
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 09:13:25.622 28372-28372/com.example.rxjavademo D/chan: ==================onSubscribe 
05-24 09:13:25.623 28372-28372/com.example.rxjavademo D/chan: ==================onNext chan
==================onNext ze
==================onNext de
05-24 09:13:25.624 28372-28372/com.example.rxjavademo D/chan: ==================onError java.lang.Throwable: 终止啦
</code></pre><p>将 onError(new Exception(“404”)) 改为 onError(new Exception(“303”)) 看看打印结果：</p>
<pre><code>==================onNext chan
05-24 09:54:08.653 29694-29694/? D/chan: ==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
......
</code></pre><p>从结果可以看出，会不断重复发送消息。</p>
<h2 id="4-18-repeat"><a href="#4-18-repeat" class="headerlink" title="4.18 repeat()"></a>4.18 repeat()</h2><h4 id="方法预览：-47"><a href="#方法预览：-47" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; repeat(long times)
......
</code></pre><h4 id="有什么用？-46"><a href="#有什么用？-46" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>重复发送被观察者的事件，times 为发送次数。</p>
<h4 id="怎么用？-46"><a href="#怎么用？-46" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.repeat(2)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 11:33:29.565 8544-8544/com.example.rxjavademo D/chan: ===================onSubscribe 
===================onNext 1
===================onNext 2
===================onNext 3
===================onNext 1
===================onNext 2
===================onNext 3
05-24 11:33:29.565 8544-8544/com.example.rxjavademo D/chan: ===================onComplete 
</code></pre><p>从结果可以看出，该事件发送了两次。</p>
<h2 id="4-19-repeatWhen"><a href="#4-19-repeatWhen" class="headerlink" title="4.19 repeatWhen()"></a>4.19 repeatWhen()</h2><h4 id="方法预览：-48"><a href="#方法预览：-48" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)
</code></pre><h4 id="有什么用？-47"><a href="#有什么用？-47" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p>
<h4 id="怎么用？-47"><a href="#怎么用？-47" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>这里分三种情况，如果新的被观察者返回 onComplete 或者 onError 事件，则旧的被观察者不会继续发送事件。如果被观察者返回其他事件，则会重复发送事件。</p>
<p>现在试验发送 onComplete 事件，代码如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.repeatWhen(new Function &lt; Observable &lt; Object &gt; , ObservableSource &lt;? &gt;&gt; () {
    @Override
    public ObservableSource &lt;? &gt; apply(Observable &lt; Object &gt; objectObservable) throws Exception {
        return Observable.empty();
    //  return Observable.error(new Exception(&quot;404&quot;));
    //  return Observable.just(4); null;
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 11:44:33.486 9379-9379/com.example.rxjavademo D/chan: ===================onSubscribe 
05-24 11:44:33.487 9379-9379/com.example.rxjavademo D/chan: ===================onComplete 
</code></pre><p>下面直接看看发送 onError 事件和其他事件的打印结果。</p>
<p>发送 onError 打印结果：</p>
<pre><code>05-24 11:46:29.507 9561-9561/com.example.rxjavademo D/chan: ===================onSubscribe 
05-24 11:46:29.508 9561-9561/com.example.rxjavademo D/chan: ===================onError 
</code></pre><p>发送其他事件的打印结果：</p>
<pre><code>05-24 11:48:35.844 9752-9752/com.example.rxjavademo D/chan: ===================onSubscribe 
===================onNext 1
===================onNext 2
===================onNext 3
===================onComplete 
</code></pre><h2 id="4-20-subscribeOn"><a href="#4-20-subscribeOn" class="headerlink" title="4.20 subscribeOn()"></a>4.20 subscribeOn()</h2><h4 id="方法预览：-49"><a href="#方法预览：-49" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler)
</code></pre><h4 id="有什么用？-48"><a href="#有什么用？-48" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。</p>
<h4 id="怎么用？-48"><a href="#怎么用？-48" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
//.subscribeOn(Schedulers.newThread())
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>现在不调用 subscribeOn() 方法，来看看打印结果：</p>
<pre><code>05-26 10:40:42.246 21466-21466/? D/chan: ======================onSubscribe
05-26 10:40:42.247 21466-21466/? D/chan: =========================currentThread name: main
======================onNext 1
======================onNext 2
======================onNext 3
======================onComplete
</code></pre><p>可以看到打印被观察者的线程名字是主线程。</p>
<p>接着调用 subscribeOn(Schedulers.newThread()) 来看看打印结果：</p>
<pre><code>05-26 10:43:26.964 22530-22530/com.example.rxjavademo D/chan: ======================onSubscribe
05-26 10:43:26.966 22530-22569/com.example.rxjavademo D/chan: =========================currentThread name: RxNewThreadScheduler-1
05-26 10:43:26.967 22530-22569/com.example.rxjavademo D/chan: ======================onNext 1
======================onNext 2
======================onNext 3
======================onComplete
</code></pre><p>可以看到打印结果被观察者是在一条新的线程。</p>
<p>现在看看多次调用会不会有效，代码如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.subscribeOn(Schedulers.computation())
.subscribeOn(Schedulers.newThread())
.subscribe(new Observer &lt; Integer &gt; () {@Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:47:20.925 23590-23590/com.example.rxjavademo D/chan: ======================onSubscribe
05-26 10:47:20.930 23590-23629/com.example.rxjavademo D/chan: =========================currentThread name: RxComputationThreadPool-1
======================onNext 1
======================onNext 2
======================onNext 3
======================onComplete
</code></pre><p>可以看到第二次调动的 subscribeOn(Schedulers.newThread()) 并没有效果。</p>
<h2 id="4-21-observeOn"><a href="#4-21-observeOn" class="headerlink" title="4.21 observeOn()"></a>4.21 observeOn()</h2><h4 id="方法预览：-50"><a href="#方法预览：-50" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler)
</code></pre><h4 id="有什么用？-49"><a href="#有什么用？-49" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>指定观察者的线程，每指定一次就会生效一次。</p>
<h4 id="怎么用？-49"><a href="#怎么用？-49" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3)
.observeOn(Schedulers.newThread())
.flatMap(new Function &lt; Integer, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception {
        Log.d(TAG, &quot;======================flatMap Thread name &quot; + Thread.currentThread().getName());
        return Observable.just(&quot;chan&quot; + integer);
    }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;======================onNext Thread name &quot; + Thread.currentThread().getName());
        Log.d(TAG, &quot;======================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:58:04.593 25717-25717/com.example.rxjavademo D/chan: ======================onSubscribe
05-26 10:58:04.594 25717-25753/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler-1
05-26 10:58:04.595 25717-25753/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler-1
======================flatMap Thread name RxNewThreadScheduler-1
05-26 10:58:04.617 25717-25717/com.example.rxjavademo D/chan: ======================onNext Thread name main
======================onNext chan1
======================onNext Thread name main
======================onNext chan2
======================onNext Thread name main
======================onNext chan3
05-26 10:58:04.618 25717-25717/com.example.rxjavademo D/chan: ======================onComplete
</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p>
<p>下表总结了 RxJava 中的调度器：</p>
<table>
<thead>
<tr>
<th>调度器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Schedulers.computation( )</td>
<td>用于使用计算任务，如事件循环和回调处理</td>
</tr>
<tr>
<td>Schedulers.immediate( )</td>
<td>当前线程</td>
</tr>
<tr>
<td>Schedulers.io( )</td>
<td>用于 IO 密集型任务，如果异步阻塞 IO 操作。</td>
</tr>
<tr>
<td>Schedulers.newThread( )</td>
<td>创建一个新的线程</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>Android 的 UI 线程，用于操作 UI。</td>
</tr>
</tbody></table>
<h1 id="5-过滤操作符"><a href="#5-过滤操作符" class="headerlink" title="5. 过滤操作符"></a>5. 过滤操作符</h1><h2 id="5-1-filter"><a href="#5-1-filter" class="headerlink" title="5.1 filter()"></a>5.1 filter()</h2><h4 id="方法预览：-51"><a href="#方法预览：-51" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)
</code></pre><h4 id="有什么用？-50"><a href="#有什么用？-50" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。</p>
<h4 id="怎么用？-50"><a href="#怎么用？-50" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code> Observable.just(1, 2, 3)
    .filter(new Predicate &lt; Integer &gt; () {
        @Override
        public boolean test(Integer integer) throws Exception {
            return integer &lt; 2;
        }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>以上代码只有小于2的事件才会发送，来看看打印结果：</p>
<pre><code>05-24 22:57:32.562 12776-12776/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onComplete 
</code></pre><h2 id="5-2-ofType"><a href="#5-2-ofType" class="headerlink" title="5.2 ofType()"></a>5.2 ofType()</h2><h4 id="方法预览：-52"><a href="#方法预览：-52" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz)
</code></pre><h4 id="有什么用？-51"><a href="#有什么用？-51" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以过滤不符合该类型事件</p>
<h4 id="怎么用？-51"><a href="#怎么用？-51" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, &quot;chan&quot;, &quot;zhide&quot;)
.ofType(Integer.class)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 23:04:24.752 13229-13229/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
05-24 23:04:24.753 13229-13229/? D/chan: ==================onComplete 
</code></pre><h2 id="5-3-skip"><a href="#5-3-skip" class="headerlink" title="5.3 skip()"></a>5.3 skip()</h2><h4 id="方法预览：-53"><a href="#方法预览：-53" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; skip(long count)
.......
</code></pre><h4 id="有什么用？-52"><a href="#有什么用？-52" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>跳过正序某些事件，count 代表跳过事件的数量</p>
<h4 id="怎么用？-52"><a href="#怎么用？-52" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3)
.skip(2)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 23:13:50.448 13831-13831/? D/chan: ==================onSubscribe 
05-24 23:13:50.449 13831-13831/? D/chan: ==================onNext 3
==================onComplete 
</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件，这里就不再讲解了。</p>
<h2 id="5-4-distinct"><a href="#5-4-distinct" class="headerlink" title="5.4 distinct()"></a>5.4 distinct()</h2><h4 id="方法预览：-54"><a href="#方法预览：-54" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; distinct() 
</code></pre><h4 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用?"></a>有什么用?</h4><p>过滤事件序列中的重复事件。</p>
<h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code>Observable.just(1, 2, 3, 3, 2, 1)
.distinct()
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果:</p>
<pre><code>05-24 23:19:44.334 14206-14206/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><h2 id="5-5-distinctUntilChanged"><a href="#5-5-distinctUntilChanged" class="headerlink" title="5.5 distinctUntilChanged()"></a>5.5 distinctUntilChanged()</h2><h4 id="方法预览：-55"><a href="#方法预览：-55" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; distinctUntilChanged()
</code></pre><h4 id="有什么用？-53"><a href="#有什么用？-53" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>过滤掉连续重复的事件</p>
<h4 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code>Observable.just(1, 2, 3, 3, 2, 1)
.distinctUntilChanged()
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果:</p>
<pre><code>05-24 23:22:35.985 14424-14424/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 2
==================onNext 1
==================onComplete 
</code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p>
<h2 id="5-6-take"><a href="#5-6-take" class="headerlink" title="5.6 take()"></a>5.6 take()</h2><h4 id="方法预览：-56"><a href="#方法预览：-56" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; take(long count)
......
</code></pre><h4 id="有什么用-1"><a href="#有什么用-1" class="headerlink" title="有什么用?"></a>有什么用?</h4><p>控制观察者接收的事件的数量。</p>
<h4 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code>Observable.just(1, 2, 3, 4, 5)
.take(3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 23:28:32.899 14704-14704/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情，这里就不再讲解了，大家可以自己试试。</p>
<h2 id="5-7-debounce"><a href="#5-7-debounce" class="headerlink" title="5.7 debounce()"></a>5.7 debounce()</h2><h4 id="方法预览：-57"><a href="#方法预览：-57" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit)
......
</code></pre><h4 id="有什么用？-54"><a href="#有什么用？-54" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p>
<h4 id="怎么用？-53"><a href="#怎么用？-53" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        Thread.sleep(900);
        e.onNext(2);
    }
})
.debounce(1, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-25 20:39:10.512 17441-17441/com.example.rxjavademo D/chan: ===================onSubscribe 
05-25 20:39:12.413 17441-17478/com.example.rxjavademo D/chan: ===================onNext 2
</code></pre><p>可以看到事件1并没有发送出去，现在将间隔时间改为1000，看看打印结果：</p>
<pre><code>05-25 20:42:10.874 18196-18196/com.example.rxjavademo D/chan: ===================onSubscribe 
05-25 20:42:11.875 18196-18245/com.example.rxjavademo D/chan: ===================onNext 1
05-25 20:42:12.875 18196-18245/com.example.rxjavademo D/chan: ===================onNext 2
</code></pre><p>throttleWithTimeout() 与此方法的作用一样，这里就不再赘述了。</p>
<h2 id="5-8-firstElement-amp-amp-lastElement"><a href="#5-8-firstElement-amp-amp-lastElement" class="headerlink" title="5.8 firstElement() &amp;&amp; lastElement()"></a>5.8 firstElement() &amp;&amp; lastElement()</h2><h5 id="方法预览：-58"><a href="#方法预览：-58" class="headerlink" title="方法预览："></a>方法预览：</h5><pre><code>public final Maybe&lt;T&gt; firstElement()
public final Maybe&lt;T&gt; lastElement()
</code></pre><h4 id="有什么用？-55"><a href="#有什么用？-55" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p>
<h4 id="怎么用？-54"><a href="#怎么用？-54" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4)
.firstElement()
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================firstElement &quot; + integer);
    }
});

Observable.just(1, 2, 3, 4)
.lastElement()
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================lastElement &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-25 20:47:22.189 19909-19909/? D/chan: ====================firstElement 1
====================lastElement 4
</code></pre><h2 id="5-9-elementAt-amp-elementAtOrError"><a href="#5-9-elementAt-amp-elementAtOrError" class="headerlink" title="5.9 elementAt() &amp; elementAtOrError()"></a>5.9 elementAt() &amp; elementAtOrError()</h2><h4 id="方法预览：-59"><a href="#方法预览：-59" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Maybe&lt;T&gt; elementAt(long index)
public final Single&lt;T&gt; elementAtOrError(long index)
</code></pre><h4 id="有什么用？-56"><a href="#有什么用？-56" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p>
<h4 id="怎么用？-55"><a href="#怎么用？-55" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4)
.elementAt(0)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-25 20:56:22.266 23346-23346/com.example.rxjavademo D/chan: ====================accept 1
</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。</p>
<p>替换 elementAt() 为 elementAtOrError()，代码如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.elementAtOrError(5)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>io.reactivex.exceptions.OnErrorNotImplementedException
at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java: 704)
at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java: 701)
at io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java: 47)
at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onComplete(ObservableElementAtSingle.java: 117)
at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java: 110)
at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java: 36)
at io.reactivex.Observable.subscribe(Observable.java: 10903)
at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java: 37)
at io.reactivex.Single.subscribe(Single.java: 2707)
at io.reactivex.Single.subscribe(Single.java: 2693)
at io.reactivex.Single.subscribe(Single.java: 2664)
at com.example.rxjavademo.MainActivity.onCreate(MainActivity.java: 103)
at android.app.Activity.performCreate(Activity.java: 6942)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java: 1126)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java: 2880)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java: 2988)
at android.app.ActivityThread. - wrap14(ActivityThread.java)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java: 1631)
at android.os.Handler.dispatchMessage(Handler.java: 102)
at android.os.Looper.loop(Looper.java: 154)
at android.app.ActivityThread.main(ActivityThread.java: 6682)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: 1520)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java: 1410)
Caused by: java.util.NoSuchElementException
at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onComplete(ObservableElementAtSingle.java: 117) 
at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java: 110) 
at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java: 36) 
at io.reactivex.Observable.subscribe(Observable.java: 10903) 
at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java: 37) 
at io.reactivex.Single.subscribe(Single.java: 2707) 
at io.reactivex.Single.subscribe(Single.java: 2693) 
at io.reactivex.Single.subscribe(Single.java: 2664) 
at com.example.rxjavademo.MainActivity.onCreate(MainActivity.java: 103) 
at android.app.Activity.performCreate(Activity.java: 6942) 
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java: 1126) 
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java: 2880) 
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java: 2988) 
at android.app.ActivityThread. - wrap14(ActivityThread.java) 
at android.app.ActivityThread$H.handleMessage(ActivityThread.java: 1631) 
at android.os.Handler.dispatchMessage(Handler.java: 102) 
at android.os.Looper.loop(Looper.java: 154) 
at android.app.ActivityThread.main(ActivityThread.java: 6682) 
at java.lang.reflect.Method.invoke(Native Method) 
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: 1520) 
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java: 1410) 
</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p>
<h1 id="6-条件操作符"><a href="#6-条件操作符" class="headerlink" title="6. 条件操作符"></a>6. 条件操作符</h1><h2 id="6-1-all"><a href="#6-1-all" class="headerlink" title="6.1 all()"></a>6.1 all()</h2><h4 id="方法预览：-60"><a href="#方法预览：-60" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; ambWith(ObservableSource&lt;? extends T&gt; other)
</code></pre><h4 id="有什么用？-57"><a href="#有什么用？-57" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p>
<h4 id="怎么用？-56"><a href="#怎么用？-56" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4)
.all(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 5;
    }
})
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;==================aBoolean &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:39:51.644 1482-1482/com.example.rxjavademo D/chan: ==================aBoolean true
</code></pre><h2 id="6-2-takeWhile"><a href="#6-2-takeWhile" class="headerlink" title="6.2 takeWhile()"></a>6.2 takeWhile()</h2><h4 id="方法预览：-61"><a href="#方法预览：-61" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)
</code></pre><h4 id="有什么用？-58"><a href="#有什么用？-58" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送。</p>
<h4 id="怎么用？-57"><a href="#怎么用？-57" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4)
.takeWhile(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:43:14.634 3648-3648/com.example.rxjavademo D/chan: ========================integer 1
========================integer 2
</code></pre><h2 id="6-3-skipWhile"><a href="#6-3-skipWhile" class="headerlink" title="6.3 skipWhile()"></a>6.3 skipWhile()</h2><h4 id="方法预览：-62"><a href="#方法预览：-62" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate)
</code></pre><h4 id="有什么用？-59"><a href="#有什么用？-59" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p>
<h4 id="怎么用？-58"><a href="#怎么用？-58" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4)
.skipWhile(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:47:32.653 4861-4861/com.example.rxjavademo D/chan: ========================integer 3
========================integer 4
</code></pre><h2 id="6-4-takeUntil"><a href="#6-4-takeUntil" class="headerlink" title="6.4 takeUntil()"></a>6.4 takeUntil()</h2><h4 id="方法预览：-63"><a href="#方法预览：-63" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate
</code></pre><h4 id="有什么用？-60"><a href="#有什么用？-60" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p>
<h4 id="怎么用？-59"><a href="#怎么用？-59" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3, 4, 5, 6)
.takeUntil(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &gt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:55:12.918 7933-7933/com.example.rxjavademo D/chan: ========================integer 1
========================integer 2
05-26 09:55:12.919 7933-7933/com.example.rxjavademo D/chan: ========================integer 3
========================integer 4
</code></pre><h2 id="6-5-skipUntil"><a href="#6-5-skipUntil" class="headerlink" title="6.5 skipUntil()"></a>6.5 skipUntil()</h2><h4 id="方法预览：-64"><a href="#方法预览：-64" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final &lt;U&gt; Observable&lt;T&gt; skipUntil(ObservableSource&lt;U&gt; other)
</code></pre><h4 id="有什么用？-61"><a href="#有什么用？-61" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。</p>
<h4 id="怎么用？-60"><a href="#怎么用？-60" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS)
.skipUntil(Observable.intervalRange(6, 5, 3, 1, TimeUnit.SECONDS))
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;========================onSubscribe &quot;);
    }

    @Override
    public void onNext(Long along) {
        Log.d(TAG, &quot;========================onNext &quot; + along);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;========================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;========================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:08:50.574 13023-13023/com.example.rxjavademo D/chan: ========================onSubscribe 
05-26 10:08:53.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 4
05-26 10:08:54.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 5
========================onComplete 
</code></pre><p>从结果可以看出，skipUntil() 里的 Observable 并不会发送事件给观察者。</p>
<h2 id="6-6-sequenceEqual"><a href="#6-6-sequenceEqual" class="headerlink" title="6.6 sequenceEqual()"></a>6.6 sequenceEqual()</h2><h4 id="方法预览：-65"><a href="#方法预览：-65" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)
......
</code></pre><h4 id="有什么用？-62"><a href="#有什么用？-62" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断两个  Observable 发送的事件是否相同。</p>
<h4 id="怎么用？-61"><a href="#怎么用？-61" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.sequenceEqual(Observable.just(1, 2, 3),
Observable.just(1, 2, 3))
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:11:45.975 14157-14157/? D/chan: ========================onNext true
</code></pre><h2 id="6-7-contains"><a href="#6-7-contains" class="headerlink" title="6.7 contains()"></a>6.7 contains()</h2><h4 id="方法预览：-66"><a href="#方法预览：-66" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Single&lt;Boolean&gt; contains(final Object element)
</code></pre><h4 id="有什么用？-63"><a href="#有什么用？-63" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p>
<h4 id="怎么用？-62"><a href="#怎么用？-62" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.just(1, 2, 3)
.contains(3)
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:14:23.522 15085-15085/com.example.rxjavademo D/chan: ========================onNext true
</code></pre><h2 id="6-8-isEmpty"><a href="#6-8-isEmpty" class="headerlink" title="6.8 isEmpty()"></a>6.8 isEmpty()</h2><h4 id="方法预览：-67"><a href="#方法预览：-67" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Single&lt;Boolean&gt; isEmpty()
</code></pre><h4 id="有什么用？-64"><a href="#有什么用？-64" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列是否为空。</p>
<h4 id="怎么用？-63"><a href="#怎么用？-63" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onComplete();
    }
})
.isEmpty()
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:17:16.725 16109-16109/com.example.rxjavademo D/chan: ========================onNext true
</code></pre><h2 id="6-9-amb"><a href="#6-9-amb" class="headerlink" title="6.9 amb()"></a>6.9 amb()</h2><h4 id="方法预览：-68"><a href="#方法预览：-68" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public static &lt;T&gt; Observable&lt;T&gt; amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)
</code></pre><h4 id="有什么用？-65"><a href="#有什么用？-65" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃。</p>
<h4 id="怎么用？-64"><a href="#怎么用？-64" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>ArrayList &lt; Observable &lt; Long &gt;&gt; list = new ArrayList &lt; &gt; ();

list.add(Observable.intervalRange(1, 5, 2, 1, TimeUnit.SECONDS));
list.add(Observable.intervalRange(6, 5, 0, 1, TimeUnit.SECONDS));

Observable.amb(list)
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;========================aLong &quot; + aLong);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:21:29.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 6
05-26 10:21:30.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 7
05-26 10:21:31.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 8
05-26 10:21:32.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 9
05-26 10:21:33.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 10
</code></pre><h2 id="6-10-defaultIfEmpty"><a href="#6-10-defaultIfEmpty" class="headerlink" title="6.10 defaultIfEmpty()"></a>6.10 defaultIfEmpty()</h2><h4 id="方法预览：-69"><a href="#方法预览：-69" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code>public final Observable&lt;T&gt; defaultIfEmpty(T defaultItem)
</code></pre><h4 id="有什么用？-66"><a href="#有什么用？-66" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值。</p>
<h4 id="怎么用？-65"><a href="#怎么用？-65" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onComplete();
    }
})
.defaultIfEmpty(666)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:26:56.376 19249-19249/com.example.rxjavademo D/chan: ========================onNext 666
</code></pre><p>RxJava 常见的使用方式都已经介绍的差不多，相信大家如果都掌握这些操作符的用法的话，那么使用 RxJava 将不会再是难题了。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
            
            
            <div id="vcomments"></div>
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="http://q1.qlogo.cn/g?b=qq&nk=2391624941&s=640" height=300 width=300></img>
                    <p>Apocalypse</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        <dd><a href="https://github.com/TriDiamond" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                        <dd><a href="https://twitter.com/TriDiamond6" target="_blank"><span
                                    class=" iconfont icon-twitter"></span></a></dd>
                        <dd><a href="https://stackoverflow.com/users/7602324/tridiamond?tab=profile" target="_blank"><span
                                    class=" iconfont icon-stack-overflow"></span></a></dd>
                    </dl>
                </div>
                <ul>
                    <li><a href="/">25 <p>Articles</p></a></li>
                    <li><a href="/categories">2 <p>Categories</p></a></li>
                    <li><a href="/tags">2 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-简介"><span class="toc-number">1.</span> <span class="toc-text">0. 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-创建操作符"><span class="toc-number">2.</span> <span class="toc-text">1. 创建操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-create"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-just"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 just()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-From-操作符"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 From 操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-1-fromArray"><span class="toc-number">2.4.</span> <span class="toc-text">1.3.1  fromArray()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-2-fromCallable"><span class="toc-number">2.5.</span> <span class="toc-text">1.3.2 fromCallable()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-3-fromFuture"><span class="toc-number">2.6.</span> <span class="toc-text">1.3.3 fromFuture()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-4-fromIterable"><span class="toc-number">2.7.</span> <span class="toc-text">1.3.4 fromIterable()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-defer"><span class="toc-number">2.8.</span> <span class="toc-text">1.4 defer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-timer"><span class="toc-number">2.9.</span> <span class="toc-text">1.5 timer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-interval"><span class="toc-number">2.10.</span> <span class="toc-text">1.6 interval()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-intervalRange"><span class="toc-number">2.11.</span> <span class="toc-text">1.7 intervalRange()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-range"><span class="toc-number">2.12.</span> <span class="toc-text">1.8 range()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-rangeLong"><span class="toc-number">2.13.</span> <span class="toc-text">1.9 rangeLong()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-empty-amp-never-amp-error"><span class="toc-number">2.14.</span> <span class="toc-text">1.10 empty() &amp; never() &amp; error()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-转换操作符"><span class="toc-number">3.</span> <span class="toc-text">2. 转换操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-map"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 map()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-flatMap"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 flatMap()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-concatMap"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 concatMap()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-buffer"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 buffer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-groupBy"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 groupBy()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-scan"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 scan()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-window"><span class="toc-number">3.7.</span> <span class="toc-text">2.7 window()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-组合操作符"><span class="toc-number">4.</span> <span class="toc-text">3. 组合操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-concat"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 concat()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-concatArray"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 concatArray()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-merge"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 merge()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-concatArrayDelayError-amp-mergeArrayDelayError"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 concatArrayDelayError() &amp; mergeArrayDelayError()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-zip"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 zip()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-combineLatest-amp-combineLatestDelayError"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 combineLatest() &amp;  combineLatestDelayError()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-reduce"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 reduce()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-collect"><span class="toc-number">4.8.</span> <span class="toc-text">3.8 collect()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-startWith-amp-startWithArray"><span class="toc-number">4.9.</span> <span class="toc-text">3.9 startWith() &amp; startWithArray()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-count"><span class="toc-number">4.10.</span> <span class="toc-text">3.10 count()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-功能操作符"><span class="toc-number">5.</span> <span class="toc-text">4. 功能操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-delay"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 delay()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-doOnEach"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 doOnEach()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-doOnNext"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 doOnNext()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-doAfterNext"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 doAfterNext()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-doOnComplete"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 doOnComplete()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-doOnError"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 doOnError()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-doOnSubscribe"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 doOnSubscribe()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-doOnDispose"><span class="toc-number">5.8.</span> <span class="toc-text">4.8 doOnDispose()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-doOnLifecycle"><span class="toc-number">5.9.</span> <span class="toc-text">4.9 doOnLifecycle()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-doOnTerminate-amp-doAfterTerminate"><span class="toc-number">5.10.</span> <span class="toc-text">4.10 doOnTerminate() &amp; doAfterTerminate()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-doFinally"><span class="toc-number">5.11.</span> <span class="toc-text">4.11 doFinally()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-onErrorReturn"><span class="toc-number">5.12.</span> <span class="toc-text">4.12 onErrorReturn()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-onErrorResumeNext"><span class="toc-number">5.13.</span> <span class="toc-text">4.13 onErrorResumeNext()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-onExceptionResumeNext"><span class="toc-number">5.14.</span> <span class="toc-text">4.14 onExceptionResumeNext()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-15-retry"><span class="toc-number">5.15.</span> <span class="toc-text">4.15 retry()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-16-retryUntil"><span class="toc-number">5.16.</span> <span class="toc-text">4.16 retryUntil()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-17-retryWhen"><span class="toc-number">5.17.</span> <span class="toc-text">4.17 retryWhen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-18-repeat"><span class="toc-number">5.18.</span> <span class="toc-text">4.18 repeat()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-19-repeatWhen"><span class="toc-number">5.19.</span> <span class="toc-text">4.19 repeatWhen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-20-subscribeOn"><span class="toc-number">5.20.</span> <span class="toc-text">4.20 subscribeOn()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-21-observeOn"><span class="toc-number">5.21.</span> <span class="toc-text">4.21 observeOn()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-过滤操作符"><span class="toc-number">6.</span> <span class="toc-text">5. 过滤操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-filter"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 filter()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-ofType"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 ofType()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-skip"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 skip()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-distinct"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 distinct()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-distinctUntilChanged"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 distinctUntilChanged()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-take"><span class="toc-number">6.6.</span> <span class="toc-text">5.6 take()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-debounce"><span class="toc-number">6.7.</span> <span class="toc-text">5.7 debounce()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-firstElement-amp-amp-lastElement"><span class="toc-number">6.8.</span> <span class="toc-text">5.8 firstElement() &amp;&amp; lastElement()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-elementAt-amp-elementAtOrError"><span class="toc-number">6.9.</span> <span class="toc-text">5.9 elementAt() &amp; elementAtOrError()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-条件操作符"><span class="toc-number">7.</span> <span class="toc-text">6. 条件操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-all"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-takeWhile"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 takeWhile()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-skipWhile"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 skipWhile()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-takeUntil"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 takeUntil()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-skipUntil"><span class="toc-number">7.5.</span> <span class="toc-text">6.5 skipUntil()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-sequenceEqual"><span class="toc-number">7.6.</span> <span class="toc-text">6.6 sequenceEqual()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-contains"><span class="toc-number">7.7.</span> <span class="toc-text">6.7 contains()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-isEmpty"><span class="toc-number">7.8.</span> <span class="toc-text">6.8 isEmpty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-amb"><span class="toc-number">7.9.</span> <span class="toc-text">6.9 amb()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-defaultIfEmpty"><span class="toc-number">7.10.</span> <span class="toc-text">6.10 defaultIfEmpty()</span></a></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2020
        <span class="gradient-text">
            Apocalypse
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.3" target="_blank" rel="noopener">v1.4.3</a></small>
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>




<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>


<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>


<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>

    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>






<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-149874671-1');
    </script>





<script>
    function initialTyped () {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ["Think like an artist, develop like an artisan", "艺术家思维去思考问题，工匠创造精神去开发"],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>


    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

    <script>

        var valine = new Valine();

        function initValine(path) {
            if (!path) path = window.location.pathname;
            let language = 'en';
            if (!language) {
                language = 'en';
            } else {
                language = language.toLowerCase();
            }
            valine.init({
                el: '#vcomments',
                appId: 'GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz',
                appKey: 'FihoucantYlc5U1FQ9BzkO3l',
                notify: 'false',
                verify: 'false',
                avatar: 'mp',
                placeholder: 'Leave your throughs behind~',
                visitor: 'true',
                path: path,
                lang: language
            });
        }

        $(document).ready(function () {
            initValine();
        });
    </script>



</html>
