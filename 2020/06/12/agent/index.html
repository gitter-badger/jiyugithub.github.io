<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!--icon-->
    
        <link rel="shortcut icon" type='image/x-icon' href="/favicon.ico">
    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- meta -->
    
    <title>动态代理设计模式 | Apocalypse&#39;s Blog</title>
    

    <!-- OpenGraph -->
     
        <meta name="description" content="10分钟看懂动态代理设计模式 动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。">
<meta property="og:type" content="article">
<meta property="og:title" content="动态代理设计模式">
<meta property="og:url" content="https://jiyugithub.github.io/2020/06/12/agent/index.html">
<meta property="og:site_name" content="Apocalypse&#39;s Blog">
<meta property="og:description" content="10分钟看懂动态代理设计模式 动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba292275e28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923a81ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923ae39e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba293f2e59e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294367cdd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294623577?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d87bf2f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d92efdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2dfeb24bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2020-06-11T22:00:05.000Z">
<meta property="article:modified_time" content="2020-06-13T20:42:55.308Z">
<meta property="article:author" content="Apocalypse">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba292275e28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
    

    <!-- feed -->
    

    
<link rel="stylesheet" href="/css/style/main.css">
 
    
    
        
<link rel="stylesheet" href="/css/style/dark.css">

        
<script src="/js/darkmode.js"></script>

    

    
        
            <link rel="stylesheet" id="hljs-default-theme" href="/css/highlight/github.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
            
                <link rel="stylesheet" id="hljs-dark-theme" href="/css/highlight/atom-one-dark.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')!==-1)this.media='all'">
            
        
    

    
        <link rel="stylesheet" href="/css/style/note.css" media="none" onload="this.media='all'">
    

     

    

<meta name="generator" content="Hexo 4.2.1"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">
                Apocalypse's Blog 
            </span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="cover__menus">
                
                    <a href="/" class="cover-menu button">
                        首页
                    </a>
                
                    <a href="/tags/" class="cover-menu button">
                        标签
                    </a>
                
                    <a href="/archives/" class="cover-menu button">
                        归档
                    </a>
                
                    <a href="/friends/" class="cover-menu button">
                        友链
                    </a>
                
                    <a href="/page/" class="cover-menu button">
                        Page
                    </a>
                
            </div>
        
        
            <a href="javaScript:void(0);" id="btn-toggle-dark">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </a>
        
         
            <a href="javaScript:void(0);" id="b2t" style="" aria-label="Back to Top" title="Back to Top">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='32' height='32' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M13.889,11.611c-0.17,0.17-0.443,0.17-0.612,0l-3.189-3.187l-3.363,3.36c-0.171,0.171-0.441,0.171-0.612,0c-0.172-0.169-0.172-0.443,0-0.611l3.667-3.669c0.17-0.17,0.445-0.172,0.614,0l3.496,3.493C14.058,11.167,14.061,11.443,13.889,11.611 M18.25,10c0,4.558-3.693,8.25-8.25,8.25c-4.557,0-8.25-3.692-8.25-8.25c0-4.557,3.693-8.25,8.25-8.25C14.557,1.75,18.25,5.443,18.25,10 M17.383,10c0-4.07-3.312-7.382-7.383-7.382S2.618,5.93,2.618,10S5.93,17.381,10,17.381S17.383,14.07,17.383,10"></path>
                </svg>
            </a>
        
        
            <a class="dropdown-icon button" id="btn-dropdown">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                    <path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path>
                </svg>
            </a>
            <div class="dropdown-menus" id="dropdown-menus">
                <a class="dropback-icon button" id="btn-dropback">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                        <path fill="currentColor" d="M11.469,10l7.08-7.08c0.406-0.406,0.406-1.064,0-1.469c-0.406-0.406-1.063-0.406-1.469,0L10,8.53l-7.081-7.08c-0.406-0.406-1.064-0.406-1.469,0c-0.406,0.406-0.406,1.063,0,1.469L8.531,10L1.45,17.081c-0.406,0.406-0.406,1.064,0,1.469c0.203,0.203,0.469,0.304,0.735,0.304c0.266,0,0.531-0.101,0.735-0.304L10,11.469l7.08,7.081c0.203,0.203,0.469,0.304,0.735,0.304c0.267,0,0.532-0.101,0.735-0.304c0.406-0.406,0.406-1.064,0-1.469L11.469,10z"></path>
                    </svg>
                </a>
                
                    <a href="/" class="dropdown-menu button">
                        首页
                    </a>
                
                    <a href="/tags/" class="dropdown-menu button">
                        标签
                    </a>
                
                    <a href="/archives/" class="dropdown-menu button">
                        归档
                    </a>
                
                    <a href="/friends/" class="dropdown-menu button">
                        友链
                    </a>
                
                    <a href="/page/" class="dropdown-menu button">
                        Page
                    </a>
                
            </div>
            <script>
                document.getElementById('btn-dropdown').addEventListener('click', () => {
                    const dd = document.getElementById('dropdown-menus');
                    requestAnimationFrame(() => {
                        dd.style.display = 'flex';
                        requestAnimationFrame(() => {
                            dd.style.transform = 'translateY(0)';
                            dd.style.opacity = '1';
                        });
                    });
                });
                document.getElementById('btn-dropback').addEventListener('click', () => {
                    const dd = document.getElementById('dropdown-menus');
                    dd.style.transform = 'translateY(2.25rem)';                    
                    dd.style.opacity = '0';
                    setTimeout(() => {dd.style.display = 'none';}, 350);
                });
            </script>
        
    </div>
</header>


            <main class="main">
    <div class="post-title">
    <h1 class="post-title__text">
        动态代理设计模式
    </h1>
    <div class="post-title__meta">
        
            <a href="/archives/2020/06/" class="button" style="color: #808080;">
    2020-06-12
</a>
        
        
            
 
        
        
     
 

  
    </div>
</div>


    <div class="post__with-side">
        <aside class="post-side">
            <div class="post-side__toc">
                <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是代理"><span class="toc-text">什么是代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a）使用继承"><span class="toc-text">a）使用继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理"><span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理"><span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#第一步：生成TimeProxy源码"><span class="toc-text">第一步：生成TimeProxy源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第二步：编译TimeProxy源码"><span class="toc-text">第二步：编译TimeProxy源码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第三步：加载到内存中并创建对象"><span class="toc-text">第三步：加载到内存中并创建对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第四步：增加InvocationHandler接口"><span class="toc-text">第四步：增加InvocationHandler接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用"><span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK实现揭秘"><span class="toc-text">JDK实现揭秘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#答疑解惑"><span class="toc-text">答疑解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#invoke方法的第一个参数proxy到底有什么作用？"><span class="toc-text">invoke方法的第一个参数proxy到底有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态代理到底有什么用？"><span class="toc-text">动态代理到底有什么用？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
            </div>
        </aside>
        <article class="post content-card">
            <div class="post__header">
                
                     
                
                
                    
    <div class="post__expire" id="post-expired-notify">
        <p>
            This article was last updated on <span id="expire-date"></span> days ago, the information described in the article may be outdated.
        </p>
    </div>
    <script>
        (() => {
            var update = Date.parse("2020-06-14"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script>

                
            </div>
            <div class="post__content">
                <div class="md-content">
                    <h1 id="10分钟看懂动态代理设计模式"><a href="#10分钟看懂动态代理设计模式" class="headerlink" title="10分钟看懂动态代理设计模式"></a>10分钟看懂动态代理设计模式</h1><blockquote>
<p>动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。</p>
<p>是的，你没有看错，代理就是这么简单！</p>
<p>理解了代理的意思，你脑海中恐怕还有两个巨大的疑问：</p>
<ul>
<li>怎么实现代理模式</li>
<li>代理模式有什么实际用途</li>
</ul>
<p>要理解这两个问题，看一个简单的例子：</p>
<pre><code>public interface Flyable {
    void fly();
}

public class Bird implements Flyable {

    @Override
    public void fly() {
        System.out.println(&quot;Bird is flying...&quot;);
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？</p>
<p>有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。</p>
<pre><code>   @Override
    public void fly() {
        long start = System.currentTimeMillis();
        System.out.println(&quot;Bird is flying...&quot;);
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
</code></pre><p>的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？</p>
<p>一定会有人说，我可以在调用的地方这样写：</p>
<pre><code>public static void main(String[] args) {
        Bird bird = new Bird();
        long start = System.currentTimeMillis();
        bird.fly();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
}
</code></pre><p>这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？</p>
<h5 id="a）使用继承"><a href="#a）使用继承" class="headerlink" title="a）使用继承"></a>a）使用继承</h5><p>继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。 为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：</p>
<pre><code>public class Bird2 extends Bird {

    @Override
    public void fly() {
        long start = System.currentTimeMillis();

        super.fly();

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>这是一种解决方案，还有一种解决方案叫做：<strong>聚合</strong>，其实也是比较容易想到的。 我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：</p>
<pre><code>public class Bird3 implements Flyable {
    private Bird bird;

    public Bird3(Bird bird) {
        this.bird = bird;
    }

    @Override
    public void fly() {
        long start = System.currentTimeMillis();

        bird.fly();

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！</p>
<p>继续深入思考，用问题推导来解答这个问题：</p>
<p><strong>问题一</strong>：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？ 有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。</p>
<p><strong>问题二</strong>：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？ 有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。</p>
<p>问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 <a href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" target="_blank" rel="noopener">聚合</a> 是否可以避免这个问题呢？ 答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable</p>
<pre><code>public class Bird3 implements Flyable {
    private Flyable flyable;

    public Bird3(Flyable flyable) {
        this.flyable = flyable;
    }

    @Override
    public void fly() {
        long start = System.currentTimeMillis();

        flyable.fly();

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志：</p>
<pre><code>public class BirdLogProxy implements Flyable {
    private Flyable flyable;

    public BirdLogProxy(Flyable flyable) {
        this.flyable = flyable;
    }

    @Override
    public void fly() {
        System.out.println(&quot;Bird fly start...&quot;);

        flyable.fly();

        System.out.println(&quot;Bird fly end...&quot;);
    }
}
</code></pre><p>接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做：</p>
<pre><code>    public static void main(String[] args) {
        Bird bird = new Bird();
        BirdLogProxy p1 = new BirdLogProxy(bird);
        BirdTimeProxy p2 = new BirdTimeProxy(p1);

        p2.fly();
    }
</code></pre><p>反过来，可以这么做：</p>
<pre><code> public static void main(String[] args) {
        Bird bird = new Bird();
        BirdTimeProxy p2 = new BirdTimeProxy(bird);
        BirdLogProxy p1 = new BirdLogProxy(p2);

        p1.fly();
 }
</code></pre><p>看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 <a href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" target="_blank" rel="noopener">聚合</a> 可以做到，而继承不行呢。我们用一张图来解释一下：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba292275e28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。</p>
<p>从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题：</p>
<ul>
<li>如果同时代理多个类，依然会导致类无限制扩展</li>
<li>如果类中有多个方法，同样的逻辑需要反复实现</li>
</ul>
<p>那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：<strong>动态代理</strong>。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。</p>
<p>这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923a81ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 这个第三方库帮我们生成TimeProxy的源码。希望 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 不要成为你的负担，不理解 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 没有关系，你只要把它当成一个Java源码生成工具使用即可。</p>
<p>PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。</p>
<h5 id="第一步：生成TimeProxy源码"><a href="#第一步：生成TimeProxy源码" class="headerlink" title="第一步：生成TimeProxy源码"></a>第一步：生成TimeProxy源码</h5><pre><code>public class Proxy {

    public static Object newProxyInstance() throws IOException {
        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;)
                .addSuperinterface(Flyable.class);

        FieldSpec fieldSpec = FieldSpec.builder(Flyable.class, &quot;flyable&quot;, Modifier.PRIVATE).build();
        typeSpecBuilder.addField(fieldSpec);

        MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(Flyable.class, &quot;flyable&quot;)
                .addStatement(&quot;this.flyable = flyable&quot;)
                .build();
        typeSpecBuilder.addMethod(constructorMethodSpec);

        Method[] methods = Flyable.class.getDeclaredMethods();
        for (Method method : methods) {
            MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName())
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class)
                    .returns(method.getReturnType())
                    .addStatement(&quot;long start = $T.currentTimeMillis()&quot;, System.class)
                    .addCode(&quot;\n&quot;)
                    .addStatement(&quot;this.flyable.&quot; + method.getName() + &quot;()&quot;)
                    .addCode(&quot;\n&quot;)
                    .addStatement(&quot;long end = $T.currentTimeMillis()&quot;, System.class)
                    .addStatement(&quot;$T.out.println(\&quot;Fly Time =\&quot; + (end - start))&quot;, System.class)
                    .build();
            typeSpecBuilder.addMethod(methodSpec);
        }

        JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build();
        // 为了看的更清楚，我将源码文件生成到桌面
        javaFile.writeTo(new File(&quot;/Users/ouyangfeng/Desktop/&quot;));

        return null;
    }

}
</code></pre><p>在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下：</p>
<pre><code>package com.youngfeng.proxy;

import java.lang.Override;
import java.lang.System;

class TimeProxy implements Flyable {
  private Flyable flyable;

  public TimeProxy(Flyable flyable) {
    this.flyable = flyable;
  }

  @Override
  public void fly() {
    long start = System.currentTimeMillis();

    this.flyable.fly();

    long end = System.currentTimeMillis();
    System.out.println(&quot;Fly Time =&quot; + (end - start));
  }
}
</code></pre><h5 id="第二步：编译TimeProxy源码"><a href="#第二步：编译TimeProxy源码" class="headerlink" title="第二步：编译TimeProxy源码"></a>第二步：编译TimeProxy源码</h5><p>编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作：</p>
<pre><code>public class JavaCompiler {

    public static void compile(File javaFile) throws IOException {
        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);
        Iterable iterable = fileManager.getJavaFileObjects(javaFile);
        javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);
        task.call();
        fileManager.close();
    }
}
</code></pre><p>在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成：</p>
<pre><code>// 为了看的更清楚，我将源码文件生成到桌面
String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;;
javaFile.writeTo(new File(sourcePath));

// 编译
JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;));
</code></pre><p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923ae39e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="第三步：加载到内存中并创建对象"><a href="#第三步：加载到内存中并创建对象" class="headerlink" title="第三步：加载到内存中并创建对象"></a>第三步：加载到内存中并创建对象</h5><pre><code>  URL[] urls = new URL[] {new URL(&quot;file:/&quot; + sourcePath)};
  URLClassLoader classLoader = new URLClassLoader(urls);
  Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);
  Constructor constructor = clazz.getConstructor(Flyable.class);
  Flyable flyable = (Flyable) constructor.newInstance(new Bird());
  flyable.fly();
</code></pre><p>通过以上三个步骤，我们至少解决了下面两个问题：</p>
<ul>
<li>不再需要手动创建TimeProxy</li>
<li>可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间</li>
</ul>
<p>可是，说好的任意对象呢？</p>
<h5 id="第四步：增加InvocationHandler接口"><a href="#第四步：增加InvocationHandler接口" class="headerlink" title="第四步：增加InvocationHandler接口"></a>第四步：增加InvocationHandler接口</h5><p>查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba293f2e59e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！</p>
<p>为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增<code>InvocationHandler</code>接口，用于处理自定义逻辑：</p>
<pre><code>public interface InvocationHandler {
    void invoke(Object proxy, Method method, Object[] args);
}
</code></pre><p>想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）：</p>
<ul>
<li>proxy =&gt; 这个参数指定动态生成的代理类，这里是<code>TimeProxy</code></li>
<li>method =&gt; 这个参数表示传入接口中的所有Method对象</li>
<li>args =&gt; 这个参数对应当前method方法中的参数</li>
</ul>
<p>引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样：</p>
<pre><code>MyInvocationHandler handler = new MyInvocationHandler();
Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler);
proxy.fly();

方法执行流：proxy.fly() =&gt; handler.invoke()
</code></pre><p>为此，我们需要在Proxy.newProxyInstance()方法中做如下改动：</p>
<ul>
<li>在newProxyInstance方法中传入InvocationHandler</li>
<li>在生成的代理类中增加成员变量handler</li>
<li>在生成的代理类方法中，调用invoke方法</li>
</ul>
<pre><code>  public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception {
        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(inf);

        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, &quot;handler&quot;, Modifier.PRIVATE).build();
        typeSpecBuilder.addField(fieldSpec);

        MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(InvocationHandler.class, &quot;handler&quot;)
                .addStatement(&quot;this.handler = handler&quot;)
                .build();

        typeSpecBuilder.addMethod(constructorMethodSpec);

        Method[] methods = inf.getDeclaredMethods();
        for (Method method : methods) {
            MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName())
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class)
                    .returns(method.getReturnType())
                    .addCode(&quot;try {\n&quot;)
                    .addStatement(&quot;\t$T method = &quot; + inf.getName() + &quot;.class.getMethod(\&quot;&quot; + method.getName() + &quot;\&quot;)&quot;, Method.class)
                    // 为了简单起见，这里参数直接写死为空
                    .addStatement(&quot;\tthis.handler.invoke(this, method, null)&quot;)
                    .addCode(&quot;} catch(Exception e) {\n&quot;)
                    .addCode(&quot;\te.printStackTrace();\n&quot;)
                    .addCode(&quot;}\n&quot;)
                    .build();
            typeSpecBuilder.addMethod(methodSpec);
        }

        JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build();
        // 为了看的更清楚，我将源码文件生成到桌面
        String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;;
        javaFile.writeTo(new File(sourcePath));

        // 编译
        JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;));

        // 使用反射load到内存
        URL[] urls = new URL[] {new URL(&quot;file:&quot; + sourcePath)};
        URLClassLoader classLoader = new URLClassLoader(urls);
        Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);
        Constructor constructor = clazz.getConstructor(InvocationHandler.class);
        Object obj = constructor.newInstance(handler);

        return obj;
 }
</code></pre><p>上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码：</p>
<p><strong>测试代码</strong></p>
<pre><code>Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird()));
</code></pre><p><strong>生成的TimeProxy.java源码</strong></p>
<pre><code>package com.youngfeng.proxy;

import java.lang.Override;
import java.lang.reflect.Method;

public class TimeProxy implements Flyable {
  private InvocationHandler handler;

  public TimeProxy(InvocationHandler handler) {
    this.handler = handler;
  }

  @Override
  public void fly() {
    try {
        Method method = com.youngfeng.proxy.Flyable.class.getMethod(&quot;fly&quot;);
        this.handler.invoke(this, method, null);
    } catch(Exception e) {
        e.printStackTrace();
    }
  }
}
</code></pre><p><strong>MyInvocationHandler.java</strong></p>
<pre><code>public class MyInvocationHandler implements InvocationHandler {
    private Bird bird;

    public MyInvocationHandler(Bird bird) {
        this.bird = bird;
    }

    @Override
    public void invoke(Object proxy, Method method, Object[] args) {
        long start = System.currentTimeMillis();

        try {
            method.invoke(bird, new Object[] {});
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>至此，整个方法栈的调用栈变成了这样：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294367cdd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。</p>
<p>其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳：</p>
<ul>
<li>Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象</li>
<li>InvocationHandler：这个接口主要用于自定义代理逻辑处理</li>
<li>为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。</li>
</ul>
<p>查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。</p>
<p>这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？</p>
<p>想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！</p>
<p>只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。</p>
<p>事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。</p>
<h3 id="JDK实现揭秘"><a href="#JDK实现揭秘" class="headerlink" title="JDK实现揭秘"></a>JDK实现揭秘</h3><p>通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。</p>
<p><strong>Proxy.java</strong></p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294623577?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>InvocationHandler</strong></p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d87bf2f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义：</p>
<ul>
<li>Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。</li>
<li>Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。</li>
</ul>
<p>最后一个参数就不用说了，和我们实现的版本完全是一样的。</p>
<p>仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d92efdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><em>核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。</em></p>
<p>遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。</p>
<h3 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h3><h5 id="invoke方法的第一个参数proxy到底有什么作用？"><a href="#invoke方法的第一个参数proxy到底有什么作用？" class="headerlink" title="invoke方法的第一个参数proxy到底有什么作用？"></a>invoke方法的第一个参数proxy到底有什么作用？</h5><p>这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。</p>
<h5 id="动态代理到底有什么用？"><a href="#动态代理到底有什么用？" class="headerlink" title="动态代理到底有什么用？"></a>动态代理到底有什么用？</h5><p>学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 <a href="https://baike.baidu.com/item/AOP/1332219" target="_blank" rel="noopener">AOP</a>。所谓的AOP，就像刀一样，抓住时机，趁机插入。</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2dfeb24bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>基于这样一种动态特性，我们可以用它做很多事情，例如：</p>
<ul>
<li>事务提交或回退（Web开发中很常见）</li>
<li>权限管理</li>
<li>自定义缓存逻辑处理</li>
<li>SDK Bug修复 …</li>
</ul>
<p>如果你阅读过 <a href="https://github.com/yuanhoujun/Android_Slide_To_Close" target="_blank" rel="noopener">Android_Slide_To_Close</a> 的源码会发现，它也在某个地方使用了动态代理设计模式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。</p>
<p>为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点：</p>
<ul>
<li>至少已经理解了面向对象语言的多态特性</li>
<li>了解简单的反射用法</li>
<li>会简单使用 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 生成Java源码</li>
</ul>

                </div>
            </div>
            
                
    <div class="post__license">
        <p>
            <strong>Author: </strong>Apocalypse
        </p>
        <p>
            <strong>
                Permalink: 
            </strong>
            <a href="https://jiyugithub.github.io/2020/06/12/agent/">https://jiyugithub.github.io/2020/06/12/agent/</a>
        </p>
        
    </div>
 
            
            
                <div class="post-meta post-footer__meta">
    <p>
        最后更新于：2020-06-14
    </p>
</div> 
            
            
                <div class="post-cats post-card__cats">
    
    
</div> 
             
        </article>
        
    </div>


</main>
<footer class="footer">
     


     
  
    
        
            <p>Copyright © 2020</p>

        
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>


        </div>
        

 

 

 

  

 

 
    
<script src="/js/b2t.js"></script>








    </body>
</html>
