<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">

  

  

  
    <meta name="author" content="Apocalypse">
  

  

  

  <title>HashMap原理技术知识整理 | Apocalypse&#39;s Blog</title>

  

  
    <link rel="icon" href="/favicon.ico">
  

  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.6/styles/monokai.min.css" rel="stylesheet">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div class="root-container">
    <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          Apocalypse&#39;s Blog
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">HOME</a></li>
        
          <li class="navbar-list-item"><a href="/about">ABOUT</a></li>
        
          <li class="navbar-list-item"><a href="/links">LINK</a></li>
        
          <li class="navbar-list-item"><a href="/tags">TAGS</a></li>
        
          <li class="navbar-list-item"><a href="/categories">CATEGORIES</a></li>
        
      </ul>
    </div>
  </div>
</nav>

    
<!-- header container -->
<header class="header-container post">

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-image" style="background-image: url(https://qiniu.miiiku.xyz/src/images/banner.jpg)"></div>
      <div class="post-text">
        <div class="type-wrap">
          
        </div>
        <h1 class="title-wrap">HashMap原理技术知识整理</h1>
        <h2 class="title-sub-wrap">
          <strong>Apocalypse</strong>
          <span>发布于</span>
          
  <a href="javascript:;" class="article-date">
    <time datetime="2020-06-11T21:47:26.000Z" itemprop="datePublished">2020-06-12</time>
  </a>

        </h2>
      </div>
    </div>
  

  
  

  </header>

    <!-- 文章 -->

<!-- 文章内容 -->

<div class="body-container">
  <article class="content-container article-container">
    <div class="article-content">
      
      

      <section class="article-entry">
        <p><img src="http://user-gold-cdn.xitu.io/2020/1/8/16f81686afbf1d6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>HashMap涉及的技术点非常多，典型的数据结构和算法有机结合，JDK对HashMap优化变化中不断权衡时间复杂和空间复杂度。</p>
<a id="more"></a>

<h3 id="一-存储结构"><a href="#一-存储结构" class="headerlink" title="一. 存储结构"></a>一. 存储结构</h3><p>1.JDK1.8之前 HashMap = 数组(O(1)）+ 单向链表（O(n)）</p>
<p>2.JDK1.8之后 HashMap = 数组(O(1)）+ 单向链表（O(n)）+ 红黑树(O(log n)</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/8/16f815af3de6cbaf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HashMap结构图.png"></p>
<p>关于结构的几个关键数字：</p>
<p>1.默认初始化数组容量大小是16。</p>
<p>2.数组扩容刚好是2的次幂。</p>
<p>3.默认的加载因子是0.75。</p>
<p>4.链表长度超过8时将链表转化成红黑树结构。 5.红黑树节点数减少到6的时候退化成链表。</p>
<p>以上几个数字关系，又为什么是上边的几个数字接下来一个个分析。</p>
<h3 id="二-操作原理"><a href="#二-操作原理" class="headerlink" title="二. 操作原理"></a>二. 操作原理</h3><h5 id="1-put储存流程"><a href="#1-put储存流程" class="headerlink" title="1. put储存流程"></a>1. put储存流程</h5><p>①计算桶的位置，根据key的hashcode求出hash值，位置index = hash%length。</p>
<p>②判断是否达到扩容条件，threshold=DEFAULT_INITIAL_CAPACITY * loadFactor（16*0.75=12）大于这个阀门值就需要扩容，否则下一步。</p>
<p>③判断桶位置是否为空，如果为空直接在数据插入数据。如果不为空，下一步。</p>
<p>④判断是链表还是红黑树，链表是否到达转化红黑树，当前链表节点数&lt;=8，插入节点；如果是红黑树插入节点，否则下一步。</p>
<p>⑤链表转化成红黑树，插入节点。</p>
<p>⑥插入节点后计算当前size是否需要扩容，如果大于阀门值需要扩容resize。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Implements Map.put and related methods</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param hash hash for key</span><br><span class="hljs-comment"> * @param key the key</span><br><span class="hljs-comment"> * @param value the value to put</span><br><span class="hljs-comment"> * @param onlyIfAbsent if true, don't change existing value</span><br><span class="hljs-comment"> * @param evict if false, the table is in creation mode.</span><br><span class="hljs-comment"> * @return previous value, or null if none</span><br><span class="hljs-comment"> */</span><br>final V <span class="hljs-built_in">putVal</span>(int hash, K <span class="hljs-built_in">key</span>, V value, boolean onlyIfAbsent,<br>               boolean evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-built_in">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-built_in">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = <span class="hljs-built_in">resize</span>()).length;<br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-built_in">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-built_in">null</span>)<br>        <span class="hljs-built_in">tab</span>[i] = <span class="hljs-built_in">newNode</span>(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-built_in">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).<span class="hljs-built_in">putTreeVal</span>(this, <span class="hljs-built_in">tab</span>, hash, <span class="hljs-built_in">key</span>, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                if ((e = p.next) == <span class="hljs-built_in">null</span>) &#123;<br>                    p.next = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-built_in">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-built_in">treeifyBin</span>(<span class="hljs-built_in">tab</span>, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-built_in">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-built_in">null</span>)<br>                e.value = value;<br>            <span class="hljs-built_in">afterNodeAccess</span>(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    <span class="hljs-built_in">afterNodeInsertion</span>(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上是JDK1.8的HashMap的get调用关键方法源码。</p>
<h5 id="2-get获取过程"><a href="#2-get获取过程" class="headerlink" title="2. get获取过程"></a>2. get获取过程</h5><p>①计算桶的位置，根据key的hashcode求出hash值，位置index = hash%length。</p>
<p>②无论是数值，链表还是红黑树，for循环判断hash值冲突就比对key是否相等，相等就返回对应的value。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs q">/**<br> * Implements Map.<span class="hljs-built_in">get</span> <span class="hljs-built_in">and</span> related methods<br> *<br> * @param hash hash for <span class="hljs-built_in">key</span><br> * @param <span class="hljs-built_in">key</span> the <span class="hljs-built_in">key</span><br> * @return the node, <span class="hljs-built_in">or</span> <span class="hljs-built_in">null</span> if none<br> */<br>final Node&lt;K,V&gt; getNode(<span class="hljs-type">int</span> hash, Object <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; <span class="hljs-type">int</span> n; K k;<br>    if ((tab = table) != <span class="hljs-built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-built_in">null</span>) &#123;<br>        if (<span class="hljs-built_in">first</span>.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            return <span class="hljs-built_in">first</span>;<br>        if ((e = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>) &#123;<br>            if (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                return ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(hash, <span class="hljs-built_in">key</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                if (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    return e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-built_in">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上是JDK1.8的HashMap的put调用关键方法源码。</p>
<h3 id="三-数据结构和算法思考"><a href="#三-数据结构和算法思考" class="headerlink" title="三. 数据结构和算法思考"></a>三. 数据结构和算法思考</h3><h5 id="1-为什么选择数组和链表结构？"><a href="#1-为什么选择数组和链表结构？" class="headerlink" title="1.为什么选择数组和链表结构？"></a>1.为什么选择数组和链表结构？</h5><p>①数组内存连续块分配，效率体现查询更快。HashMap中用作查找数组桶的位置，利用元素的key的hash值对数组长度取模得到。</p>
<p>②链表效率体现增加和删除。HashMap中链表是用来解决hash冲突，增删空间消耗平衡。</p>
<p><strong>扩展：</strong> 为什么不是ArrayList而是使用Node&lt;K,V&gt;[] tab？因为ArrayList的扩容机制是1.5倍扩容，而HashMap扩容是2的次幂。</p>
<h5 id="2-为什么扩容是2次幂，根据key的hashcode再求hash值？"><a href="#2-为什么扩容是2次幂，根据key的hashcode再求hash值？" class="headerlink" title="2.为什么扩容是2次幂，根据key的hashcode再求hash值？"></a>2.为什么扩容是2次幂，根据key的hashcode再求hash值？</h5><h5 id="①key的hash值计算"><a href="#①key的hash值计算" class="headerlink" title="①key的hash值计算"></a>①key的hash值计算</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-built_in">int</span> h;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码意思是hash = hashcode的高16位异化低16位，而不是直接hashcode。</p>
<h5 id="②计算桶的位置代码"><a href="#②计算桶的位置代码" class="headerlink" title="②计算桶的位置代码"></a>②计算桶的位置代码</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">index</span> = (<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) &amp; hash<br></code></pre></td></tr></table></figure>

<p><strong>思想：</strong></p>
<p>一是，为了减少hash冲突使用hash%length计算，求模计算保证了得到的结果一定在0-length范围之内。</p>
<p>二是，为了提高运算速度，模运算比不上位运算，当n是2的次幂才满足hash%length == （n-1）&amp;hash。</p>
<p>确定公式中（n-1）符合最优等式，剩下考虑hash值的最优，hash值这个因子考虑影响结果尽可能不冲突。</p>
<p>因为计算速度体现在位运算上，条件n是2的次幂，那么n-1的换算成二进制前边都是连续的0，后边都是连续的1,。比如n=16，则n-1=15，15的二进制1111。hash &amp; 1111 = 只要关注的hash的二进制的最后四位数进行&amp;运算。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/8/16f815af3f39c141?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="（n-1）&amp; length.png"></p>
<p>如上图，最终会与15的二进制进行1111四位运算，如果与key.hashcode进行与运算的话，只要key的hashcode最后四位为0000前边无论是什么都没关系，这样出现相同值的概率高很多。所以，引入hashcode先高低16位进行异或运算，减少hash冲突。</p>
<p><strong>扩展：</strong> hashcode与equals相等判断对比： 两个key的hashcode相等，key不一定equals。 两个key的equals，hashcode一定相等。</p>
<h5 id="3-为什么加载因子为0-75，链表长度大于8转成红黑树？"><a href="#3-为什么加载因子为0-75，链表长度大于8转成红黑树？" class="headerlink" title="3.为什么加载因子为0.75，链表长度大于8转成红黑树？"></a>3.为什么加载因子为0.75，链表长度大于8转成红黑树？</h5><p><strong>思想：</strong></p>
<p>上边问题不是两个独立问题而是相互相关，<strong>目的尽量减少冲突前提提高空间利用率和减少查询成本的折中。</strong></p>
<p>加载因子决定了HashMap的扩容的阀门值，如果桶是16，那么扩容值16* 0.75=12，也就是12的时候就要考虑扩容，还有4个没有被利用到，牺牲的空间。如果加载因子是1，空间利用率高，但是查询速度变慢。</p>
<p><strong>原理：</strong></p>
<p>权衡依据是以上情况符合泊松分布（一种统计与概率学里常见到的离散概率分布，适合于描述单位时间（或空间）内随机事件发生的次数），<strong>用0.75作为加载因子，每个碰撞位置的链表长度超过８个概率非常低，少于千万分之一。</strong></p>
<p><strong>源码说明：</strong></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">* Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="hljs-comment">* use them only when bins contain enough nodes to warrant use</span><br><span class="hljs-comment">* (see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="hljs-comment">* removal or resizing) they are converted back to plain bins.  In</span><br><span class="hljs-comment">* usages with well-distributed user hashCodes, tree bins are</span><br><span class="hljs-comment">* rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="hljs-comment">* nodes in bins follows a Poisson distribution</span><br><span class="hljs-comment">* (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><br><span class="hljs-comment">* parameter of about 0.5 on average for the default resizing</span><br><span class="hljs-comment">* threshold of 0.75, although with a large variance because of</span><br><span class="hljs-comment">* resizing granularity. Ignoring variance, the expected</span><br><span class="hljs-comment">* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span><br><span class="hljs-comment">* factorial(k)). The first values are:</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 0:    0.60653066</span><br><span class="hljs-comment">* 1:    0.30326533</span><br><span class="hljs-comment">* 2:    0.07581633</span><br><span class="hljs-comment">* 3:    0.01263606</span><br><span class="hljs-comment">* 4:    0.00157952</span><br><span class="hljs-comment">* 5:    0.00015795</span><br><span class="hljs-comment">* 6:    0.00001316</span><br><span class="hljs-comment">* 7:    0.00000094</span><br><span class="hljs-comment">* 8:    0.00000006</span><br><span class="hljs-comment">* more: less than 1 in ten million</span><br></code></pre></td></tr></table></figure>

<p><strong>扩展：</strong></p>
<p>为什么不一开始选择红黑树？</p>
<p>红黑树近乎于平衡二叉树，结构适合均匀分布节点，减少树的深度像链表长度情况。原因主要是插入效率上，红黑树增加节点很可能需要进行左旋，右旋，着色操作，这些时间效率并没有链表形式高。</p>
<h5 id="4-HashMap的key选择"><a href="#4-HashMap的key选择" class="headerlink" title="4.HashMap的key选择"></a>4.HashMap的key选择</h5><p>1）选择不可变的对象，比如字符串或int类型。</p>
<p>2）如果要用一个自定义实体类作为key：</p>
<p>①类添加final修饰符，保证类不被继承。</p>
<p>②保证所有成员变量必须私有，并且加上final修饰。</p>
<p>③不提供改变成员变量的方法，包括setter。</p>
<p>④通过构造器初始化所有成员，进行深拷贝(deep copy)。</p>
<h5 id="5-String类中的hashcode计算"><a href="#5-String类中的hashcode计算" class="headerlink" title="5.String类中的hashcode计算"></a>5.String类中的hashcode计算</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">int</span> h = hash;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">value</span>.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">char</span> val[] = <span class="hljs-keyword">value</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">value</span>.length; i++) &#123;<br>              h = <span class="hljs-number">31</span> * h + val[i];<br>          &#125;<br>          hash = h;<br>      &#125;<br>      <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>哈希计算公式：s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1]</p>
<h3 id="四-横向扩展"><a href="#四-横向扩展" class="headerlink" title="四. 横向扩展"></a>四. 横向扩展</h3><h5 id="1-HashMap出现线程问题"><a href="#1-HashMap出现线程问题" class="headerlink" title="1.HashMap出现线程问题"></a>1.HashMap出现线程问题</h5><p>①多线程扩容，引起的死循环问题（jdk1.8中，死循环问题已经解决）。</p>
<p>②多线程put的时候可能导致元素丢失。</p>
<p>③put非null元素后get出来的却是null。</p>
<h5 id="2-使用线程安全Map"><a href="#2-使用线程安全Map" class="headerlink" title="2.使用线程安全Map"></a>2.使用线程安全Map</h5><p>①HashMap并不是线程安全，要实现线程安全可以用Collections.synchronizedMap(m)获取一个线程安全的HashMap。</p>
<p>②CurrentHashMap和HashTable是线程安全的。CurrentHashMap使用分段锁技术，要操作节点先获取段锁，在修改节点。</p>
<h5 id="3-Android提倡使用ArrayMap"><a href="#3-Android提倡使用ArrayMap" class="headerlink" title="3.Android提倡使用ArrayMap"></a>3.Android提倡使用ArrayMap</h5><p>①ArrayMap数据结构是两个数组，一个存放hash值，另一个存放key和value。</p>
<p>②根据key的hash值利用二分查找在hash数组中找出index。</p>
<p>③根据index在key-value数组中对应位置查找，如果不相等认为冲突了，会以key为中心，分别上下展开，逐一查找。</p>
<p>优势，数据量少时（少于1000）相比HashMap更节省内存。劣势，删除和插入时效率要比HashMap要低。</p>

      </section>

      <section class="article-footer">
        
      </section>

      <section class="article-navs">
        
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
      <div id="article-nav-newer" class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2020/06/12/javafs/"></a>
          <strong class="article-nav-caption">Newer</strong>
          <p class="article-nav-title">
            
              Java反射真的很慢吗
            
          </p>
        </article>
      </div>
    
    
      <div id="article-nav-older" class="card-item">
        <article>
          
          <a class="card-link article-nav-link" href="/2020/06/12/Rxjava/"></a>
          <strong class="article-nav-caption">Older</strong>
          <p class="article-nav-title">
            
              Rxjava只看这一篇文章就够了
            
          </p>
        </article>
      </div>
    
  </div>
</nav>

      </section>

      

  
  
  <div class="valine-container">
    <div id="valine_thread" class="valine-thread"></div>
  </div>
  

  
  


    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
     
    <p>&copy; 2020 <a href="/" target="_blank">Apocalypse</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=a&amp;encode=js&select=%23hitokoto" defer></script>
    

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
  <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
  <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
</svg> 
  </div>

  
  
<!-- valine 评论 start -->
<script type="text/javascript" src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
  new Valine({
    el: "#valine_thread",
    appId: "GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz",
    appKey: "FihoucantYlc5U1FQ9BzkO3l",
    avatar: "mm",
    placeholder: "随便说点什么叭～",
    notify: true,
    visitor: true,
    pageSize: 10,
  });
</script>
<!-- valine 评论 end -->



  <!-- aplayer 音频 start -->
  <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  <script type="text/javascript" src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
  <script type="text/javascript">
    const aplayer = document.querySelectorAll(".aplayer");
    aplayer && initaplayer(aplayer);
    function initaplayer(els) {
      let elsArr = Array.from(els);
      elsArr.forEach(el => {
        new APlayer({
          container: el,
          audio: { ...el.dataset },
          theme: "#b7daff",
          lrcType: 3,
          autoplay: false,
          loop: false,
          mutex: true,
        });
      });
    }
  </script>
  <!-- aplayer 音频 end -->
  

<!-- dplayer 视频 start -->
<script type="text/javascript" src="https://unpkg.com/dplayer@1.25.1/dist/DPlayer.min.js"></script>
<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      let subtitle = el.dataset.subtitle;

      let options = {
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      }

      if (subtitle) {
        options.subtitle = {
          url: el.dataset.subtitle,
        }
      }
      new DPlayer(options);
    });
  }
</script>
<!-- dplayer 视频 end -->


<!-- waterfall 瀑布流 start -->

<script src="/lib/waterfall.min.js"></script>

<script type="text/javascript">

const waterfalls = document.querySelectorAll(".waterfall-container");

if (waterfalls && waterfalls.length > 0) {
  waterfalls.forEach((waterfall, index) => {
    let cls = "waterfall-container-" + index;
    waterfall.classList.add(cls);
    initWaterfall(cls, waterfall);
  });
}

function initWaterfall(selector, el) {
  const options = {};
  if (Object.keys(el.dataset).length > 0) {
    for (let k in el.dataset) {
      options[k] = el.dataset[k];
    }
  }
  waterfall(`.${selector}`, options);
}
</script>
<!-- waterfall 瀑布流 end -->


  <!-- zoom start -->
  
<script src="/lib/zoom.min.js"></script>

  <script type="text/javascript">
    document.querySelector(".article-content") && zoom(".article-content");
  </script>
  <!-- zoom end -->
  



  


  


  




<script src="/js/script.js"></script>

  
  <!-- 尾部用户自定义相关内容 -->

</body>
</html>