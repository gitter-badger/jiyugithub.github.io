<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Apocalypse">





<title>Java反射真的很慢吗 | Apocalypse&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Apocalypse&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Apocalypse&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java反射真的很慢吗</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Apocalypse</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 12, 2020&nbsp;&nbsp;5:49:50</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="反射到底是好是坏"><a href="#反射到底是好是坏" class="headerlink" title="反射到底是好是坏"></a>反射到底是好是坏</h2><p>说到Java 中的反射，初学者在刚刚接触到反射的各种高级特性时，往往表示十分兴奋，甚至会在一些不需要使用反射的场景中强行使用反射来「炫技」。而经验较为丰富的长者，看到反射时往往会发出灵魂三问：为什么要用反射？反射不会降低性能么？不用还有什么办法可以解决这个问题？</p>
<a id="more"></a>

<p>那么今天我们就来深入探讨下，反射到底对性能有多大影响？顺便探讨下，反射为什么对性能有影响？</p>
<h2 id="编码试验"><a href="#编码试验" class="headerlink" title="编码试验"></a>编码试验</h2><p>在我们分析具体原理之前，我们可以通过编写代码做实验得出结论。</p>
<p>反射可能会涉及多种类型的操作，比如生成实例，获取/设置变量属性，调用方法等。经过简单的思考，我们认为生成实例对性能的影响相对其他操作要大一些，所以我们采用生成实例来做试验。</p>
<p>在如下代码中，我们定义了一个类 <code>InnerClass</code>，我们测试分别使用<code>new</code>和<code>反射</code>来生成 <code>MAX_TIMES</code>个实例，并打印出耗时时间。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MainActivity extends AppCompatActivity &#123;<br><br>    <span class="hljs-keyword">private</span> static final String TAG = <span class="hljs-string">"MainAc"</span>;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-built_in">int</span> MAX_TIMES = <span class="hljs-number">100</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> InnerClass innerList<span class="hljs-literal">[]</span>;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>        set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br><br>        innerList = <span class="hljs-keyword">new</span> InnerClass<span class="hljs-literal">[MAX<span class="hljs-identifier">_TIMES</span>]</span>;<br><br>        long startTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>elapsed<span class="hljs-constructor">Realtime()</span>;<br>        for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX_TIMES; i++) &#123;<br>            innerList<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InnerClass()</span>;<br>        &#125;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(TAG, <span class="hljs-string">"totalTime: "</span> + (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>elapsed<span class="hljs-constructor">Realtime()</span> - startTime));<br><br>        long startTime2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>elapsed<span class="hljs-constructor">Realtime()</span>;<br>        for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX_TIMES; i++) &#123;<br>            innerList<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-keyword">new</span><span class="hljs-constructor">InstanceByReflection()</span>;<br>        &#125;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(TAG, <span class="hljs-string">"totalTime2: "</span> + (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>elapsed<span class="hljs-constructor">Realtime()</span> - startTime2));<br>    &#125;<br><br>    public InnerClass <span class="hljs-keyword">new</span><span class="hljs-constructor">InstanceByReflection()</span> &#123;<br>        Class clazz = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">InnerClass</span>.</span></span><span class="hljs-keyword">class</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            return (InnerClass) clazz.get<span class="hljs-constructor">DeclaredConstructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>        &#125; catch (NoSuchMethodException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; catch (IllegalAccessException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; catch (InstantiationException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; catch (InvocationTargetException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>        return null;<br>    &#125;<br><br>    static <span class="hljs-keyword">class</span> InnerClass &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">2020</span><span class="hljs-number">-03</span><span class="hljs-number">-19</span> <span class="hljs-number">22</span>:<span class="hljs-number">34</span>:<span class="hljs-number">49.738</span> <span class="hljs-number">2151</span><span class="hljs-number">-2151</span>/? E/MainAc: totalTime: <span class="hljs-number">15</span><br><span class="hljs-number">2020</span><span class="hljs-number">-03</span><span class="hljs-number">-19</span> <span class="hljs-number">22</span>:<span class="hljs-number">34</span>:<span class="hljs-number">50.409</span> <span class="hljs-number">2151</span><span class="hljs-number">-2151</span>/? E/MainAc: totalTime2: <span class="hljs-number">670</span><br></code></pre></td></tr></table></figure>

<p>使用反射生成 10万 个实例，耗时 670ms，明显高于直接使用 <code>new</code>关键字的 15ms，所以反射性能低。别急，这个结论总结的还有点早，我们将要生成的实例总数改为 1000个试试，输出日志：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">2020</span><span class="hljs-number">-03</span><span class="hljs-number">-19</span> <span class="hljs-number">22</span>:<span class="hljs-number">39</span>:<span class="hljs-number">21.287</span> <span class="hljs-number">3641</span><span class="hljs-number">-3641</span>/com.example.myapplication E/MainAc: totalTime: <span class="hljs-number">2</span><br><span class="hljs-number">2020</span><span class="hljs-number">-03</span><span class="hljs-number">-19</span> <span class="hljs-number">22</span>:<span class="hljs-number">39</span>:<span class="hljs-number">21.296</span> <span class="hljs-number">3641</span><span class="hljs-number">-3641</span>/com.example.myapplication E/MainAc: totalTime2: <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>

<p>使用反射生成 1000 个实例，虽然需要9ms，高于<code>new</code>的 2ms，但是 9ms 和 2ms 的差距本身肉眼不可见，而且通常我们在业务中写的反射一般来说执行频率也未必会超过 1000 次，这种场景下，我们还能理直气壮地说反射性能很低么？</p>
<p>很显然，不能。</p>
<p>除了代码执行耗时，我们再看看反射对内存的影响。我们仍然以生成 10万 个实例为目标，对上述代码做略微改动，依次只保留 <code>new</code> 方式和反射方式，然后运行程序，观察内存占用情况。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df2febd3611?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>使用 <code>new</code> 方式</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df300d4decd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>使用反射</p>
<p>对比两图，我们可以看到第二张图中多了很多 <code>Constructor</code>和<code>Class</code>对象实例，这两部分占用的内存2.7M。因此，我们可以得出结论，反射会产生大量的临时对象，并且会占用额外内存空间。</p>
<h2 id="刨根问底：反射原理是什么"><a href="#刨根问底：反射原理是什么" class="headerlink" title="刨根问底：反射原理是什么"></a>刨根问底：反射原理是什么</h2><p>我们以前面试验中反射生成实例的代码为入口。</p>
<p>首先回顾下虚拟机中类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载。在加载的过程 中，虚拟机会把类的字节码转换成运行时数据结构，并保存在方法区，在内存中会生成一个代表这个类数据结构的 java.lang.Class 对象，后续访问这个类的数据结构就可以通过这个 Class 对象来访问。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> InnerClass <span class="hljs-keyword">new</span><span class="hljs-type">InstanceByReflection</span>() &#123;<br>    <span class="hljs-comment">// 获取虚拟机中 InnerClass 类的 Class 对象</span><br>    Class clazz = InnerClass.class;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (InnerClass) clazz.getDeclaredConstructor().<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码中 <code>clazz.getDeclaredConstructor()</code> 用于获取类中定义的构造方法，由于我们没有显式定义构造方法，所以会返回编译器为我们自己生成的默认无参构造方法。</p>
<p>下面我们看下 <code>getDeclaredConstructor</code>是如何返回构造方法的。以下均以 jdk 1.8代码为源码。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">@CallerSensitive<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>&lt;?&gt;... parameterTypes)</span></span><br><span class="hljs-function">    <span class="hljs-title">throws</span> <span class="hljs-title">NoSuchMethodException</span>, <span class="hljs-title">SecurityException</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    // 权限检查</span></span><br><span class="hljs-function"><span class="hljs-comment">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span></span><br><span class="hljs-function"><span class="hljs-comment">    return getConstructor0(parameterTypes, Member.DECLARED);</span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br></code></pre></td></tr></table></figure>

<p><code>getDeclaredConstructor</code> 方法首先做了权限检查，然后直接调用 <code>getConstructor0</code> 方法。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">getConstructor0</span><span class="hljs-params">(<span class="hljs-keyword">Class</span>&lt;?&gt;[] parameterTypes,</span></span><br><span class="hljs-function"><span class="hljs-params">                                    int which)</span> <span class="hljs-title">throws</span> <span class="hljs-title">NoSuchMethodException</span></span><br><span class="hljs-function"><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    // privateGetDeclaredConstructors 方法是获取所有的构造方法数组</span></span><br><span class="hljs-function"><span class="hljs-comment">    Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span></span><br><span class="hljs-function"><span class="hljs-comment">    // 遍历所有的构造方法数组，根据传入的参数类型依次匹配，找到合适的构造方法后就会拷贝一份作为返回值</span></span><br><span class="hljs-function"><span class="hljs-comment">    for (Constructor&lt;T&gt; constructor : constructors) &#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">        if (arrayContentsEq(parameterTypes,</span></span><br><span class="hljs-function"><span class="hljs-comment">                            constructor.getParameterTypes())) &#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">            // 拷贝构造方法</span></span><br><span class="hljs-function"><span class="hljs-comment">            return getReflectionFactory().copyConstructor(constructor);</span></span><br><span class="hljs-function"><span class="hljs-comment">        &#125;</span></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">    <span class="hljs-comment">// 没有找到的话，就抛出异常 </span></span><br><span class="hljs-function">    <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">NoSuchMethodException</span><span class="hljs-params">(getName()</span> + ".&lt;<span class="hljs-title">init</span>&gt;" + <span class="hljs-title">argumentTypesToString</span><span class="hljs-params">(parameterTypes)</span>);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>getConstructor0</code> 方法主要做了两件事：</p>
<ul>
<li>获取所有构造方法组成的数组</li>
<li>遍历构造方法数组，找到匹配的</li>
</ul>
<p>遍历匹配没啥好说的，我们重点看下第一件事，怎么获取的所有构造方法数组，也就是这个方法 <code>privateGetDeclaredConstructors</code>。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Constructor&lt;T&gt;<span class="hljs-literal">[]</span> <span class="hljs-keyword">private</span><span class="hljs-constructor">GetDeclaredConstructors(<span class="hljs-params">boolean</span> <span class="hljs-params">publicOnly</span>)</span> &#123;<br>    check<span class="hljs-constructor">Initted()</span>;<br>    Constructor&lt;T&gt;<span class="hljs-literal">[]</span> res;<br>    <span class="hljs-comment">// 获取缓存的 ReflectionData 数据</span><br>    ReflectionData&lt;T&gt; rd = reflection<span class="hljs-constructor">Data()</span>;<br>    <span class="hljs-comment">// 如果缓存中有 ReflectionData，就先看看 ReflectionData 中的 publicConstructors 或 declaredConstructors是否为空</span><br>    <span class="hljs-keyword">if</span> (rd != null) &#123;<br>        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;<br>        <span class="hljs-keyword">if</span> (res != null) return res;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有缓存，或者缓存中构造方法数组为空</span><br>    <span class="hljs-comment">// No cached value available; request value from VM</span><br>    <span class="hljs-comment">// 对接口类型的字节码特殊处理</span><br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Interface()</span>) &#123;<br>        @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br>        <span class="hljs-comment">// 如果是接口类型，那么生成一个长度为0的构造方法数组</span><br>        Constructor&lt;T&gt;<span class="hljs-literal">[]</span> temporaryRes = (Constructor&lt;T&gt;<span class="hljs-literal">[]</span>) <span class="hljs-keyword">new</span> Constructor&lt;?&gt;<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>        res = temporaryRes;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不是接口类型，就调用 getDeclaredConstructors0 获取构造方法数组</span><br>        res = get<span class="hljs-constructor">DeclaredConstructors0(<span class="hljs-params">publicOnly</span>)</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取到构造方法数组后，再赋值给缓存 ReflectionData 中的对应属性</span><br>    <span class="hljs-keyword">if</span> (rd != null) &#123;<br>        <span class="hljs-keyword">if</span> (publicOnly) &#123;<br>            rd.publicConstructors = res;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rd.declaredConstructors = res;<br>        &#125;<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中我已经对关键代码进行了注释，在讲解整个流程之前，我们看到了一个陌生的类型 <code>ReflectionData</code>。它对应的数据结构是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectionData</span>&lt;T&gt; &#123;</span><br>    <span class="hljs-keyword">volatile</span> Field[] declaredFields;<br>    <span class="hljs-keyword">volatile</span> Field[] publicFields;<br>    <span class="hljs-keyword">volatile</span> Method[] declaredMethods;<br>    <span class="hljs-keyword">volatile</span> Method[] publicMethods;<br>    <span class="hljs-keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;<br>    <span class="hljs-keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;<br>    <span class="hljs-comment">// Intermediate results for getFields and getMethods</span><br>    <span class="hljs-keyword">volatile</span> Field[] declaredPublicFields;<br>    <span class="hljs-keyword">volatile</span> Method[] declaredPublicMethods;<br>    <span class="hljs-keyword">volatile</span> Class&lt;?&gt;[] interfaces;<br><br>    <span class="hljs-comment">// Value of classRedefinedCount when we created this ReflectionData instance</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> redefinedCount;<br><br>    ReflectionData(<span class="hljs-keyword">int</span> redefinedCount) &#123;<br>        <span class="hljs-keyword">this</span>.redefinedCount = redefinedCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ReflectionData</code> 这个类就是用来保存从虚拟机中获取到的一些数据。同时我们可以看到所有反射属性都使用了 <code>volatile</code>关键字修饰。</p>
<p>获取缓存的 <code>ReflectionData</code> 数据是通过调用<code>reflectionData()</code>方法获取的。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 定义在 Class 类中的反射缓存对象</span><br><span class="hljs-keyword">private</span> volatile transient SoftReference&lt;ReflectionData&lt;T&gt;&gt; <span class="hljs-built_in">ref</span>lectionData;<br><br><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-built_in">ref</span>lectionData() &#123;<br>    SoftReference&lt;ReflectionData&lt;T&gt;&gt; <span class="hljs-built_in">ref</span>lectionData = <span class="hljs-keyword">this</span>.<span class="hljs-built_in">ref</span>lectionData;<br>    <span class="hljs-built_in">int</span> classRedefinedCount = <span class="hljs-keyword">this</span>.classRedefinedCount;<br>    ReflectionData&lt;T&gt; rd;<br>    <span class="hljs-keyword">if</span> (useCaches &amp;&amp;<br>        <span class="hljs-built_in">ref</span>lectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>        (rd = <span class="hljs-built_in">ref</span>lectionData.<span class="hljs-keyword">get</span>()) != <span class="hljs-literal">null</span> &amp;&amp;<br>        rd.redefinedCount == classRedefinedCount) &#123;<br>        <span class="hljs-keyword">return</span> rd;<br>    &#125;<br>    <span class="hljs-comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span><br>    <span class="hljs-comment">// -&gt; create and replace new instance</span><br>    <span class="hljs-keyword">return</span> newReflectionData(<span class="hljs-built_in">ref</span>lectionData, classRedefinedCount);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到 <code>reflectionData</code>实际上是一个软引用，软引用会在内存不足的情况下被虚拟机回收，所以<code>reflectionData()</code>方法在开始的地方，先判断了是否可以使用缓存以及缓存是否失效，如果失效了，就会调用 <code>newReflectionData</code>方法生成一个新的 <code>ReflectionData</code> 实例。</p>
<p>接下来看看 <code>newReflectionData</code> 方法。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> ReflectionData&lt;T&gt; <span class="hljs-keyword">new</span><span class="hljs-type">ReflectionData</span>(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,<br>                                                int classRedefinedCount) &#123;<br>    <span class="hljs-comment">// 如果不允许使用缓存，直接返回 null</span><br>    <span class="hljs-keyword">if</span> (!useCaches) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        ReflectionData&lt;T&gt; rd = <span class="hljs-keyword">new</span> <span class="hljs-type">ReflectionData</span>&lt;&gt;(classRedefinedCount);<br>        <span class="hljs-comment">// try to CAS it...</span><br>        <span class="hljs-keyword">if</span> (Atomic.casReflectionData(<span class="hljs-built_in">this</span>, oldReflectionData, <span class="hljs-keyword">new</span> <span class="hljs-type">SoftReference</span>&lt;&gt;(rd))) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>        <span class="hljs-comment">// else retry</span><br>        oldReflectionData = <span class="hljs-built_in">this</span>.reflectionData;<br>        classRedefinedCount = <span class="hljs-built_in">this</span>.classRedefinedCount;<br>        <span class="hljs-keyword">if</span> (oldReflectionData != <span class="hljs-literal">null</span> &amp;&amp;<br>            (rd = oldReflectionData.<span class="hljs-keyword">get</span>()) != <span class="hljs-literal">null</span> &amp;&amp;<br>            rd.redefinedCount == classRedefinedCount) &#123;<br>            <span class="hljs-keyword">return</span> rd;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>newReflectionData</code>中使用 <strong>volatile + 死循环 + CAS 机制</strong> 保证线程安全。注意到这里的死循环每执行一次都会构造一个新的 <code>ReflectionData</code> 实例。</p>
<p>你可能会有疑问，<code>Class</code> 中 <code>reflectionData</code>属性什么时候被赋值的，其实是封装在<code>Atomic.casReflectionData</code>这个方法里了，他会检测当前<code>Class</code>对象中的<code>reflectionData</code>是否与<code>oldReflectionData</code>相等，如果相等，就会把<code>new SoftReference&lt;&gt;(rd)</code>赋值给 <code>reflectionData</code>。</p>
<p>到现在为止，关于 <code>ReflectionData</code>的背景知识都介绍完了。我们再回到 <code>privateGetDeclaredConstructors</code>中看看获取构造方法的流程。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df304157365?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>privateGetDeclaredConstructors</code>流程图</p>
<p>可以看到对于普通类，最终通过调用 <code>getDeclaredConstructors0</code>方法获取的构造方法列表。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">private</span> native <span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">T</span>&gt;[] <span class="hljs-title">getDeclaredConstructors0</span><span class="hljs-params">(boolean publicOnly)</span>;</span><br></code></pre></td></tr></table></figure>

<p>这个方法是 native 的，具体逻辑在 jdk 源码中。</p>
<p>在 <code>native/java/lang/Class_getDeclaredConstructors0.c</code> 文件中，</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void get<span class="hljs-constructor">DeclaredConstructors0(Frame <span class="hljs-operator">*</span> <span class="hljs-params">frame</span>)</span><br>&#123;<br>    <span class="hljs-comment">// Frame 可以理解为调用native方法时，java层传递过来的数据的一种封装</span><br>	LocalVars<span class="hljs-operator"> * </span>vars = frame-&gt;localVars;<br>	Object<span class="hljs-operator"> * </span>classObj = get<span class="hljs-constructor">LocalVarsThis(<span class="hljs-params">vars</span>)</span>;<br>    <span class="hljs-comment">// 取得java方法的入参</span><br>	<span class="hljs-built_in">bool</span> publicOnly = get<span class="hljs-constructor">LocalVarsBoolean(<span class="hljs-params">vars</span>, 1)</span>;<br><br>	uint16_t constructorsCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 获取要查询的类的 Class 对象</span><br>	Class<span class="hljs-operator"> * </span>c = classObj-&gt;extra;<br>    <span class="hljs-comment">// 获取这个类的所有构造方法，且数量保存在 constructorsCount 中</span><br>	Method*<span class="hljs-operator"> * </span>constructors = get<span class="hljs-constructor">ClassConstructors(<span class="hljs-params">c</span>, <span class="hljs-params">publicOnly</span>, &amp;<span class="hljs-params">constructorsCount</span>)</span>;<br>	<span class="hljs-comment">// 获取 java 方法调用所属的 classLoader</span><br>	ClassLoader<span class="hljs-operator"> *  </span>classLoader = frame-&gt;<span class="hljs-keyword">method</span>-&gt;classMember.attachClass-&gt;classLoader;<br>	<span class="hljs-comment">// 拿到 Constructor 对应的 class 对象</span><br>	Class<span class="hljs-operator"> * </span>constructorClass = load<span class="hljs-constructor">Class(<span class="hljs-params">classLoader</span>, <span class="hljs-string">"java/lang/reflect/Constructor"</span>)</span>;<br>    <span class="hljs-comment">//创建一个长度为 constructorsCount 的数组保存构造方法</span><br>	Object<span class="hljs-operator"> * </span>constructorArr = <span class="hljs-keyword">new</span><span class="hljs-constructor">Array(<span class="hljs-params">arrayClass</span>(<span class="hljs-params">constructorClass</span>)</span>, constructorsCount);<br><br>	push<span class="hljs-constructor">OperandRef(<span class="hljs-params">frame</span>-&gt;<span class="hljs-params">operandStack</span>, <span class="hljs-params">constructorArr</span>)</span>;<br>	<span class="hljs-comment">// 后面是具体的赋值逻辑。将native中的Method对象转化为java层的Constructor对象</span><br>	<span class="hljs-keyword">if</span> (constructorsCount &gt; <span class="hljs-number">0</span>)<br>	&#123;<br>		Thread<span class="hljs-operator"> * </span>thread = frame-&gt;thread;<br>		Object*<span class="hljs-operator"> * </span>constructorObjs = get<span class="hljs-constructor">ObjectRefs(<span class="hljs-params">constructorArr</span>)</span>;<br><br>		Method<span class="hljs-operator"> * </span>constructorInitMethod = get<span class="hljs-constructor">ClassConstructor(<span class="hljs-params">constructorClass</span>, <span class="hljs-params">_constructorConstructorDescriptor</span>)</span>;<br>		for (uint16_t i = <span class="hljs-number">0</span>; i &lt; constructorsCount; i++)<br>		&#123;<br>			Method<span class="hljs-operator"> * </span>constructor = constructors<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br><br>			Object<span class="hljs-operator"> * </span>constructorObj = <span class="hljs-keyword">new</span><span class="hljs-constructor">Object(<span class="hljs-params">constructorClass</span>)</span>;<br>			constructorObj-&gt;extra = constructor;<br>			constructorObjs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = constructorObj;<br><br>			OperandStack<span class="hljs-operator"> * </span>ops = <span class="hljs-keyword">new</span><span class="hljs-constructor">OperandStack(9)</span>;<br>			push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">constructorObj</span>)</span>;<br>			push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">classObj</span>)</span>;<br>			push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">toClassArr</span>(<span class="hljs-params">classLoader</span>, <span class="hljs-params">methodParameterTypes</span>(<span class="hljs-params">constructor</span>)</span>, constructor-&gt;parsedDescriptor-&gt;parameterTypesCount));<br>			<span class="hljs-keyword">if</span> (constructor-&gt;exceptions != NULL)<br>				push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">toClassArr</span>(<span class="hljs-params">classLoader</span>, <span class="hljs-params">methodExceptionTypes</span>(<span class="hljs-params">constructor</span>)</span>, constructor-&gt;exceptions-&gt;number_of_exceptions));<br>			<span class="hljs-keyword">else</span><br>				push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">toClassArr</span>(<span class="hljs-params">classLoader</span>, <span class="hljs-params">methodExceptionTypes</span>(<span class="hljs-params">constructor</span>)</span>, <span class="hljs-number">0</span>));<br>			push<span class="hljs-constructor">OperandInt(<span class="hljs-params">ops</span>, <span class="hljs-params">constructor</span>-&gt;<span class="hljs-params">classMember</span>.<span class="hljs-params">accessFlags</span>)</span>;<br>			push<span class="hljs-constructor">OperandInt(<span class="hljs-params">ops</span>, 0)</span>;<br>			push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">getSignatureStr</span>(<span class="hljs-params">classLoader</span>, <span class="hljs-params">constructor</span>-&gt;<span class="hljs-params">classMember</span>.<span class="hljs-params">signature</span>)</span>);         <span class="hljs-comment">// signature</span><br>			push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">toByteArr</span>(<span class="hljs-params">classLoader</span>, <span class="hljs-params">constructor</span>-&gt;<span class="hljs-params">classMember</span>.<span class="hljs-params">annotationData</span>, <span class="hljs-params">constructor</span>-&gt;<span class="hljs-params">classMember</span>.<span class="hljs-params">annotationDataLen</span>)</span>);<br>			push<span class="hljs-constructor">OperandRef(<span class="hljs-params">ops</span>, <span class="hljs-params">toByteArr</span>(<span class="hljs-params">classLoader</span>, <span class="hljs-params">constructor</span>-&gt;<span class="hljs-params">parameterAnnotationData</span>, <span class="hljs-params">constructor</span>-&gt;<span class="hljs-params">parameterAnnotationDataLen</span>)</span>);<br><br><br>			Frame<span class="hljs-operator"> * </span>shimFrame = <span class="hljs-keyword">new</span><span class="hljs-constructor">ShimFrame(<span class="hljs-params">thread</span>, <span class="hljs-params">ops</span>)</span>;<br>			push<span class="hljs-constructor">ThreadFrame(<span class="hljs-params">thread</span>, <span class="hljs-params">shimFrame</span>)</span>;<br><br>			<span class="hljs-comment">// init constructorObj</span><br>			<span class="hljs-constructor">InvokeMethod(<span class="hljs-params">shimFrame</span>, <span class="hljs-params">constructorInitMethod</span>)</span>;<br>		&#125;<br><br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的逻辑，可以知道获取构造方法的核心方法是 <code>getClassConstructors</code> ，所在文件为 <code>rtda/heap/class.c</code>。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-function"><span class="hljs-keyword">Method</span>* * <span class="hljs-title">getClassConstructors</span>(</span><span class="hljs-class"><span class="hljs-keyword">Class</span> * <span class="hljs-title">self</span>, <span class="hljs-title">bool</span> <span class="hljs-title">publicOnly</span>, <span class="hljs-title">uint16_t</span> * <span class="hljs-title">constructorsCount</span>)</span><br>&#123;<br>    // 分配大小为 sizeof(<span class="hljs-function"><span class="hljs-keyword">Method</span>) 的长度为 <span class="hljs-title">methodsCount</span> 的连续内存地址，即数组</span><br>	<span class="hljs-function"><span class="hljs-keyword">Method</span>* * <span class="hljs-title">constructors</span> =</span> calloc(<span class="hljs-built_in">self</span>-&gt;methodsCount, sizeof(<span class="hljs-function"><span class="hljs-keyword">Method</span>));</span><br>	*constructorsCount = <span class="hljs-number">0</span>;<br>    // 在native 层，构造方法和普通方法都存在 methods 中，逐一遍历<br>	<span class="hljs-keyword">for</span> (uint16_t i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">self</span>-&gt;methodsCount; i++)<br>	&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">Method</span> * <span class="hljs-title">method</span> =</span> <span class="hljs-built_in">self</span>-&gt;methods + i;<br>        // 判断是否是构造方法<br>		<span class="hljs-keyword">if</span> (isMethodConstructor(<span class="hljs-function"><span class="hljs-keyword">method</span>))</span><br>		&#123;<br>            // 检查权限<br>			<span class="hljs-keyword">if</span> (!publicOnly || isMethodPublic(<span class="hljs-function"><span class="hljs-keyword">method</span>))</span><br>			&#123;<br>                // 符合条件的构造方法依次存到数组中<br>				constructors[*constructorsCount] = <span class="hljs-function"><span class="hljs-keyword">method</span>;</span><br>				(*constructorsCount)++;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> constructors;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到<code>getClassConstructors</code>实际上就是对 <code>methods</code> 进行了一次过滤，过滤的条件为：1.是构造方法；2.权限一致。</p>
<p><code>isMethodConstructor</code> 方法的判断逻辑也是十分简单，不是静态方法，而且方法名是<code>&lt;init&gt;</code>即可。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">bool isMethodConstructor(<span class="hljs-function"><span class="hljs-keyword">Method</span> * <span class="hljs-title">self</span>)</span><br><span class="hljs-function"><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">	return !isMethodStatic(self) &amp;&amp; strcmp(self-&gt;classMember.name, "&lt;init&gt;") == 0;	</span></span><br><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><br></code></pre></td></tr></table></figure>

<p>所以核心的逻辑变成了<code>Class</code>中的 <code>methods</code>数组何时被初始化赋值的？我们刨根问底的追踪下。</p>
<p>我们先找到类加载到虚拟机中的入口方法 <code>loadNonArrayClass</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Class * <span class="hljs-title">loadNonArrayClass</span><span class="hljs-params">(ClassLoader * classLoader, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * className)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int32_t</span> classSize = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">char</span> * classContent = <span class="hljs-literal">NULL</span>;<br>	Class * loadClass = <span class="hljs-literal">NULL</span>;<br>	classSize = readClass(className, &amp;classContent);<br>	<span class="hljs-keyword">if</span> (classSize &gt; <span class="hljs-number">0</span> &amp;&amp; classContent != <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"class size:%d,class data:["</span>, classSize);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; classSize; i++)<br>		&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0x%02x "</span>, classContent[i]);<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"]\n"</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>	&#125;<br>	<span class="hljs-keyword">if</span> (classSize &lt;= <span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Could not found target class\n"</span>);<br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">127</span>);<br>	&#125;<br>	<span class="hljs-comment">// 解析字节码文件</span><br>	loadClass = parseClassFile(classContent, classSize);<br>	loadClass-&gt;classLoader = classLoader;<br>	<span class="hljs-comment">// 加载</span><br>	defineClass(classLoader, loadClass);<br>	<span class="hljs-comment">// 链接</span><br>	linkClass(classLoader, loadClass);<br><br>	<span class="hljs-comment">//printf("[Loaded %s\n", loadClass-&gt;name);</span><br>	<span class="hljs-keyword">return</span> loadClass;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>parseClassFile</code>方法中，调用了<code>newClass</code>方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class<span class="hljs-operator"> * </span>parse<span class="hljs-constructor">ClassFile(<span class="hljs-params">char</span> <span class="hljs-operator">*</span> <span class="hljs-params">classContent</span>, <span class="hljs-params">int32_t</span> <span class="hljs-params">classSize</span>)</span><br>&#123;<br>	ClassFile<span class="hljs-operator"> * </span>classFile = NULL;<br><br>	classFile = parse<span class="hljs-constructor">ClassData(<span class="hljs-params">classContent</span>, <span class="hljs-params">classSize</span>)</span>;<br><br>	return <span class="hljs-keyword">new</span><span class="hljs-constructor">Class(<span class="hljs-params">classFile</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>newClass</code>方法在<code>rtda/heap/class.c</code>文件中。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class<span class="hljs-operator"> * </span><span class="hljs-keyword">new</span><span class="hljs-constructor">Class(ClassFile <span class="hljs-operator">*</span> <span class="hljs-params">classFile</span>)</span><br>&#123;<br>	Class<span class="hljs-operator"> * </span>c = calloc(<span class="hljs-number">1</span>, sizeof(Class));<br>	c-&gt;accessFlags = classFile-&gt;accessFlags;<br>	c-&gt;sourceFile = get<span class="hljs-constructor">ClassSourceFileName(<span class="hljs-params">classFile</span>)</span>;<br>	<span class="hljs-keyword">new</span><span class="hljs-constructor">ClassName(<span class="hljs-params">c</span>, <span class="hljs-params">classFile</span>)</span>;<br>	<span class="hljs-keyword">new</span><span class="hljs-constructor">SuperClassName(<span class="hljs-params">c</span>, <span class="hljs-params">classFile</span>)</span>;<br>	<span class="hljs-keyword">new</span><span class="hljs-constructor">InterfacesName(<span class="hljs-params">c</span>, <span class="hljs-params">classFile</span>)</span>;<br>	<span class="hljs-keyword">new</span><span class="hljs-constructor">ConstantPool(<span class="hljs-params">c</span>, <span class="hljs-params">classFile</span>)</span>;<br>	<span class="hljs-keyword">new</span><span class="hljs-constructor">Fields(<span class="hljs-params">c</span>, <span class="hljs-params">classFile</span>)</span>;<br>	<span class="hljs-keyword">new</span><span class="hljs-constructor">Methods(<span class="hljs-params">c</span>, <span class="hljs-params">classFile</span>)</span>;<br>	return c;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在native层创建了一个<code>Class</code>对象，我们重点看<code>newMethods(c, classFile)</code>方法啊，这个方法定义在<code>rtda/heap/method.c</code>中。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Method<span class="hljs-operator"> * </span><span class="hljs-keyword">new</span><span class="hljs-constructor">Methods(<span class="hljs-params">struct</span> Class <span class="hljs-operator">*</span> <span class="hljs-params">c</span>, ClassFile <span class="hljs-operator">*</span> <span class="hljs-params">classFile</span>)</span><br>&#123;<br>	c-&gt;methodsCount = classFile-&gt;methodsCount;<br>	c-&gt;methods = NULL;<br>	<span class="hljs-keyword">if</span> (c-&gt;methodsCount<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>		return NULL;<br><br>	c-&gt;methods = calloc(classFile-&gt;methodsCount, sizeof(Method));<br>	for (uint16_t i = <span class="hljs-number">0</span>; i &lt; c-&gt;methodsCount; i++)<br>	&#123;		<br>		c-&gt;methods<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.classMember.attachClass = c;<br>		copy<span class="hljs-constructor">MethodInfo(&amp;<span class="hljs-params">c</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>], &amp;<span class="hljs-params">classFile</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>], <span class="hljs-params">classFile</span>)</span>;<br>		copy<span class="hljs-constructor">Attributes(&amp;<span class="hljs-params">c</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>], &amp;<span class="hljs-params">classFile</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>], <span class="hljs-params">classFile</span>)</span>;<br>		MethodDescriptor<span class="hljs-operator"> * </span>md = parse<span class="hljs-constructor">MethodDescriptor(<span class="hljs-params">c</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>].<span class="hljs-params">classMember</span>.<span class="hljs-params">descriptor</span>)</span>;<br>		c-&gt;methods<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.parsedDescriptor = md;<br>		calc<span class="hljs-constructor">ArgSlotCount(&amp;<span class="hljs-params">c</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>])</span>;<br>		<span class="hljs-keyword">if</span> (is<span class="hljs-constructor">MethodNative(&amp;<span class="hljs-params">c</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>])</span>)<br>		&#123;<br>			inject<span class="hljs-constructor">CodeAttribute(&amp;<span class="hljs-params">c</span>-&gt;<span class="hljs-params">methods</span>[<span class="hljs-params">i</span>], <span class="hljs-params">md</span>-&gt;<span class="hljs-params">returnType</span>)</span>;<br>		&#125;<br>	&#125;<br> <br>	return NULL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码可以看出，实际上就是把<code>ClassFile</code>中解析到的方法逐一赋值给了 <code>Class</code> 对象的 <code>methods</code> 数组。</p>
<p>总算梳理清楚了，反射创建对象的调用链为：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">loadClass</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">loadNonArrayClass</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">parseClassFile</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">newMethods</span> -&gt;</span> Class 的 methods数组<br><br><span class="hljs-function"><span class="hljs-title">privateGetDeclaredConstructors</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">getDeclaredConstructors0</span> -&gt;</span> getClassConstructors (过滤Class 的 methods数组)<br></code></pre></td></tr></table></figure>

<p>到目前为止，我们搞明白反射时如何找到对应的构造方法的。下面我们来看 <code>newInstance</code> 方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">(InnerClass) clazz.get<span class="hljs-constructor">DeclaredConstructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br> <br>public T <span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(Object <span class="hljs-operator">...</span> <span class="hljs-params">initargs</span>)</span><br>        throws InstantiationException, IllegalAccessException,<br>               IllegalArgumentException, InvocationTargetException<br>    &#123;<br>        <span class="hljs-comment">// 构造方法是否被重载了</span><br>        <span class="hljs-keyword">if</span> (!override) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>quick<span class="hljs-constructor">CheckMemberAccess(<span class="hljs-params">clazz</span>, <span class="hljs-params">modifiers</span>)</span>) &#123;<br>                Class&lt;?&gt; caller = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>get<span class="hljs-constructor">CallerClass()</span>;<br>                <span class="hljs-comment">// 检查权限</span><br>                check<span class="hljs-constructor">Access(<span class="hljs-params">caller</span>, <span class="hljs-params">clazz</span>, <span class="hljs-params">null</span>, <span class="hljs-params">modifiers</span>)</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 枚举类型报错</span><br>        <span class="hljs-keyword">if</span> ((clazz.get<span class="hljs-constructor">Modifiers()</span> &amp; Modifier.ENUM) != <span class="hljs-number">0</span>)<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalArgumentException(<span class="hljs-string">"Cannot reflectively create enum objects"</span>)</span>;<br>        <span class="hljs-comment">// ConstructorAccessor 是缓存的，如果为空，就去创建一个</span><br>        ConstructorAccessor ca = constructorAccessor;   <span class="hljs-comment">// read volatile</span><br>        <span class="hljs-keyword">if</span> (ca<span class="hljs-operator"> == </span>null) &#123;<br>            <span class="hljs-comment">// 创建 ConstructorAccessor</span><br>            ca = acquire<span class="hljs-constructor">ConstructorAccessor()</span>;<br>        &#125;<br>        @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br>        <span class="hljs-comment">// 使用 ConstructorAccessor 的 newInstance 构造实例</span><br>        T inst = (T) ca.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(<span class="hljs-params">initargs</span>)</span>;<br>        return inst;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>接着看下 <code>acquireConstructorAccessor</code> 方法。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs smali">private ConstructorAccessor acquireConstructorAccessor() &#123;<br>    // First<span class="hljs-built_in"> check </span>to see<span class="hljs-built_in"> if </span>one has been created yet,<span class="hljs-built_in"> and </span>take it<br>    //<span class="hljs-built_in"> if </span>so.<br>    ConstructorAccessor tmp = null;<br>    // 可以理解为缓存的对象<br>   <span class="hljs-built_in"> if </span>(root != null) tmp = root.getConstructorAccessor();<br>   <span class="hljs-built_in"> if </span>(tmp != null) &#123;<br>       <span class="hljs-keyword"> constructor</span>Accessor = tmp;<br>    &#125; else &#123;<br>        // Otherwise fabricate one<span class="hljs-built_in"> and </span>propagate it up to the root<br>        // 生成一个 ConstructorAccessor，并缓存起来<br>        tmp = reflectionFactory.newConstructorAccessor(this);<br>        setConstructorAccessor(tmp);<br>    &#125;<br><br>   <span class="hljs-built_in"> return </span>tmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续走到<code>newConstructorAccessor</code>方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public ConstructorAccessor <span class="hljs-keyword">new</span><span class="hljs-constructor">ConstructorAccessor(Constructor&lt;?&gt; <span class="hljs-params">var1</span>)</span> &#123;<br>        check<span class="hljs-constructor">Initted()</span>;<br>        Class var2 = var1.get<span class="hljs-constructor">DeclaringClass()</span>;<br>    <span class="hljs-comment">// 如果是抽象类，报错</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Abstract(<span class="hljs-params">var2</span>.<span class="hljs-params">getModifiers</span>()</span>)) &#123;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">InstantiationExceptionConstructorAccessorImpl((String)</span>null);<br>    &#125; <br>    <span class="hljs-comment">// 如果 Class 类报错</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (var2<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">class</span>) &#123;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">InstantiationExceptionConstructorAccessorImpl(<span class="hljs-string">"Can not instantiate java.lang.Class"</span>)</span>;<br>    &#125; <br>    <span class="hljs-comment">// 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>is<span class="hljs-constructor">SubclassOf(<span class="hljs-params">var2</span>, ConstructorAccessorImpl.<span class="hljs-params">class</span>)</span>) &#123;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">BootstrapConstructorAccessorImpl(<span class="hljs-params">var1</span>)</span>;<br>    &#125; <br>    <span class="hljs-comment">// 判断 noInflation , 后面是判断不是匿名类</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (noInflation<span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectUtil</span>.</span></span>is<span class="hljs-constructor">VMAnonymousClass(<span class="hljs-params">var1</span>.<span class="hljs-params">getDeclaringClass</span>()</span>)) &#123;<br>        return (<span class="hljs-keyword">new</span> <span class="hljs-constructor">MethodAccessorGenerator()</span>).generate<span class="hljs-constructor">Constructor(<span class="hljs-params">var1</span>.<span class="hljs-params">getDeclaringClass</span>()</span>, var1.get<span class="hljs-constructor">ParameterTypes()</span>, var1.get<span class="hljs-constructor">ExceptionTypes()</span>, var1.get<span class="hljs-constructor">Modifiers()</span>);<br>    &#125; <br>    <span class="hljs-comment">// 使用 NativeConstructorAccessorImpl 来生成实例</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        NativeConstructorAccessorImpl var3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NativeConstructorAccessorImpl(<span class="hljs-params">var1</span>)</span>;<br>        DelegatingConstructorAccessorImpl var4 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DelegatingConstructorAccessorImpl(<span class="hljs-params">var3</span>)</span>;<br>        var3.set<span class="hljs-constructor">Parent(<span class="hljs-params">var4</span>)</span>;<br>        return var4;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体逻辑，在上述代码中已经注释了。这里提一下 <code>noInflation</code>。</p>
<p><code>ReflectionFactory</code>在执行所有方法前会检查下是否执行过了<code>checkInitted</code>方法，这个方法会把<code>noInflation</code>的值和<code>inflationThreshold</code>从虚拟机的环境变量中读取出来并赋值。</p>
<p>当<code>noInflation</code> 为 <code>false</code>而且不是匿名类时，就会使用<code>MethodAccessorGenerator</code>方式。否则就是用 <code>NativeConstructorAccessorImpl</code>的方式来生成。</p>
<p>默认<code>noInflation</code> 为<code>false</code>，所以我们先看native调用的方式。关注 <code>NativeConstructorAccessorImpl</code>类。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> NativeConstructorAccessorImpl extends ConstructorAccessorImpl &#123;<br>    <span class="hljs-keyword">private</span> final Constructor&lt;?&gt; c;<br>    <span class="hljs-keyword">private</span> DelegatingConstructorAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> numInvocations;<br><br>    <span class="hljs-constructor">NativeConstructorAccessorImpl(Constructor&lt;?&gt; <span class="hljs-params">var1</span>)</span> &#123;<br>        this.c = var1;<br>    &#125;<br><br>    public Object <span class="hljs-keyword">new</span><span class="hljs-constructor">Instance(Object[] <span class="hljs-params">var1</span>)</span> throws InstantiationException, IllegalArgumentException, InvocationTargetException &#123;<br>        <span class="hljs-keyword">if</span> (++this.numInvocations &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectionFactory</span>.</span></span>inflation<span class="hljs-constructor">Threshold()</span><span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectUtil</span>.</span></span>is<span class="hljs-constructor">VMAnonymousClass(<span class="hljs-params">this</span>.<span class="hljs-params">c</span>.<span class="hljs-params">getDeclaringClass</span>()</span>)) &#123;<br>            ConstructorAccessorImpl var2 = (ConstructorAccessorImpl)(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MethodAccessorGenerator()</span>).generate<span class="hljs-constructor">Constructor(<span class="hljs-params">this</span>.<span class="hljs-params">c</span>.<span class="hljs-params">getDeclaringClass</span>()</span>, this.c.get<span class="hljs-constructor">ParameterTypes()</span>, this.c.get<span class="hljs-constructor">ExceptionTypes()</span>, this.c.get<span class="hljs-constructor">Modifiers()</span>);<br>            this.parent.set<span class="hljs-constructor">Delegate(<span class="hljs-params">var2</span>)</span>;<br>        &#125;<br><br>        return <span class="hljs-keyword">new</span><span class="hljs-constructor">Instance0(<span class="hljs-params">this</span>.<span class="hljs-params">c</span>, <span class="hljs-params">var1</span>)</span>;<br>    &#125;<br><br>    void set<span class="hljs-constructor">Parent(DelegatingConstructorAccessorImpl <span class="hljs-params">var1</span>)</span> &#123;<br>        this.parent = var1;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static native Object <span class="hljs-keyword">new</span><span class="hljs-constructor">Instance0(Constructor&lt;?&gt; <span class="hljs-params">var0</span>, Object[] <span class="hljs-params">var1</span>)</span> throws InstantiationException, IllegalArgumentException, InvocationTargetException;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到 <code>NativeConstructorAccessorImpl</code> 中维护了一个计数器<code>numInvocations</code>,在每次调用<code>newInstance</code>方法生成实例时，就会对计数器自增，当计数器超过<code>ReflectionFactory.inflationThreshold()</code>的阈值，默认为15，就会使用 <code>ConstructorAccessorImpl</code>替换 <code>NativeConstructorAccessorImpl</code>,后面就会直接调用<code>MethodAccessorGenerator</code>中的方法了。</p>
<p>我们先看看没到达阈值前，会调用native方法 <code>newInstance0</code>,这个方法定义在<code>native/sun/reflect/NativeConstructorAccessorImpl.c</code>中，具体<code>newInstance0</code>的流程我就不分析了，大致逻辑是操作堆栈执行方法。</p>
<p>然后我们再看看超过阈值后，执行的是 <code>MethodAccessorGenerator</code>生成构造器的方式。这种方式与<code>newConstructorAccessor</code>方法中<code>noInflation</code> 为 <code>false</code>的处理方式一样。所以可以解释为：java虚拟机在执行反射操作时，如果同一操作执行次数超过阈值，会从native生成实例的方式转变为java生成实例的方式。</p>
<p><code>MethodAccessorGenerator</code>的<code>MethodAccessorGenerator</code>方法如下。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> ConstructorAccessor generateConstructor(<span class="hljs-keyword">Class</span>&lt;?&gt; var1, <span class="hljs-keyword">Class</span>&lt;?&gt;[] var2, <span class="hljs-keyword">Class</span>&lt;?&gt;[] var3, <span class="hljs-keyword">int</span> var4) &#123;<br>    <span class="hljs-keyword">return</span> (ConstructorAccessor)<span class="hljs-keyword">this</span>.generate(var1, <span class="hljs-string">"&lt;init&gt;"</span>, var2, <span class="hljs-keyword">Void</span>.TYPE, var3, var4, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, (<span class="hljs-keyword">Class</span>)<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续跟踪下去可以发现，反射调用构造方法实际上是动态编写字节码，并且在虚拟机中把编好的字节码加载成一个Class，这个Class实际上是 <code>ConstructorAccessorImpl</code> 类型的，然后调用这个动态类的<code>newInstance</code>方法。回看刚刚我们梳理的<code>newConstructorAccessor</code>代码，可以看到第三个逻辑：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflection</span>.</span></span>is<span class="hljs-constructor">SubclassOf(<span class="hljs-params">var2</span>, ConstructorAccessorImpl.<span class="hljs-params">class</span>)</span>) &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">BootstrapConstructorAccessorImpl(<span class="hljs-params">var1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终执行的是 <code>BootstrapConstructorAccessorImpl</code>的<code>newInstance</code>方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootstrapConstructorAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConstructorAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Constructor</span>&lt;?&gt; constructor;<br><br>    <span class="hljs-type">BootstrapConstructorAccessorImpl</span>(<span class="hljs-type">Constructor</span>&lt;?&gt; var1) &#123;<br>        <span class="hljs-keyword">this</span>.constructor = var1;<br>    &#125;<br><br>    public <span class="hljs-type">Object</span> newInstance(<span class="hljs-type">Object</span>[] var1) <span class="hljs-keyword">throws</span> <span class="hljs-type">IllegalArgumentException</span>, <span class="hljs-type">InvocationTargetException</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">UnsafeFieldAccessorImpl</span>.unsafe.allocateInstance(<span class="hljs-keyword">this</span>.constructor.getDeclaringClass());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">InstantiationException</span> var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">InvocationTargetException</span>(var3);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是通过使用<code>Unsafe</code>类分配了一个实例。</p>
<h2 id="反射带来的问题"><a href="#反射带来的问题" class="headerlink" title="反射带来的问题"></a>反射带来的问题</h2><p>到现在为止，我们已经把反射生成实例的所有流程都搞清楚了。回到文章开头的问题，我们现在反思下，反射性能低么？为什么？</p>
<ol>
<li>反射调用过程中会产生大量的临时对象，这些对象会占用内存，可能会导致频繁 gc，从而影响性能。</li>
<li>反射调用方法时会从方法数组中遍历查找，并且会检查可见性等操作会耗时。</li>
<li>反射在达到一定次数时，会动态编写字节码并加载到内存中，这个字节码没有经过编译器优化，也不能享受JIT优化。</li>
<li>反射一般会涉及自动装箱/拆箱和类型转换，都会带来一定的资源开销。</li>
</ol>
<p>在Android中，我们可以在某些情况下对反射进行优化。举个例子，EventBus 2.x 会在 register 方法运行时，遍历所有方法找到回调方法；而EventBus 3.x 则在编译期间，将所有回调方法的信息保存的自己定义的 <code>SubscriberMethodInfo</code> 中，这样可以减少对运行时的性能影响。</p>
<p><strong>本文的结论如下：</strong></p>
<ol>
<li>不要在性能敏感的应用中，频繁调用反射。</li>
<li>如果反射执行的次数小于1000这个数量级，反射的耗时实际上与正常调用无太大差异。</li>
<li>反射对内存占用还有一定影响的，在内存敏感的场景下，谨慎使用反射。</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Apocalypse</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://jiyugithub.github.io/2020/06/12/javafs/">https://jiyugithub.github.io/2020/06/12/javafs/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/06/12/undefined/">Android目前最稳定和高效的UI适配方案</a>
            
            
            <a class="next" rel="next" href="/2020/06/12/hashmap/">HashMap原理技术知识整理</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Apocalypse | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
