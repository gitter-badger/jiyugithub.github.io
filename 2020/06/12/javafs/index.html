<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java反射真的很慢吗"><meta name="keywords" content=""><meta name="author" content="Apocalypse"><meta name="copyright" content="Apocalypse"><title>Java反射真的很慢吗 | Apocalypse's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#反射到底是好是坏"><span class="toc-number">1.</span> <span class="toc-text">反射到底是好是坏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码试验"><span class="toc-number">2.</span> <span class="toc-text">编码试验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#刨根问底：反射原理是什么"><span class="toc-number">3.</span> <span class="toc-text">刨根问底：反射原理是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射带来的问题"><span class="toc-number">4.</span> <span class="toc-text">反射带来的问题</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Apocalypse</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Apocalypse's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java反射真的很慢吗</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="反射到底是好是坏"><a href="#反射到底是好是坏" class="headerlink" title="反射到底是好是坏"></a>反射到底是好是坏</h2><p>说到Java 中的反射，初学者在刚刚接触到反射的各种高级特性时，往往表示十分兴奋，甚至会在一些不需要使用反射的场景中强行使用反射来「炫技」。而经验较为丰富的长者，看到反射时往往会发出灵魂三问：为什么要用反射？反射不会降低性能么？不用还有什么办法可以解决这个问题？</p>
<a id="more"></a>

<p>那么今天我们就来深入探讨下，反射到底对性能有多大影响？顺便探讨下，反射为什么对性能有影响？</p>
<h2 id="编码试验"><a href="#编码试验" class="headerlink" title="编码试验"></a>编码试验</h2><p>在我们分析具体原理之前，我们可以通过编写代码做实验得出结论。</p>
<p>反射可能会涉及多种类型的操作，比如生成实例，获取/设置变量属性，调用方法等。经过简单的思考，我们认为生成实例对性能的影响相对其他操作要大一些，所以我们采用生成实例来做试验。</p>
<p>在如下代码中，我们定义了一个类 <code>InnerClass</code>，我们测试分别使用<code>new</code>和<code>反射</code>来生成 <code>MAX_TIMES</code>个实例，并打印出耗时时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;MainAc&quot;;</span><br><span class="line">    private final int MAX_TIMES &#x3D; 100 * 1000;</span><br><span class="line">    private InnerClass innerList[];</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        innerList &#x3D; new InnerClass[MAX_TIMES];</span><br><span class="line"></span><br><span class="line">        long startTime &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">        for (int i&#x3D;0; i &lt; MAX_TIMES; i++) &#123;</span><br><span class="line">            innerList[i] &#x3D; new InnerClass();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, &quot;totalTime: &quot; + (SystemClock.elapsedRealtime() - startTime));</span><br><span class="line"></span><br><span class="line">        long startTime2 &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">        for (int i&#x3D;0; i &lt; MAX_TIMES; i++) &#123;</span><br><span class="line">            innerList[i] &#x3D; newInstanceByReflection();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, &quot;totalTime2: &quot; + (SystemClock.elapsedRealtime() - startTime2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public InnerClass newInstanceByReflection() &#123;</span><br><span class="line">        Class clazz &#x3D; InnerClass.class;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (InnerClass) clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class InnerClass &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-19 22:34:49.738 2151-2151&#x2F;? E&#x2F;MainAc: totalTime: 15</span><br><span class="line">2020-03-19 22:34:50.409 2151-2151&#x2F;? E&#x2F;MainAc: totalTime2: 670</span><br></pre></td></tr></table></figure>

<p>使用反射生成 10万 个实例，耗时 670ms，明显高于直接使用 <code>new</code>关键字的 15ms，所以反射性能低。别急，这个结论总结的还有点早，我们将要生成的实例总数改为 1000个试试，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-19 22:39:21.287 3641-3641&#x2F;com.example.myapplication E&#x2F;MainAc: totalTime: 2</span><br><span class="line">2020-03-19 22:39:21.296 3641-3641&#x2F;com.example.myapplication E&#x2F;MainAc: totalTime2: 9</span><br></pre></td></tr></table></figure>

<p>使用反射生成 1000 个实例，虽然需要9ms，高于<code>new</code>的 2ms，但是 9ms 和 2ms 的差距本身肉眼不可见，而且通常我们在业务中写的反射一般来说执行频率也未必会超过 1000 次，这种场景下，我们还能理直气壮地说反射性能很低么？</p>
<p>很显然，不能。</p>
<p>除了代码执行耗时，我们再看看反射对内存的影响。我们仍然以生成 10万 个实例为目标，对上述代码做略微改动，依次只保留 <code>new</code> 方式和反射方式，然后运行程序，观察内存占用情况。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df2febd3611?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>使用 <code>new</code> 方式</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df300d4decd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>使用反射</p>
<p>对比两图，我们可以看到第二张图中多了很多 <code>Constructor</code>和<code>Class</code>对象实例，这两部分占用的内存2.7M。因此，我们可以得出结论，反射会产生大量的临时对象，并且会占用额外内存空间。</p>
<h2 id="刨根问底：反射原理是什么"><a href="#刨根问底：反射原理是什么" class="headerlink" title="刨根问底：反射原理是什么"></a>刨根问底：反射原理是什么</h2><p>我们以前面试验中反射生成实例的代码为入口。</p>
<p>首先回顾下虚拟机中类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载。在加载的过程 中，虚拟机会把类的字节码转换成运行时数据结构，并保存在方法区，在内存中会生成一个代表这个类数据结构的 java.lang.Class 对象，后续访问这个类的数据结构就可以通过这个 Class 对象来访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public InnerClass newInstanceByReflection() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取虚拟机中 InnerClass 类的 Class 对象</span><br><span class="line">    Class clazz &#x3D; InnerClass.class;</span><br><span class="line">    try &#123;</span><br><span class="line">        return (InnerClass) clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中 <code>clazz.getDeclaredConstructor()</code> 用于获取类中定义的构造方法，由于我们没有显式定义构造方法，所以会返回编译器为我们自己生成的默认无参构造方法。</p>
<p>下面我们看下 <code>getDeclaredConstructor</code>是如何返回构造方法的。以下均以 jdk 1.8代码为源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">    throws NoSuchMethodException, SecurityException &#123;</span><br><span class="line">    &#x2F;&#x2F; 权限检查</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br><span class="line">    return getConstructor0(parameterTypes, Member.DECLARED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getDeclaredConstructor</code> 方法首先做了权限检查，然后直接调用 <code>getConstructor0</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                    int which) throws NoSuchMethodException</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; privateGetDeclaredConstructors 方法是获取所有的构造方法数组</span><br><span class="line">    Constructor&lt;T&gt;[] constructors &#x3D; privateGetDeclaredConstructors((which &#x3D;&#x3D; Member.PUBLIC));</span><br><span class="line">    &#x2F;&#x2F; 遍历所有的构造方法数组，根据传入的参数类型依次匹配，找到合适的构造方法后就会拷贝一份作为返回值</span><br><span class="line">    for (Constructor&lt;T&gt; constructor : constructors) &#123;</span><br><span class="line">        if (arrayContentsEq(parameterTypes,</span><br><span class="line">                            constructor.getParameterTypes())) &#123;</span><br><span class="line">            &#x2F;&#x2F; 拷贝构造方法</span><br><span class="line">            return getReflectionFactory().copyConstructor(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没有找到的话，就抛出异常 </span><br><span class="line">    throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getConstructor0</code> 方法主要做了两件事：</p>
<ul>
<li>获取所有构造方法组成的数组</li>
<li>遍历构造方法数组，找到匹配的</li>
</ul>
<p>遍历匹配没啥好说的，我们重点看下第一件事，怎么获取的所有构造方法数组，也就是这个方法 <code>privateGetDeclaredConstructors</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) &#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Constructor&lt;T&gt;[] res;</span><br><span class="line">    &#x2F;&#x2F; 获取缓存的 ReflectionData 数据</span><br><span class="line">    ReflectionData&lt;T&gt; rd &#x3D; reflectionData();</span><br><span class="line">    &#x2F;&#x2F; 如果缓存中有 ReflectionData，就先看看 ReflectionData 中的 publicConstructors 或 declaredConstructors是否为空</span><br><span class="line">    if (rd !&#x3D; null) &#123;</span><br><span class="line">        res &#x3D; publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br><span class="line">        if (res !&#x3D; null) return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果没有缓存，或者缓存中构造方法数组为空</span><br><span class="line">    &#x2F;&#x2F; No cached value available; request value from VM</span><br><span class="line">    &#x2F;&#x2F; 对接口类型的字节码特殊处理</span><br><span class="line">    if (isInterface()) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 如果是接口类型，那么生成一个长度为0的构造方法数组</span><br><span class="line">        Constructor&lt;T&gt;[] temporaryRes &#x3D; (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];</span><br><span class="line">        res &#x3D; temporaryRes;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不是接口类型，就调用 getDeclaredConstructors0 获取构造方法数组</span><br><span class="line">        res &#x3D; getDeclaredConstructors0(publicOnly);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取到构造方法数组后，再赋值给缓存 ReflectionData 中的对应属性</span><br><span class="line">    if (rd !&#x3D; null) &#123;</span><br><span class="line">        if (publicOnly) &#123;</span><br><span class="line">            rd.publicConstructors &#x3D; res;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rd.declaredConstructors &#x3D; res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中我已经对关键代码进行了注释，在讲解整个流程之前，我们看到了一个陌生的类型 <code>ReflectionData</code>。它对应的数据结构是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class ReflectionData&lt;T&gt; &#123;</span><br><span class="line">    volatile Field[] declaredFields;</span><br><span class="line">    volatile Field[] publicFields;</span><br><span class="line">    volatile Method[] declaredMethods;</span><br><span class="line">    volatile Method[] publicMethods;</span><br><span class="line">    volatile Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">    volatile Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">    &#x2F;&#x2F; Intermediate results for getFields and getMethods</span><br><span class="line">    volatile Field[] declaredPublicFields;</span><br><span class="line">    volatile Method[] declaredPublicMethods;</span><br><span class="line">    volatile Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Value of classRedefinedCount when we created this ReflectionData instance</span><br><span class="line">    final int redefinedCount;</span><br><span class="line"></span><br><span class="line">    ReflectionData(int redefinedCount) &#123;</span><br><span class="line">        this.redefinedCount &#x3D; redefinedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReflectionData</code> 这个类就是用来保存从虚拟机中获取到的一些数据。同时我们可以看到所有反射属性都使用了 <code>volatile</code>关键字修饰。</p>
<p>获取缓存的 <code>ReflectionData</code> 数据是通过调用<code>reflectionData()</code>方法获取的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义在 Class 类中的反射缓存对象</span><br><span class="line">private volatile transient SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;</span><br><span class="line"></span><br><span class="line">private ReflectionData&lt;T&gt; reflectionData() &#123;</span><br><span class="line">    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData &#x3D; this.reflectionData;</span><br><span class="line">    int classRedefinedCount &#x3D; this.classRedefinedCount;</span><br><span class="line">    ReflectionData&lt;T&gt; rd;</span><br><span class="line">    if (useCaches &amp;&amp;</span><br><span class="line">        reflectionData !&#x3D; null &amp;&amp;</span><br><span class="line">        (rd &#x3D; reflectionData.get()) !&#x3D; null &amp;&amp;</span><br><span class="line">        rd.redefinedCount &#x3D;&#x3D; classRedefinedCount) &#123;</span><br><span class="line">        return rd;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; else no SoftReference or cleared SoftReference or stale ReflectionData</span><br><span class="line">    &#x2F;&#x2F; -&gt; create and replace new instance</span><br><span class="line">    return newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>reflectionData</code>实际上是一个软引用，软引用会在内存不足的情况下被虚拟机回收，所以<code>reflectionData()</code>方法在开始的地方，先判断了是否可以使用缓存以及缓存是否失效，如果失效了，就会调用 <code>newReflectionData</code>方法生成一个新的 <code>ReflectionData</code> 实例。</p>
<p>接下来看看 <code>newReflectionData</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span><br><span class="line">                                                int classRedefinedCount) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果不允许使用缓存，直接返回 null</span><br><span class="line">    if (!useCaches) return null;</span><br><span class="line">	</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        ReflectionData&lt;T&gt; rd &#x3D; new ReflectionData&lt;&gt;(classRedefinedCount);</span><br><span class="line">        &#x2F;&#x2F; try to CAS it...</span><br><span class="line">        if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) &#123;</span><br><span class="line">            return rd;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; else retry</span><br><span class="line">        oldReflectionData &#x3D; this.reflectionData;</span><br><span class="line">        classRedefinedCount &#x3D; this.classRedefinedCount;</span><br><span class="line">        if (oldReflectionData !&#x3D; null &amp;&amp;</span><br><span class="line">            (rd &#x3D; oldReflectionData.get()) !&#x3D; null &amp;&amp;</span><br><span class="line">            rd.redefinedCount &#x3D;&#x3D; classRedefinedCount) &#123;</span><br><span class="line">            return rd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newReflectionData</code>中使用 <strong>volatile + 死循环 + CAS 机制</strong> 保证线程安全。注意到这里的死循环每执行一次都会构造一个新的 <code>ReflectionData</code> 实例。</p>
<p>你可能会有疑问，<code>Class</code> 中 <code>reflectionData</code>属性什么时候被赋值的，其实是封装在<code>Atomic.casReflectionData</code>这个方法里了，他会检测当前<code>Class</code>对象中的<code>reflectionData</code>是否与<code>oldReflectionData</code>相等，如果相等，就会把<code>new SoftReference&lt;&gt;(rd)</code>赋值给 <code>reflectionData</code>。</p>
<p>到现在为止，关于 <code>ReflectionData</code>的背景知识都介绍完了。我们再回到 <code>privateGetDeclaredConstructors</code>中看看获取构造方法的流程。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df304157365?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>privateGetDeclaredConstructors</code>流程图</p>
<p>可以看到对于普通类，最终通过调用 <code>getDeclaredConstructors0</code>方法获取的构造方法列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);</span><br></pre></td></tr></table></figure>

<p>这个方法是 native 的，具体逻辑在 jdk 源码中。</p>
<p>在 <code>native/java/lang/Class_getDeclaredConstructors0.c</code> 文件中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getDeclaredConstructors0(Frame * frame)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Frame 可以理解为调用native方法时，java层传递过来的数据的一种封装</span><br><span class="line">	LocalVars * vars &#x3D; frame-&gt;localVars;</span><br><span class="line">	Object * classObj &#x3D; getLocalVarsThis(vars);</span><br><span class="line">    &#x2F;&#x2F; 取得java方法的入参</span><br><span class="line">	bool publicOnly &#x3D; getLocalVarsBoolean(vars, 1);</span><br><span class="line"></span><br><span class="line">	uint16_t constructorsCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 获取要查询的类的 Class 对象</span><br><span class="line">	Class * c &#x3D; classObj-&gt;extra;</span><br><span class="line">    &#x2F;&#x2F; 获取这个类的所有构造方法，且数量保存在 constructorsCount 中</span><br><span class="line">	Method* * constructors &#x3D; getClassConstructors(c, publicOnly, &amp;constructorsCount);</span><br><span class="line">	&#x2F;&#x2F; 获取 java 方法调用所属的 classLoader</span><br><span class="line">	ClassLoader *  classLoader &#x3D; frame-&gt;method-&gt;classMember.attachClass-&gt;classLoader;</span><br><span class="line">	&#x2F;&#x2F; 拿到 Constructor 对应的 class 对象</span><br><span class="line">	Class * constructorClass &#x3D; loadClass(classLoader, &quot;java&#x2F;lang&#x2F;reflect&#x2F;Constructor&quot;);</span><br><span class="line">    &#x2F;&#x2F;创建一个长度为 constructorsCount 的数组保存构造方法</span><br><span class="line">	Object * constructorArr &#x3D; newArray(arrayClass(constructorClass), constructorsCount);</span><br><span class="line"></span><br><span class="line">	pushOperandRef(frame-&gt;operandStack, constructorArr);</span><br><span class="line">	&#x2F;&#x2F; 后面是具体的赋值逻辑。将native中的Method对象转化为java层的Constructor对象</span><br><span class="line">	if (constructorsCount &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		Thread * thread &#x3D; frame-&gt;thread;</span><br><span class="line">		Object* * constructorObjs &#x3D; getObjectRefs(constructorArr);</span><br><span class="line"></span><br><span class="line">		Method * constructorInitMethod &#x3D; getClassConstructor(constructorClass, _constructorConstructorDescriptor);</span><br><span class="line">		for (uint16_t i &#x3D; 0; i &lt; constructorsCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Method * constructor &#x3D; constructors[i];</span><br><span class="line"></span><br><span class="line">			Object * constructorObj &#x3D; newObject(constructorClass);</span><br><span class="line">			constructorObj-&gt;extra &#x3D; constructor;</span><br><span class="line">			constructorObjs[i] &#x3D; constructorObj;</span><br><span class="line"></span><br><span class="line">			OperandStack * ops &#x3D; newOperandStack(9);</span><br><span class="line">			pushOperandRef(ops, constructorObj);</span><br><span class="line">			pushOperandRef(ops, classObj);</span><br><span class="line">			pushOperandRef(ops, toClassArr(classLoader, methodParameterTypes(constructor), constructor-&gt;parsedDescriptor-&gt;parameterTypesCount));</span><br><span class="line">			if (constructor-&gt;exceptions !&#x3D; NULL)</span><br><span class="line">				pushOperandRef(ops, toClassArr(classLoader, methodExceptionTypes(constructor), constructor-&gt;exceptions-&gt;number_of_exceptions));</span><br><span class="line">			else</span><br><span class="line">				pushOperandRef(ops, toClassArr(classLoader, methodExceptionTypes(constructor), 0));</span><br><span class="line">			pushOperandInt(ops, constructor-&gt;classMember.accessFlags);</span><br><span class="line">			pushOperandInt(ops, 0);</span><br><span class="line">			pushOperandRef(ops, getSignatureStr(classLoader, constructor-&gt;classMember.signature));         &#x2F;&#x2F; signature</span><br><span class="line">			pushOperandRef(ops, toByteArr(classLoader, constructor-&gt;classMember.annotationData, constructor-&gt;classMember.annotationDataLen));</span><br><span class="line">			pushOperandRef(ops, toByteArr(classLoader, constructor-&gt;parameterAnnotationData, constructor-&gt;parameterAnnotationDataLen));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			Frame * shimFrame &#x3D; newShimFrame(thread, ops);</span><br><span class="line">			pushThreadFrame(thread, shimFrame);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; init constructorObj</span><br><span class="line">			InvokeMethod(shimFrame, constructorInitMethod);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的逻辑，可以知道获取构造方法的核心方法是 <code>getClassConstructors</code> ，所在文件为 <code>rtda/heap/class.c</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method* * getClassConstructors(Class * self, bool publicOnly, uint16_t * constructorsCount)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 分配大小为 sizeof(Method) 的长度为 methodsCount 的连续内存地址，即数组</span><br><span class="line">	Method* * constructors &#x3D; calloc(self-&gt;methodsCount, sizeof(Method));</span><br><span class="line">	*constructorsCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 在native 层，构造方法和普通方法都存在 methods 中，逐一遍历</span><br><span class="line">	for (uint16_t i &#x3D; 0; i &lt; self-&gt;methodsCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Method * method &#x3D; self-&gt;methods + i;</span><br><span class="line">        &#x2F;&#x2F; 判断是否是构造方法</span><br><span class="line">		if (isMethodConstructor(method))</span><br><span class="line">		&#123;</span><br><span class="line">            &#x2F;&#x2F; 检查权限</span><br><span class="line">			if (!publicOnly || isMethodPublic(method))</span><br><span class="line">			&#123;</span><br><span class="line">                &#x2F;&#x2F; 符合条件的构造方法依次存到数组中</span><br><span class="line">				constructors[*constructorsCount] &#x3D; method;</span><br><span class="line">				(*constructorsCount)++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return constructors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>getClassConstructors</code>实际上就是对 <code>methods</code> 进行了一次过滤，过滤的条件为：1.是构造方法；2.权限一致。</p>
<p><code>isMethodConstructor</code> 方法的判断逻辑也是十分简单，不是静态方法，而且方法名是<code>&lt;init&gt;</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isMethodConstructor(Method * self)</span><br><span class="line">&#123;</span><br><span class="line">	return !isMethodStatic(self) &amp;&amp; strcmp(self-&gt;classMember.name, &quot;&lt;init&gt;&quot;) &#x3D;&#x3D; 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以核心的逻辑变成了<code>Class</code>中的 <code>methods</code>数组何时被初始化赋值的？我们刨根问底的追踪下。</p>
<p>我们先找到类加载到虚拟机中的入口方法 <code>loadNonArrayClass</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class * loadNonArrayClass(ClassLoader * classLoader, const char * className)</span><br><span class="line">&#123;</span><br><span class="line">	int32_t classSize &#x3D; 0;</span><br><span class="line">	char * classContent &#x3D; NULL;</span><br><span class="line">	Class * loadClass &#x3D; NULL;</span><br><span class="line">	classSize &#x3D; readClass(className, &amp;classContent);</span><br><span class="line">	if (classSize &gt; 0 &amp;&amp; classContent !&#x3D; NULL)&#123;</span><br><span class="line">#if 0</span><br><span class="line">		printf(&quot;class size:%d,class data:[&quot;, classSize);</span><br><span class="line">		for (int32_t i &#x3D; 0; i &lt; classSize; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;0x%02x &quot;, classContent[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;]\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	if (classSize &lt;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Could not found target class\n&quot;);</span><br><span class="line">		exit(127);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 解析字节码文件</span><br><span class="line">	loadClass &#x3D; parseClassFile(classContent, classSize);</span><br><span class="line">	loadClass-&gt;classLoader &#x3D; classLoader;</span><br><span class="line">	&#x2F;&#x2F; 加载</span><br><span class="line">	defineClass(classLoader, loadClass);</span><br><span class="line">	&#x2F;&#x2F; 链接</span><br><span class="line">	linkClass(classLoader, loadClass);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;printf(&quot;[Loaded %s\n&quot;, loadClass-&gt;name);</span><br><span class="line">	return loadClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>parseClassFile</code>方法中，调用了<code>newClass</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class * parseClassFile(char * classContent, int32_t classSize)</span><br><span class="line">&#123;</span><br><span class="line">	ClassFile * classFile &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	classFile &#x3D; parseClassData(classContent, classSize);</span><br><span class="line"></span><br><span class="line">	return newClass(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newClass</code>方法在<code>rtda/heap/class.c</code>文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class * newClass(ClassFile * classFile)</span><br><span class="line">&#123;</span><br><span class="line">	Class * c &#x3D; calloc(1, sizeof(Class));</span><br><span class="line">	c-&gt;accessFlags &#x3D; classFile-&gt;accessFlags;</span><br><span class="line">	c-&gt;sourceFile &#x3D; getClassSourceFileName(classFile);</span><br><span class="line">	newClassName(c, classFile);</span><br><span class="line">	newSuperClassName(c, classFile);</span><br><span class="line">	newInterfacesName(c, classFile);</span><br><span class="line">	newConstantPool(c, classFile);</span><br><span class="line">	newFields(c, classFile);</span><br><span class="line">	newMethods(c, classFile);</span><br><span class="line">	return c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在native层创建了一个<code>Class</code>对象，我们重点看<code>newMethods(c, classFile)</code>方法啊，这个方法定义在<code>rtda/heap/method.c</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method * newMethods(struct Class * c, ClassFile * classFile)</span><br><span class="line">&#123;</span><br><span class="line">	c-&gt;methodsCount &#x3D; classFile-&gt;methodsCount;</span><br><span class="line">	c-&gt;methods &#x3D; NULL;</span><br><span class="line">	if (c-&gt;methodsCount &#x3D;&#x3D; 0)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	c-&gt;methods &#x3D; calloc(classFile-&gt;methodsCount, sizeof(Method));</span><br><span class="line">	for (uint16_t i &#x3D; 0; i &lt; c-&gt;methodsCount; i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		c-&gt;methods[i].classMember.attachClass &#x3D; c;</span><br><span class="line">		copyMethodInfo(&amp;c-&gt;methods[i], &amp;classFile-&gt;methods[i], classFile);</span><br><span class="line">		copyAttributes(&amp;c-&gt;methods[i], &amp;classFile-&gt;methods[i], classFile);</span><br><span class="line">		MethodDescriptor * md &#x3D; parseMethodDescriptor(c-&gt;methods[i].classMember.descriptor);</span><br><span class="line">		c-&gt;methods[i].parsedDescriptor &#x3D; md;</span><br><span class="line">		calcArgSlotCount(&amp;c-&gt;methods[i]);</span><br><span class="line">		if (isMethodNative(&amp;c-&gt;methods[i]))</span><br><span class="line">		&#123;</span><br><span class="line">			injectCodeAttribute(&amp;c-&gt;methods[i], md-&gt;returnType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以看出，实际上就是把<code>ClassFile</code>中解析到的方法逐一赋值给了 <code>Class</code> 对象的 <code>methods</code> 数组。</p>
<p>总算梳理清楚了，反射创建对象的调用链为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadClass -&gt; loadNonArrayClass -&gt; parseClassFile -&gt; newMethods -&gt; Class 的 methods数组</span><br><span class="line"></span><br><span class="line">privateGetDeclaredConstructors -&gt; getDeclaredConstructors0 -&gt; getClassConstructors (过滤Class 的 methods数组)</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们搞明白反射时如何找到对应的构造方法的。下面我们来看 <code>newInstance</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(InnerClass) clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"> </span><br><span class="line">public T newInstance(Object ... initargs)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">               IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 构造方法是否被重载了</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller &#x3D; Reflection.getCallerClass();</span><br><span class="line">                &#x2F;&#x2F; 检查权限</span><br><span class="line">                checkAccess(caller, clazz, null, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 枚举类型报错</span><br><span class="line">        if ((clazz.getModifiers() &amp; Modifier.ENUM) !&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">        &#x2F;&#x2F; ConstructorAccessor 是缓存的，如果为空，就去创建一个</span><br><span class="line">        ConstructorAccessor ca &#x3D; constructorAccessor;   &#x2F;&#x2F; read volatile</span><br><span class="line">        if (ca &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建 ConstructorAccessor</span><br><span class="line">            ca &#x3D; acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        &#x2F;&#x2F; 使用 ConstructorAccessor 的 newInstance 构造实例</span><br><span class="line">        T inst &#x3D; (T) ca.newInstance(initargs);</span><br><span class="line">        return inst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接着看下 <code>acquireConstructorAccessor</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ConstructorAccessor acquireConstructorAccessor() &#123;</span><br><span class="line">    &#x2F;&#x2F; First check to see if one has been created yet, and take it</span><br><span class="line">    &#x2F;&#x2F; if so.</span><br><span class="line">    ConstructorAccessor tmp &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 可以理解为缓存的对象</span><br><span class="line">    if (root !&#x3D; null) tmp &#x3D; root.getConstructorAccessor();</span><br><span class="line">    if (tmp !&#x3D; null) &#123;</span><br><span class="line">        constructorAccessor &#x3D; tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Otherwise fabricate one and propagate it up to the root</span><br><span class="line">        &#x2F;&#x2F; 生成一个 ConstructorAccessor，并缓存起来</span><br><span class="line">        tmp &#x3D; reflectionFactory.newConstructorAccessor(this);</span><br><span class="line">        setConstructorAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续走到<code>newConstructorAccessor</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConstructorAccessor newConstructorAccessor(Constructor&lt;?&gt; var1) &#123;</span><br><span class="line">        checkInitted();</span><br><span class="line">        Class var2 &#x3D; var1.getDeclaringClass();</span><br><span class="line">    &#x2F;&#x2F; 如果是抽象类，报错</span><br><span class="line">    if (Modifier.isAbstract(var2.getModifiers())) &#123;</span><br><span class="line">        return new InstantiationExceptionConstructorAccessorImpl((String)null);</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 如果 Class 类报错</span><br><span class="line">    else if (var2 &#x3D;&#x3D; Class.class) &#123;</span><br><span class="line">        return new InstantiationExceptionConstructorAccessorImpl(&quot;Can not instantiate java.lang.Class&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl </span><br><span class="line">    else if (Reflection.isSubclassOf(var2, ConstructorAccessorImpl.class)) &#123;</span><br><span class="line">        return new BootstrapConstructorAccessorImpl(var1);</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 判断 noInflation , 后面是判断不是匿名类</span><br><span class="line">    else if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;</span><br><span class="line">        return (new MethodAccessorGenerator()).generateConstructor(var1.getDeclaringClass(), var1.getParameterTypes(), var1.getExceptionTypes(), var1.getModifiers());</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F; 使用 NativeConstructorAccessorImpl 来生成实例</span><br><span class="line">    else &#123;</span><br><span class="line">        NativeConstructorAccessorImpl var3 &#x3D; new NativeConstructorAccessorImpl(var1);</span><br><span class="line">        DelegatingConstructorAccessorImpl var4 &#x3D; new DelegatingConstructorAccessorImpl(var3);</span><br><span class="line">        var3.setParent(var4);</span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体逻辑，在上述代码中已经注释了。这里提一下 <code>noInflation</code>。</p>
<p><code>ReflectionFactory</code>在执行所有方法前会检查下是否执行过了<code>checkInitted</code>方法，这个方法会把<code>noInflation</code>的值和<code>inflationThreshold</code>从虚拟机的环境变量中读取出来并赋值。</p>
<p>当<code>noInflation</code> 为 <code>false</code>而且不是匿名类时，就会使用<code>MethodAccessorGenerator</code>方式。否则就是用 <code>NativeConstructorAccessorImpl</code>的方式来生成。</p>
<p>默认<code>noInflation</code> 为<code>false</code>，所以我们先看native调用的方式。关注 <code>NativeConstructorAccessorImpl</code>类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NativeConstructorAccessorImpl extends ConstructorAccessorImpl &#123;</span><br><span class="line">    private final Constructor&lt;?&gt; c;</span><br><span class="line">    private DelegatingConstructorAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeConstructorAccessorImpl(Constructor&lt;?&gt; var1) &#123;</span><br><span class="line">        this.c &#x3D; var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Object[] var1) throws InstantiationException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.c.getDeclaringClass())) &#123;</span><br><span class="line">            ConstructorAccessorImpl var2 &#x3D; (ConstructorAccessorImpl)(new MethodAccessorGenerator()).generateConstructor(this.c.getDeclaringClass(), this.c.getParameterTypes(), this.c.getExceptionTypes(), this.c.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return newInstance0(this.c, var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingConstructorAccessorImpl var1) &#123;</span><br><span class="line">        this.parent &#x3D; var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object newInstance0(Constructor&lt;?&gt; var0, Object[] var1) throws InstantiationException, IllegalArgumentException, InvocationTargetException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>NativeConstructorAccessorImpl</code> 中维护了一个计数器<code>numInvocations</code>,在每次调用<code>newInstance</code>方法生成实例时，就会对计数器自增，当计数器超过<code>ReflectionFactory.inflationThreshold()</code>的阈值，默认为15，就会使用 <code>ConstructorAccessorImpl</code>替换 <code>NativeConstructorAccessorImpl</code>,后面就会直接调用<code>MethodAccessorGenerator</code>中的方法了。</p>
<p>我们先看看没到达阈值前，会调用native方法 <code>newInstance0</code>,这个方法定义在<code>native/sun/reflect/NativeConstructorAccessorImpl.c</code>中，具体<code>newInstance0</code>的流程我就不分析了，大致逻辑是操作堆栈执行方法。</p>
<p>然后我们再看看超过阈值后，执行的是 <code>MethodAccessorGenerator</code>生成构造器的方式。这种方式与<code>newConstructorAccessor</code>方法中<code>noInflation</code> 为 <code>false</code>的处理方式一样。所以可以解释为：java虚拟机在执行反射操作时，如果同一操作执行次数超过阈值，会从native生成实例的方式转变为java生成实例的方式。</p>
<p><code>MethodAccessorGenerator</code>的<code>MethodAccessorGenerator</code>方法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConstructorAccessor generateConstructor(Class&lt;?&gt; var1, Class&lt;?&gt;[] var2, Class&lt;?&gt;[] var3, int var4) &#123;</span><br><span class="line">    return (ConstructorAccessor)this.generate(var1, &quot;&lt;init&gt;&quot;, var2, Void.TYPE, var3, var4, true, false, (Class)null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪下去可以发现，反射调用构造方法实际上是动态编写字节码，并且在虚拟机中把编好的字节码加载成一个Class，这个Class实际上是 <code>ConstructorAccessorImpl</code> 类型的，然后调用这个动态类的<code>newInstance</code>方法。回看刚刚我们梳理的<code>newConstructorAccessor</code>代码，可以看到第三个逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl </span><br><span class="line">else if (Reflection.isSubclassOf(var2, ConstructorAccessorImpl.class)) &#123;</span><br><span class="line">    return new BootstrapConstructorAccessorImpl(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终执行的是 <code>BootstrapConstructorAccessorImpl</code>的<code>newInstance</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BootstrapConstructorAccessorImpl extends ConstructorAccessorImpl &#123;</span><br><span class="line">    private final Constructor&lt;?&gt; constructor;</span><br><span class="line"></span><br><span class="line">    BootstrapConstructorAccessorImpl(Constructor&lt;?&gt; var1) &#123;</span><br><span class="line">        this.constructor &#x3D; var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object newInstance(Object[] var1) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return UnsafeFieldAccessorImpl.unsafe.allocateInstance(this.constructor.getDeclaringClass());</span><br><span class="line">        &#125; catch (InstantiationException var3) &#123;</span><br><span class="line">            throw new InvocationTargetException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是通过使用<code>Unsafe</code>类分配了一个实例。</p>
<h2 id="反射带来的问题"><a href="#反射带来的问题" class="headerlink" title="反射带来的问题"></a>反射带来的问题</h2><p>到现在为止，我们已经把反射生成实例的所有流程都搞清楚了。回到文章开头的问题，我们现在反思下，反射性能低么？为什么？</p>
<ol>
<li>反射调用过程中会产生大量的临时对象，这些对象会占用内存，可能会导致频繁 gc，从而影响性能。</li>
<li>反射调用方法时会从方法数组中遍历查找，并且会检查可见性等操作会耗时。</li>
<li>反射在达到一定次数时，会动态编写字节码并加载到内存中，这个字节码没有经过编译器优化，也不能享受JIT优化。</li>
<li>反射一般会涉及自动装箱/拆箱和类型转换，都会带来一定的资源开销。</li>
</ol>
<p>在Android中，我们可以在某些情况下对反射进行优化。举个例子，EventBus 2.x 会在 register 方法运行时，遍历所有方法找到回调方法；而EventBus 3.x 则在编译期间，将所有回调方法的信息保存的自己定义的 <code>SubscriberMethodInfo</code> 中，这样可以减少对运行时的性能影响。</p>
<p><strong>本文的结论如下：</strong></p>
<ol>
<li>不要在性能敏感的应用中，频繁调用反射。</li>
<li>如果反射执行的次数小于1000这个数量级，反射的耗时实际上与正常调用无太大差异。</li>
<li>反射对内存占用还有一定影响的，在内存敏感的场景下，谨慎使用反射。</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Apocalypse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jiyugithub.github.io/2020/06/12/javafs/">https://jiyugithub.github.io/2020/06/12/javafs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/12/undefined/"><i class="fa fa-chevron-left">  </i><span>Android目前最稳定和高效的UI适配方案</span></a></div><div class="next-post pull-right"><a href="/2020/06/12/hashmap/"><span>HashMap原理技术知识整理</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz',
  appKey:'FihoucantYlc5U1FQ9BzkO3l',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Apocalypse</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>