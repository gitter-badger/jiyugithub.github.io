



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Apocalypse's Blog" href="https://jiyugithub.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Apocalypse's Blog" href="https://jiyugithub.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Apocalypse's Blog" href="https://jiyugithub.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.1.9">

  


<meta name="description" content="" >


<link rel="canonical" href="https://jiyugithub.github.io/2020/06/12/multitype/">



  <title>
Android 复杂的列表视图新写法 MultiType |
启示录 = Apocalypse's Blog</title>
<meta name="generator" content="Hexo 4.2.1"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Android 复杂的列表视图新写法 MultiType
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2020-06-12 03:57:58">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2020-06-12T03:57:58+08:00">2020-06-12</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">启示录</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main id="main">
      <div class="inner">
        <div id="content" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://jiyugithub.github.io/2020/06/12/multitype/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.png">
    <meta itemprop="name" content="Apocalypse">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Apocalypse's Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="android-复杂的列视图新写法-multitype"><a class="markdownIt-Anchor" href="#android-复杂的列视图新写法-multitype">#</a> Android 复杂的列视图新写法 MultiType</h1>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h1>
<p>在开发我的 <strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvVGltZU1hY2hpbmU=">TimeMachine</span></strong> 时，我有一个复杂的聊天页面，于是我设计了我的类型池系统，它是完全解耦的，因此我能够轻松将它抽离出来分享，并给它取名为 <strong>MultiType</strong>.</p>
<a id="more"></a>
<p>从前，<strong>比如我们写一个类似微博列表页面</strong>，这样的列表是十分复杂的：有纯文本的、带转发原文的、带图片的、带视频的、带文章的等等，甚至穿插一条可以横向滑动的好友推荐条目。不同的 item 类型众多，而且随着业务发展，还会更多。如果我们使用传统的开发方式，经常要做一些繁琐的工作，代码可能都堆积在一个  <code>Adapter</code>  中：我们需要覆写  <code>RecyclerView.Adapter</code>  的  <code>getItemViewType</code>  方法，罗列一些  <code>type</code>  整型常量，并且  <code>ViewHolder</code>  转型、绑定数据也比较麻烦。一旦产品需求有变，或者产品设计说需要增加一种新的 item 类型，我们需要去代码堆里找到原来的逻辑去修改，或找到正确的位置去增加代码。这些过程都比较繁琐，侵入较强，需要小心翼翼，以免改错影响到其他地方。</p>
<p>现在好了，我们有了 <strong>MultiType</strong>，简单来说，<strong>MultiType 就是一个多类型列表视图的中间分发框架，它能帮助你快速并且清晰地开发一些复杂的列表页面。</strong> 它本是为聊天页面开发的，聊天页面的消息类型也是有大量不同种类，且新增频繁，而 <strong>MultiType</strong> 能够轻松胜任。</p>
<p><strong>MultiType</strong> 以灵活直观为第一宗旨进行设计，它内建了  <code>类型</code>  -  <code>View</code>  的复用池系统，支持  <code>RecyclerView</code> ，随时可拓展新的类型进入列表当中，使用简单，令代码清晰、模块化、灵活可变。</p>
<p>因此，我写了这篇文章，目的有几个：一是以作者的角度对 <strong>MultiType</strong> 进行入门和进阶详解。二是传递我开发过程中的思想、设计理念，这些偏细腻的内容，即使不使用 <strong>MultiType</strong>，想必也能带来很多启发。最后就是把自我觉得不错的东西分享给大家，试想如果你制造的东西很多人在用，即使没有带来任何收益，也是一件很自豪的事情。</p>
<h1 id="multitype-的特性"><a class="markdownIt-Anchor" href="#multitype-的特性">#</a> MultiType 的特性</h1>
<ul>
<li>轻盈，整个类库只有 14 个类文件， <code>aar</code>  或  <code>jar</code>  包大小只有 13 KB</li>
<li>周到，支持 data type  <code>&lt;--&gt;</code>  item view binder 之间 一对一 和 一对多 的关系绑定</li>
<li>灵活，几乎所有的部件 (类) 都可被替换、可继承定制，面向接口 / 抽象编程</li>
<li>纯粹，只负责本分工作，专注多类型的列表视图 类型分发，绝不会去影响 views 的内容或行为</li>
<li>高效，没有性能损失，内存友好，最大限度发挥  <code>RecyclerView</code>  的复用性</li>
<li>可读，代码清晰干净、设计精巧，极力避免复杂化，可读性很好，为拓展和自行解决问题提供了基础</li>
</ul>
<h1 id="总览"><a class="markdownIt-Anchor" href="#总览">#</a> 总览</h1>
<p><strong>MultiType</strong> 能轻松实现如下页面，它们将在示例篇章具体提供:</p>
<p><img data-src="http://gank.io/images/ada238b5a25e43f2881acc4cd290c257" alt="img"></p>
<p>MultiType 的源码关系：</p>
<p><a href="http://ww1.sinaimg.cn/large/86e2ff85gy1ffc03rofrmj21kw12htjl.jpg" target="_blank" rel="noopener"><img data-src="http://gank.io/images/6bf70d44bb1e489b951345b3a1c7d239" alt="img"></a></p>
<h1 id="multitype-基础用法"><a class="markdownIt-Anchor" href="#multitype-基础用法">#</a> MultiType 基础用法</h1>
<p>可能有的新手看到以上特性介绍说什么 “一对多”、抽象编程等等，都不太懂，我想说完全不要紧，不懂可以回过头来再看，我们先从基础用法入手，其实 <strong>MultiType</strong> 使用起来特别简单。使用 <strong>MultiType</strong> 一般情况下只要 maven 引入 + 三个小步骤。之后还会介绍使用插件生成代码方式，步骤将更加简化：</p>
<h3 id="引入"><a class="markdownIt-Anchor" href="#引入">#</a> 引入</h3>
<p>在你的  <code>build.gradle</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;me.drakeet.multitype:multitype:3.0.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<strong>MultiType</strong> 内部引用了  <code>recyclerview-v7:25.3.1</code> ，如果你不想使用这个版本，可以使用  <code>exclude</code>  将它排除掉，再自行引入你选择的版本。示例如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(&#39;me.drakeet.multitype:multitype:3.0.0&#39;, &#123;</span><br><span class="line">       exclude group: &#39;com.android.support&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    compile &#39;com.android.support:recyclerview-v7:你选择的版本&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用">#</a> 使用</h2>
<p><strong>Step 1</strong>. 创建一个  <code>class</code> ，它将是你的数据类型或 Java bean /model. 对这个类的内容没有任何限制。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Category &#123;</span><br><span class="line"></span><br><span class="line">    @NonNull public final String text;</span><br><span class="line"></span><br><span class="line">    public Category(@NonNull String text) &#123;</span><br><span class="line">        this.text &#x3D; text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Step 2</strong>. 创建一个  <code>class</code>  继承  <code>ItemViewBinder</code> .</p>
<p><code>ItemViewBinder</code>  是个抽象类，其中  <code>onCreateViewHolder</code>  方法用于生产你的 Item View Holder,  <code>onBindViewHolder</code>  用于绑定数据到  <code>View</code> s. 一般一个  <code>ItemViewBinder</code>  类在内存中只会有一个实例对象，MultiType 内部将复用这个 binder 对象来生产所有相关的 item views 和绑定数据。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CategoryViewBinder</span><br><span class="line">    extends ItemViewBinder&lt;Category, CategoryViewBinder.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @NonNull @Override</span><br><span class="line">    protected ViewHolder onCreateViewHolder(@NonNull LayoutInflater inflater, @NonNull ViewGroup parent) &#123;</span><br><span class="line">        View root &#x3D; inflater.inflate(R.layout.item_category, parent, false);</span><br><span class="line">        return new ViewHolder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull Category category) &#123;</span><br><span class="line">        holder.category.setText(category.text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        @NonNull private final TextView category;</span><br><span class="line"></span><br><span class="line">        ViewHolder(@NonNull View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            this.category &#x3D; (TextView) itemView.findViewById(R.id.category);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Step 3</strong>. 在  <code>Activity</code>  中加入  <code>RecyclerView</code>  和  <code>List</code>  并注册你的类型，示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private MultiTypeAdapter adapter;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Items 等同于 ArrayList&lt;Object&gt; *&#x2F;</span><br><span class="line">    private Items items;</span><br><span class="line"></span><br><span class="line">    @Override </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        RecyclerView recyclerView &#x3D; (RecyclerView) findViewById(R.id.list);</span><br><span class="line"></span><br><span class="line">        adapter &#x3D; new MultiTypeAdapter();</span><br><span class="line"></span><br><span class="line">        &#x2F;* 注册类型和 View 的对应关系 *&#x2F;</span><br><span class="line">        adapter.register(Category.class, new CategoryViewBinder());</span><br><span class="line">        adapter.register(Song.class, new SongViewBinder());</span><br><span class="line">        recyclerView.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        &#x2F;* 模拟加载数据，也可以稍后再加载，然后使用</span><br><span class="line">         * adapter.notifyDataSetChanged() 刷新列表 *&#x2F;</span><br><span class="line">        items &#x3D; new Items();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            items.add(new Category(&quot;Songs&quot;));</span><br><span class="line">            items.add(new Song(&quot;小艾大人&quot;, R.drawable.avatar_dakeet));</span><br><span class="line">            items.add(new Song(&quot;许岑&quot;, R.drawable.avatar_cen));</span><br><span class="line">        &#125;</span><br><span class="line">        adapter.setItems(items);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成！这就是 <strong>MultiType</strong> 的基础用法了。其中  <code>onCreateViewHolder</code>  和  <code>onBindViewHolder</code>  方法名沿袭了使用  <code>RecyclerView</code>  的习惯，令人一目了然，减少了新人的学习成本。</p>
<h1 id="设计思想"><a class="markdownIt-Anchor" href="#设计思想">#</a> 设计思想</h1>
<p><strong>MultiType</strong> 设计伊始，我给它定了几个原则：</p>
<ul>
<li>
<p>要简单，便于他人阅读代码</p>
<p>因此我极力避免将它复杂化，避免加入许多不相干的内容。我想写人人可读的代码，使用简单的方式，去实现复杂的需求。过多不相干、没必要的代码，将会使项目变得令人晕头转向，难以阅读，遇到需要定制、解决问题的时候，无从下手。</p>
</li>
<li>
<p>要灵活，便于拓展和适应各种需求</p>
<p>很多人会得意地告诉我，他们把 <strong>MultiType</strong> 源码精简成三四个类，甚至一个类，以为代码越少就是越好，这我不能赞同。<strong>MultiType</strong> 考虑得更远，这是一个提供给大众使用的类库，过度的精简只会使得大幅失去灵活性。<strong>它或许不是使用起来最简单的，但很可能是使用起来最灵活的。</strong> 在我看来，“直观”、“灵活 &quot;优先级大于&quot; 简单”。因此，<strong>MultiType</strong> 以接口或抽象进行连接，这意味着它的角色、组件都可以被替换，或者被拓展和继承。如果你觉得它使用起来还不够简单，完全可以通过继承封装出更具体符合你使用需求的方法。它已经暴露了足够丰富、周到的接口以供拓展，我们不应该直接去修改源码，这会导致一旦后续发现你的精简版满足不了你的需求时，已经没有回头路了。</p>
</li>
<li>
<p>要直观，使用起来能令项目代码更清晰可读，一目了然</p>
<p><strong>MultiType</strong> 提供的  <code>ItemViewBinder</code>  沿袭了  <code>RecyclerView Adapter</code>  的接口命名，使用起来更加舒适，符合习惯。另外，MultiType 很多地方放弃使用反射而是让用户显式指明一些关系，如： <code>MultiTypeAdapter#register</code>  方法，需要传递一个数据模型  <code>class</code>  和  <code>ItemViewBinder</code>  对象，虽然有很多方法可以把它精简成单一参数方法，但我们认为显式声明数据模型类与对应关系，更具直观。</p>
</li>
</ul>
<h1 id="高级用法"><a class="markdownIt-Anchor" href="#高级用法">#</a> 高级用法</h1>
<p>介绍了基础用法和设计思想后，我们可以来介绍一下 <strong>MultiType</strong> 的高级用法。这是一些典型需求和案例，它们是基础用法的延伸，也是设计思想的体现。也许一开始并不会使用到，但如若了解，能够拓宽使用 <strong>MultiType</strong> 的思路，也能过了解到我们考虑问题的角度。</p>
<h2 id="使用-multitypetemplates-插件自动生成代码"><a class="markdownIt-Anchor" href="#使用-multitypetemplates-插件自动生成代码">#</a> 使用 MultiTypeTemplates 插件自动生成代码</h2>
<p>在基础用法中，我们了通过 3 个步骤完成 <strong>MultiType</strong> 的初次接入使用，实际上这个过程可以更加简化，<strong>MultiType</strong> 提供了 Android Studio 插件来自动生成代码：</p>
<p><strong>MultiTypeTemplates</strong>，源码也是开源的，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvTXVsdGlUeXBlVGVtcGxhdGVzJUUzJTgwJTgyJUU4JUJGJTk5JUU0JUI4JUFBJUU2JThGJTkyJUU0JUJCJUI2JUU0JUI4JThEJUU0JUJCJTg1JUU2JThGJTkwJUU0JUJFJTlCJUU0JUJBJTg2JUU0JUI4JTgwJUU5JTk0JUFFJUU3JTk0JTlGJUU2JTg4JTkw">https://github.com/drakeet/MultiTypeTemplates。这个插件不仅提供了一键生成</span> item 类文件和  <code>ItemViewBinder</code> ，而且 ** 是一个很好的利用代码模版自动生成代码的示例。** 其中使用到了官方提供的代码模版 API，也用到了我自己发明的更灵活修改模版内容的方法，有兴趣做这方面插件的可以看看。</p>
<p>话说回来，安装和使用 <strong>MultiTypeTemplates</strong> 非常简单：</p>
<p><strong>Step 1.</strong> 打开 Android Studio 的 <code>设置</code>  -&gt;  <code>Plugin</code>  -&gt;  <code>Browse repositories</code> ，搜索  <code>MultiTypeTemplates</code>  即可获得下载安装：</p>
<p><img data-src="http://gank.io/images/cd52ae3e4b8d4c5095afdea8948ab940" alt="img"></p>
<p><strong>Step 2.</strong> 安装完成后，重启 Android Studio. 右键点击你的 package，选择  <code>New</code>  -&gt;  <code>MultiType Item</code> ，然后输入你的 item 名字，它就会自动生成 item 模型类 和  <code>ItemViewBinder</code>  文件和代码。</p>
<p>比如你输入的是 “Category”，它就会自动生成  <code>Category.java</code>  和  <code>CategoryViewBinder.java</code> .</p>
<p>特别方便，相信你会很喜欢它。未来这个插件也将会支持自动生成布局文件，这是目前欠缺的，但不要紧，其实 AS 在这方面已经很方便了，对布局  <code>R.layout.item_category</code>  使用  <code>alt + enter</code>  快捷键即可自动生成布局文件。</p>
<h2 id="一个类型对应多个-itemviewbinder"><a class="markdownIt-Anchor" href="#一个类型对应多个-itemviewbinder">#</a> 一个类型对应多个  <code>ItemViewBinder</code></h2>
<p><strong>MultiType</strong> 天然支持一个类型对应多个  <code>ItemViewBinder</code> ，注册方式也很简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adapter.register(Data.class).to(</span><br><span class="line">    new DataType1ViewBinder(),</span><br><span class="line">    new DataType2ViewBinder()</span><br><span class="line">).withClassLinker(new ClassLinker&lt;Data&gt;() &#123;</span><br><span class="line">    @NonNull @Override</span><br><span class="line">    public Class&lt;? extends ItemViewBinder&lt;Data, ?&gt;&gt; index(@NonNull Data data) &#123;</span><br><span class="line">        if (data.type &#x3D;&#x3D; Data.TYPE_2) &#123;</span><br><span class="line">            return DataType2ViewBinder.class;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return DataType1ViewBinder.class;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adapter.register(Data.class).to(</span><br><span class="line">    new DataType1ViewBinder(),</span><br><span class="line">    new DataType2ViewBinder()</span><br><span class="line">).withLinker(new Linker&lt;Data&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int index(@NonNull Data data) &#123;</span><br><span class="line">        if (data.type &#x3D;&#x3D; Data.TYPE_2) &#123; return 1; &#125; else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你使用 Lambda 表达式，以上代码可以更简洁：</p>
<p><img data-src="https://cloud.githubusercontent.com/assets/5214214/25094943/e458121a-23cb-11e7-9bb6-106d6b1d8401.png" alt="img"></p>
<p>解释：</p>
<p>如上示例代码，对于一对多，我们需要使用  <code>MultiType#register(class)</code>  方法，它会返回一个  <code>OneToManyFlow</code>  让你紧接着绑定多个  <code>ItemViewBinder</code>  实例，最后再调用  <code>OneToManyEndpoint#withLinker</code>  或  <code>OneToManyEndpoint#withClassLinker</code>  操作符方法类设置 linker. 所谓 linker，是负责动态连接这个 “一” 对应 “多” 中哪一个 binder 的角色。</p>
<p>这个方案具有很好的性能表现，而且可谓十分直观。另外，我使用了  <code>@CheckResult</code>  注解来让编译器督促开发者一定要完整调用方法链才不至于出错。</p>
<p>更详细的 &quot;一对多&quot; 示例可以参考我的 sample <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvTXVsdGlUeXBlL3RyZWUvbWFzdGVyL3NhbXBsZS9zcmMvbWFpbi9qYXZhL21lL2RyYWtlZXQvbXVsdGl0eXBlL3NhbXBsZS9vbmUybWFueQ==">源码</span></p>
<h2 id="使用-全局类型池"><a class="markdownIt-Anchor" href="#使用-全局类型池">#</a> 使用 全局类型池</h2>
<p><strong>MultiType</strong> 在 3.0 版本之前一直是支持全局类型池的，你可以往一个全局类型池中 register 类型和 view binder，然后让你的各个  <code>MultiTypeAdapter</code>  都能使用它。</p>
<p>但在 <strong>MultiType</strong> 3.0 之后，我们废弃并删除了内置的全局类型池。原因在于全局类型池容易对全局产生不可见影响，比如你注册了一堆全局类型关系并在多处引用它，某一天你的伙伴不小心修改了全局类型池的某个内容，将导致所有使用的地方皆受到变化，是我们不希望发生的。一个好的模块，应该是高内聚、自包含的，如果过多下放权力到外围，很容易遭受破坏或影响。</p>
<p>另外，全局类型池一般都是 static 形式的，如果我们给这个 static 容器传递了  <code>Activity</code>  或  <code>Context</code>  对象，而没有在退出时释放，就容易造出内存泄漏，这对新手来说很容易触犯。</p>
<p>因此我们删除了内置的全局类型池，当你创建一个  <code>MultiTypeAdapter</code>  对象时，默认情况下，它内部会自动创建一个局部类型池以供你接下来注册类型。当然了，如果你实在需要它，完全可以自己创建一个 static 的  <code>MultiTypePool</code> ，然后通过  <code>MultiTypeAdapter#registerAll(pool)</code>  将这个类型池传入，以此达到多个地方共同使用。</p>
<h2 id="与-itemviewbinder-通讯"><a class="markdownIt-Anchor" href="#与-itemviewbinder-通讯">#</a> 与  <code>ItemViewBinder</code>  通讯</h2>
<p><code>ItemViewBinder</code>  对象可以接受外部类型、回调函数，只要在使用之前，传递进去即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OnClickListener listener &#x3D; new OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">adapter.register(Post.class, new PostViewBinder(xxx, listener));</span><br></pre></td></tr></table></figure>
<p>但话说回来，对于点击事件，能不依赖  <code>binder</code>  外部内容的话，最好就在  <code>binder</code>  内部完成。 <code>binder</code>  内部能够拿到 Views 和 数据，大部分情况下，完全有能力不依赖外部 独立完成逻辑。这样能使代码更加模块化，实现解耦和内聚。例如下面便是一个完全自包含的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SquareViewBinder extends ItemViewBinder&lt;Square, SquareViewBinder.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @NonNull @Override</span><br><span class="line">    protected ViewHolder onCreateViewHolder(</span><br><span class="line">        @NonNull LayoutInflater inflater, @NonNull ViewGroup parent) &#123;</span><br><span class="line">        View root &#x3D; inflater.inflate(R.layout.item_square, parent, false);</span><br><span class="line">        return new ViewHolder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull Square square) &#123;</span><br><span class="line">        holder.square &#x3D; square;</span><br><span class="line">        holder.squareView.setText(valueOf(square.number));</span><br><span class="line">        holder.squareView.setSelected(square.isSelected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class ViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        private TextView squareView;</span><br><span class="line">        private Square square;</span><br><span class="line"></span><br><span class="line">        ViewHolder(final View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            squareView &#x3D; (TextView) itemView.findViewById(R.id.square);</span><br><span class="line">            itemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override public void onClick(View v) &#123;</span><br><span class="line">                    itemView.setSelected(square.isSelected &#x3D; !square.isSelected);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用断言比传统-adapter-更加易于调试"><a class="markdownIt-Anchor" href="#使用断言比传统-adapter-更加易于调试">#</a> 使用断言，比传统 Adapter 更加易于调试</h2>
<p><strong>众所周知，如果一个传统的  <code>RecyclerView</code>   <code>Adapter</code>  内部有异常导致崩溃，它的异常栈是不会指向到你的  <code>Activity</code> </strong>，这给我们开发调试过程中带来了麻烦。如果我们的  <code>Adapter</code>  是复用的，就不知道是哪一个页面崩溃。而对于  <code>MultiTypeAdapter</code> ，我们显然要用于多个地方，而且可能出现开发者忘记注册类型等等问题。为了便于调试，开发期快速失败，<strong>MultiType</strong> 提供了很方便的断言 API:  <code>MultiTypeAsserts</code> ，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import static me.drakeet.multitype.MultiTypeAsserts.assertAllRegistered;</span><br><span class="line">import static me.drakeet.multitype.MultiTypeAsserts.assertHasTheSameAdapter;</span><br><span class="line"></span><br><span class="line">public class SimpleActivity extends MenuBaseActivity &#123;</span><br><span class="line"></span><br><span class="line">    private Items items;</span><br><span class="line">    private MultiTypeAdapter adapter;</span><br><span class="line"></span><br><span class="line">    @Override protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        RecyclerView recyclerView &#x3D; (RecyclerView) findViewById(R.id.list);</span><br><span class="line"></span><br><span class="line">        items &#x3D; new Items();</span><br><span class="line">        adapter &#x3D; new MultiTypeAdapter(items);</span><br><span class="line">        adapter.register(TextItem.class, new TextItemViewBinder());</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            items.add(new TextItem(valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* 断言所有使用的类型都已注册 *&#x2F;</span><br><span class="line">        assertAllRegistered(adapter, items);</span><br><span class="line">        recyclerView.setAdapter(adapter);</span><br><span class="line">        &#x2F;* 断言 recyclerView 使用的是正确的 adapter *&#x2F;</span><br><span class="line">        assertHasTheSameAdapter(recyclerView, adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>assertAllRegistered</code>  和  <code>assertHasTheSameAdapter</code>  都是可选择性使用， <code>assertAllRegistered</code>  需要在加载或更新数据之后，  <code>assertHasTheSameAdapter</code>  必须在  <code>recyclerView.setAdapter(adapter)</code>  之后。</p>
<p>这样做以后， <code>MultiTypeAdapter</code>  相关的异常都会报到你的  <code>Activity</code> ，并且会详细注明出错的原因，而如果符合断言，断言代码不会有任何副作用或影响你的代码逻辑，这时你可以把它当作废话。关于这个类的源代码是很简单的，有兴趣可以直接看看源码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvTXVsdGlUeXBlL2Jsb2IvbWFzdGVyL2xpYnJhcnkvc3JjL21haW4vamF2YS9tZS9kcmFrZWV0L211bHRpdHlwZS9NdWx0aVR5cGVBc3NlcnRzLmphdmE=">drakeet/multitype/MultiTypeAsserts.java</span></p>
<h2 id="支持-google-autovalue"><a class="markdownIt-Anchor" href="#支持-google-autovalue">#</a> 支持 Google AutoValue</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9hdXRvL3RyZWUvbWFzdGVyL3ZhbHVl">AutoValue</span> 是 Google 提供的一个在 Java 实体类中自动生成代码的类库，使你更专注于处理项目的其他逻辑，它可使代码更少，更干净，以及更少的 bug.</p>
<p>当我们使用传统方式创建一个 Java 模型类的时候，经常需要写一堆  <code>toString()</code> 、 <code>hashCode()</code> 、getter、setter 等等方法，而且对于 Android 开发，大多情况下还需要实现  <code>Parcelable</code>  接口。这样的结果是，我本来想要一个只有几个属性的小模型类，但出于各种原因，这个模型类方法数变得十分繁复，阅读起来很不清爽，并且难免会写错内容。AutoValue 的出现解决了这个问题，我们只需定义一些抽象类交给 AutoValue，AutoValue 会<strong>自动</strong>生成该抽象类的具体实现子类，并携带各种样板代码。</p>
<p>更详细的介绍内容和使用教程，我会在文章末尾会给出 AutoValue 的相关链接，不熟悉 AutoValue 可以借此机会看一下，在这里就不做过多介绍了。新手暂时看不懂也不必纠结，了解之后都是十分容易的。</p>
<p><strong>MultiType</strong> 支持了 Google AutoValue，支持自动映射某个已经注册的类型的<strong>子类</strong>到同一  <code>ItemViewBinder</code> ，规则是：如果子类<strong>有</strong>注册，就用注册的映射关系；如果子类<strong>没</strong>注册，则该子类对象使用注册过的父类映射关系。</p>
<h2 id="flattypeadapter已废弃"><a class="markdownIt-Anchor" href="#flattypeadapter已废弃">#</a> FlatTypeAdapter (已废弃)</h2>
<p>MultiType 3.0 之前提供了一个  <code>FlatTypeAdapter</code>  类，3.0 之后，这个类已经被删除了，你可以完全不必关心它。如果你使用过它，现在它已经被一对多方案替代了，请转成使用一对多功能实现。</p>
<h2 id="multitype-与下拉刷新-加载更多-headerview-footerview-diff"><a class="markdownIt-Anchor" href="#multitype-与下拉刷新-加载更多-headerview-footerview-diff">#</a> MultiType 与下拉刷新、加载更多、HeaderView、FooterView、Diff</h2>
<p><strong>MultiType</strong> 设计从始至终，都极力避免往复杂化方向发展，一开始我的设计宗旨就是它应该是一个非常纯粹的、专一的项目，而非各种乱七八糟的功能都要囊括进来的多合一大型库，因此它很克制，期间有许多人给我发过一些无关特性的 Pull Request，表示感谢，但全被拒绝了。</p>
<p>对于很多人关心的 下拉刷新、加载更多、HeaderView、FooterView、Diff 这些功能特性，其实都不应该是 <strong>MultiType</strong> 的范畴，<strong>MultiType</strong> 的分内之事是做类型、事件与 View 的分发、连接工作，其余无关的需求，都是可以在 <strong>MultiType</strong> 外部完成，或者通过继承 进行自行封装和拓展，而作为一个基础、公共类库，我想它是不应该包含这些内容。</p>
<p>但很多新手可能并不习惯代码分工、模块化，因此在此我有必要对这几个点简单示范下如何在 <strong>MultiType</strong> 之外去实现：</p>
<ul>
<li>
<p><strong>下拉刷新：</strong></p>
<p>对于下拉刷新， <code>Android</code>  官方提供了  <code>support.v4</code>   <code>SwipeRefreshLayout</code> ，在  <code>Activity</code>  层面，可以拿到  <code>SwipeRefreshLayout</code>  调用  <code>setOnRefreshListener</code>  设置监听器即可.</p>
<p>或者参考我的 rebase-android 项目编写的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvcmViYXNlLWFuZHJvaWQvYmxvYi9tYXN0ZXIvYXBwL3NyYy9tYWluL2phdmEvY29tL2RyYWtlZXQvcmViYXNlL3Rvb2wvU3dpcGVSZWZyZXNoRGVsZWdhdGUuamF2YQ==">SwipeRefreshDelegate.java</span>.</p>
</li>
<li>
<p><strong>加载更多：</strong></p>
<p><code>RecyclerView</code>  提供了  <code>addOnScrollListener</code>  滚动位置变化监听，要实现加载更多，只要监听并检测列表是否滚动到底部即可，有多种方式，鉴于  <code>LayoutManager</code>  本应该只做布局相关的事务，因此我们推荐直接在  <code>OnScrollListener</code>  层面进行判断。提供一个简单版  <code>OnScrollListener</code>  继承类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class OnLoadMoreListener extends RecyclerView.OnScrollListener &#123;</span><br><span class="line"></span><br><span class="line">  private LinearLayoutManager layoutManager;</span><br><span class="line">  private int itemCount, lastPosition, lastItemCount;</span><br><span class="line"></span><br><span class="line">  public abstract void onLoadMore();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123;</span><br><span class="line">      if (recyclerView.getLayoutManager() instanceof LinearLayoutManager) &#123;</span><br><span class="line">          layoutManager &#x3D; (LinearLayoutManager) recyclerView.getLayoutManager();</span><br><span class="line"></span><br><span class="line">          itemCount &#x3D; layoutManager.getItemCount();</span><br><span class="line">          lastPosition &#x3D; layoutManager.findLastCompletelyVisibleItemPosition();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          Log.e(&quot;OnLoadMoreListener&quot;, &quot;The OnLoadMoreListener only support LinearLayoutManager&quot;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (lastItemCount !&#x3D; itemCount &amp;&amp; lastPosition &#x3D;&#x3D; itemCount - 1) &#123;</span><br><span class="line">          lastItemCount &#x3D; itemCount;</span><br><span class="line">          this.onLoadMore();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者参考我的 rebase-android 项目编写的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvcmViYXNlLWFuZHJvaWQvYmxvYi9tYXN0ZXIvYXBwL3NyYy9tYWluL2phdmEvY29tL2RyYWtlZXQvcmViYXNlL3Rvb2wvTG9hZE1vcmVEZWxlZ2F0ZS5qYXZh">LoadMoreDelegate.java</span>.</p>
</li>
<li>
<p><strong>获取数据后做 Diff 更新：</strong></p>
<p><strong>MultiType</strong> 支持 onBindViewHolder with payloads，详情见  <code>ItemViewBinder</code>  类文档。对于 Diff，可以在  <code>Activity</code>  中进行 Diff，或者继承  <code>MultiTypeAdapter</code>  提供接收数据方法，在方法中进行 Diff. <strong>MultiType</strong> 不提供内置 Diff 方案，不然需要依赖 v4 包，并且这也不应该属于它的范畴。</p>
<p>示例代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvTXVsdGlUeXBlL2lzc3Vlcy81Ng==">https://github.com/drakeet/MultiType/issues/56</span></p>
</li>
<li>
<p><strong>HeaderView、FooterView</strong></p>
<p><strong>MultiType</strong> 其实本身就支持  <code>HeaderView</code> 、 <code>FooterView</code> ，只要创建一个  <code>Header.class</code>  -  <code>HeaderViewBinder</code>  和  <code>Footer.class</code>  -  <code>FooterViewBinder</code>  即可，然后把  <code>new Header()</code>  添加到  <code>items</code>  第一个位置，把  <code>new Footer()</code>  添加到  <code>items</code>  最后一个位置。需要注意的是，如果使用了 Footer View，在底部插入数据的时候，需要添加到  <code>最后位置 - 1</code> ，即倒二个位置，或者把  <code>Footer</code>  remove 掉，再添加数据，最后再插入一个新的  <code>Footer</code> .</p>
</li>
</ul>
<h2 id="实现-recyclerview-嵌套横向-recyclerview"><a class="markdownIt-Anchor" href="#实现-recyclerview-嵌套横向-recyclerview">#</a> 实现 RecyclerView 嵌套横向 RecyclerView</h2>
<p><strong>MultiType</strong> 天生就适合实现类似 Google Play 或 iOS App Store 那样复杂的首页列表，这种页面通常会在垂直列表中嵌套横向列表，其实横向列表我们完全可以把它视为一种  <code>Item</code>  类型，这个 item 持有一个列表数据和当前横向列表滑动到的位置，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PostList &#123;</span><br><span class="line"></span><br><span class="line">    public final List&lt;Post&gt; posts;</span><br><span class="line">    public int currentPosition;</span><br><span class="line"></span><br><span class="line">    public PostList(@NonNull List&lt;Post&gt; posts) &#123;this.posts &#x3D; posts;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的  <code>HorizontalItemViewBinder</code>  类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class HorizontalItemViewBinder</span><br><span class="line">    extends ItemViewBinder&lt;PostList, HorizontalItemViewBinder.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @NonNull @Override</span><br><span class="line">    protected ViewHolder onCreateViewHolder(</span><br><span class="line">        @NonNull LayoutInflater inflater, @NonNull ViewGroup parent) &#123;</span><br><span class="line">        &#x2F;* item_horizontal_list 就是一个只有 RecyclerView 的布局 *&#x2F;</span><br><span class="line">        View view &#x3D; inflater.inflate(R.layout.item_horizontal_list, parent, false);</span><br><span class="line">        return new ViewHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull PostList postList) &#123;</span><br><span class="line">        holder.setPosts(postList.posts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class ViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        private RecyclerView recyclerView;</span><br><span class="line">        private PostsAdapter adapter;</span><br><span class="line"></span><br><span class="line">        private ViewHolder(@NonNull View itemView) &#123;</span><br><span class="line">            super(itemView);</span><br><span class="line">            recyclerView &#x3D; (RecyclerView) itemView.findViewById(R.id.post_list);</span><br><span class="line">            LinearLayoutManager layoutManager &#x3D; new LinearLayoutManager(itemView.getContext());</span><br><span class="line">            layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);</span><br><span class="line">            recyclerView.setLayoutManager(layoutManager);</span><br><span class="line">            &#x2F;* adapter 只负责灌输、适配数据，布局交给 LayoutManager，可复用 *&#x2F;</span><br><span class="line">            adapter &#x3D; new PostsAdapter(); &#x2F;&#x2F; 或者直接使用 MultiTypeAdapter 更加方便</span><br><span class="line">            recyclerView.setAdapter(adapter);</span><br><span class="line">            &#x2F;* 在此设置横向滑动监听器，用于记录和恢复当前滑动到的位置，略 *&#x2F;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void setPosts(List&lt;Post&gt; posts) &#123;</span><br><span class="line">            adapter.setPosts(posts);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现线性布局和网格布局混排列表"><a class="markdownIt-Anchor" href="#实现线性布局和网格布局混排列表">#</a> 实现线性布局和网格布局混排列表</h2>
<p>这个课题其实也不属于 <strong>MultiType</strong> 的范畴，<strong>MultiType</strong> 的职责是做数据类型分发，而不是布局，但鉴于很多复杂页面都会需要线性布局和网格布局混排，我就简单讲一讲，关键在于  <code>RecyclerView</code>  的  <code>LayoutManager</code> . 虽然是线性和网格混合，但实现起来其实只要一个网格布局  <code>GridLayoutManager</code> ，如果你查看  <code>GridLayoutManager</code>  的官方源码，你会发现它其实继承自  <code>LinearLayoutManager</code> . 以下是示例和解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MultiGridActivity extends MenuBaseActivity &#123;</span><br><span class="line"></span><br><span class="line">    private final static int SPAN_COUNT &#x3D; 5;</span><br><span class="line">    private MultiTypeAdapter adapter;</span><br><span class="line">    private Items items;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_multi_grid);</span><br><span class="line">        items &#x3D; new Items();</span><br><span class="line">        RecyclerView recyclerView &#x3D; (RecyclerView) findViewById(R.id.list);</span><br><span class="line"></span><br><span class="line">        final GridLayoutManager layoutManager &#x3D; new GridLayoutManager(this, SPAN_COUNT);</span><br><span class="line"></span><br><span class="line">        &#x2F;* 关键内容：通过 setSpanSizeLookup 来告诉布局，你的 item 占几个横向单位，</span><br><span class="line">           如果你横向有 5 个单位，而你返回当前 item 占用 5 个单位，那么它就会看起来单独占用一行 *&#x2F;</span><br><span class="line">        layoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int getSpanSize(int position) &#123;</span><br><span class="line">                return (items.get(position) instanceof Category) ? SPAN_COUNT : 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        recyclerView.setLayoutManager(layoutManager);</span><br><span class="line"></span><br><span class="line">        adapter &#x3D; new MultiTypeAdapter(items);</span><br><span class="line">        adapter.applyGlobalMultiTypePool();</span><br><span class="line">        adapter.register(Square.class, new SquareViewBinder());</span><br><span class="line"></span><br><span class="line">        assertAllRegistered(adapter, items);</span><br><span class="line">        recyclerView.setAdapter(adapter);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadData() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据扁平化处理"><a class="markdownIt-Anchor" href="#数据扁平化处理">#</a> 数据扁平化处理</h2>
<p>在一个<strong>垂直</strong>  <code>RecyclerView</code>  中，item 们都是同级的，没有任何嵌套关系，但我们的数据结构往往存在嵌套关系，比如  <code>Post</code>  内部包含了  <code>Comment</code> s 数据，或换句话说  <code>Post</code>  嵌套了  <code>Comment</code> ，就像微信朋友圈一样，“动态” 伴随着 “评论”。那么如何把 非扁平化 的数据排布在 扁平 的列表中呢？必然需要一个<em>数据扁平化处理</em>的过程，就像  <code>ListView</code>  的数据需要一个  <code>Adapter</code>  来适配， <code>Adapter</code>  就像一个油漏斗，把油引入瓶子中。我们在面对嵌套数据结构的时候，可以采用如下的扁平化处理，关于扁平化这个词，不必太纠结，简单说，就是把嵌套数据都拉出来，摊平，让  <code>Comment</code>  和  <code>Post</code>  同级，最后把它们都 add 进同一个  <code>Items</code>  容器，交给  <code>MultiTypeAdapter</code> . 示例：</p>
<p>假设：你的  <code>Post</code>  是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Post &#123;</span><br><span class="line"></span><br><span class="line">    public String content;</span><br><span class="line">    public List&lt;Comment&gt; comments; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设：你的  <code>Comment</code>  是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Comment &#123;</span><br><span class="line"></span><br><span class="line">    public String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设：你服务端返回的 JSON 数据是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;content&quot;:&quot;I have released the MultiType v2.2.2&quot;, </span><br><span class="line">        &quot;comments&quot;:[</span><br><span class="line">            &#123;&quot;content&quot;:&quot;great&quot;&#125;,</span><br><span class="line">            &#123;&quot;content&quot;:&quot;I love your post!&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>那么你的 JSON 转成 Java Bean 之后，你拿到手应该是个  <code>List&lt;Post&gt; posts</code>  对象，现在我们写一个扁平化处理的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Object&gt; flattenData(List&lt;Post&gt; posts) &#123;</span><br><span class="line">    final List&lt;Object&gt; items &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Post post : posts) &#123;</span><br><span class="line">        &#x2F;* 将 post 加进 items，Binder 内部拿到它的时候，</span><br><span class="line">         * 我们无视它的 comments 内容即可 *&#x2F;</span><br><span class="line">        items.add(post);</span><br><span class="line">        &#x2F;* 紧接着将 comments 拿出来插入进 items，</span><br><span class="line">         * 评论就能正好处于该条 post 下面 *&#x2F;</span><br><span class="line">        items.addAll(post.comments);</span><br><span class="line">    &#125;</span><br><span class="line">    return items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们所有的  <code>posts</code>  在加入全局 MultiType  <code>Items</code>  之前，都需要经过扁平化处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items.addAll(flattenData(posts));</span><br><span class="line">adapter.notifyDataSetChanged();</span><br></pre></td></tr></table></figure>
<p>整个过程其实并不困难，相信大家都已经理解了。</p>
<h1 id="更多示例"><a class="markdownIt-Anchor" href="#更多示例">#</a> 更多示例</h1>
<p><strong>MultiType</strong> 的开源项目提供了许多的 samples (示例) 程序，这些示例秉承了一贯的代码清晰、干净的风格，十分易于阅读：</p>
<ul>
<li>
<p><a href="https://github.com/drakeet/MultiType/tree/master/sample/src/main/java/me/drakeet/multitype/sample/weibo" target="_blank" rel="noopener">仿造<strong>微博</strong>的数据结构和二级 ItemViewBinder</a></p>
<p>这是一个类似微博数据结构的示例，数据两层结构，Item 也是两层结构：一层框架（包含头像用户名等），一层 content view (微博内容)，内容嵌套于框架中。微博的每一条微博 item 都包含了这样两层嵌套关系，这样做的好处是，你不必每个 item 都去重复制造一遍外层框架。</p>
<p>或者换一个比喻，就像聊天消息，一条聊天消息也是两层的，一层头像、用户名、聊天气泡框，一层你的文字、图片等。另外，每一种消息都有左边和右边的样式，分别对应别人发来的消息和你发出的消息。如果左边算一种，右边又算一种，就是比较不好的设计了，会导致布局内容重复、冗余，修改操作都要做两遍。最好的方案是让他们视被为同一种类型，然后在 item 框层次进行左右边判断和框架相关数据绑定。</p>
<p>我提供的这个二级  <code>ItemViewBinder</code>  示例便是这样的两层结构。它能够让你每次新增加一个类型，只要实现内容即可，框不应该重复实现。</p>
<p>如果再不明白，或许你可以看看我的这个示例中 微博 Item 框的布局：</p>
<p><img data-src="http://gank.io/images/c69f1e58ddbf44d4ba9352c826780dc9" alt="img"></p>
<p>从我这个  <code>frame</code>  布局可以看出来，它内部有一个  <code>FrameLayout</code>  作为  <code>container</code>  将用于容纳不同的微博内容，而这一层框架则是共同的。</p>
<p>这个例子算高级中的高级，但实际上也是很简单，展示了 <strong>MultiType</strong> 优秀的可拓展能力。完整运行结果展示如下：</p>
<p><img data-src="http://gank.io/images/7232768a27cf4350ba6a7afb9a35de11" alt="img"> <img data-src="http://gank.io/images/0cb1a0c41af84a4497c2fcb097c969f8" alt="img"></p>
<blockquote>
<p>注：以上我们并没有提到服务端 JSON 数据转为我们定义的 Weibo 对象过程，实际上对于完整链路，这个过程是需要做数据转换，我们需要在  <code>WeiboContent</code>  层加一个  <code>type</code>  或  <code>describe</code>  字段用于描述微博内容类型，然后再将微博内容的 JSON 文本转为具体微博内容对象交给 Weibo. 这个内容建议直接阅读这个 sample 的  <code>WeiboContentDeserializer</code>  源码，我利用了一种很简单又巧妙的方式，在 JSON 解析底层便进行抽象数据具体化，使得客户端和服务端都能够轻松适应这种微博和微博内容嵌套关系。</p>
</blockquote>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvYWJvdXQtcGFnZQ==">drakeet/about-page</span></p>
<p>一个 Material Design 的关于页面，核心基于 MultiType，包含了多种 items，美观，容易使用。</p>
<p><img data-src="http://gank.io/images/37d1dfc1645b483f8c02be2fead59230" alt="img"></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvTXVsdGlUeXBlL3RyZWUvbWFzdGVyL3NhbXBsZS9zcmMvbWFpbi9qYXZhL21lL2RyYWtlZXQvbXVsdGl0eXBlL3NhbXBsZS9ncmlk">线性和网格布局混排</span></p>
<p>使用  <code>MultiType</code>  和  <code>GridLayoutManager</code>  实现网格和线性混合布局，实现一个选集页面。</p>
<p><img data-src="http://gank.io/images/9cd6a2403d744bd69caf40678b676620" alt="img"></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvVGltZU1hY2hpbmU=">drakeet/TimeMachine</span></p>
<p>TimeMachine 使用了 <strong>MultiType</strong> 来创建一个复杂的聊天页面，页面和需求虽然复杂，但使用 <strong>MultiType</strong> 显得轻松简单。</p>
<p><img data-src="http://gank.io/images/a5c0712162cb4e17952d16e2943374e1" alt="img"><img data-src="http://gank.io/images/6f5bf7ec6ff34bf38a14b8e33621b9d6" alt="img"></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYWtlZXQvTXVsdGlUeXBlL3RyZWUvbWFzdGVyL3NhbXBsZS9zcmMvbWFpbi9qYXZhL21lL2RyYWtlZXQvbXVsdGl0eXBlL3NhbXBsZS9iaWxpYmlsaQ==">类似 Bilibili iOS 端首页</span></p>
<p>使用  <code>MultiType</code>  实现类似 Bilibili iOS 端首页复杂的多类型列表视图，包括嵌套横向  <code>RecyclerView</code> .</p>
<p><img data-src="http://gank.io/images/9e7d77b8f85043c09f92bc3fdf342e15" alt="img"></p>
</li>
</ul>
<h1 id="q-a"><a class="markdownIt-Anchor" href="#q-a">#</a> Q &amp; A</h1>
<ul>
<li>
<p><strong>Q: 觉得 MultiType 不够精简，应该怎么做？</strong></p>
<p>A: 在前面 “设计思想” 中我们谈到：*MultiType 或许不是使用起来最简单的，但很可能是使用起来最灵活的。* 其中的缘由是它高度可定制、可拓展，而不是把一些路封死。作为一个基础类库，简单和灵活需要一个均衡点，过度精简便要以失去灵活性为代价。如果觉得 <strong>MultiType</strong> 不够精简，想将它修改得更加容易使用，我推荐的方式是去继承  <code>MultiTypeAdapter</code>  或  <code>ItemViewBinder</code> ，甚至你可以重新实现一个  <code>TypePool</code>  再设置给  <code>MultiTypeAdapter</code> . 我们不应该直接到底层去修改、破坏它们。总之，利用开放接口或继承的做法不管对于 <strong>MultiType</strong> 还是其它开源库，都应该是定制的首选。</p>
</li>
<li>
<p><strong>Q: 在  <code>ItemViewBinder</code>  中如何拿到  <code>Context</code>  对象？</strong></p>
<p>A: 有人问我说，他在  <code>ItemViewBinder</code>  里使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J1bXB0ZWNoL2dsaWRl">Glide</span> 来加载图片需要获取到 Activity  <code>Context</code>  对象，要怎么才能拿到  <code>Context</code>  对象？这是一个特别简单的问题，但我想既然有人问，应该比较典型，我就详细解答下：首先，在 Android 开发中，任何  <code>View</code>  对象都能通过  <code>view.getContext()</code>  拿到  <code>Context</code>  对象，这些对象本质上都是  <code>Activity</code>  对象的引用。而在我们的  <code>ItemViewBinder</code>  中，可以通过  <code>holder.itemView.getContext()</code>  获取到  <code>Context</code>  对象，也可以通过 viewHolder 的任意  <code>View</code>  对象  <code>getContext()</code>  方法拿到  <code>Context</code>  对象.  <code>Context</code>  中文释义是 <em>“上下文对象”</em>，一般情况下，都是由  <code>Activity</code>  传递给  <code>View</code> s， <code>View</code> s 内部再进行传递。比如我们使用  <code>RecyclerView</code> ， <code>Activity</code>  会将它的  <code>Context</code>  传递给  <code>RecyclerView</code> ， <code>RecyclerView</code>  再传递给  <code>Adapter</code> ， <code>Adapter</code>  再传递给  <code>ViewHolder</code>  的  <code>itemView</code> ， <code>itemView</code>  再传递给它的各个子  <code>View</code> s，传递来传递去，其实都是同一个对象的引用。</p>
<p>总而言之，拿到  <code>Context</code>  对象非常简单，只要你能拿到一个  <code>View</code>  对象，调用  <code>view.getContext()</code>  即可。另外，也可以参考 <em><span class="exturl" data-url="aHR0cHM6Ly9nYW5rLmlvL3Bvc3QvNWU3YTA1ZTVhMzdlMDFhNGZhOTllNTJmIyVFNCVCOCU4RS12aWV3YmluZGVyLSVFOSU4MCU5QSVFOCVBRSVBRg==">与 binder 通讯</span></em> 章节，我们可以很方便地给  <code>binder</code>  传递任何对象进去，包括  <code>Context</code>  对象。</p>
</li>
<li>
<p><strong>Q：如何在  <code>ItemViewBinder</code>  中获取到 item position？</strong></p>
<p>A: 从 v2.3.5 版本开始，只需要在你的  <code>ItemViewBinder</code>  子类里调用  <code>getPosition(holder)</code>  方法即可。另外， <code>ItemViewBinder</code>  还提供了  <code>getAdapter()</code>  或许也是很多人想要的，比如调用 adapter 进行 notify 刷新视图等。</p>
</li>
</ul>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2020-06-12 04:20:32" itemprop="dateModified" datetime="2020-06-12T04:20:32+08:00">2020-06-12</time>
  </span>
  <span id="2020/06/12/multitype/" class="item leancloud_visitors" data-flag-title="Android 复杂的列表视图新写法 MultiType" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Apocalypse <i class="ic i-at"><em>@</em></i>Apocalypse's Blog
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://jiyugithub.github.io/2020/06/12/multitype/" title="Android 复杂的列表视图新写法 MultiType">https://jiyugithub.github.io/2020/06/12/multitype/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="nav">
    <div class="item left">
      

  <a href="/2020/06/11/vue/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg" title="从0到1教你搭建前端团队的组件系统（高级进阶必备）">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>从0到1教你搭建前端团队的组件系统（高级进阶必备）</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2020/06/12/view1/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg" title="一文彻底了解Android自定义控件1">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>一文彻底了解Android自定义控件1</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments" data-id="2020/06/12/multitype/"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#android-复杂的列视图新写法-multitype"><span class="toc-number">1.</span> <span class="toc-text"> Android 复杂的列视图新写法 MultiType</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#multitype-的特性"><span class="toc-number">3.</span> <span class="toc-text"> MultiType 的特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总览"><span class="toc-number">4.</span> <span class="toc-text"> 总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#multitype-基础用法"><span class="toc-number">5.</span> <span class="toc-text"> MultiType 基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入"><span class="toc-number">5.0.1.</span> <span class="toc-text"> 引入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-number">5.1.</span> <span class="toc-text"> 使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计思想"><span class="toc-number">6.</span> <span class="toc-text"> 设计思想</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高级用法"><span class="toc-number">7.</span> <span class="toc-text"> 高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-multitypetemplates-插件自动生成代码"><span class="toc-number">7.1.</span> <span class="toc-text"> 使用 MultiTypeTemplates 插件自动生成代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个类型对应多个-itemviewbinder"><span class="toc-number">7.2.</span> <span class="toc-text"> 一个类型对应多个  ItemViewBinder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-全局类型池"><span class="toc-number">7.3.</span> <span class="toc-text"> 使用 全局类型池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与-itemviewbinder-通讯"><span class="toc-number">7.4.</span> <span class="toc-text"> 与  ItemViewBinder  通讯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用断言比传统-adapter-更加易于调试"><span class="toc-number">7.5.</span> <span class="toc-text"> 使用断言，比传统 Adapter 更加易于调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支持-google-autovalue"><span class="toc-number">7.6.</span> <span class="toc-text"> 支持 Google AutoValue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flattypeadapter已废弃"><span class="toc-number">7.7.</span> <span class="toc-text"> FlatTypeAdapter (已废弃)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multitype-与下拉刷新-加载更多-headerview-footerview-diff"><span class="toc-number">7.8.</span> <span class="toc-text"> MultiType 与下拉刷新、加载更多、HeaderView、FooterView、Diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现-recyclerview-嵌套横向-recyclerview"><span class="toc-number">7.9.</span> <span class="toc-text"> 实现 RecyclerView 嵌套横向 RecyclerView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现线性布局和网格布局混排列表"><span class="toc-number">7.10.</span> <span class="toc-text"> 实现线性布局和网格布局混排列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据扁平化处理"><span class="toc-number">7.11.</span> <span class="toc-text"> 数据扁平化处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更多示例"><span class="toc-number">8.</span> <span class="toc-text"> 更多示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#q-a"><span class="toc-number">9.</span> <span class="toc-text"> Q &amp; A</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Apocalypse"
      data-src="/images/avatar.png">
  <p class="name" itemprop="name">Apocalypse</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">37</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">2</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppeXVnaXRodWI=" title="https:&#x2F;&#x2F;github.com&#x2F;jiyugithub"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
    <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2020/06/11/vue/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2020/06/12/view1/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/10/07/Jetapp/" title="我们要不要上线「个人app」 ？">我们要不要上线「个人app」 ？</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/12/blog/" title="如何快速搭建好看的个人博客">如何快速搭建好看的个人博客</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/16/100js/" title="100 行 js 代码下载抖音无水印视频">100 行 js 代码下载抖音无水印视频</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/12/undefined/" title="Android目前最稳定和高效的UI适配方案">Android目前最稳定和高效的UI适配方案</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/03/14/TopKotlin/" title="快速入门 Kotlin">快速入门 Kotlin</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/14/KotlinJava/" title="Kotlin与Java的异同">Kotlin与Java的异同</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/14/Kotlinyf/" title="Kotlin实战 | 语法糖">Kotlin实战 | 语法糖</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/12/hashmap/" title="HashMap原理技术知识整理">HashMap原理技术知识整理</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/12/vue_js/" title="10+个很酷的Vue.js组件，模板和demo示例">10+个很酷的Vue.js组件，模板和demo示例</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/06/12/agent/" title="动态代理设计模式">动态代理设计模式</a></span>
  </li>

  </ul>
</div>
<div id="rcomment">
  <h2>Recent Comments</h2>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2020</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Apocalypse @ 启示录</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'https://jiyugithub.github.io/2020/06/12/multitype/',
    favicon: {
      show: "（●´3｀●）",
      hide: "(´Д｀)"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return uri === LOCAL.path;
      }
    ]
  };
</script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/velocity-animate@1.5.2/velocity.min.js,npm/velocity-animate@1.5.2/velocity.ui.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js,npm/leancloud-storage@3/dist/av-min.js"></script>

<script src="/js/app.js?v=0.1.9"></script>




</body>
</html>
