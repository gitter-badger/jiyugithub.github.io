<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android 10(Q)/11(R) 分区存储适配"><meta name="keywords" content=""><meta name="author" content="Apocalypse"><meta name="copyright" content="Apocalypse"><title>Android 10(Q)/11(R) 分区存储适配 | Apocalypse's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-存储分区情况"><span class="toc-number">1.</span> <span class="toc-text">Android 存储分区情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-10-Q-："><span class="toc-number">2.</span> <span class="toc-text">Android 10(Q) ：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问不同分区的方式："><span class="toc-number">2.1.</span> <span class="toc-text">访问不同分区的方式：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-11-R"><span class="toc-number">3.</span> <span class="toc-text">Android 11 (R):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-新增执行批量操作"><span class="toc-number">3.1.</span> <span class="toc-text">1. 新增执行批量操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-使用直接文件路径和原生库访问文件"><span class="toc-number">3.2.</span> <span class="toc-text">2. 使用直接文件路径和原生库访问文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#性能："><span class="toc-number">3.2.0.1.</span> <span class="toc-text">性能：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-新增权限"><span class="toc-number">3.3.</span> <span class="toc-text">3. 新增权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sample"><span class="toc-number">4.</span> <span class="toc-text">Sample</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-媒体集"><span class="toc-number">4.1.</span> <span class="toc-text">1. 媒体集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）-查询媒体集（需要-READ-EXTERNAL-STORAGE-权限）"><span class="toc-number">4.1.1.</span> <span class="toc-text">1） 查询媒体集（需要 READ_EXTERNAL_STORAGE 权限）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）插入媒体集（无需权限）"><span class="toc-number">4.1.2.</span> <span class="toc-text">2）插入媒体集（无需权限）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3）更新自己创建的媒体集（无需权限）"><span class="toc-number">4.1.3.</span> <span class="toc-text">3）更新自己创建的媒体集（无需权限）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4）更新-删除其它媒体创建的媒体集"><span class="toc-number">4.1.4.</span> <span class="toc-text">4）更新&#x2F;删除其它媒体创建的媒体集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-文件集-（通过-SAF）"><span class="toc-number">4.2.</span> <span class="toc-text">2. 文件集 （通过 SAF）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）创建文档"><span class="toc-number">4.2.1.</span> <span class="toc-text">1）创建文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）打开文档"><span class="toc-number">4.2.2.</span> <span class="toc-text">2）打开文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3）授予对目录内容的访问权限"><span class="toc-number">4.2.3.</span> <span class="toc-text">3）授予对目录内容的访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4）永久获取目录访问权限"><span class="toc-number">4.2.4.</span> <span class="toc-text">4）永久获取目录访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5）SAF-API-响应"><span class="toc-number">4.2.5.</span> <span class="toc-text">5）SAF API 响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-其它操作"><span class="toc-number">4.2.6.</span> <span class="toc-text">6) 其它操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-批量操作媒体集"><span class="toc-number">4.2.7.</span> <span class="toc-text">3. 批量操作媒体集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配和兼容"><span class="toc-number">4.3.</span> <span class="toc-text">适配和兼容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">4.4.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#关于适配的难度："><span class="toc-number">5.0.0.1.</span> <span class="toc-text">关于适配的难度：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Apocalypse</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Apocalypse's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android 10(Q)/11(R) 分区存储适配</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-31</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>大部分应用都会请求 ( READ_EXTERNAL_STORAGE ) ( WRITE_EXTERNAL_STORAGE ) 存储权限，来做一些诸如在 SD 卡中存储文件或者读取多媒体文件等常规操作。这些应用可能会在磁盘中存储大量文件，即使应用被卸载了还会依然存在。另外，这些应用还可能会读取其他应用的一些敏感文件数据。</p>
<p>为此，Google 终于下定决心在 Android 10 中引入了分区存储，对权限进行场景的细分，按需索取，并在 Android 11 中进行了进一步的调整。</p>
<a id="more"></a>

<h2 id="Android-存储分区情况"><a href="#Android-存储分区情况" class="headerlink" title="Android 存储分区情况"></a>Android 存储分区情况</h2><p>Android 中存储可以分为两大类：私有存储和共享存储</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：<ul>
<li>内部存储私有目录<code>(/data/data/packageName)</code> ；</li>
<li>外部存储私有目录 <code>(/sdcard/Android/data/packageName)</code>，</li>
</ul>
</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录。</li>
</ul>
<h2 id="Android-10-Q-："><a href="#Android-10-Q-：" class="headerlink" title="Android 10(Q) ："></a>Android 10(Q) ：</h2><p>Android 10 中主要对<code>共享目录</code>进行了权限详细的划分，不再能通过绝对路径访问。</p>
<p>受影响的接口：</p>
<p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/965a48c9cb474e4cac1ced76a484d884~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="访问不同分区的方式："><a href="#访问不同分区的方式：" class="headerlink" title="访问不同分区的方式："></a>访问不同分区的方式：</h3><ol>
<li>私有目录：和以前的版本一致，可通过 <code>File()</code> API 访问，无需申请权限。</li>
<li>共享目录：需要通过<code>MediaStore</code>和<code>Storage Access Framework</code> API 访问，视具体情况申请权限，下面详细介绍。</li>
</ol>
<p>其中，对共享目录的权限进行了细分：</p>
<ol>
<li>无需申请权限的操作：<br> 通过 <code>MediaStore API</code>对媒体集、文件集进行媒体/文件的添加、对 <strong>自身APP</strong> 创建的 媒体/文件 进行查询、修改、删除的操作。</li>
<li>需要申请<code>READ_EXTERNAL_STORAGE</code>权限：<br> 通过 <code>MediaStore API</code>对所有的媒体集进行查询、修改、删除的操作。</li>
<li>调用 <code>Storage Access Framework API</code> ：<br> 会启动系统的文件选择器向用户申请操作指定的文件</li>
</ol>
<p>新的访问方式：</p>
<p><img src="http://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f33f704994494fe3ae731f66e948bef9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h2 id="Android-11-R"><a href="#Android-11-R" class="headerlink" title="Android 11 (R):"></a>Android 11 (R):</h2><p>Android 11 (R) 在 Android 10 (Q) 中分区存储的基础上进行了调整</p>
<h3 id="1-新增执行批量操作"><a href="#1-新增执行批量操作" class="headerlink" title="1. 新增执行批量操作"></a>1. 新增执行批量操作</h3><blockquote>
<p>为实现各种设备之间的一致性并增加用户便利性，Android 11 向 MediaStore API 中添加了多种方法。对于希望简化特定媒体文件更改流程（例如在原位置编辑照片）的应用而言，这些方法尤为有用。</p>
</blockquote>
<p>MediaStore API 新增的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>createWriteRequest (ContentResolver, Collection)</td>
<td>用户向应用授予对指定媒体文件组的写入访问权限的请求。</td>
</tr>
<tr>
<td>createFavoriteRequest (ContentResolver, Collection, boolean)</td>
<td>用户将设备上指定的媒体文件标记为 “收藏” 的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为 “收藏”。</td>
</tr>
<tr>
<td>createTrashRequest (ContentResolver, Collection, boolean)</td>
<td>用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容在特定时间段（默认为 7 天）后会永久删除。</td>
</tr>
<tr>
<td>createDeleteRequest (ContentResolver, Collection)</td>
<td>用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。</td>
</tr>
</tbody></table>
<p>系统在调用以上任何一个方法后，会构建一个 PendingIntent 对象。应用调用此 intent 后，用户会看到一个对话框，请求用户同意应用更新或删除指定的媒体文件。</p>
<h3 id="2-使用直接文件路径和原生库访问文件"><a href="#2-使用直接文件路径和原生库访问文件" class="headerlink" title="2. 使用直接文件路径和原生库访问文件"></a>2. 使用直接文件路径和原生库访问文件</h3><blockquote>
<p>为了帮助您的应用更顺畅地使用第三方媒体库，Android 11 允许您使用除 MediaStore API 之外的 API 访问共享存储空间中的媒体文件。不过，您也可以转而选择使用以下任一 API 直接访问媒体文件：</p>
<p>File API。<br> 原生库，例如 fopen()。</p>
</blockquote>
<p>简单来说就是，可以通过 <code>File()</code> 等API 访问有权限访问的媒体集了。</p>
<h5 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h5><p>通过 <code>File ()</code> 等直接通过路径访问的 API 实际上也会映射为<code>MediaStore</code> API 。<br> 按文件路径顺序读取的时候性能相当；随机读取和写入的时候则会更慢，所以还是推荐直接使用 <code>MediaStore</code>API。 </p>
<h3 id="3-新增权限"><a href="#3-新增权限" class="headerlink" title="3. 新增权限"></a>3. 新增权限</h3><p><code>MANAGE_EXTERNAL_STORAGE</code> : 类似以前的 <code>READ_EXTERNAL_STORAGE</code> + <code>WRITE_EXTERNAL_STORAGE</code>，除了应用专有目录都可以访问。</p>
<p> 应用可通过执行以下操作向用户请求名为所有文件访问权限的特殊应用访问权限：</p>
<ol>
<li>在清单中声明 <code>MANAGE_EXTERNAL_STORAGE</code> 权限。  </li>
<li>使用 <code>ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION</code> intent 操作将用户引导至一个系统设置页面，在该页面上，用户可以为您的应用启用以下选项：授予所有文件的管理权限。</li>
</ol>
<ul>
<li>在 Google Play 上架的话，需要提交使用此权限的说明，只有指定的几种类型的 APP 才能使用。</li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><ul>
<li>使用 <code>MediaStore</code> 增删改查媒体集</li>
<li>使用 <code>Storage Access Framework</code> 访问文件集</li>
</ul>
<h3 id="1-媒体集"><a href="#1-媒体集" class="headerlink" title="1. 媒体集"></a>1. 媒体集</h3><h4 id="1）-查询媒体集（需要-READ-EXTERNAL-STORAGE-权限）"><a href="#1）-查询媒体集（需要-READ-EXTERNAL-STORAGE-权限）" class="headerlink" title="1） 查询媒体集（需要 READ_EXTERNAL_STORAGE 权限）"></a>1） 查询媒体集（需要 READ_EXTERNAL_STORAGE 权限）</h4><p>实际上 <code>MediaStore</code> 是以前就有的 API ，不同的是过去主要通过 <code>MediaStore.Video.Media._DATA</code> 这个 colum 请求原始数据，可以得到绝对<code>Uri</code> ，现在需要请求<code>MediaStore.Video.Media._ID</code>来得到相对<code>Uri</code>再进行处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Need the READ_EXTERNAL_STORAGE permission if accessing video files that your</span></span><br><span class="line"><span class="comment">// app didn't create.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Container for information about each video.</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span></span>(</span><br><span class="line">    <span class="keyword">val</span> uri: Uri,</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> duration: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> videoList = mutableListOf&lt;Video&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> projection = arrayOf(</span><br><span class="line">    MediaStore.Video.Media._ID,</span><br><span class="line">    MediaStore.Video.Media.DISPLAY_NAME,</span><br><span class="line">    MediaStore.Video.Media.DURATION,</span><br><span class="line">    MediaStore.Video.Media.SIZE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show only videos that are at least 5 minutes in duration.</span></span><br><span class="line"><span class="keyword">val</span> selection = <span class="string">"<span class="subst">$&#123;MediaStore.Video.Media.DURATION&#125;</span> &gt;= ?"</span></span><br><span class="line"><span class="keyword">val</span> selectionArgs = arrayOf(</span><br><span class="line">    TimeUnit.MILLISECONDS.convert(<span class="number">5</span>, TimeUnit.MINUTES).toString()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display videos in alphabetical order based on their display name.</span></span><br><span class="line"><span class="keyword">val</span> sortOrder = <span class="string">"<span class="subst">$&#123;MediaStore.Video.Media.DISPLAY_NAME&#125;</span> ASC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> query = ContentResolver.query(</span><br><span class="line">    MediaStore.Video.Media.EXTERNAL_CONTENT_URI,</span><br><span class="line">    projection,</span><br><span class="line">    selection,</span><br><span class="line">    selectionArgs,</span><br><span class="line">    sortOrder</span><br><span class="line">)</span><br><span class="line">query?.use &#123; cursor -&gt;</span><br><span class="line">    <span class="comment">// Cache column indices.</span></span><br><span class="line">    <span class="keyword">val</span> idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)</span><br><span class="line">    <span class="keyword">val</span> nameColumn =</span><br><span class="line">            cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)</span><br><span class="line">    <span class="keyword">val</span> durationColumn =</span><br><span class="line">            cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)</span><br><span class="line">    <span class="keyword">val</span> sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">        <span class="comment">// Get values of columns for a given video.</span></span><br><span class="line">        <span class="keyword">val</span> id = cursor.getLong(idColumn)</span><br><span class="line">        <span class="keyword">val</span> name = cursor.getString(nameColumn)</span><br><span class="line">        <span class="keyword">val</span> duration = cursor.getInt(durationColumn)</span><br><span class="line">        <span class="keyword">val</span> size = cursor.getInt(sizeColumn)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> contentUri: Uri = ContentUris.withAppendedId(</span><br><span class="line">            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,</span><br><span class="line">            id</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stores column values and the contentUri in a local object</span></span><br><span class="line">        <span class="comment">// that represents the media file.</span></span><br><span class="line">        videoList += Video(contentUri, name, duration, size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）插入媒体集（无需权限）"><a href="#2）插入媒体集（无需权限）" class="headerlink" title="2）插入媒体集（无需权限）"></a>2）插入媒体集（无需权限）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a media item that other apps shouldn't see until the item is</span></span><br><span class="line"><span class="comment">// fully written to the media store.</span></span><br><span class="line"><span class="keyword">val</span> resolver = applicationContext.contentResolver</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all audio files on the primary external storage device.</span></span><br><span class="line"><span class="comment">// On API &lt;= 28, use VOLUME_EXTERNAL instead.</span></span><br><span class="line"><span class="keyword">val</span> audioCollection = MediaStore.Audio.Media</span><br><span class="line">        .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> songDetails = ContentValues().apply &#123;</span><br><span class="line">    put(MediaStore.Audio.Media.DISPLAY_NAME, <span class="string">"My Workout Playlist.mp3"</span>)</span><br><span class="line">    put(MediaStore.Audio.Media.IS_PENDING, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> songContentUri = resolver.insert(audioCollection, songDetails)</span><br><span class="line"></span><br><span class="line">resolver.openFileDescriptor(songContentUri, <span class="string">"w"</span>, <span class="literal">null</span>).use &#123; pfd -&gt;</span><br><span class="line">    <span class="comment">// Write data into the pending audio file.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that we're finished, release the "pending" status, and allow other apps</span></span><br><span class="line"><span class="comment">// to play the audio track.</span></span><br><span class="line">songDetails.clear()</span><br><span class="line">songDetails.put(MediaStore.Audio.Media.IS_PENDING, <span class="number">0</span>)</span><br><span class="line">resolver.update(songContentUri, songDetails, <span class="literal">null</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3）更新自己创建的媒体集（无需权限）"><a href="#3）更新自己创建的媒体集（无需权限）" class="headerlink" title="3）更新自己创建的媒体集（无需权限）"></a>3）更新自己创建的媒体集（无需权限）</h4><p>删除类似</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Updates an existing media item.</span></span><br><span class="line"><span class="keyword">val</span> mediaId = <span class="comment">// MediaStore.Audio.Media._ID of item to update.</span></span><br><span class="line"><span class="keyword">val</span> resolver = applicationContext.contentResolver</span><br><span class="line"></span><br><span class="line"><span class="comment">// When performing a single item update, prefer using the ID</span></span><br><span class="line"><span class="keyword">val</span> selection = <span class="string">"<span class="subst">$&#123;MediaStore.Audio.Media._ID&#125;</span> = ?"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// By using selection + args we protect against improper escaping of // values.</span></span><br><span class="line"><span class="keyword">val</span> selectionArgs = arrayOf(mediaId.toString())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update an existing song.</span></span><br><span class="line"><span class="keyword">val</span> updatedSongDetails = ContentValues().apply &#123;</span><br><span class="line">    put(MediaStore.Audio.Media.DISPLAY_NAME, <span class="string">"My Favorite Song.mp3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the individual song's URI to represent the collection that's</span></span><br><span class="line"><span class="comment">// updated.</span></span><br><span class="line"><span class="keyword">val</span> numSongsUpdated = resolver.update(</span><br><span class="line">        myFavoriteSongUri,</span><br><span class="line">        updatedSongDetails,</span><br><span class="line">        selection,</span><br><span class="line">        selectionArgs)</span><br></pre></td></tr></table></figure>

<h4 id="4）更新-删除其它媒体创建的媒体集"><a href="#4）更新-删除其它媒体创建的媒体集" class="headerlink" title="4）更新/删除其它媒体创建的媒体集"></a>4）更新/删除其它媒体创建的媒体集</h4><p>若已经开启分区存储则会抛出 <code>RecoverableSecurityException</code>，捕获并通过<code>SAF</code>请求权限</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply a grayscale filter to the image at the given content URI.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    contentResolver.openFileDescriptor(image-content-uri, <span class="string">"w"</span>)?.use &#123;</span><br><span class="line">        setGrayscaleFilter(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (securityException: SecurityException) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        <span class="keyword">val</span> recoverableSecurityException = securityException <span class="keyword">as</span>?</span><br><span class="line">            RecoverableSecurityException ?:</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(securityException.message, securityException)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> intentSender =</span><br><span class="line">            recoverableSecurityException.userAction.actionIntent.intentSender</span><br><span class="line">        intentSender?.let &#123;</span><br><span class="line">            startIntentSenderForResult(intentSender, image-request-code,</span><br><span class="line">                    <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(securityException.message, securityException)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-文件集-（通过-SAF）"><a href="#2-文件集-（通过-SAF）" class="headerlink" title="2. 文件集 （通过 SAF）"></a>2. 文件集 （通过 SAF）</h3><h4 id="1）创建文档"><a href="#1）创建文档" class="headerlink" title="1）创建文档"></a>1）创建文档</h4><p>注：创建操作若重名的话不会覆盖原文档，会添加 (1) 最为后缀，如 document.pdf -&gt; document(1).pdf</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request code for creating a PDF document.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> CREATE_FILE = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFile</span><span class="params">(pickerInitialUri: <span class="type">Uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply &#123;</span><br><span class="line">        addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">        type = <span class="string">"application/pdf"</span></span><br><span class="line">        putExtra(Intent.EXTRA_TITLE, <span class="string">"invoice.pdf"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optionally, specify a URI for the directory that should be opened in</span></span><br><span class="line">        <span class="comment">// the system file picker before your app creates the document.</span></span><br><span class="line">        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)</span><br><span class="line">    &#125;</span><br><span class="line">    startActivityForResult(intent, CREATE_FILE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2）打开文档"><a href="#2）打开文档" class="headerlink" title="2）打开文档"></a>2）打开文档</h4><p>建议使用 type 设置 MIME 类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request code for selecting a PDF document.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> PICK_PDF_FILE = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openFile</span><span class="params">(pickerInitialUri: <span class="type">uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply &#123;</span><br><span class="line">        addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">        type = <span class="string">"application/pdf"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optionally, specify a URI for the file that should appear in the</span></span><br><span class="line">        <span class="comment">// system file picker when it loads.</span></span><br><span class="line">        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startActivityForResult(intent, PICK_PDF_FILE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3）授予对目录内容的访问权限"><a href="#3）授予对目录内容的访问权限" class="headerlink" title="3）授予对目录内容的访问权限"></a>3）授予对目录内容的访问权限</h4><p>用户选择目录后，可访问该目录下的所有内容</p>
<p><strong><em>Android 11 中无法访问 Downloads\</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openDirectory</span><span class="params">(pickerInitialUri: <span class="type">Uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Choose a directory using the system's file picker.</span></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply &#123;</span><br><span class="line">        <span class="comment">// Provide read access to files and sub-directories in the user-selected</span></span><br><span class="line">        <span class="comment">// directory.</span></span><br><span class="line">        flags = Intent.FLAG_GRANT_READ_URI_PERMISSION</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optionally, specify a URI for the directory that should be opened in</span></span><br><span class="line">        <span class="comment">// the system file picker when it loads.</span></span><br><span class="line">        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startActivityForResult(intent, your-request-code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4）永久获取目录访问权限"><a href="#4）永久获取目录访问权限" class="headerlink" title="4）永久获取目录访问权限"></a>4）永久获取目录访问权限</h4><p>上面提到的授权是临时性的，重启后则会失效。可以通过下面的方法获取相应目录永久性的权限</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> contentResolver = applicationContext.contentResolver</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> takeFlags: <span class="built_in">Int</span> = Intent.FLAG_GRANT_READ_URI_PERMISSION or</span><br><span class="line">        Intent.FLAG_GRANT_WRITE_URI_PERMISSION</span><br><span class="line"><span class="comment">// Check for the freshest data.</span></span><br><span class="line">contentResolver.takePersistableUriPermission(uri, takeFlags)</span><br></pre></td></tr></table></figure>

<h4 id="5）SAF-API-响应"><a href="#5）SAF-API-响应" class="headerlink" title="5）SAF API 响应"></a>5）SAF API 响应</h4><p><code>SAF API</code> 调用后都是通过 <code>onActivityResult</code>来相应动作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, resultData: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == your-request-code</span><br><span class="line">            &amp;&amp; resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        <span class="comment">// The result data contains a URI for the document or directory that</span></span><br><span class="line">        <span class="comment">// the user selected.</span></span><br><span class="line">        resultData?.<span class="keyword">data</span>?.also &#123; uri -&gt;</span><br><span class="line">            <span class="comment">// Perform operations on the document using its URI.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-其它操作"><a href="#6-其它操作" class="headerlink" title="6) 其它操作"></a>6) 其它操作</h4><p>除了上面的操作之外，对文档其它的复制、移动等操作都是通过设置不同的 FLAG 来实现，见 <a href="https://developer.android.com/reference/android/provider/DocumentsContract.Document#COLUMN_FLAGS" target="_blank" rel="noopener"><code>Document.COLUMN_FLAGS</code></a></p>
<h4 id="3-批量操作媒体集"><a href="#3-批量操作媒体集" class="headerlink" title="3. 批量操作媒体集"></a>3. 批量操作媒体集</h4><p>构建一个媒体集的写入操作 <code>createWriteRequest()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> urisToModify = <span class="comment">/* A collection of content URIs to modify. */</span></span><br><span class="line"><span class="keyword">val</span> editPendingIntent = MediaStore.createWriteRequest(contentResolver,</span><br><span class="line">        urisToModify)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Launch a system prompt requesting user permission for the operation.</span></span><br><span class="line">startIntentSenderForResult(editPendingIntent.intentSender, EDIT_REQUEST_CODE,</span><br><span class="line">    <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相应</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">        EDIT_REQUEST_CODE -&gt;</span><br><span class="line">            <span class="keyword">if</span> (resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">                <span class="comment">/* Edit request granted; proceed. */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Edit request not granted; explain to the user. */</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createFavoriteRequest()</code> <code>createTrashRequest()</code> <code>createDeleteRequest()</code> 同理</p>
<p><img src="http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01e345829bcf4127b0dad00359bb4a85~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h3 id="适配和兼容"><a href="#适配和兼容" class="headerlink" title="适配和兼容"></a>适配和兼容</h3><p>在 targetSDK = 29 APP 中，在 <code>AndroidManifes</code> 设置 <code>requestLegacyExternalStorage=&quot;true&quot;</code> 启用兼容模式，以传统分区模式运行。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- This attribute is "false" by default on apps targeting</span></span><br><span class="line"><span class="comment">        Android 10 or higher. --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:requestLegacyExternalStorage</span>=<span class="string">"true"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">     ...</span><br><span class="line">   <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果某个应用在安装时启用了传统外部存储，则该应用会保持此模式，直到卸载为止。无论设备后续是否升级为搭载 Android 10 或更高版本，或者应用后续是否更新为以 Android 10 或更高版本为目标平台，此兼容性行为均适用。</p>
</blockquote>
<p>意思就是在新系统新安装的应用才会启用，覆盖安装会保持传统分区模式，例如：</p>
<ul>
<li>系统通过 OTA 升级到 Android 10/11</li>
<li>应用通过更新升级到 targetSdkVersion &gt;= 29 </li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>Q：之前讨论过一些问题，APP 无需权限可以访问自己创建的媒体，那么系统如何进行判断？</p>
<p>A：创建媒体时系统会给媒体打上 packageName tag，应用被卸载则会清除 tag ，所以不会存在使用同样 packageName 进行欺骗的情况。</p>
<p>Q：我可以在媒体集文件夹下创建文档，就可以避开权限的问题了？</p>
<p>A：官方文档上写了只能创建相应类型的媒体/文件，具体如何限制的，没有说明。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 Android 10提出分区存储之后到现在已经一年多了，所以Google 从强制推行的态度到现在  targetSDK &gt;=30 才强制启用分区存储来看，Google 还是渐渐地选择给开发者留更多的时间。缺点当然是不强制启用的话，国内 APP 适配进度估计得延后了。不过好消息是在查资料的时候，看到了国内大厂的相关适配文章，至少说明大厂在跟进了。</p>
<p>去年（19年）的文档描述是无论 targetSDK 多少，明年（20年）高版本强制启用。</p>
<p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/081ad21e0ef942a3b1fdb5d541349fe1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>今年（20）文档描述是 targetSDK &gt;=30 才强制启用</p>
<p><img src="http://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e387ab5aa2d246139f4cf2c72df3e5ba~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h5 id="关于适配的难度："><a href="#关于适配的难度：" class="headerlink" title="关于适配的难度："></a>关于适配的难度：</h5><p>对绝对路径相关接口依赖比较深的 APP 适配还是改动挺多的；其次权限的划分很细，什么时候需要什么权限以及调用哪个接口，理解起来需要一定时间；<code>MediaStore API</code>  <code>SAF API</code> 这类接口以前就设计好了，我也觉得也不算特别友好；最后测试也需要重新进行。</p>
<p>所以虽然明年才会强制执行分区存储，但还是建议尽早理解和 review 项目中需要适配的代码。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Apocalypse</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jiyugithub.github.io/2020/08/31/uinm/">https://jiyugithub.github.io/2020/08/31/uinm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/08/03/uinm/"><span>这15个Android开源库，只有经常逛Github的才知道！</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz',
  appKey:'FihoucantYlc5U1FQ9BzkO3l',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Apocalypse</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>