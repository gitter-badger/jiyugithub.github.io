{"meta":{"title":"Apocalypse's Blog","subtitle":"","description":"","author":"Apocalypse","url":"https://jiyugithub.github.io","root":"/"},"pages":[{"title":"About","date":"2020-06-06T01:04:26.000Z","updated":"2020-06-06T01:05:46.840Z","comments":true,"path":"about/index.html","permalink":"https://jiyugithub.github.io/about/index.html","excerpt":"","text":""},{"title":"友情链","date":"2020-07-05T00:56:18.000Z","updated":"2020-07-05T01:09:58.078Z","comments":true,"path":"links/index.html","permalink":"https://jiyugithub.github.io/links/index.html","excerpt":"","text":""},{"title":"Category","date":"2020-06-06T01:03:58.000Z","updated":"2020-06-06T01:06:22.297Z","comments":true,"path":"category/index.html","permalink":"https://jiyugithub.github.io/category/index.html","excerpt":"","text":""},{"title":"Tag","date":"2020-06-06T01:03:46.000Z","updated":"2020-06-06T01:07:05.773Z","comments":true,"path":"tag/index.html","permalink":"https://jiyugithub.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Android全新UI编程 - Jetpack Compose 超详细教程 第1弹","slug":"Android全新UI编程-Jetpack-Compose-超详细教程-第1弹","date":"2020-07-26T19:45:38.000Z","updated":"2020-07-26T19:56:14.452Z","comments":true,"path":"2020/07/27/Jetpack/","link":"","permalink":"https://jiyugithub.github.io/2020/07/27/Jetpack/","excerpt":"1. 简介Jetpack Compose是在2019Google i/O大会上发布的新的库。Compose库是用响应式编程的方式对View进行构建,可以用更少更直观的代码，更强大的功能，能提高开发速度（这一段是谷歌自己说的）。 说实话，View/Layout的模式对安卓工程师来说太过于熟悉，对于学习曲线陡峭的Jetpack Compose能不能很好的普及还是有所担心。","text":"1. 简介Jetpack Compose是在2019Google i/O大会上发布的新的库。Compose库是用响应式编程的方式对View进行构建,可以用更少更直观的代码，更强大的功能，能提高开发速度（这一段是谷歌自己说的）。 说实话，View/Layout的模式对安卓工程师来说太过于熟悉，对于学习曲线陡峭的Jetpack Compose能不能很好的普及还是有所担心。 因为Jetpack Compose的内容比较多，我会分成多个文章来进行介绍。 内容包括常用UI组件的使用，Flow和Compose的结合使用，以及如何构建MVVM应用。 还有，Compose的API还没有完全的确定下来，如果有API的修改，我也会对文章进行修订，所以敬请放心。 第1弹将会介绍如何创建Compose应用以及基本注解，Compose方法的使用。 好了，闲话不多说，开整! 2. 教程2.1 创建新的项目或导入库Jetpack Compose是从Android Studio 4.2开始支持的，所以需要通过4.2(现在是canary版本)创建新的项目或者添加导入库。这里按照创建新的项目来进行介绍。 根据上图所示，在创建新的项目时需要选择Empty Compose Activity。 此时模块中的build.gradle文件会新增下列的库的依赖。 dependencies { ... implementation &#39;androidx.ui:ui-layout:&quot;${compose_version}&quot;&#39; implementation &#39;androidx.ui:ui-material:&quot;${compose_version}&quot;&#39; implementation &#39;androidx.ui:ui-tooling:&quot;${compose_version}&quot;&#39; ... } 还有在模块的build.gradle文件中新增下列的设置。 android { ... buildFeatures { compose true } composeOptions { kotlinCompilerExtensionVersion &quot;${compose_version}&quot; kotlinCompilerVersion &quot;1.3.70-dev-withExperimentalGoogleExtensions-20200424&quot; } } 2.2 UI相关2.2.1 @Compose所有关于构建View的方法都必须添加@Compose的注解才可以。并且@Compose跟协程的Suspend的使用方法比较类似,被@Compose的注解的方法只能在同样被@Comopse注解的方法中才能被调用。 @Composable fun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;) } 2.2.2 @Preview加上@Preview注解的方法可以在不运行App的情况下就可以确认布局的情况。 @Preview的注解中比较常用的参数如下： name: String: 为该Preview命名，该名字会在布局预览中显示。 showBackground: Boolean: 是否显示背景，true为显示。 backgroundColor: Long: 设置背景的颜色。 showDecoration: Boolean: 是否显示Statusbar和Toolbar，true为显示。 group: String: 为该Preview设置group名字，可以在UI中以group为单位显示。 fontScale: Float: 可以在预览中对字体放大，范围是从0.01。 widthDp: Int: 在Compose中渲染的最大宽度，单位为dp。 heightDp: Int: 在Compose中渲染的最大高度，单位为dp。 上面的参数都是可选参数，还有像背景设置等的参数并不是对实际的App进行设置，只是对Preview中的背景进行设置，为了更容易看清布局。 @Preview(showBackground = true, name = &quot;Home UI&quot;, showDecoration = true) @Composable fun DefaultPreview() { MyApplicationTheme { Greeting(&quot;Android&quot;) } } 在IDE的右上角有Code，Split,Design三个选项。分别是只显示代码，同时显示代码和布局和只显示布局。 当更改跟UI相关的代码时，会显示一个横条通知，点击Build&amp;Refresh即可更新显示所更改代码的UI。 2.2.3 setContentsetContent的作用是和zaiLayout/View中的setContentView是一样的。 setContent的方法也是有@Compose注解的方法。所以，在setContent中写入关于UI的@Compopse方法，即可在Activity中显示。 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { JetpackComposeDemoTheme { Greeting(&quot;Android&quot;) } } } 2.2.4 *Theme在创建新的Compose项目时会自动创建一个项目名+Theme的@Compose方法。 我们可以通过更改颜色来完成对主题颜色的设置。 生成的Theme方法的代码如下。 private val DarkColorPalette = darkColorPalette( primary = purple200, primaryVariant = purple700, secondary = teal200 ) private val LightColorPalette = lightColorPalette( primary = purple500, primaryVariant = purple700, secondary = teal200 /* Other default colors to override background = Color.White, surface = Color.White, onPrimary = Color.White, onSecondary = Color.Black, onBackground = Color.Black, onSurface = Color.Black, */ ) @Composable fun JetpackComposeDemoTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable() () -&gt; Unit) { val colors = if (darkTheme) { DarkColorPalette } else { LightColorPalette } MaterialTheme( colors = colors, typography = typography, shapes = shapes, content = content ) } Theme方法中有正常主题和Dark主题的颜色设置，里面还有关于MeterialTheme的设置。 关于Theme方法的用法如下。 setContent { JetpackComposeDemoTheme { Greeting(&quot;Android&quot;) } } 在JetpackComposeDemoTheme里面的所有UI方法都会应用上述主题中指定的颜色。 2.2.4 ModifierModifier是各个Compose的UI组件一定会用到的一个类。它是被用于设置UI的摆放位置，padding等信息的类。关于Modifier相关的设置实在是太多，在这里只介绍会经常用到的。 padding 设置各个UI的padding。padding的重载的方法一共有四个。 Modifier.padding(10.dp) // 给上下左右设置成同一个值 Modifier.padding(10.dp, 11.dp, 12.dp, 13.dp) // 分别为上下左右设值 Modifier.padding(10.dp, 11.dp) // 分别为上下和左右设值 Modifier.padding(InnerPadding(10.dp, 11.dp, 12.dp, 13.dp))// 分别为上下左右设值 这里设置的值必须为Dp，Compose为我们在Int中扩展了一个方法dp，帮我们转换成Dp。 plus 可以把其他的Modifier加入到当前的Modifier中。 Modifier.plus(otherModifier) // 把otherModifier的信息加入到现有的modifier中 fillMaxHeight,fillMaxWidth,fillMaxSize 类似于match_parent,填充整个父layout。 Modifier.fillMaxHeight() // 填充整个高度 width,heigh,size 设置Content的宽度和高度。 Modifier.width(2.dp) // 设置宽度 Modifier.height(3.dp) // 设置高度 Modifier.size(4.dp, 5.dp) // 设置高度和宽度 widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值。 Modifier.widthIn(2.dp) // 设置最大宽度 Modifier.heightIn(3.dp) // 设置最大高度 Modifier.sizeIn(4.dp, 5.dp, 6.dp, 7.dp) // 设置最大最小的宽度和高度 gravity 在Column中元素的位置。 Modifier.gravity(Alignment.CenterHorizontally) // 横向居中 Modifier.gravity(Alignment.Start) // 横向居左 Modifier.gravity(Alignment.End) // 横向居右 rtl, ltr 开始布局UI的方向。 Modifier.rtl // 从右到左 Modifier.ltr // 从左到右 Modifier的方法都返回Modifier的实例的链式调用，所以只要连续调用想要使用的方法即可。 @Composable fun Greeting(name: String) { Text(text = &quot;Hello $name!&quot;, modifier = Modifier.padding(20.dp).fillMaxSize()) } 2.2.5 Column，Row正如其名字一样，Column和Row可以理解为在View/Layout体系中的纵向和横向的ViewGroup。 需要传入的参数一共有四个。 Modifier 用上述的方法传入已经按需求设置好的Modifier即可。 Arrangement.Horizontal, Arrangement.Vertical 需要给Row传入Arrangement.Horizontal，为Column传入Arrangement.Vertical。 这些值决定如何布置内部UI组件。 可传入的值为Center, Start, End, SpaceEvenly, SpaceBetween, SpaceAround。 重点解释一下SpaceEvenly, SpaceBetween, SpaceAround。 SpaceEvenly：各个元素间的空隙为等比例。SpaceBetween：第一元素前和最后一个元素之后没有空隙，所有空隙都按等比例放入各个元素之间。 SpaceAround：把整体中一半的空隙平分的放入第一元素前和最后一个元素之后，剩余的一半等比例的放入各个元素之间。 Alignment.Vertical, Alignment.Horizontal 需要给Row传入Alignment.Vertical，为Column传入Alignment.Horizontal。 使用方法和Modifier的gravity中传入参数的用法是一样的，这里就略过了。 @Composable ColumnScope.() -&gt; Unit 需要传入标有@Compose的UI方法。但是这里我们会有lamda函数的写法来实现。 整体代码如下。 Column { Row(modifier = Modifier.ltr.fillMaxWidth(),horizontalArrangement = Arrangement.SpaceAround, verticalGravity = Alignment.Top) { // ..,... }","categories":[],"tags":[]},{"title":"Android进阶基础系列：View的工作原理 全面理解！","slug":"Android进阶基础系列：View的工作原理-全面理解！","date":"2020-07-25T11:03:07.000Z","updated":"2020-07-25T11:13:03.956Z","comments":true,"path":"2020/07/25/andview/","link":"","permalink":"https://jiyugithub.github.io/2020/07/25/andview/","excerpt":"","text":"1、ViewRoot 和 DecorView ViewRoot对应ViewRootImpl类，是连接WindowManager和DecorView的纽带。View的三大流程是通过ViewRoot完成的。 在ActivityThread中，当Activity对象被创建完毕时，会将DecorView添加到Window中，同时会创建ViewRootImpl，且ViewRootImpl和DecorView会建立关联。如下代码，WindowManagerGlobal的addView()方法： public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) { ... root = new ViewRootImpl(view.getContext(), display); root.setView(view, wparams, panelParentView); ... } View绘制流程从 performTraversals开始，经过Measure、layout、draw。流程图如下 \\3. DecorView是顶级View，是一个FrameLayout，上面是标题栏、下面是内容栏。内容栏就是setContengView的内容view，id是content。事件 经过DecorView 然后传给我们自己的View。 2、 MeasureSpec MeasureSpec封装了从父级传递到子级的布局要求。系统把view的LayoutParams 根据 父容器施加的规则（父容器的SpecMode） 转换成 view的MeasureSpec，然后使用这个MeasureSpec确定view的测量宽高（不一定是最终宽高）。 2.1MeasureSpec1.MeasureSpec—view的测量规格：高2位的SpecMode，低30位的SpecSize。 2.SpecMode的分类： UNPECIFIED，父容器对view不限制，要多大给多大，一般系统内部使用。 EXACTLY，父容器检测出view所需大小，view最终大小就是SpecSize的值。对应 LayoutParams中的matchParent、具体数值 两种模式。 AT_MOST，父容器制定了可用大小即SpecSize，view的大小不能大于这个值，具体要看view的具体实现。对应LayoutParams中的wrap_content。 2.2MeasureSpec和LayoutParams的对应关系 前面说了View的MeasureSpec是由LayoutParams和父容器的MeasureSpec共同决定。顶级view，即DecorView，是由窗口尺寸和自身LayoutParams决定。 1、DecorView，ViewRootImpl中measureHierarchy()方法（performTraversals中执行），代码如下，desiredWindowWidth、desiredWindowHeight是屏幕的尺寸。 private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) { ... childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... } performMeasure()内部是调用mView.measure(childWidthMeasureSpec, childHeightMeasureSpec)，mView就是DecorVIew。继续看getRootMeasureSpec（）方法如下： /** * Figures out the measure spec for the root view in a window based on it&#39;s * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */ private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&#39;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec; } DecorView的MeasureSpec就明确了，根据其LayoutParams： MATCH_PARENT：精确模式，就是窗口大小； WRAP_CONTENT：最大值模式，最大值不能超过窗口大小； 固定值（如100dp）：精确模式，就是LayoutParams的指定值。 2、普通View，测量过程从ViewGroup传递下来，看ViewGroup的measureChildWithMargins()方法： /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 即先获取child的MeasureSpec，再调child.measure()。可以看到，child的MeasureSpec是由父容器的 MeasureSpec、父容器的padding、child的LayoutParams、child的marging 共同决定。继续看getChildMeasureSpec()方法： /** * Does the hard part of measureChildren: figuring out the MeasureSpec to * pass to a particular child. This method figures out the right MeasureSpec * for one dimension (height or width) of one child view. * * The goal is to combine information from our MeasureSpec with the * LayoutParams of the child to get the best possible results. For example, * if the this view knows its size (because its MeasureSpec has a mode of * EXACTLY), and the child has indicated in its LayoutParams that it wants * to be the same size as the parent, the parent should ask the child to * layout given an exact size. * * @param spec The requirements for this view * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //padding,就是已被占用的空间，就是 父容器的padding+child的marging //size，是ViewGroup本身size减去已使用的空间，是ViewGroup能提供给child的最大值。 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&#39;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&#39;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 可见，view的MeasureSpec由 viewParent的MeasureSpec和自身layoutParams确定。另外，child的可利用的尺寸是parent尺寸减去padding，上面代码已有注释，这很好理解。 梳理如下： parentSpecMode /childLayoutParams EXACTLY AT_MOST UNSPECIFIED dp/px EXACTLY childSize EXACTLY childsize EXACTLY childsize match_parent EXACTLY parentSize AT_MOST parentSize UNSPECIFIED 0 wrap_content AT_MOST parentSize AT_MOST parentSize UNSPECIFIED 0 注意，parentSize是父容器可使用的大小。 更新，看到鸿洋公众号的文章关于UNSPECIFIED说明： MeasureSpec.UNSPECIFIED是不是真的不常见？ 在日常定制View时，确实很少会专门针对这个模式去做特殊处理，大多数情况下，都会把它当成MeasureSpec.AT_MOST一样看待，就比如最最常用的TextView，它在测量时也是不会区分UNSPECIFIED和AT_MOST的。 不过，虽说这个模式比较少直接接触到，但很多场景下，我们已经在不知不觉中用上了，比如RecyclerView的Item，如果Item的宽/高是wrap_content且列表可滚动的话，那么Item的宽/高的测量模式就会是UNSPECIFIED。 还有就是NestedScrollView和ScrollView，因为它们都是扩展自FrameLayout，所以它们的子View会测量两次，第一次测量时，子View的heightMeasureSpec的模式是写死为UNSPECIFIED的。 我们在自定义ViewGroup过程中，如果允许子View的尺寸比ViewGroup大的话，在测量子View时就可以把Mode指定为UNSPECIFIED。 看到ScrollView重写了measureChild方法，指定高度的mode是UNSPECIFIED ![ScrollView重写了measureChild方法，指定高度的mode是UNSPECIFIED](data:image/svg+xml;utf8,) 3、View的工作流程 View的三大流程，measure、layout、draw。measure确定view的测量宽高，layout确定view的最终宽高和四个顶点位置，draw绘制到屏幕。 3.1 Measure过程view的测量过程，由measure()方法完成。viewGroup测量自身后，还需调用child.measure()遍历测量子view。 3.1.1 view的测量过程/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * {@link #onMeasure(int, int)}, called by this method. Therefore, only * {@link #onMeasure(int, int)} can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); ... } 可见view的measure()方法是final，不可被子类重写。里面调用onMeasure()，实际真正的测量过程在onMeasure()中。所以只有onMeasure()可以且必须被子类重写。另外，参数widthMeasureSpec、heightMeasureSpec就是上一节最后的表格中的值。继续看onMeasure()： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 从名字就可以看出，setMeasuredDimension()就是设置测量的尺寸，且在onMeasure()中必须被调用，否则在测量时会发送异常。getDefaultSize()获取默认的宽/高。所以View类中的onMeasure() 是设置默认的宽高。 继续看getDefaultSize()具体实现： public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result; } UNSPECIFIED，一般是系统使用，不需要关心。这里view大小直接取size，就是getSuggestedMinimumWidth()/getSuggestedMinimumHeight()，意思是 建议的 最小宽高。看下实现： protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); } 没有背景，就取mMinWidth，就是xml中设置的minWidth属性值；有背景，取 mMinWidth 、背景的MinimumWidth 的较大值。drawable的getMinimumWidth()如下，有固有宽度就取固有宽度（如BitmapDrawable），没有就是0（如ShadeDrawable）。 public int getMinimumWidth() { final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth &gt; 0 ? intrinsicWidth : 0; } AT_MOST、EXACTLY，直接取specSize，就是上一节最后的表格中的值，作为测量宽高。那这样取specSize是否合适呢？ 再来看一遍specSize的来源。 parentSpecMode /childLayoutParams EXACTLY AT_MOST UNSPECIFIED dp/px 1EXACTLY childSize 2EXACTLY childsize EXACTLY childsize match_parent 3EXACTLY parentSize 4AT_MOST parentSize UNSPECIFIED 0 wrap_content 5AT_MOST parentSize 6AT_MOST parentSize UNSPECIFIED 0 1、2的情况，具体dp值，取SpecSize没问题，因为是EXACTLY，就是给定的的尺寸。 3的情况，match_parent，取SpecSize，即parentSize，也没问题，因为是EXACTLY，也是确定的尺寸。 4的情况，match_parent，但父容器又是wrap_content，系统就给了AT_MOST+parentSize，限制最大尺寸为parentSize。而这里直接取specSize即parentSize，似乎也没问题。这个看一个例子一，如下，view是match_parent，可见view取得确实是parentSize。 5、6的情况，wrapContent即AT_MOST+parentSize，取specSize也就是parentSize，所以和3、4一样都是parentSize，即 View类 中 默认wrapContent等同于match_parent。 再看一个情况例子二，如下，View换成TextView（继承View），尺寸就不是parentSize了，而是内容尺寸，说明TextView在onMeasure中做了处理。 继续看，例子三如下，同时有TextView、View，此时textView又是取parentSize（可用空间）： 所以得出结论： 通常直接继承View的自定义View，在onMeasure()需要处理 ： a、wrap_content的情况，否则wrap_content就等同于match_parent； b、match_parent+父容器wrap_content的情况，否则就像例子一，父容器wrap_content是无效的，处理方式就是例子二中的textView。 总结就是，直接继承View的自定义View，需要处理AT_MOST时的宽高。 处理方式如下： @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) { setMeasuredDimension(mWidth, mHeight); } else if (widthMode == MeasureSpec.AT_MOST) { setMeasuredDimension(mWidth, heightSize); } else if (heightMode == MeasureSpec.AT_MOST) { setMeasuredDimension(widthSize, mHeight); } } 实际就是在 AT_MOST时 设置一个指定的尺寸mWidth、mHeight，其他情况沿用系统。至于mWidth、mHeight是多少，则要具体看你的view的逻辑了。例如TextView，可以参考其源码的实现。 3.1.2 ViewGroup的测量过程 ViewGroup需要完成自身的测量，还要遍历子view调用measure()方法进行测量。 ViewGroup是抽象类，没有重写onMeasure，因为无法做到统一，是让具体继承ViewGroup的子类重写自己的逻辑。但是提供一些方便的方法给子类调用。如measureChildren()、measureChild()、measureChildWithMargins()，上面第二节分析过measureChildWithMargins()，这里我们看下measureChildren()： /** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } 就是遍历子view，调用measureChild()，继续看： protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 通过getChildMeasureSpec()获取child的MeasureSpec，然后调用child.measure()，测量就传到child内部了，很好理解。measureChild()相比measureChildWithMargins() 没有考虑child的margin值。 上面说了，ViewGroup没有重写onMeasure，因为无法做到统一，让具体继承ViewGroup的子类重写自己的逻辑。具体看下LinearLayout的测量过程。 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } 继续看measureVertical()： void measureVertical(int widthMeasureSpec, int heightMeasureSpec) { ... //下面这句官方注释：看每个人多高，也记住最大宽度。想想这不就是计算竖向LinearLayout宽高的思路嘛！ // See how tall everyone is. Also remember max width. for (int i = 0; i &lt; count; ++i) { ... final View child = getVirtualChildAt(i); ... final LayoutParams lp = (LayoutParams) child.getLayoutParams(); ... // Determine how big this child would like to be. If this or // previous children have given a weight, then we allow it to // use all available space (and we will shrink things later // if needed). final int usedHeight = totalWeight == 0 ? mTotalLength : 0; //这里测量child（里面就是measureChildWithMargins()） measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight); final int childHeight = child.getMeasuredHeight(); ... final int totalLength = mTotalLength; //这里mTotalLength加上child的高度、margin，就是child高度累积。 mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); ... //这里记录最大宽度（包含margin） final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); ... } //遍历完了：高度加上自身的上下padding // Add in our padding mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; // Check against our minimum height heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); //这里很重要：调用resolveSizeAndState--决定 计算的高度（高度累加）和 LinearLayout的父容器约束的高度，取哪一个。 // Reconcile our calculated size with the heightMeasureSpec int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0); heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK; ... //最大宽度加上左右margin maxWidth += mPaddingLeft + mPaddingRight; // Check against our minimum width maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); //设置最终的测量尺寸（宽也也同样调用resolveSizeAndState决定取哪个） setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); } 所以，简单概括就是： 1.先测量所有child； 2.根据child的情况获取自身宽高（累加高度、最大宽度）。 那么，是否就取 累加高度、最大宽度？再看下resolveSizeAndState(): /** * Utility to reconcile a desired size and state, with constraints imposed * by a MeasureSpec. Will take the desired size, unless a different size * is imposed by the constraints. The returned value is a compound integer, * with the resolved size in the {@link #MEASURED_SIZE_MASK} bits and * optionally the bit {@link #MEASURED_STATE_TOO_SMALL} set if the * resulting size is smaller than the size the view wants to be. * * @param size How big the view wants to be. --想要的尺寸 * @param measureSpec Constraints imposed by the parent. --父布局给的measureSpec * @param childMeasuredState Size information bit mask for the view&#39;s * children. * @return Size information bit mask as defined by * {@link #MEASURED_SIZE_MASK} and * {@link #MEASURED_STATE_TOO_SMALL}. */ public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { case MeasureSpec.AT_MOST: //AT_MOST时，想要的尺寸大于约束的尺寸，就只能取 约束的尺寸。 if (specSize &lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { result = size; } break; case MeasureSpec.EXACTLY: //dp值、match_parent且父EXACTLY，就是SpecSize result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; } return result | (childMeasuredState &amp; MEASURED_STATE_MASK); } 这个过程就是 限制 AT_MOST时，即wrap_content（或match_parent且父wrap_content）时高度不能大于parent的剩余空间。 3.1.3 获取View宽高的时机 Measure过程完成，就可通过getMeasuredWidth()、getMeasuredHeight()获取测量宽高。但某些极端情况 需要多次Measure才能确定最终宽高。所以在onLayout方法中获取测量宽高是真正ok的。 我们知道，activity的onCreate中无法获取到view的宽高。实际onCreate、onStart、onResume都不能保证view已完成测量，所以可能获取的都是0。因为view的measure和activity生命周期不是同步的。 以下是保证可以获取view测量宽高的方法： 1、Activity/View # onWindowFocusChangedonWindowFocusChanged：View已初始化完毕，宽高已准备ok。 但会多次调用，获取焦点、失去焦点都回调用。(这个回调是ViewRootIml中分发到DecorView，接着到Activity、到各级View。) @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); if (hasFocus) { int measuredWidth = scoreView.getMeasuredWidth(); int measuredHeight = scoreView.getMeasuredHeight(); } } 2、view.post(runnable)view.post可以把runnable放入消息队列，等待looper到此runnable是view已经初始化完成。v详细原理参考【Android源码解析】View.post()到底干了啥 @Override protected void onStart() { super.onStart(); scoreView.post(new Runnable() { @Override public void run() { int measuredWidth = scoreView.getMeasuredWidth(); int measuredHeight = scoreView.getMeasuredHeight(); } }); } 3、ViewTreeObserverViewTreeObserver有很多回调，其中有个OnGlobalLayoutListener，当View树的状态发生改变或者View树内部view的可见性发生改变时 方法 onGlobalLayout()都会被调用。所以是会回调多次。 此时也可以获取view的宽高： ViewTreeObserver observer = view.getViewTreeObserver(); observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mDefaultControlLayout.getViewTreeObserver().removeGlobalOnLayoutListener(this); if (mIsGroupListAnimating) { mIsGroupListAnimationPending = true; } else { updateLayoutHeightInternal(animate); } } }); 3.2Layout过程layout()的作用是View用来确定view本身位置，内部调用onLayout()来确定子view的位置。 layout过程比measure过程简单很多。看View的layout方法： public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //使用setFrame方法设置4个顶点，就确定位置了~ boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { //这里调用onLayout，是个空实现。ViewGroup中重写了，还是空实现，但加了abstract，即ViewGroup的子类必须重写onLayout确定子View的位置。 onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) { if(mRoundScrollbarRenderer == null) { mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); } } else { mRoundScrollbarRenderer = null; } mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } ... } 先是用setFrame方法设置4个顶点，就确定位置了，即mLeft、mTop、mBottom、mRight确定了。 然后调用onLayout，是个空实现。ViewGroup中重写了onLayout，还是空实现，但加了abstract，即ViewGroup的子类必须重写onLayout确定子View的位置。 那就看看LinearLayout的onLayout： @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } 继续看layoutVertical()： void layoutVertical(int left, int top, int right, int bottom) { final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go final int width = right - left; int childRight = width - mPaddingRight; // Space available for child int childSpace = width - paddingLeft - mPaddingRight; final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; switch (majorGravity) { case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; } //遍历子view for (int i = 0; i &lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { //获取child的测量宽高 final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) { gravity = minorGravity; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; } if (hasDividerBeforeChildAt(i)) { childTop += mDividerHeight; } childTop += lp.topMargin; //以上就是获取子view的左、上的位置，即宽高，然后调用setChildFrame setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); //top位置加上高度和margin，就是下一个view的top childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); } } } 就是遍历子view，确认childLeft、childTop，调用setChildFrame确认子view的位置： private void setChildFrame(View child, int left, int top, int width, int height) { //这里width、height就是 上面获取的 测量宽高 child.layout(left, top, left + width, top + height); } 也就是调用child的layout方法，这样就走child的layout过程了。 一个问题：getMeasuredWidth() 与 getWidth()有何区别？ 答曰：一般情况，getMeasuredWidth() 与 getWidth()两者无区别。 先看，getWidth(): public final int getWidth() { return mRight - mLeft; } 在上面分析LinearLayout时，child.layout的参数中 mRight就是mLeft + measuredWidth，所以getWidth()就是measuredWidth。只不过是measuredWidth在测量过程产生，getWidth()在layout过程产生。 只要不重写view的layout()方法（也不需要重写）改变顶点位置就不会出现不同的情况，例如下面这个最终宽高比测量宽高大100。 public void layout(int l, int t, int r, int b) { super.layout(l,t,r+100,b+100); } 3.3Draw过程draw过程： 1、画背景 2、画自己– onDraw，自己实现 3、画子view– dispatchDraw 4、画装饰 public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&#39; layers to prepare for fading * 3. Draw view&#39;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we&#39;re done... return; } ViewGroup一般不用onDraw画自己，只需要画子View就可以了。但明确需要画自己的话，需要调用setViewNotDraw(false); 以上View的三大流程就分析完了。 4、自定义View 自定义view涉及view层次结构、事件分发、工作原理，有一定复杂度，但也是有章可循的。 4.1自定义view的分类 继承View：重写onDraw，要处理wrap_content、padding。 继承ViewGroup：重写onMeasure测量自己、子View，重写onLayout布局子View。 继承特定View（如TextView）：扩展自己的功能。 继承特定ViewGroup（如LinearLayout）：扩展自己的功能。 4.2 自定义view 注意点 支持wrap_content：直接继承View或ViewGroup的，要在onMeasure中处理wrap_content的情况。 支持padding：直接继承View在onDraw中处理；直接继承ViewGroup，在onMeasure、onLayout中处理padding和子view的margin。 不要在View中使用handler，因为本身提供了post方法。 在View#onDetachedFromWindow中停止动画或线程。 处理好嵌套滑动。 4.3 例子自定义ViewGroup实例：横向滑动HorizontalView 4.4 自定义view的思想先掌握基本功，弹性滑动、滑动冲突、绘制原理等，然后选择自定义的类别，按照注意事项多做就可以了。","categories":[],"tags":[]},{"title":"用协程控制多个并行异步结果的优先级","slug":"用协程控制多个并行异步结果的优先级","date":"2020-07-05T01:09:27.000Z","updated":"2020-07-05T01:15:37.558Z","comments":true,"path":"2020/07/05/suspendAction/","link":"","permalink":"https://jiyugithub.github.io/2020/07/05/suspendAction/","excerpt":"你会怎么实现下面这个场景？应用首页有三个优先级从高到低的弹窗，展示内容依赖网络请求，若低优先级弹窗请求先返回则需等待，让高优先级先展示。","text":"你会怎么实现下面这个场景？应用首页有三个优先级从高到低的弹窗，展示内容依赖网络请求，若低优先级弹窗请求先返回则需等待，让高优先级先展示。 串行请求是最容易想到的解决方案，即先请求最高优先级的弹窗，当它返回展示后再请求第二优先级弹窗。但这样会拉长所有弹窗的展示时间。 性能更好的方案是同时并行发出三个请求，但网络请求时长的不确定性使得最高优先级的弹窗不一定优先返回，所以得设计一种优先级阻塞机制。本文使用 协程 + 链式队列 实现这个机制。 异步任务链把单个异步任务进行抽象： // 单个异步任务 class Item { companion object { // 默认异步优先级 const val PRIORITY_DEFAULT = 0 } // 异步操作：耗时的异步操作 var suspendAction: (suspend () -&gt; Any?)? = null set(value) { field = value value?.let { // 启动协程执行异步操作 GlobalScope.launch { deferred = async { it.invoke() } } } } // 异步响应：异步操作结束后要做的事情 var resumeAction: ((Any?) -&gt; Unit)? = null // 异步结果：异步操作返回值 var deferred: Deferred&lt;*&gt;? = null // 异步优先级 var priority: Int = PRIORITY_DEFAULT } 异步任务有三个主要的属性，分别是异步操作suspendAction、异步响应resumeAction、异步结果deferred。每当异步操作被赋值时，就启动协程执行它，并将其返回值保存在deferred中。 为了确保异步任务的优先级，把多个异步任务用链的方式串起来，组成异步任务链： class Item { companion object { const val PRIORITY_DEFAULT = 0 } var suspendAction: (suspend () -&gt; Any?)? = null set(value) { field = value value?.let { GlobalScope.launch { deferred = async { it.invoke() } } } } var resumeAction: ((Any?) -&gt; Unit)? = null var deferred: Deferred&lt;*&gt;? = null var priority: Int = PRIORITY_DEFAULT // 异步任务前结点（Item 包含 Item） internal var next: Item? = null // 异步任务后结点（Item 包含 Item） internal var pre: Item? = null // 在当前结点后插入新结点 internal fun addNext(item: Item) { next?.let { it.pre = item item.next = it item.pre = this this.next = item } ?: also { // 尾结点插入 this.next = item item.pre = this item.next = null } } // 在当前结点前插入新结点 internal fun addPre(item: Item) { pre?.let { it.next = item item.pre = it item.next = this this.pre = item } ?: also { // 头结点插入 item.next = this item.pre = null this.pre = item } } } 用 自己包含自己 的方式就能实现链式结构。Android 消息列表也用同样的结构： public final class Message implements Parcelable { Message next; ... } 链必须有个头结点，存放头结点的类就是存放整个链的类，就好像消息列表MessageQueue一样： public final class MessageQueue { Message mMessages; } 模仿消息列表，写一个异步任务链： // 异步任务链 class SuspendList { // 头结点 private var head: Item = emptyItem() // 向异步任务链插入结点 fun add(item: Item) { // 从头结点向后查找插入位置，找到再后插入 head.findItem(item.priority).addNext(item) } // 根据优先级向后查找插入位置(优先级升序) private fun Item.findItem(priority: Int): Item { // 当前结点 var p: Item? = this // 当前结点的后续结点 var next: Item? = p?.next // 从当前结点开始向后遍历异步任务链 while (next != null) { // 若优先级介于当前结点和其后续结点之间,则表示找到插入位置 if (priority in p!!.priority until next.priority) { break } p = p.next next = p?.next } return p!! } // 观察异步任务链并按优先级阻塞 fun observe() = GlobalScope.launch(Dispatchers.Main) { // 从头结点向后遍历异步任务链 var p: Item? = head.next while (p != null) { // 在每个异步结果上阻塞，直到异步任务完成后执行异步响应 p.resumeAction?.invoke(p.deferred?.await()) p = p.next } } // 异步任务(已讲解不再赘述) class Item { ... } } // 空结点(头结点) fun emptyItem(): SuspendList.Item = SuspendList.Item().apply { priority = -1 } SuspendList持有链的头结点，为了使“头插入”和“中间插入”复用一套代码，将头结点设置为“空结点”。 异步任务链上的任务按优先级升序排列（优先级数字越小优先级越高）。这保证了优先级最高的异步任务总是在链表头。 优先级阻塞：当所有异步任务都被添加到链之后，调用observe()观察整个异步任务链。该方法启动了一个协程，在协程中从头结点向后遍历链，并在每个异步任务的Deferred上阻塞。因为链表已按优先级排序，所以阻塞时也是按优先级从高到低进行的。 全局作用域真实业务场景中，需要统一安排优先级的异步任务可能是跨界面的。这就要求异步任务链能全局访问，单例是一个最直接的选择，但它限制了整个 App 中异步任务链的数量： // 私有构造函数 class SuspendList private constructor() { companion object { // 静态 map 存放所有异步任务链 var map = ArrayMap&lt;String, SuspendList&gt;() // 根据 key 构建异步任务链 fun of(key: String): SuspendList = map[key] ?: let { val p = SuspendList() map[key] = p p } } ... } 然后就可以像这样使用异步任务链： // 构建异步任务链 SuspendList.of(&quot;dialog&quot;).apply { // 向链添加异步任务1 add(Item { suspendAction = { fetchUser() } resumeAction = { user: Any? -&gt; onUserResume(user) } priority = 3 }) // 向链添加异步任务2 add(Item { suspendAction = { fetchActivity() } resumeAction = { activity: Any? -&gt; onActivityResume(activity) } priority = 1 }) }.observe() suspend fun fetchUser(): String { delay(4000) return &quot;User Taylor&quot; } suspend fun fetchActivity(): String { delay(5000) return &quot;Activity Bonus&quot; } private fun onActivityResume(activity: Any?) { Log.v(&quot;test&quot;, &quot;activity(${activity.toString()}) resume&quot;) } private fun onUserResume(user: Any?) { Log.v(&quot;test&quot;, &quot;user(${user.toString()}) resume&quot;) } 上述代码构建了一个名为 dialog 的异步任务链，向其中添加了两个异步任务，并按优先级观察它们的结果。 其中Item()是一个顶层方法，用于构建单个异步任务： fun Item(init: SuspendList.Item.() -&gt; Unit): SuspendList.Item = SuspendList.Item().apply(init) 这是构建对象 DSL 的标准写法，详细讲解可以参见这里。 运用 DSL 的思路还可以进一步将构建代码简化成这样： SuspendList.of(&quot;dialog&quot;) { Item { suspendAction = { fetchUser() } resumeAction = { user: Any? -&gt; onUserResume(user) } priority = 3 } Item { suspendAction = { fetchActivity() } resumeAction = { activity: Any? -&gt; onActivityResume(activity) } priority = 1 } }.observe() 不过需要对原先的of()和Item()做一些调整： // 新增接收者为SuspendList的 lambda 参数，为构建异步任务提供外层环境 fun of(key: String, init: SuspendList.() -&gt; Unit): SuspendList = (map[key] ?: let { val p = SuspendList() map[key] = p p }).apply(init) // 将构建异步任务声明为SuspendList的扩展方法 // 构建异步任务后将其插入到异步任务链中 fun SuspendList.Item(init: SuspendList.Item.() -&gt; Unit): SuspendList.Item = SuspendList.Item().apply(init).also { add(it) } 异步超时若某个高优先级的异步任务迟迟不能结束，其它任务只能都被阻塞？ 得加个超时参数： class Item { // 为异步操作赋值时,不再立刻构建协程 var suspendAction: (suspend () -&gt; Any?)? = null // 超时时长 var timeout: Long = -1 ... } 为单个异步任务添加超时时长参数，还得重构一下异步任务的构建函数： fun SuspendList.Item(init: SuspendList.Item.() -&gt; Unit): SuspendList.Item = SuspendList.Item().apply { // 为异步任务设置各种参数 init() // 启动协程 GlobalScope.launch { // 将异步任务结果包装成 Deferred deferred = async { // 若需要超时机制 if (timeout &gt; 0) { withTimeoutOrNull(timeout) { suspendAction?.invoke() } } // 不需要超时机制 else { suspendAction?.invoke() } } } }.also { add(it) } 原本在suspendAction赋值时就立马启动协程，现在将其延后，等所有参数都设置完毕后才启动。这样可以避免“先为 suspendAction 赋值，再为 timeout 赋值”case 下超时无效的 bug。 使用withTimeoutOrNull()实现超时机制，当超时发生时，业务会从resumeAction中获得null。 异步任务生命周期管理构建异步任务链时使用了GlobalScope.launch()启动协程，其创建的协程不符合structured-concurrency。所以需要手动管理生命周期： class SuspendList private constructor() { class Item { // 为异步任务新增 Job 属性，指向其对应的协程 internal var job:Job? = null ... } // observer()返回类型为 Job,业务层可以在需要的时候取消它 fun observe() = GlobalScope.launch(Dispatchers.Main) { var p: Item? = head.next while (p != null) { p.resumeAction?.invoke(p.deferred?.await()) // 当异步任务响应被处理后，取消其协程以释放资源 p.job?.cancel() p = p.next } } } fun SuspendList.Item(init: SuspendList.Item.() -&gt; Unit): SuspendList.Item = SuspendList.Item().apply { init() // 将该异步任务的协程存储在 job 中 job = GlobalScope.launch { deferred = async { if (timeout &gt; 0) { withTimeoutOrNull(timeout) { suspendAction?.invoke() } } else { suspendAction?.invoke() } } } }.also { add(it) } Talk is cheap, show me the code本篇的完整源码可以点击这里","categories":[],"tags":[]},{"title":"帮朋友转发一个博客","slug":"帮朋友转发一个博客","date":"2020-06-30T15:51:51.000Z","updated":"2020-07-05T01:12:03.012Z","comments":true,"path":"2020/06/30/blogs/","link":"","permalink":"https://jiyugithub.github.io/2020/06/30/blogs/","excerpt":"","text":"http://blog.moiyun.cn/archives/15/除非付诸行动，否则空口无凭 博主：刘时俊","categories":[],"tags":[]},{"title":"聊聊 Android 开发的现状和思考","slug":"聊聊-Android-开发的现状和思考","date":"2020-06-28T15:51:51.000Z","updated":"2020-06-30T09:51:55.855Z","comments":true,"path":"2020/06/28/androidxx/","link":"","permalink":"https://jiyugithub.github.io/2020/06/28/androidxx/","excerpt":"回想这六年里 Android 开发的发展历程，现如今的 Android 已经拥有了成熟的开发体系，技术框架也是经历了一代一代的更新： HttpClient、Volley 、OkHttp、Retrofit ； ImageLoader、Picasso、Fresco、Glide； OrmLite、LitePal、GreenDao、Realm、Room； 除了熟悉的网络、图片和数据库“三大件”外，还有像 xUtils、EventBus、Dagger、RxJava、MultiType 等等，它们对于老 Android 来说，可以说是贯穿了整个“青春期”的回忆。","text":"回想这六年里 Android 开发的发展历程，现如今的 Android 已经拥有了成熟的开发体系，技术框架也是经历了一代一代的更新： HttpClient、Volley 、OkHttp、Retrofit ； ImageLoader、Picasso、Fresco、Glide； OrmLite、LitePal、GreenDao、Realm、Room； 除了熟悉的网络、图片和数据库“三大件”外，还有像 xUtils、EventBus、Dagger、RxJava、MultiType 等等，它们对于老 Android 来说，可以说是贯穿了整个“青春期”的回忆。 从一开始的 MVC 到 MVP 再到 MVVM 乃至官方提供的 AAC 架构，Android 的技术栈一直在“刷新”，而随着 Kotlin 的扶正还有 Android Jetpack 的提出，新一代的完善开发体系也给老开发们带来了一些额外的“烦躁”。 “AS 2.3 又不是不能用？！” ”项目还要继续兼容 4.4 版本？！！” “RxJava 都还没用上就开始吹协程？！！！” 因为旧项目的维护或者工作环境的影响，很多时候其实没有新框架落地的条件，甚至于 Flutter 的出现都会被贩卖一波焦虑。 那就让我们聊聊这种焦虑或者不安。放心，后面没有“防不胜防”！ “没用过”的焦虑对于老 Android 来说，有一种“焦虑”情绪来自于“我还没用过”，因为新生的框架和技术在不断迭代，而“没有用过就跟不上时代”的情绪，会在每次技术更新迭代时被反复放大，这大概就是部分 Android 焦虑的来源。 例如现在的 Android Jetpack、协程、 Jetpack Compose 、Flutter 等，每次看到这些字眼时就会莫名地出现“焦虑”，犹如当年一开始听到 Dagger、RxJava 、React Native 一样。 那要怎么样缓（tao）解（bi）这种焦虑呢？这就要先理解下这些“新技术”名词不断出现地原因，我把这种“我还没用过”的焦虑理解为“扳手升级副作用”。 这里举一个有趣的例子，如下图所示是不同阶段扳手，可以看到： 从 1 到 2 用户拧螺母需要准备的扳手数量减少了； 从 2 到 3 扳手变得更加帅气有力，并且附带的“攻击力”也有所上升； 那问题来了： 一、既然有 2 这样便捷的扳手，那 1 这种扳手还有必要存在吗？ 答案是有的，因为 1 中的扳手性价比更高，在特点的场景下会更轻便。 二、那扳手 2 既然都满足大部分场景了，扳手 3 有必要存在吗？ 答案也是有的，因为 3 中的扳手更加帅气，同时从健壮的角度更可靠。 这里扯了这两个问题其实是想表达：正在情况下随着技术的发展，新生框架和技术是为了让开发变成更便捷，同时降低开发门槛方便后来者入坑。 所以作为老 Android 开发，在经历了开发项目需要准备“一堆扳手”的手动挡时代，如今在这个只要一个“扳手”就能干活的半自动挡时代，怎么可能会拧不动螺母？ 过去的日子我们拧了无数的螺母，现在只不过要需要换个“扳手”，而这个扳手是可能是 3 ，第一次拿起来也许会“太重”，扭动的开关也不熟练，但是曾经的螺母需要“拧多深”和“卡什么体位”，这些对我们来说其实和之前没太大区别。 所以只要还是“拧螺母”，我们不应该因为担心“扳手”的品类太多而焦虑，或者还应该“庆幸”这个领域仍在健康发展。 技术的健康演进只会让它越来越容易被理解和使用，让开发的门槛变得越来越低： 从 RxJava1 到 RxJava2 的变化； 从 Dagger 到现在官方的 Koin； 从 Java 的 AsyncTask 到 Kotlin 的协程； 从 ButterKnife 到 KTX ； 所以用新的”扳手”肯定比用旧的一堆”扳手”方便，实际上开发者需要维护的代码和逻辑会越来越少，这是一个社区越来越成熟的表现，进而开发的门槛也就越来越低了。 而对于新技术的无法落地到项目的焦虑，我们可以换个思路：没有条件落地，但是可以去尝试理解这个新框架或技术的本质是什么，从而缓解对未知的恐惧。 比如 Dagger 说白了就是基于注解和模板生成代码，所以如果看不懂各种”生涩”的注解，那可以直接看生成的代码，理解 Dagger 是如何用“臃肿”的代码来为我们解耦。 另外在接下来的 Android Studio 4.1 下，已经开始支持了 Dagger 类的直接跳转，我们可以轻松地在 Dagger 的关联代码间进行导航。 所以换一个“扳手”的学习成本并不高，只要你扭螺母的功底还在。“现在还没用过”也不用慌，也许等等技术还能更成熟更方便学习，何况再等等还能白嫖大佬的文章不是么？ 当然这里还有一个有趣的误解： 扳手 2 升级后比扳手 1 牛逼了，所以作为使用扳手 2 的我比使用扳手 1 的牛逼？ 然而真相是：牛逼的是扳手的制造者，而作为使用者，直接使用 OkHttp 的可能还不如使用 HttpClient 的开发对网络请求的理解”深刻”。 框架降低了开发的门槛，提高了代码的可维护性，但是作为使用者的我们在享受便捷的同时，要变牛逼的根本不在于用，而在于需要理解框架为什么好用！ 比如 OkHttp 好用在于它优秀的拦截器设计，而 Retrofit 通过注解生成模板代码提高了开发效率，但是 Retrofit 本身网络请求部分还是需要 OkHttp等去支持。 把框架优秀的部分吃下去，那么你才会变牛逼，OkHttp 的设计就在 Flutter 中就被 Dio 框架完美复现，而 Dio 框架也成为了 Flutter 下热门的网络请求封装之一。 竞争力的焦虑还有一种就是竞争力的焦虑，我们时不时会把自己和年轻一代的开发们做比较，明显年轻人更便宜更耐C也更有体力，这让即将成为后浪的我们产生了职业生涯的焦虑。 因为开发体系的成熟带来了的门槛的降低，开发 Android 应用的要求确实没以前高，但是“能用”和“好用”那是两个故事！ 对比年轻人我们存在一些劣势，但是作为老开发在竞争力上还是有着一些其他的优势，比如：对业务的理解和落地能力。 简单举个例子，在 Android 上产品提出了一个需求： “增加一个播放功能，效果和爱奇艺差不多就行。” 多么“合理”的需求，这时候“吃过盐”的老 Android 相信都会“心头一颤“，在心里默默“问候”产品的同时，开始思考开发前需要讨论的“坑位”： 视频是否需要规定好编码格式，比如 H264/AAC 、MPEG/MP3？ 封装协议用 MP4 还是 M3U8？ 码率和帧率是否需要适应网络？ 用软解码 FFMPEG 还是 MediaCodec ？ 视频是否需要支持 AES128 加密？ 本地是否要增加离线缓存？ 是否要支持断线重连？ 后续是否要支持直播和广告的拓展？ 虽说不考虑以上部分写的代码也能用，也有一些开源项目提供“保姆式”支持，但是当你遇到坑后还能不能继续推进项目，并且如何在项目周期内合理避坑，这些都很考验一个开发的综合能力。 这个综合能力自然不只包括代码，而是需要时间慢慢去养成和踩坑来得到。 是的，在我的角度而言开发不只是写代码，我们的竞争力也不只在于代码，比如业务落地的能力就是长期的经验累积而成，比如： 一个工单的发起到结束流程会经历什么； 一个购物订单从发起到售后的流转需要考虑什么； 一个订房系统在并发时需要关注的什么； 一个直播系统需要怎么样的技术栈去支撑； 这些业务在具体场景下需要面对哪些坑？为什么这个业务要这么写？甚至是你在知道这样设计是不合理的情况下，要如何组织代码去避免后期频繁修改带来的负担。 毕竟好的代码千百万，坏的代码都是在业务高压下多次无情的修改摧残出来。 瞎扯了这么多，其实就是想表达：作为普通人的我们，一般情况下技术并不会成为我们的壁垒，因为现在的 IT 行业很多岗位把脑力密集型变成了体力密集型，996和007需要体力，更需要圆滑的心态去站稳脚跟，年轻气盛的是少年，而行业经验能让我们更好地保存体力去面对职场的“风起云涌”。 当然，如果职业几年来都是深水摸鱼，那也无 fuck 可说了～ 所以我也一直有个建议：在条件允许的情况下，尽量选择一个行业，不要今年搞教育、明年干餐饮、后年跳物联网这样跨界。 常年的“跨界”可能到哪都只是“大头兵”，一个行业内的人脉是资源，我们可能不擅长交际，但是我们一直说xxx圈子很小，或者我们能力不是特别出众，但是干的久了认识的圈内人也就多了。 到了 35 岁之后，10年的电商行业经验或者会比 10 年的移动开发经验更有用一点点。 当然这属于站着说要不腰疼，条件允许是指经济压力不大的情况下，不管什么狗屁理论，活下去就是第一要素。 最后回归主题，从 2018 Android 提出的 Jetpack 看，到了 2020 年的现在变化其实也不大，也就多了像 ViewPager2 、 CameraX 、Motionlayout 等的更新(最近还有 Hilt、Paging 3、App Startup )，并且在 Android 10 和 Android 11 开始着重隐私和Scoped Storage 分区等，这大概也是 Android 开发在趋向成熟和稳定的表现。 所以 Android 现在已经拥有十分成熟的开发体系，成熟也说明了这个系统的带来的开发红利消退了，说通俗点就是可以跳槽岗位少了。 而作为非技术大佬的我，就会选择一些其他的东西来尝试突破，比如前端、RN、Flutter 等其他技术领域做尝试。 当然每个人的理念和选择可能不同，也许我的方式就并不适合你，这里只是想表达一下：当你觉得自己处于“瓶颈”而焦虑时，或者可以选择从别的方向去折腾下。 另外友情提醒，不要给自己随便定计划，如要”周更多少文章”或者”月读多少书”，定了就要尽可能去完成，不然因为完成不了计划的“自作孽”而增加焦虑也是够够的。 最后，这里大多属于一家之言，仅供参考，主要也是有感而发，希望能对你有点帮助，让开发的日常也能够继续安心摸鱼！","categories":[],"tags":[]},{"title":"FragmentStatePagerAdapter在ViewPager中优化了什么","slug":"FragmentStatePagerAdapter在ViewPager中优化了什么","date":"2020-06-15T22:42:45.000Z","updated":"2020-06-15T22:47:10.334Z","comments":true,"path":"2020/06/16/fragmentstatepager/","link":"","permalink":"https://jiyugithub.github.io/2020/06/16/fragmentstatepager/","excerpt":"前言OK，填坑篇的文章来了。 当我打开官方文档准备开始了解FragmentStatePagerAdapter的时候。我仿佛像是…闭关蛰伏数十载，准备反清复明；出关时发现大清已经亡了… 什么鬼，我还不会用呢，就tm废弃了？？？","text":"前言OK，填坑篇的文章来了。 当我打开官方文档准备开始了解FragmentStatePagerAdapter的时候。我仿佛像是…闭关蛰伏数十载，准备反清复明；出关时发现大清已经亡了… 什么鬼，我还不会用呢，就tm废弃了？？？ 正文当然这不妨碍咱们去了解它如何增强了FragmentPagerAdapter。扶我起来，我还能学！ 看FragmentStatePagerAdapter之前，咱们还是要先看文档 官网是这么介绍这个类的（我直接用自己蹩脚的英文翻译了一下）： 当存在大量fragment时，此版本的更加高效。当Fragment对用户不可见时，它们的整个Fragment可能会被destory，仅保留该Fragment的状态。与FragmentPagerAdapter相比会占用更少的内存。 它的用法和FragmentPagerAdapter（以下简称FPA）一模一样，这里就不展开了。大家有兴趣可以直接看文档中的demo。 从文档介绍来看，FragmentStatePagerAdapter提供更少的内存开销。第二篇文章，咱们也已经明白了FragmentPagerAdapter在FragmentManager体系下会可能出现大量内存消耗的问题。那么咱们就来看看，FragmentStatePagerAdapter是如何优化这个问题。 一、如果做到更少的内存开销？FragmentStatePagerAdapter（以下简称FSPA）的实现比较的简单，解决方式也很简单粗暴。咱们先看一个关键的方法instantiateItem()，基于这个方法咱们分4步来看一下这里的实现原理： @Override public Object instantiateItem(@NonNull ViewGroup container, int position) { // 步骤1 if (mFragments.size() &gt; position) { Fragment f = mFragments.get(position); if (f != null) { return f; } } // 省略代码 // 步骤2 Fragment fragment = getItem(position); if (mSavedState.size() &gt; position) { Fragment.SavedState fss = mSavedState.get(position); if (fss != null) { fragment.setInitialSavedState(fss); } } // 步骤 3 while (mFragments.size() &lt;= position) { mFragments.add(null); } // 省略部分代码 // 步骤4 mFragments.set(position, fragment); mCurTransaction.add(container.getId(), fragment); // 省略部分代码 return fragment; } 我们可以看到这里的instantiateItem()和FPA有着极大的不同：这里没有通过FragmentManager去find已经存在的Fragment！这里可以断定FSPA失去了FPA上缓存的逻辑，接下来咱们会通过FSPA的源码来进一步了解二者逻辑上的不同。 1.1、步骤一分析步骤1中的mFragments是Adapter里的局部变量private ArrayList&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;()，看到着我们第一想法就能够明白FSPA对Fragment的管理，在FragmentManager的基础上包了一层。 这里的处理也很简单粗暴，如果基于position能在mFragments中找到Fragment就直接return。这里有一个点，我们需要注意，这里是直接return。也就是意味着被mFragment持有的Fragment实例是没有从FragmentManager中detach的，因此不需要重新走状态。 此外需要留意的一点是：if (f != null)，意味着mFragments里是有可能为null的，所以我们可以猜测mFragments对Fragment也是一个动态变化的持有关系。 1.2、步骤二分析很熟悉的方法调用，找不到缓存的Fragment，调getItem()，交给实现方自行初始化Fragment。 然后基于mSavedState对当前Fragment执行一次initSavedState操作。 这里可能有小伙伴会有疑问，新new出来的Fragment为啥有可能会有SavedState呢？ 针对这个问题，先简单解释一下（大家可以再后文中得到详细答案）：因为这个mSavedState会存在所有实例过的Fragment的状态，但是mFragments里仅仅会存放当前attach的Fragment。因此调用getItem()时初始化的Fragment是有可能之前初始化过，因此这种case下是要恢复其状态的。 1.3、步骤三分析步骤三做的事情就比较有趣了： while (mFragments.size() &lt;= position) { mFragments.add(null); } 说白了就是在占位。看到这一步，咱们就能明白：mFragments就是一个“以position为key，fragment为value的Map”。 当我们定位到一个很靠后的position时。那么代码走到这我们得到的mFragments的List很有可能是这样的 ：[fragment1,fragment2,null,null,null,接下来要被add的fragment6] 1.4、步骤四分析步骤四就很简单了，add我们getItem出来的Fragment。 看完这四步，咱们大概也会发现代码并没有什么难的，虽然我们只看了一个方法，但是基本可以猜出FSPA的原理： 只缓存当前attach上的Fragment 缓存所有attach过Fragment的SaveState，以便重新new时的状态恢复 看起来是因为缓存的Fragment数量少了所以内存开销变少了…不过我猜有同学这个时候会提出疑问：即使FSPA里mFragments缓存的Fragment少了，但是FragmentStore里该缓存还是要缓存的啊，这么一看，FSPA甚至多缓存了一份！ 接下来咱们就要看另一个方法了，看看FSPA如果解决上述的问题。 二、销毁Fragment其实有了第二篇文章的分析，咱们已经明确是FragmentManager内存爆炸的原因就是在于FragmentStore在mActive中强引用了所有的Fragment实例，不进行任何回收。 既然FSPA号称更少的开销，那么势必要直面这个问题。所以接下来就让咱们看看，FSPA销毁Fragment的策略。 2.1、destroyItem()FSPA和FPA主要区别就在于对destroyItem()的实现。这里咱们先对比一下二者的实现： // FSPA @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) { Fragment fragment = (Fragment) object; if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } while (mSavedState.size() &lt;= position) { mSavedState.add(null); } mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); // 注意这里 mCurTransaction.remove(fragment); if (fragment.equals(mCurrentPrimaryItem)) { mCurrentPrimaryItem = null; } } // FPA @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) { Fragment fragment = (Fragment) object; if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } // 注意这里 mCurTransaction.detach(fragment); if (fragment.equals(mCurrentPrimaryItem)) { mCurrentPrimaryItem = null; } } FSPA调用了remove方法，而FPA调用的是detach方法。接下来咱们就看看这二者有什么不同。其实无论是remove还是detach都会走到executeOps()中的switch判断： case OP_REMOVE: f.setNextAnim(op.mExitAnim); mManager.removeFragment(f); break; case OP_DETACH: f.setNextAnim(op.mExitAnim); mManager.detachFragment(f); break; 但是这里无论是removeFrament()还是detachFragment()。本质调的都是mFragmentStore.removeFragment(fragment);，这里是把当前Fragment从FragmentStore中的mAdded列表移除还不会动mActive列表。 因此对于FSPA来说，它并不是通过这种方式来控制内存开销。咱们继续往下看… 2.2、控制Fragment的状态机上述switch判断结束后，才会走到真正驱动状态的地方： if (!mReorderingAllowed &amp;&amp; op.mCmd != OP_ADD &amp;&amp; f != null) { // 这里边会走到moveToState()中 mManager.moveFragmentToExpectedState(f); } FragmentManager#moveToState() if (f.mState &lt;= newState) { switch (f.mState) { case Fragment.INITIALIZING:{ if (newState &gt; Fragment.INITIALIZING) { // 省略部分代码 } } case Fragment.ATTACHED:{ // 省略部分代码 } // 省略部分代码 }else if (f.mState &gt; newState) { switch (f.mState) { case Fragment.RESUMED: if (newState &lt; Fragment.RESUMED) { // 省略部分代码 } case Fragment.CREATED: if (newState &lt; Fragment.CREATED) { // 重点在这 boolean beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack(); if (beingRemoved || mNonConfig.shouldDestroy(f)) { makeInactive(fragmentStateManager); } // 省略部分代码 } // 省略部分代码 } // 省略部分代码 } 这里状态机的逻辑，大家有兴趣可以自己阅读一下。这里处理状态的逻辑还是挺“骚”的。咱们只关注makeInactive()。上文我们之后remove和detach的区别，而这个区别的分水岭就在于这个方法。remove是会走到这个方法中： private void makeInactive(@NonNull FragmentStateManager fragmentStateManager) { // 省略部分代码 mFragmentStore.makeInactive(fragmentStateManager); removeRetainedFragment(f); } void makeInactive(@NonNull FragmentStateManager newlyInactive) { Fragment f = newlyInactive.getFragment(); for (FragmentStateManager fragmentStateManager : mActive.values()) { if (fragmentStateManager != null) { Fragment fragment = fragmentStateManager.getFragment(); if (f.mWho.equals(fragment.mTargetWho)) { fragment.mTarget = f; fragment.mTargetWho = null; } } } mActive.put(f.mWho, null); if (f.mTargetWho != null) { f.mTarget = findActiveFragment(f.mTargetWho); } } 可以看到makeInactive()方法中会对mActive进行回收的操作。因此FSPA比FPA的优化就在于移除掉了对mActive中“不必要”的引用。 我猜看到这大家应该就能够get到FSPA的优化点，不过…问题来了：既然把FragmentManager中mActive移除掉了，那我们的缓存呢？ 三、失去了缓存事实的确如此，咱们在开篇看instantiateItem()实现的时候就已经发现，FSPA移除了通过FragmentManager去find缓存的逻辑。 咱们基于之前的文章，可以明白FPA的缓存是基于FragmentManager的mActive缓存，也明白FPA内存溢出也是因为FragmentManager的mActive缓存。 因此FSPA的优化原理也很好理解，在FragmentManager中移除掉了mActive的缓存。 这里也就意味着，FSPA和FPA有一些不同： 1、只要不在mAdd的Fragment，FSPA都会走getItem()去new Fragment。 2、我们没办法方便的基于FragmentManager去拿到我们想要得到的Fragment实例。（FSPA是基于id去把Fragment添加到mAdd） 3.1、ViewPager中取特定Fragment实例是否合理这里咱们多聊一句。不知道大家有没有发现，无论上FPA还是FSPA，Google都没有主动提供获取内部持有Fragment的public方法。甚至在FSPA中，移除了任何这种操作的可能行。 如果单纯从这个现象来看，基于ViewPager去变相的获取内部Fragment是一个“不合理”的操作。但是咱们也很清楚需求这种东西，如果都“合理”那就不叫需求了…因此这种操作是无法避免的。所有，咱们需要从FSPA和FPA的不同点来明确咱们该用谁… 如果我们需要FragmentManager去缓存我们的Fragment那么FPA是一个不错的选择。 如果我们拥有大量的Fragment在ViewPager中，那么FSPA是一个不错的选择。 当然鉴于FSPA已经被废弃了，咱们项目中首选还是ViewPager2。关于ViewPager2的分析会在后续放出… 尾声尽可能的学的深入，尽可能的发布正确的文章。欢迎大家评论区一起讨论~","categories":[],"tags":[]},{"title":"100 行 js 代码下载抖音无水印视频","slug":"100行js代码下载抖音无水印视频","date":"2020-06-15T22:18:29.000Z","updated":"2020-06-15T22:33:48.426Z","comments":true,"path":"2020/06/16/100js/","link":"","permalink":"https://jiyugithub.github.io/2020/06/16/100js/","excerpt":"本文大约 600 字，看完本文大概需要 5 分钟，仅供学习使用，如有错误，请指正。 需求抖音平台下载一个视频，去掉左上角的水印id。 先来看看有水印效果这时候就会发现，抖音官方下载下来的视频，会有抖音的水印，需要去掉水印。","text":"本文大约 600 字，看完本文大概需要 5 分钟，仅供学习使用，如有错误，请指正。 需求抖音平台下载一个视频，去掉左上角的水印id。 先来看看有水印效果这时候就会发现，抖音官方下载下来的视频，会有抖音的水印，需要去掉水印。 分享视频从抖音分享一个视频，你会获得一个分享文案和地址，格式如下（不懂怎么分享可以百度） 一只都放不明白 https://v.douyin.com/JdbBqog/ 复制此链接，打开【抖音短视频】，直接观看视频！把上面的 url 地址 ( v.douyin.com/JdbBqog/) 放到浏览器模拟的手机模式下看看发生了什么 1. 重定向短地址会重定向， 访问这个重定向的地址获取两个重要的参数 2. 一个关键的 ajax利用上面 html 内嵌 script 获取的两个参数，请求下面的地址。 请求返回了一个 json 包含了这个视频的一些信息，其中有一个去水印的关键参数 uri 到这里，抖音官方的流程就走完了。 3. 如何去水印？原理：并不是用高大上的人工智障或者类似 ps 去掉某一个地方的水印，而是抖音会保存一份无水印的视频，我们只需要找到这个无水印视频的地址就可以了。 说完原理，实现就是根据上面获取的字段 uri ,然后拼接在一个抖音存储无水印视频的地址上就完事了。（这个拼接的地址在浏览器上可能访问不了） 看代码吧 实现效果 node.js 代码仓库代码仓库 仅供学习使用 分两种下载模式，浏览器下载和命令行下载 浏览器输入即可下载 (方便提供接口) npm start or node index 使用 代码 工具模式下载到目录(类似命令行工具) node tool 参考mp.weixin.qq.com/s/DF7_b_F1i… gitee.com/goldriver/d…","categories":[],"tags":[]},{"title":"Kotlin与Java的异同","slug":"Kotlin与Java的异同","date":"2020-06-13T21:47:39.000Z","updated":"2020-06-15T22:41:45.255Z","comments":true,"path":"2020/06/14/KotlinJava/","link":"","permalink":"https://jiyugithub.github.io/2020/06/14/KotlinJava/","excerpt":"打印日志 Java System.out.print(&quot;hello world&quot;); System.out.println(&quot;hello world&quot;); Kotlin print(&quot;hello world&quot;) println(&quot;hello world&quot;)","text":"打印日志 Java System.out.print(&quot;hello world&quot;); System.out.println(&quot;hello world&quot;); Kotlin print(&quot;hello world&quot;) println(&quot;hello world&quot;) 定义变量与常量常 Java String name = &quot;hello world&quot;; final String name = &quot;hello world&quot;; Kotlin var name = &quot;hello world&quot; val name = &quot;hello world&quot; null声明 Java String otherName; otherName = null; Kotlin var otherName : String? otherName = null 空判断 Java if (text != null) { int length = text.length(); } Kotlin text?.let { val length = text.length } // or simply val length = text?.length 字符串拼接 Java String firstName = &quot;Android&quot;; String lastName = &quot;Architect&quot;; String message = &quot;My name is: &quot; + firstName + &quot; &quot; + lastName; Kotlin val firstName = &quot;Android&quot; val lastName = &quot;Architect&quot; val message = &quot;My name is: $firstName $lastName&quot; 换行 Java String text = &quot;First Line\\n&quot; + &quot;Second Line\\n&quot; + &quot;Third Line&quot;; Kotlin val text = &quot;&quot;&quot; |First Line |Second Line |Third Line &quot;&quot;&quot;.trimMargin() 三元表达式 Java String text = x &gt; 5 ? &quot;x &gt; 5&quot; : &quot;x &lt;= 5&quot;; Kotlin val text = if (x &gt; 5) &quot;x &gt; 5&quot; else &quot;x &lt;= 5&quot; 操作符 java final int andResult = a &amp; b; final int orResult = a | b; final int xorResult = a ^ b; final int rightShift = a &gt;&gt; 2; final int leftShift = a &lt;&lt; 2; final int unsignedRightShift = a &gt;&gt;&gt; 2; Kotlin val andResult = a and b val orResult = a or b val xorResult = a xor b val rightShift = a shr 2 val leftShift = a shl 2 val unsignedRightShift = a ushr 2 类型判断和转换 (声明式) Java Car car = (Car) object; Kotlin var car = object as Car 类型判断和转换 (隐式) Java if (object instanceof Car) { Car car = (Car) object; } Kotlin if (object is Car) { var car = object // 自动识别 } 多重条件 Java if (score &gt;= 0 &amp;&amp; score &lt;= 300) { } Kotlin if (score in 0..300) { } 更灵活的case语句 Java int score = // some score; String grade; switch (score) { case 10: case 9: grade = &quot;Excellent&quot;; break; case 8: case 7: case 6: grade = &quot;Good&quot;; break; case 5: case 4: grade = &quot;OK&quot;; break; case 3: case 2: case 1: grade = &quot;Fail&quot;; break; default: grade = &quot;Fail&quot;; } Kotlin var score = // some score var grade = when (score) { 9, 10 -&gt; &quot;Excellent&quot; in 6..8 -&gt; &quot;Good&quot; 4, 5 -&gt; &quot;OK&quot; in 1..3 -&gt; &quot;Fail&quot; else -&gt; &quot;Fail&quot; } for循环 Java for (int i = 1; i &lt;= 10 ; i++) { } for (int i = 1; i &lt; 10 ; i++) { } for (int i = 10; i &gt;= 0 ; i--) { } for (int i = 1; i &lt;= 10 ; i+=2) { } for (int i = 10; i &gt;= 0 ; i-=2) { } for (String item : collection) { } for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) { } Kotlin for (i in 1..10) { } for (i in 1 until 10) { } for (i in 10 downTo 0) { } for (i in 1..10 step 2) { } for (i in 10 downTo 0 step 2) { } for (item in collection) { } for ((key, value) in map) { } 更方便的集合操作 Java final List&lt;Integer&gt; listOfNumber = Arrays.asList(1, 2, 3, 4); final Map&lt;Integer, String&gt; keyValue = new HashMap&lt;Integer, String&gt;(); map.put(1, &quot;Android&quot;); map.put(2, &quot;Ali&quot;); map.put(3, &quot;Mindorks&quot;); // Java 9 final List&lt;Integer&gt; listOfNumber = List.of(1, 2, 3, 4); final Map&lt;Integer, String&gt; keyValue = Map.of(1, &quot;Android&quot;, 2, &quot;Ali&quot;, 3, &quot;Mindorks&quot;); Kotlin val listOfNumber = listOf(1, 2, 3, 4) val keyValue = mapOf(1 to &quot;Android&quot;, 2 to &quot;Ali&quot;, 3 to &quot;Mindorks&quot;) 遍历 Java // Java 7 and below for (Car car : cars) { System.out.println(car.speed); } // Java 8+ cars.forEach(car -&gt; System.out.println(car.speed)); // Java 7 and below for (Car car : cars) { if (car.speed &gt; 100) { System.out.println(car.speed); } } // Java 8+ cars.stream().filter(car -&gt; car.speed &gt; 100).forEach(car -&gt; System.out.println(car.speed)); Kotlin cars.forEach { println(it.speed) } cars.filter { it.speed &gt; 100 } .forEach { println(it.speed)} 方法定义 Java void doSomething() { // logic here } void doSomething(int... numbers) { // logic here } Kotlin fun doSomething() { // logic here } fun doSomething(vararg numbers: Int) { // logic here } 带返回值的方法 Java int getScore() { // logic here return score; } Kotlin fun getScore(): Int { // logic here return score } // as a single-expression function fun getScore(): Int = score 无结束符号 Java int getScore(int value) { // logic here return 2 * value; } Kotlin fun getScore(value: Int): Int { // logic here return 2 * value } // as a single-expression function fun getScore(value: Int): Int = 2 * value constructor 构造器 Java public class Utils { private Utils() { // This utility class is not publicly instantiable } public static int getScore(int value) { return 2 * value; } } Kotlin class Utils private constructor() { companion object { fun getScore(value: Int): Int { return 2 * value } } } // another way object Utils { fun getScore(value: Int): Int { return 2 * value } } Get Set 构造器 Java public class Developer { private String name; private int age; public Developer(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } Kotlin data class Developer(val name: String, val age: Int) 参考 慕课网移动端架构师成长体系课","categories":[],"tags":[]},{"title":"炫酷！从未见过如此Q弹的Switcher","slug":"炫酷！从未见过如此Q弹的Switcher","date":"2020-06-13T18:40:38.000Z","updated":"2020-06-13T20:44:26.122Z","comments":true,"path":"2020/06/14/switcher/","link":"","permalink":"https://jiyugithub.github.io/2020/06/14/switcher/","excerpt":"前言最近逛Dribbble的时候，看到了一个非常酷的Switcher动画，特别喜欢，本想着试着用代码在Android平台来实现一下，没想到已经有实现的版本，并且作者还写了文章分享，思路清晰，各个实现关键点都讲的特别清楚，因此就译诚中文，分享大家，正如作者最后所说，大家一定要运行试试，效果非常赞！ 原作者：Alexander Kolpakov 译者：依然范特稀西 地址：http://suo.im/60UJjT","text":"前言最近逛Dribbble的时候，看到了一个非常酷的Switcher动画，特别喜欢，本想着试着用代码在Android平台来实现一下，没想到已经有实现的版本，并且作者还写了文章分享，思路清晰，各个实现关键点都讲的特别清楚，因此就译诚中文，分享大家，正如作者最后所说，大家一定要运行试试，效果非常赞！ 原作者：Alexander Kolpakov 译者：依然范特稀西 地址：http://suo.im/60UJjT 正文开始最近，我写了一篇关于实现Dribbble上的一个漂亮设计的文章。得到了很多积极的反馈，对我来说，这给了我很大的动力。我非常高兴能获得这些反馈，同时我也很乐意分享我的经验。 在本文中，我们将尝试逐步实现由Oleg Frolov创建的另一个精美的动画。这与上一篇文章中的复杂动画UI无关，它是一个自定义小控件。但是它有着非常精美漂亮的动画设计，如下所示： swicher.gif 乍一看，实现这样的切换似乎并不简单，但我认为那是因为动画非常漂亮。如 你所见，创建相同的动画并不难。让我们一步一步地来实现它。 第一步，我们需要自定义View,并且实现它的3个构造方法： class Switcher @JvmOverloads constructor( context: Context, attrs: AttributeSet ? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { init { attrs?.let { retrieveAttributes(attrs, defStyleAttr) } } private fun retrieveAttributes(attrs: AttributeSet, defStyleAttr: Int) { // retrieve cutom attributes } override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { // setup switcher width and height } override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) { // setup helper sizes every time switcher size changed (radius, icon width...) } override fun onDraw(canvas: Canvas ?) { // just draw } } 接下来开始绘制在默认（选中）状态下，我们的开关由2个圆角矩形（绿色和白色）组成 绘制它们非常简单，我们只需要计算白色矩形的位置并将偏移量iconTranslateX传递给Android KTX Canvas.withTranslation扩展即可： override fun onDraw(canvas: Canvas ?) { // draw switcher (green rect) canvas?.drawRoundRect(switcherRect, switcherCornerRadius, switcherCornerRadius, switcherPaint) // draw icon (white rect) canvas?.withTranslation(x = iconTranslateX) { drawRoundRect(iconRect, switcherCornerRadius, switcherCornerRadius, iconPaint) } } 开始分解动画动画部分，我们使用ValueAnimator来实现，使用它的ofFloat(float... values)方法,我们需要三个动画： 1、switcherAnimator: 切换器图标动画，从白色矩形到圆形，反之亦然 2、translateAnimator: 为切换器图标从左到右的过渡设置动画，反之亦然； 3、colorAnimator: 将颜色从绿色（选中）更改为红色，反之亦然。 让我们先看一下switcherAnimator动画，设置0为动画的开始值，1为动画的结束值。 // ... var amplitude = BOUNCE_ANIM_AMPLITUDE_IN var frequency = BOUNCE_ANIM_FREQUENCY_IN var newProgress = 1f if (!checked) { amplitude = BOUNCE_ANIM_AMPLITUDE_OUT frequency = BOUNCE_ANIM_FREQUENCY_OUT newProgress = 0f } val switcherAnimator = ValueAnimator.ofFloat(iconProgress, newProgress).apply { addUpdateListener { iconProgress = it.animatedValue as Float } interpolator = BounceInterpolator(amplitude, frequency) duration = SWITCHER_ANIMATION_DURATION } // ... 我们可以使用 Evgenii Neumerzhitckii 写的BounceInterpolator来实现反弹效果，这非常适合我们的动画场景，不了解的可以看一下这片文章：evgenii.com/blog/spring…，它解释了BounceInterpolator是如何工作的。 在Android KTX addUpdateListener扩展中，我们更新了progress的值，然后触发invalidate方法，最后重新绘制了视图。 private var iconProgress = 0f set(value) { if (field != value) { field = value val iconOffset = lerp(0f, iconRadius - iconCollapsedWidth / 2, value) iconRect.left = width - switcherCornerRadius - iconCollapsedWidth / 2 - iconOffset iconRect.right = width - switcherCornerRadius + iconCollapsedWidth / 2 + iconOffset postInvalidateOnAnimation() } } lerp方法类似一个线性插值器，它用于计算iconOffset,反过来，它也用于计算Swicher图标的圆角矩形坐标。此图标的矩形从一个圆角矩形变为一个圆形（圆角半径较大的圆角矩形）。 我们使用了postInvalidateOnAnimation()代替postIvalidate,是因为我们需要平滑的动画，并且第一个方法有优势，详情请看：stackoverflow.com/questions/2… translateAnimator的工作方式相同，但是会更新Swicher图标的x位置。 如你所见，我们的白色圆圈就像百吉饼。我们有2种制作方法： 裁剪一个较小的圆圈 最简单的圆圈，只需在顶部绘制另一个小圆圈，然后用切换器颜色填充即可。 我选择较简单的一种。 这一切，没什么难的！我们现在有一个漂亮的自定义小控件并且带有精美的动画！ 至此，我们一切都可以了现在，我们可以使用任何类型的动画来创建自定义视图，而且我们可以稍微更改代码以创建另一个由Oleg Frolov设计的Swicher小部件。仅需将视图轮廓从圆角矩形更新为圆形，并禁用平移动画。就是这么简单。 swicherX.gif Talk is Chep，Just show Code随意获取GitHub上的源代码，查看我的其他实现，别忘了尝试一下！ Github: github.com/bitvale/Swi…","categories":[{"name":"Category1","slug":"Category1","permalink":"https://jiyugithub.github.io/categories/Category1/"},{"name":"Category2","slug":"Category1/Category2","permalink":"https://jiyugithub.github.io/categories/Category1/Category2/"}],"tags":[{"name":"Tag1","slug":"Tag1","permalink":"https://jiyugithub.github.io/tags/Tag1/"},{"name":"Tag2","slug":"Tag2","permalink":"https://jiyugithub.github.io/tags/Tag2/"}]},{"title":"Kotlin实战 | 语法糖","slug":"Kotlin实战-语法糖","date":"2020-06-13T18:15:46.000Z","updated":"2020-06-13T20:41:39.527Z","comments":true,"path":"2020/06/14/Kotlinyf/","link":"","permalink":"https://jiyugithub.github.io/2020/06/14/Kotlinyf/","excerpt":"学习了 Kotlin 后，写代码时常有一种“闹革命”的冲动，总是希望运用语法糖推翻“旧世界”（这样不好，项目会 delay 的~）。本文归纳了 Kotlin 语法糖在项目实战中的综合运用，以实际问题为索引，在分析解决方案的同时介绍相关语法知识。","text":"学习了 Kotlin 后，写代码时常有一种“闹革命”的冲动，总是希望运用语法糖推翻“旧世界”（这样不好，项目会 delay 的~）。本文归纳了 Kotlin 语法糖在项目实战中的综合运用，以实际问题为索引，在分析解决方案的同时介绍相关语法知识。 将 px 值转换成 dp 值在非 xml 环境下构建布局，需要将 px 转换为 dp 来进行多屏幕适配。Java 的做法是在Util类中新增一个静态函数。利用 Kotlin 的扩展属性可以更简洁地实现： val Int.dp: Int get() { return TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, this.toFloat(), Resources.getSystem().displayMetrics ).toInt() } 为 Int 扩展一个属性dp，它的类型是 Int。在get()中定义该属性的取值算法。 然后就可以像这样动态地将 Int 值 dp 化： viewGroup.addView( textView, LayoutParam( 40.dp, 50.dp ) ) 弃用Builder模式当构造复杂对象时，需要很多参数，如果将所有参数都通过一个构造函数来传递，缺乏灵活性，但如果重载若干个带有不同参数的构造函数，代码就变得臃肿。Builder 模式可以简化构建过程。 在 Java 中 Builder模式 代码如下： public class Person { //&#39;必选参数&#39; private String name; //&#39;以下都是可选参数&#39; private int gender; private int age; private int height; private int weight; //&#39;私有构造函数，限制必须通过构造者构建对象&#39; private Person(Builder builder) { this.name = builder.name; this.gender = builder.gender; this.age = builder.age; this.height = builder.height; this.weight = builder.weight; } //&#39;构造者&#39; public static class Builder { private String name; private int gender; private int age; private int height; private int weight; //&#39;必选参数必须在构造函数中传入&#39; public Builder(String name) { this.name = name; } //&#39;以下是每个非必要属性的设值函数，它返回构造者本身用于链式调用&#39; public Builder age(int age) { this.age = age; return this; } public Builder gender(int gender) { this.gender = gender; return this; } public Builder height(int height) { this.height = height; return this; } public Builder weight(int weight) { this.weight = weight; return this; } //&#39;构建对象&#39; public Person build() { return new Person(this); } } 然后就可以像这样构建Person实例： //&#39;使用 Builder模式&#39; Person p = new Person.Builder(&quot;taylor&quot;) .age(50) .gender(1) .weight(43) .build(); //&#39;使用构造函数&#39; Person p2 = new Person(&quot;taylor&quot;, 50, 1, 0, 43); 对比之下，Builder模式 有两个优势： 为参数标注语义：在Builder模式中，每个属性的赋值都是一个函数，函数名标注了属性语义。而直接使用构造函数时，很难分辨50，43哪个是年龄，哪个是体重。 可选参数：Builder模式中，除了必选参数，其他参数是可选的。但直接使用构造函数必须为所有参数赋值，比如上例中第四个参数身高被赋值为0。 但 Builder模式 也有代价，新增了一个中间类Builder。 使用 Kotlin 的命名参数+参数默认值+数据类语法，在没有任何副作用的情况下就能实现 Builder模式： //&#39;将Person定义为数据类&#39; data class Person( var name: String, //&#39;为以下可选参数设置默认值&#39; var gender: Int = 1, var age: Int= 0, var height: Int = 0, var weight: Int = 0 ) //&#39;使用命名参数构建Person实例&#39; val p = Person(name = “taylor”,gender = 1,weight = 43) 关于数据类、参数默认值、命名参数更详细的介绍可以点击这里 如果想增加参数约束条件可以调用require()方法： data class Person( var name: String, var gender: Int = 1, var age: Int= 0, var height: Int = 0, var weight: Int = 0 ){ //&#39;在构造函数被调用的时候执行参数合法检查&#39; init { require(name.isNotEmpty()){”name cant be empty“} } } 此时如果像下面这样构造 Person，则会抛出异常： val p = Person(name=&quot;&quot;,gender = 1) java.lang.IllegalArgumentException: name cant be empty 打印列表、map调试程序时，经常需要打印列表内容，通常会这样打印： for (String str:list) { Log.v(&quot;test&quot;, &quot;str=&quot;+str); } 不同业务界面的数据类型不同，为了调试，这样的 for 循环就会散落在各处，而且列表内容会分若干条 log 输出，中间极有可能被别的log打断。 有没有一个函数可以打印包含任意数据类型的列表，并将列表内容组织成更具可读性的字符串？ 用 Kotlin 的扩展函数+泛型+高阶函数就能优雅地做到： fun &lt;T&gt; Collection&lt;T&gt;.print(map: (T) -&gt; String) = StringBuilder(&quot;\\n[&quot;).also { sb -&gt; //&#39;遍历集合元素，通过 map 表达式将元素转换成感兴趣的字串，并独占一行&#39; this.forEach { e -&gt; sb.append(&quot;\\n\\t${map(e)},&quot;) } sb.append(&quot;\\n]&quot;) }.toString() 为集合的基类Collection新增一个扩展函数，它是一个高阶函数，因为它的参数是另一个函数，该函数用 lambda 表示。再把集合元素抽象成泛型。通过StringBuilder将所有集合内容拼接成一个自动换行的字符串。 写段测试代码看下效果： data class Person(var name: String, var age: Int) val persons = listOf( Person(&quot;Peter&quot;, 16), Person(&quot;Anna&quot;, 28), Person(&quot;Anna&quot;, 23), Person(&quot;Sonya&quot;, 39) ) persons.print { &quot;${it.name}_${it.age}&quot; }.let { Log.v(&quot;test&quot;,it) } 打印结果如下： V/test: [ Peter_16, Anna_28, Anna_23, Sonya_39, ] 同样地，可以如法炮制一个打印 map 的扩展函数： fun &lt;K, V&gt; Map&lt;K, V?&gt;.print(map: (V?) -&gt; String): String = StringBuilder(&quot;\\n{&quot;).also { sb -&gt; this.iterator().forEach { entry -&gt; sb.append(&quot;\\n\\t[${entry.key}] = ${map(entry.value)}&quot;) } sb.append(&quot;\\n}&quot;) }.toString() 将 data 类转换成 map有些数据类字段比较多，调试时，想把它们通通打印出来，在 Java 中，借助于 AndroidStudio 的 toString功能倒是可以方便地生成可读性很高的字串： public class Person { private String name; private int age; @Override public String toString() { return ”Person{“ + ”name=‘“ + name + ’\\” + ”, age=“ + age + ‘}’; } } 但是每新建一个数据类都要手动生成一个toString()方法也挺麻烦。 利用 Kotlin 的 data class可以省去这一步，但打印效果是所有字段都在同一行中： data class Person(var name: String, var age: Int) Log.v(“test”, “person=${Person(&quot;Peter&quot;, 16)}”) //输出如下： V/test: person=Person(name=Peter, age=16) 如果字段很多，把它们都打印在一行中可读性很差。 有没有一种方法，可以读取一个类中所有的字段信息？ 这样我们就可以将他们组织成想要的形状。请看下面这个方法： fun Any.ofMap() = //&#39;过滤掉除data class以外的其他类&#39; this::class.takeIf { it.isData } //&#39;遍历类的所有成员，过滤掉成员方法，只考虑成员属性&#39; ?.members?.filterIsInstance&lt;KProperty&lt;Any&gt;&gt;() //&#39;将成员属性名和值存储在Pair中&#39; ?.map { it.name to it.call(this) } //&#39;将Pair转换成map&#39; ?.toMap() 为任意 Kotlin 中的类添加一个扩展函数，它的功能是将data class中所有的字段名及其对应值存在一个 map 中。其中用到的 Kotlin 语法糖如下： isData是KClass中的一个属性，用于判断该类是不是一个data class。KClass是 Kotlin 中用来描述 类的类型，KClass可以通过对象::class语法获得。 members也是KClass中的一个属性，它包含了所有类的方法和属性。 filterIsInstance()是Iterable接口的扩展函数，用于过滤出集合中指定的类型。 to是一个infix扩展函数，它的定义如下： public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 带有infix标识的函数只允许带有一个参数，并且在调用时可以省略包裹参数的括号。这种语法叫中缀表达式 写段测试代码，结合上一节的打印 map 函数看下效果： data class Person(var name: String, var age: Int) Person(&quot;Peter&quot;, 16).ofMap()?.print { it.toString() }.let { Log.v(&quot;test&quot;,&quot;$it&quot;) } 测试代码先将Person实例转换成 map，然后打印 map。输出结果如下： V/test: { [age] = 16 [name] = Peter } 若data class嵌套会发生什么？ //&#39;位置，嵌套在Person类中&#39; data class Location(var x: Int, var y: Int) data class Person(var name: String, var age: Int, var locaton: Location? = null) Person(&quot;Peter&quot;, 16, Location(20, 30)).ofMap()?.print { it.toString() }.let { Log.v(&quot;test&quot;, &quot;$it&quot;) } //&#39;打印结果如下&#39; { [age] = 16 [locaton] = Location(x=20, y=30) [name] = Peter } 期望得到类似 Json 的打印效果，但输出结果还差一点。是因为将Person转化成Map时并没有将嵌套的Location也转化成键值对。 需要将ofMap()方法重构成递归调用： fun Any.ofMap(): Map&lt;String, Any?&gt;? { return this::class.takeIf { it.isData } ?.members?.filterIsInstance&lt;KProperty&lt;Any&gt;&gt;() ?.map { member -&gt; val value = member.call(this)?.let { v-&gt; //&#39;若成员变量是data class，则递归调用ofMap()，将其转化成键值对，否则直接返回值&#39; if (v::class.isData) v.ofMap() else v } member.name to value } ?.toMap() } 为了让打印结果也有嵌套缩进效果，打印 Map 的函数也需要相应地重构： /** * 打印 Map，生成结构化键值对子串 * @param space 行缩进量 */ fun &lt;K, V&gt; Map&lt;K, V?&gt;.print(space: Int = 0): String { //&#39;生成当前层次的行缩进，用space个空格表示，当前层次每一行内容都需要带上缩进&#39; val indent = StringBuilder().apply { repeat(space) { append(&quot; &quot;) } }.toString() return StringBuilder(&quot;\\n${indent}{&quot;).also { sb -&gt; this.iterator().forEach { entry -&gt; //&#39;如果值是 Map 类型，则递归调用print()生成其结构化键值对子串，否则返回值本身&#39; val value = entry.value.let { v -&gt; (v as? Map&lt;*, *&gt;)?.print(&quot;${indent}${entry.key} = &quot;.length) ?: v.toString() } sb.append(&quot;\\n\\t${indent}[${entry.key}] = $value,&quot;) } sb.append(&quot;\\n${indent}}&quot;) }.toString() } 写段测试代码，看看效果： //&#39;坐标类，嵌套在Location类中&#39; data class Coordinate(var x: Int, var y: Int) //&#39;位置类，嵌套在Person类中&#39; data class Location(var country: String, var city: String, var coordinate: Coordinate) data class Person(var name: String, var age: Int, var locaton: Location? = null) Person(&quot;Peter&quot;, 16, Location(&quot;china&quot;, &quot;shanghai&quot;, Coordinate(10, 20))).ofMap()?.print().let { Log.v(&quot;test&quot;, &quot;$it&quot;) } //&#39;打印如下&#39; { [age] = 16, [locaton] = { [city] = shanghai, [coordinate] = { [x] = 10, [y] = 20, }, [country] = china, }, [name] = Peter, } 获取当前周一和周日Java 系统默认一周的第一天是周日，最后一天是周六。 若需要做类似“一周一次提醒”的功能，就可以本地化提醒时间，然后在每次触发提醒时把它和当前周一作比较，大于则说明本周已提醒。 fun thisMondayInMillis() = Calendar.getInstance().let { c -&gt; //&#39;如果当前是周天，则减一天，计算周六所在周的周一&#39; if (c.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) c.add(Calendar.DATE, -1) c.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY) c.set(Calendar.HOUR_OF_DAY, 0) c.set(Calendar.MINUTE, 0) c.set(Calendar.SECOND, 0) c.set(Calendar.MILLISECOND, 0) c.timeInMillis } fun thisSundayInMillis() = Calendar.getInstance().let { c -&gt; //&#39;如果不是周天，则将日期调整到当前周的周六，然后在加一天&#39; if (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) { c.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY) c.add(Calendar.DATE, 1) } c.set(Calendar.HOUR_OF_DAY, 0) c.set(Calendar.MINUTE, 0) c.set(Calendar.SECOND, 0) c.set(Calendar.MILLISECOND, 0) c.timeInMillis } RecyclerView表项点击监听器RecyclerView没有子控件点击事件监听器，那就用Kotlin扩展方法扩展一个： //&#39;为 RecyclerView 扩展表项点击监听器&#39; fun RecyclerView.setOnItemClickListener(listener: (View, Int) -&gt; Unit) { //&#39;为 RecyclerView 子控件设置触摸监听器&#39; addOnItemTouchListener(object : RecyclerView.OnItemTouchListener { //&#39;构造手势探测器，用于解析单击事件&#39; val gestureDetector = GestureDetector(context, object : GestureDetector.OnGestureListener { override fun onShowPress(e: MotionEvent?) { } override fun onSingleTapUp(e: MotionEvent?): Boolean { //&#39;当单击事件发生时，寻找单击坐标下的子控件，并回调监听器&#39; e?.let { findChildViewUnder(it.x, it.y)?.let { child -&gt; listener(child, getChildAdapterPosition(child)) } } return false } override fun onDown(e: MotionEvent?): Boolean { return false } override fun onFling(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean { return false } override fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean { return false } override fun onLongPress(e: MotionEvent?) { } }) override fun onTouchEvent(rv: RecyclerView, e: MotionEvent) { } //&#39;在拦截触摸事件时，解析触摸事件&#39; override fun onInterceptTouchEvent(rv: RecyclerView, e: MotionEvent): Boolean { gestureDetector.onTouchEvent(e) return false } override fun onRequestDisallowInterceptTouchEvent(disallowIntercept: Boolean) { } }) }","categories":[],"tags":[]},{"title":"2020年GitHub 上那些优秀Android开源库","slug":"2020年GitHub-上那些优秀Android开源库","date":"2020-06-13T17:59:27.000Z","updated":"2020-06-13T20:38:45.128Z","comments":true,"path":"2020/06/14/Top10/","link":"","permalink":"https://jiyugithub.github.io/2020/06/14/Top10/","excerpt":"2020年有哪些优秀的开源库呢？本期就为大家带精选的10个，排名不分先后。","text":"2020年有哪些优秀的开源库呢？本期就为大家带精选的10个，排名不分先后。 No1. LiquidSwipe这是一个很棒的ViewPager库，它在浏览ViewPager的不同页面时，显示波浪的滑动动画，效果非常炫酷。该库的USP是触摸交互的。这意味着在视图中显示类似液体的显示过渡时，应考虑触摸事件。 1.1如何使用呢？导入以下Gradle依赖项: implementation &#39;com.github.Chrisvin:LiquidSwipe:1.3&#39; 然后将LiquidSwipeLayout添加为保存fragment布局的容器的根布局： &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.jem.liquidswipe.LiquidSwipeViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1.2 效果图 效果1 效果2 更多详细使用方法请看Github: github.com/Chrisvin/Li… No2. FlourishFlourish提供了一个炫酷的方式来显示或者隐藏一个布局，实现方式也很简单，就是对View或者布局进行了包装，通过构建者模式来提供api给上层调用。就像使用dialog一样，调用show和dissmiss方法来显示和隐藏。此外，通过这些类，我们还可以自定义动画（正常，加速，反弹），或为布局方向设置我们自己的起点（左上，右下等）。 2.1 如何使用？在build.gradle 中添加如下依赖： dependencies { implementation &quot;com.github.skydoves:flourish:1.0.0&quot; } 然后在代码中，构建布局： Flourish flourish = new Flourish.Builder(parentLayout) // sets the flourish layout for showing and dismissing on the parent layout. .setFlourishLayout(R.layout.layout_flourish_main) // sets the flourishing animation for showing and dismissing. .setFlourishAnimation(FlourishAnimation.BOUNCE) // sets the orientation of the starting point. .setFlourishOrientation(FlourishOrientation.TOP_LEFT) // sets a flourishListener for listening changes. .setFlourishListener(flourishListener) // sets the flourish layout should be showed on start. .setIsShowedOnStart(false) // sets the duration of the flourishing. .setDuration(800L) .build(); 还提供有更简介的DSL: val myFlourish = createFlourish(parentLayout) { setFlourishLayout(R.layout.layout_flourish_main) setFlourishAnimation(FlourishAnimation.ACCELERATE) setFlourishOrientation(FlourishOrientation.TOP_RIGHT) setIsShowedOnStart(true) setFlourishListener { } } 2.2 效果图 效果1 效果2 更多详细使用请看Github：github.com/skydoves/Fl… No3. AestheticDialogs这是一个美观而时尚的AlterDialog库，目前可支持六种不同的对话框,如： Flash Dialog Connectify Dialog Toaster Dialog Emotion Dialog Drake Dialog Emoji Dialog 并且啊，还提供了暗黑模式的适配。 3.1 如何使用？在build.gradle 中添加如下依赖： dependencies { ... implementation &#39;com.github.gabriel-TheCode:AestheticDialogs:1.1.0&#39; } 代码中，显示不同种类的对话框则调用对应的方法就好 Flash: AestheticDialog.showFlashDialog(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showFlashDialog(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); Connectify: AestheticDialog.showConnectify(this,&quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showConnectify(this, &quot;Your message&quot;, AestheticDialog.ERROR); /// Dark Theme AestheticDialog.showConnectifyDark(this,&quot;Your message&quot;,AestheticDialog.SUCCESS); AestheticDialog.showConnectifyDark(this, &quot;Your message&quot;, AestheticDialog.ERROR); Toaster: AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING); AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO); /// Dark Theme AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING); AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO); Drake : AestheticDialog.showDrake(this, AestheticDialog.SUCCESS); AestheticDialog.showDrake(this, AestheticDialog.ERROR); Emoji : AestheticDialog.showEmoji(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showEmoji(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); /// Dark Theme AestheticDialog.showEmojiDark(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showEmojiDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); Emotion : AestheticDialog.showEmotion(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showEmotion(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); Rainbow : AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS); AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR); AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING); AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO); 3.2 效果如下 Flash Dialog Connectify Dialog Toaster Dialog Emotion Dialog Drake Dialog Emoji Dialog 更多详情使用方法请看Github：github.com/gabriel-The… N4. EasyReveal从名字就知道，这是一个提供reveal动画效果的库，它的厉害之处在于可以提供不同尺寸、不同形状的reveal动画，并且还可以在定义它在屏幕任意位置开始和结束动画。 4.1 如何使用？在build.gradle 中添加如下依赖： dependencies { ... implementation &#39;com.github.Chrisvin:EasyReveal:1.2&#39; } 然后，xml中，需要添加显示或者隐藏动画的View应该包裹在EasyRevealLinearLayout中： &lt;com.jem.easyreveal.layouts.EasyRevealLinearLayout ... app:clipPathProvider=&quot;star&quot; // possible values: circular, linear, random_line, star, sweep &amp; wave app:revealAnimationDuration=&quot;2000&quot; app:hideAnimationDuration=&quot;1500&quot; &gt; &lt;!-- The views to be revealed/hidden go here --&gt; &lt;/com.jem.easyreveal.layouts.EasyRevealLinearLayout&gt; &lt;!-- Similarly for com.jem.easyreveal.layouts.EasyRevealConstraintLayout &amp; com.jem.easyreveal.layouts.EasyRevealFrameLayout --&gt; 也可以在代码中添加： val revealLayout = EasyRevealLinearLayout(this) // Set the ClipPathProvider that is used to clip the view for reveal animation revealLayout.clipPathProvider = StarClipPathProvider(numberOfPoints = 6) // Set the duration taken for reveal animation revealLayout.revealAnimationDuration = 1500 // Set the duration taken for hide animation revealLayout.hideAnimationDuration = 2000 // Set listener to get updates during reveal/hide animation revealLayout.onUpdateListener = object: RevealLayout.OnUpdateListener { override fun onUpdate(percent: Float) { Toast.makeText(this@MainActivity, &quot;Revealed percent: $percent&quot;, Toast.LENGTH_SHORT).show() } } // Start reveal animation revealLayout.reveal() // Start hide animation revealLayout.hide() 4.2效果图 Emotion Dialog Drake Dialog Emoji Dialog 更多详细使用信息请看Github： github.com/Chrisvin/Ea… No5. Android ColorXAndroid ColorX 以Kotlin 扩展函数的形式提供了一些重要的获取颜色的方法。 通过提供不同颜色格式（RGB，HSV，CYMK等）的转换功能，它使开发变得更加轻松。该库的USP具有以下功能： 颜色的不同阴影和色调。 较深和较浅的阴影。 颜色的补码 5.1 如何使用？在build.gradle 中添加如下依赖： dependencies { implementation &#39;me.jorgecastillo:androidcolorx:0.2.0&#39; } 在代码中，一系列的转换方法： val color = Color.parseColor(&quot;#e91e63&quot;) val rgb = color.asRgb() val argb = color.asArgb() val hex = color.asHex() val hsl = color.asHsl() val hsla = color.asHsla() val hsv = color.asHsv() val cmyk = color.asCmyk() val colorHsl = HSLColor(hue = 210f, saturation = 0.5f, lightness = 0.5f) val colorInt = colorHsl.asColorInt() val rgb = colorHsl.asRgb() val argb = colorHsl.asArgb() val hex = colorHsl.asHex() val cmyk = colorHsl.asCmyk() val hsla = colorHsl.asHsla() val hsv = colorHsl.asHsv() 5.2 效果图 更多详细使用信息请看Github：github.com/JorgeCastil… No6. AnimatedBottomBar这是一个带动画的底部导航栏库。它使你可以以编程方式以及通过XML添加和删除选项卡。此外，我们可以轻松地从BottomBar拦截选项卡。限制访问应用程序导航中的高级区域时，“拦截”标签非常有用。流畅的动画提供了许多自定义选项，从动画插值器到设置波纹效果。 6.1 如何使用？在build.gradle 中添加如下依赖： dependencies { implementation &#39;nl.joery.animatedbottombar:library:1.0.8&#39; } 在xml文件中添加AnimatedBottomBar和自定义属性 &lt;nl.joery.animatedbottombar.AnimatedBottomBar android:id=&quot;@+id/bottom_bar&quot; android:background=&quot;#FFF&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:abb_selectedTabType=&quot;text&quot; app:abb_indicatorAppearance=&quot;round&quot; app:abb_indicatorMargin=&quot;16dp&quot; app:abb_indicatorHeight=&quot;4dp&quot; app:abb_tabs=&quot;@menu/tabs&quot; app:abb_selectedIndex=&quot;1&quot; /&gt; 在res/menu目录下定义tabs.xml文件： &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/tab_home&quot; android:icon=&quot;@drawable/home&quot; android:title=&quot;@string/home&quot; /&gt; &lt;item android:id=&quot;@+id/tab_alarm&quot; android:icon=&quot;@drawable/alarm&quot; android:title=&quot;@string/alarm&quot; /&gt; &lt;item android:id=&quot;@+id/tab_bread&quot; android:icon=&quot;@drawable/bread&quot; android:title=&quot;@string/bread&quot; /&gt; &lt;item android:id=&quot;@+id/tab_cart&quot; android:icon=&quot;@drawable/cart&quot; android:title=&quot;@string/cart&quot; /&gt; &lt;/menu&gt; 最后，代码中添加tab // Creating a tab by passing values val bottomBarTab1 = AnimatedBottomBar.createTab(drawable, &quot;Tab 1&quot;) // Creating a tab by passing resources val bottomBarTab2 = AnimatedBottomBar.createTab(R.drawable.ic_home, R.string.tab_2, R.id.tab_home) 6.2 效果图 tab1 tab2 详情信息请看Github: github.com/Droppers/An… No7. RateBottomSheet有时候，为了推广我们的应用，我们需要让用户跳转到应用商店为我们的APP打分，传统的对话框用户体验很不好，而本库则是用BottomSheet来进行提示，它位于底部缩略区域，用户体验很好。 7.1 如何使用呢？在build.gradle 中添加如下依赖： dependencies { implementation &#39;com.mikhaellopez:ratebottomsheet:1.1.0&#39; } 然后修改默认的string资源文件来改变显示文案： &lt;resources&gt; &lt;string name=&quot;rate_popup_ask_title&quot;&gt;Like this App?&lt;/string&gt; &lt;string name=&quot;rate_popup_ask_message&quot;&gt;Do you like using this application?&lt;/string&gt; &lt;string name=&quot;rate_popup_ask_ok&quot;&gt;Yes I do&lt;/string&gt; &lt;string name=&quot;rate_popup_ask_no&quot;&gt;Not really&lt;/string&gt; &lt;string name=&quot;rate_popup_title&quot;&gt;Rate this app&lt;/string&gt; &lt;string name=&quot;rate_popup_message&quot;&gt;Would you mind taking a moment to rate it? It won\\&#39;t take more than a minute. Thanks for your support!&lt;/string&gt; &lt;string name=&quot;rate_popup_ok&quot;&gt;Rate it now&lt;/string&gt; &lt;string name=&quot;rate_popup_later&quot;&gt;Remind me later&lt;/string&gt; &lt;string name=&quot;rate_popup_no&quot;&gt;No, thanks&lt;/string&gt; &lt;/resources&gt; 代码中使用： RateBottomSheetManager(this) .setInstallDays(1) // 3 by default .setLaunchTimes(2) // 5 by default .setRemindInterval(1) // 2 by default .setShowAskBottomSheet(false) // True by default .setShowLaterButton(false) // True by default .setShowCloseButtonIcon(false) // True by default .monitor() // Show bottom sheet if meets conditions // With AppCompatActivity or Fragment RateBottomSheet.showRateBottomSheetIfMeetsConditions(this) 7.2 效果图 更多详情请看Github:github.com/lopspower/R… No8. TransformationLayout这是一个用于Activity或者Fragment 以及View切换的过渡动画库，效果非常炫，它使用Material Design的运动系统过渡模式来创建变形动画。该库提供了用于绑定目标视图，设置淡入淡出和路径运动方向以及许多其他自定义选项的属性。 8.1 如何使用？在build.gradle 中添加如下依赖： dependencies { implementation &quot;com.github.skydoves:transformationlayout:1.0.4&quot; } 然后，需要将我们需要添加过渡动画的View包裹到 TransformationLayout: &lt;com.skydoves.transformationlayout.TransformationLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:transformation_targetView=&quot;@+id/my_cardView&quot; // sets a target view. app:transformation_duration=&quot;450&quot; // sets a duration of the transformation. app:transformation_direction=&quot;auto&quot; // auto, entering, returning app:transformation_fadeMode=&quot;in&quot; // in, out, cross, through app:transformation_fitMode=&quot;auto&quot; // auto, height, width app:transformation_pathMode=&quot;arc&quot; // arc, linear &gt; &lt;!-- other views --&gt; &lt;/com.skydoves.transformationlayout.TransformationLayout&gt; 比如我们要将一个fab 过渡到一个card卡片，布局如下： &lt;com.skydoves.transformationlayout.TransformationLayout android:id=&quot;@+id/transformationLayout&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:transformation_duration=&quot;550&quot; app:transformation_targetView=&quot;@+id/myCardView&quot;&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:backgroundTint=&quot;@color/colorPrimary&quot; android:src=&quot;@drawable/ic_write&quot;/&gt; &lt;/com.skydoves.transformationlayout.TransformationLayout&gt; &lt;com.google.android.material.card.MaterialCardView android:id=&quot;@+id/myCardView&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;312dp&quot; android:layout_marginLeft=&quot;30dp&quot; android:layout_marginTop=&quot;30dp&quot; app:cardBackgroundColor=&quot;@color/colorPrimary&quot; /&gt; 重点来了，绑定视图，将一个targetView绑定到TransformationLayout有2种方式： 通过在xml中指定属性： app:transformation_targetView=&quot;@+id/myCardView&quot; 在代码中绑定 transformationLayout.bindTargetView(myCardView) 当我们点击fab时，在监听器中调用startTransform()开始过渡动画，finishTransform（）开始结束动画。 // start transformation when touching the fab. fab.setOnClickListener { transformationLayout.startTransform() } // finish transformation when touching the myCardView. myCardView.setOnClickListener { transformationLayout.finishTransform() } 8.2 效果图 更多使用方式请看Github: github.com/skydoves/Tr… No9. Donut这个一个可以展示多个数据集的圆弧形控件，具有精细的颗粒控制、间隙功能、动画选项以及按比例缩放其值的功能。可以用于项目中的一些数据统计。 9.1 如何使用？在build.gradle 中添加如下依赖： dependencies { implementation(&quot;app.futured.donut:library:$version&quot;) } 然后在布局文件中添加View: &lt;app.futured.donut.DonutProgressView android:id=&quot;@+id/donut_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:donut_bgLineColor=&quot;@color/cloud&quot; app:donut_gapWidth=&quot;20&quot; app:donut_gapAngle=&quot;270&quot; app:donut_strokeWidth=&quot;16dp&quot;/&gt; 然后在代码中设置数据： val dataset1 = DonutDataset( name = &quot;dataset_1&quot;, color = Color.parseColor(&quot;#FB1D32&quot;), amount = 1f ) val dataset2 = DonutDataset( name = &quot;dataset_2&quot;, color = Color.parseColor(&quot;#FFB98E&quot;), amount = 1f ) donut_view.cap = 5f donut_view.submitData(listOf(dataset1, dataset2)) 9.2 效果图 更多用法请看Github: github.com/futuredapp/… No10. CurveGraphViewCurveGraphView 是一个带有炫酷动画统计图表库，除了性能出色并具有许多样式选项之外，该库还支持单个平面内的多个线图。 多个折线图对于比较不同股票，共同基金，加密货币等的价格非常有用。 10.1 如何使用？1、在build.gradle 中添加如下依赖： dependencies { implementation &#39;com.github.swapnil1104:CurveGraphView:{current_lib_ver}&#39; } 2、在xml文件中添加布局： &lt;com.broooapps.graphview.CurveGraphView android:id=&quot;@+id/cgv&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;250dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 然后在代码中添加各种配置项 curveGraphView = findViewById(R.id.cgv); curveGraphView.configure( new CurveGraphConfig.Builder(this) .setAxisColor(R.color.Blue) // Set X and Y axis line color stroke. .setIntervalDisplayCount(7) // Set number of values to be displayed in X ax .setGuidelineCount(2) // Set number of background guidelines to be shown. .setGuidelineColor(R.color.GreenYellow) // Set color of the visible guidelines. .setNoDataMsg(&quot; No Data &quot;) // Message when no data is provided to the view. .setxAxisScaleTextColor(R.color.Black) // Set X axis scale text color. .setyAxisScaleTextColor(R.color.Black) // Set Y axis scale text color .build() );); 3、 提供数据集 PointMap pointMap = new PointMap(); pointMap.addPoint(0, 100); pointMap.addPoint(1, 500); pointMap.addPoint(5, 800); pointMap.addPoint(4, 600); 10.2 效果图 效果1 效果2 更多详细使用方式请看Github: github.com/swapnil1104…","categories":[],"tags":[]},{"title":"Androidx 下 Fragment 懒加载的新实现","slug":"Androidx 下 Fragment 懒加载的新实现","date":"2020-06-13T17:44:42.000Z","updated":"2020-06-13T20:39:55.073Z","comments":true,"path":"2020/06/14/FragmentTransaction/","link":"","permalink":"https://jiyugithub.github.io/2020/06/14/FragmentTransaction/","excerpt":"以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 setUserVisibleHint + onHiddenChanged 这两个函数，而在 Androidx 模式下，我们可以使用 FragmentTransaction.setMaxLifecycle() 的方式来处理 Fragment 的懒加载。","text":"以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 setUserVisibleHint + onHiddenChanged 这两个函数，而在 Androidx 模式下，我们可以使用 FragmentTransaction.setMaxLifecycle() 的方式来处理 Fragment 的懒加载。 在本文章中，我会详细介绍不同使用场景下两种方案的差异。大家快拿好小板凳。一起来学习新知识吧！ 本篇文章涉及到的 Demo，已上传至Github—-&gt;传送门 老的懒加载处理方案 如果你熟悉老一套的 Fragment 懒加载机制，你可以直接查看 Androix 懒加载相关章节 add+show+hide 模式下的老方案在没有添加懒加载之前，只要使用 add+show+hide 的方式控制并显示 Fragment, 那么不管 Fragment 是否嵌套，在初始化后，如果只调用了add+show，同级下的 Fragment 的相关生命周期函数都会被调用。且调用的生命周期函数如下所示： onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume Fragment 完整生命周期：onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroyView -&gt; onDestroy -&gt; onDetach 什么是同级 Frament 呢？看下图 上图中，都是使用 add+show+hide 的方式控制 Fragment, 在上图两种模式中: Fragment_1、Fragment_2、Fragment_3 属于同级 Fragment Fragment_a、Fragment_b、Fragment_c 属于同级 Fragment Fragment_d、Fragment_e、Fragment_f 属于同级 Fragment 那这种方式会带来什么问题呢？结合下图我们来分别分析。 观察上图我们可以发现，同级的Fragment_1、Fragment_2、Fragment_3 都调用了 onAttach...onResume 系列方法，也就是说，如果我们没有对 Fragment 进行懒加载处理，那么我们就会无缘无故的加载一些并不可见的 Fragment , 也就会造成用户流量的无故消耗（我们会在 Fragment 相关生命周期函数中，请求网络或其他数据操作）。 这里&quot;不可见的Fragment&quot;是指，实际不可见但是相关可见生命周期函数(如 onResume 方法）被调用的 Fragment 如果使用嵌套 Fragment ，这种浪费流量的行为就更明显了。以本节的图一为例，当 Fragment_1 加载时，如果你在 Fragment_1 生命周期函数中使用 show+add+hide 的方式添加 Fragment_a、Fragment_b、Fragment_c , 那么 Fragment_b 又会在其生命周期函数中继续加载 Fragment_d、Fragment_e、Fragment_f 。 那如何解决这种问题呢？我们继续接着上面的例子走，当我们 show Fragment_2，并 hide其他 Fragment 时，对应 Fragment 的生命周期调用如下： 从上图中，我们可以看出 Fragment_2 与 Fragment_3 都调用了 onHiddenChanged 函数，该函数的官方 API 声明如下： /** * Called when the hidden state (as returned by {@link #isHidden()} of * the fragment has changed. Fragments start out not hidden; this will * be called whenever the fragment changes state from that. * @param hidden True if the fragment is now hidden, false otherwise. */ public void onHiddenChanged(boolean hidden) { } 根据官方 API 的注释，我们大概能知道，当 Fragment 隐藏的状态发生改变时，该函数将会被调用，如果当前 Fragment 隐藏， hidden 的值为 true, 反之为 false。最为重要的是hidden 的值，可以通过调用 isHidden() 函数获取。 那么结合上述知识点，我们能推导出： 因为 Fragment_1 的 隐藏状态 从可见转为了不可见，所以其 onHiddenChanged 函数被调用，同时 hidden 的值为 true。 同理对于 Fragment_2 ，因为其 隐藏状态 从 不可见转为了可见 ，所以其 hidden 值为 false。 对于 Fragment_3 ,因为其隐藏状态从始至终都没有发生变化，所以其 onHiddenChanged 函数并不会调用。 嗯，好像有点眉目了。不急，我们继续看下面的例子。 show Fragment_3 并 hide 其他 Fragment ，对应生命周期函数调用如下所示： 从图中，我们可以看出，确实只有隐藏状态发生了改变的 Fragment 其 onHiddenChanged 函数才会调用，那么结合以上知识点，我们能得出如下重要结论： 只要通过 show+hide 方式控制 Fragment 的显隐，那么在第一次初始化后，Fragment 任何的生命周期方法都不会调用，只有 onHiddenChanged 方法会被调用。 那么，假如我们要在 add+show+hide 模式下控制 Fragment 的懒加载，我们只需要做这两步： 我们需要在 onResume() 函数中调用 isHidden() 函数，来处理默认显示的 Fragment 在 onHiddenChanged 函数中控制其他不可见的Fragment， 也就是这样处理： abstract class LazyFragment:Fragment(){ private var isLoaded = false //控制是否执行懒加载 override fun onResume() { super.onResume() judgeLazyInit() } override fun onHiddenChanged(hidden: Boolean) { super.onHiddenChanged(hidden) isVisibleToUser = !hidden judgeLazyInit() } private fun judgeLazyInit() { if (!isLoaded &amp;&amp; !isHidden) { lazyInit() isLoaded = true } } override fun onDestroyView() { super.onDestroyView() isLoaded = false } //懒加载方法 abstract fun lazyInit() } 该懒加载的实现，是在 onResume 方法中操作，当然你可以在其他生命周期函数中控制。但是建议在该方法中执行懒加载。 ViewPager+Fragment 模式下的老方案使用传统方式处理 ViewPager 中 Fragment 的懒加载，我们需要控制 setUserVisibleHint(boolean isVisibleToUser) 函数，该函数的声明如下所示： public void setUserVisibleHint(boolean isVisibleToUser) {} 该函数与之前我们介绍的 onHiddenChanged() 作用非常相似，都是通过传入的参数值来判断当前 Fragment 是否对用户可见，只是 onHiddenChanged() 是在 add+show+hide 模式下使用，而 setUserVisibleHint 是在 ViewPager+Fragment 模式下使用。 在本节中，我们用 FragmentPagerAdapter + ViewPager 为例，向大家讲解如何实现 Fragment 的懒加载。 注意：在本例中没有调用 setOffscreenPageLimit 方法去设置 ViewPager 预缓存的 Fragment 个数。默认情况下 ViewPager 预缓存 Fragment 的个数为 1 。 初始化 ViewPager 查看内部 Fragment 生命周期函数调用情况： 观察上图，我们能发现 ViePager 初始化时，默认会调用其内部 Fragment 的 setUserVisibleHint 方法，因为其预缓存 Fragment 个数为 1 的原因，所以只有 Fragment_1 与 Fragment_2 的生命周期函数被调用。 我们继续切换到 Fragment_2，查看各个Fragment的生命周期函数的调用变化。如下图所示： 观察上图，我们同样发现 Fragment 的 setUserVisibleHint 方法被调用了，并且 Fragment_3 的一系列生命周期函数被调用了。继续切换到 Fragment_3: 观察上图可以发现，Fragment_3 调用了 setUserVisibleHint 方法，继续又切换到 Fragment_1，查看调用函数的变化： 因为之前在切换到 Fragment_3 时，Frafgment_1 已经走了 onDestoryView(图二，蓝色标记处) 方法，所以 Fragment_1 需要重新走一次生命周期。 那么结合本节的三幅图，我们能得出以下结论： 使用 ViewPager，切换回上一个 Fragment 页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。 setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。 所以如果我们想对 ViewPager 中的 Fragment 懒加载，我们需要这样处理： abstract class LazyFragment : Fragment() { /** * 是否执行懒加载 */ private var isLoaded = false /** * 当前Fragment是否对用户可见 */ private var isVisibleToUser = false /** * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用， * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载， * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量 */ private var isCallResume = false override fun onResume() { super.onResume() isCallResume = true judgeLazyInit() } private fun judgeLazyInit() { if (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) { lazyInit() Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;) isLoaded = true } } override fun onHiddenChanged(hidden: Boolean) { super.onHiddenChanged(hidden) isVisibleToUser = !hidden judgeLazyInit() } //在Fragment销毁View的时候，重置状态 override fun onDestroyView() { super.onDestroyView() isLoaded = false isVisibleToUser = false isCallResume = false } override fun setUserVisibleHint(isVisibleToUser: Boolean) { super.setUserVisibleHint(isVisibleToUser) this.isVisibleToUser = isVisibleToUser judgeLazyInit() } abstract fun lazyInit() } 复杂 Fragment 嵌套的情况当然，在实际项目中，我们可能会遇到更为复杂的 Fragment 嵌套组合。比如 Fragment+Fragment、Fragment+ViewPager、ViewPager+ViewPager….等等。 如下图所示： 对于以上场景，我们就需要重写我们的懒加载，以支持不同嵌套组合模式下 Fragment 正确懒加载。我们需要将 LazyFragment 修改成如下这样： abstract class LazyFragment : Fragment() { /** * 是否执行懒加载 */ private var isLoaded = false /** * 当前Fragment是否对用户可见 */ private var isVisibleToUser = false /** * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用， * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载， * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量 */ private var isCallResume = false /** * 是否调用了setUserVisibleHint方法。处理show+add+hide模式下，默认可见 Fragment 不调用 * onHiddenChanged 方法，进而不执行懒加载方法的问题。 */ private var isCallUserVisibleHint = false override fun onResume() { super.onResume() isCallResume = true if (!isCallUserVisibleHint) isVisibleToUser = !isHidden judgeLazyInit() } private fun judgeLazyInit() { if (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) { lazyInit() Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;) isLoaded = true } } override fun onHiddenChanged(hidden: Boolean) { super.onHiddenChanged(hidden) isVisibleToUser = !hidden judgeLazyInit() } override fun onDestroyView() { super.onDestroyView() isLoaded = false isVisibleToUser = false isCallUserVisibleHint = false isCallResume = false } override fun setUserVisibleHint(isVisibleToUser: Boolean) { super.setUserVisibleHint(isVisibleToUser) this.isVisibleToUser = isVisibleToUser isCallUserVisibleHint = true judgeLazyInit() } abstract fun lazyInit() } Androidx 下的懒加载虽然之前的方案就能解决轻松的解决 Fragment 的懒加载，但这套方案有一个最大的弊端，就是不可见的 Fragment 执行了 onResume() 方法。onResume 方法设计的初衷，难道不是当前 Fragment 可以和用户进行交互吗？你他妈既不可见，又不能和用户进行交互，你执行 onResume 方法干嘛？ 基于此问题，Google 在 Androidx 在 FragmentTransaction 中增加了 setMaxLifecycle 方法来控制 Fragment 所能调用的最大的生命周期函数。如下所示： /** * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is * already above the received state, it will be forced down to the correct state. * * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#39;s * Lifecycle state capped, or previously added as part of this transaction. The * {@link Lifecycle.State} passed in must at least be {@link Lifecycle.State#CREATED}, otherwise * an {@link IllegalArgumentException} will be thrown.&lt;/p&gt; * * @param fragment the fragment to have it&#39;s state capped. * @param state the ceiling state for the fragment. * @return the same FragmentTransaction instance */ @NonNull public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment, @NonNull Lifecycle.State state) { addOp(new Op(OP_SET_MAX_LIFECYCLE, fragment, state)); return this; } 根据官方的注释，我们能知道，该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到正确的状态。 那如何使用该方法呢？我们先看该方法在 Androidx 模式下 ViewPager+Fragment 模式下的使用例子。 ViewPager+Fragment 模式下的方案在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有 behavior 字段的构造函数，如下所示： public FragmentPagerAdapter(@NonNull FragmentManager fm, @Behavior int behavior) { mFragmentManager = fm; mBehavior = behavior; } public FragmentStatePagerAdapter(@NonNull FragmentManager fm, @Behavior int behavior) { mFragmentManager = fm; mBehavior = behavior; } 其中 Behavior 的声明如下： @Retention(RetentionPolicy.SOURCE) @IntDef({BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT}) private @interface Behavior { } /** * Indicates that {@link Fragment#setUserVisibleHint(boolean)} will be called when the current * fragment changes. * * @deprecated This behavior relies on the deprecated * {@link Fragment#setUserVisibleHint(boolean)} API. Use * {@link #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT} to switch to its replacement, * {@link FragmentTransaction#setMaxLifecycle}. * @see #FragmentPagerAdapter(FragmentManager, int) */ @Deprecated public static final int BEHAVIOR_SET_USER_VISIBLE_HINT = 0; /** * Indicates that only the current fragment will be in the {@link Lifecycle.State#RESUMED} * state. All other Fragments are capped at {@link Lifecycle.State#STARTED}. * * @see #FragmentPagerAdapter(FragmentManager, int) */ public static final int BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = 1; 从官方的注释声明中，我们能得到如下两条结论： 如果 behavior 的值为 BEHAVIOR_SET_USER_VISIBLE_HINT，那么当 Fragment 对用户的可见状态发生改变时，setUserVisibleHint 方法会被调用。 如果 behavior 的值为 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT ，那么当前选中的 Fragment 在 Lifecycle.State#RESUMED 状态 ，其他不可见的 Fragment 会被限制在 Lifecycle.State#STARTED 状态。 那 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 这个值到底有什么作用呢？我们看下面的例子： 在该例子中设置了 ViewPager 的适配器为 FragmentPagerAdapter 且 behavior 值为 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT。 默认初始化ViewPager，Fragment 生命周期如下所示： 切换到 Fragment_2 时，日志情况如下所示： 切换到 Fragment_3 时，日志情况如下所示: 因为篇幅的原因，本文没有在讲解 FragmentStatePagerAdapter 设置 behavior 下的使用情况，但是原理以及生命周期函数调用情况一样，感兴趣的小伙伴，可以根据 AndroidxLazyLoad 项目自行测试。 观察上述例子，我们可以发现，使用了 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 后，确实只有当前可见的 Fragment 调用了 onResume 方法。而导致产生这种改变的原因，是因为 FragmentPagerAdapter 在其 setPrimaryItem 方法中调用了 setMaxLifecycle 方法，如下所示： public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) { Fragment fragment = (Fragment)object; //如果当前的fragment不是当前选中并可见的Fragment,那么就会调用 // setMaxLifecycle 设置其最大生命周期为 Lifecycle.State.STARTED if (fragment != mCurrentPrimaryItem) { if (mCurrentPrimaryItem != null) { mCurrentPrimaryItem.setMenuVisibility(false); if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED); } else { mCurrentPrimaryItem.setUserVisibleHint(false); } } //对于其他非可见的Fragment,则设置其最大生命周期为 //Lifecycle.State.RESUMED fragment.setMenuVisibility(true); if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED); } else { fragment.setUserVisibleHint(true); } mCurrentPrimaryItem = fragment; } } 既然在上述条件下，只有实际可见的 Fragment 会调用 onResume 方法， 那是不是为我们提供了 ViewPager 下实现懒加载的新思路呢？也就是我们可以这样实现 Fragment 的懒加载： abstract class LazyFragment : Fragment() { private var isLoaded = false override fun onResume() { super.onResume() if (!isLoaded) { lazyInit() Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;) isLoaded = true } } override fun onDestroyView() { super.onDestroyView() isLoaded = false } abstract fun lazyInit() } add+show+hide 模式下的新方案虽然我们实现了Androidx 包下 ViewPager下的懒加载，但是我们仍然要考虑 add+show+hide 模式下的 Fragment 懒加载的情况，基于 ViewPager 在 setPrimaryItem 方法中的思路，我们可以在调用 add+show+hide 时，这样处理： 完整的代码请点击—&gt;ShowHideExt /** * 使用add+show+hide模式加载fragment * * 默认显示位置[showPosition]的Fragment，最大Lifecycle为Lifecycle.State.RESUMED * 其他隐藏的Fragment，最大Lifecycle为Lifecycle.State.STARTED * *@param containerViewId 容器id *@param showPosition fragments *@param fragmentManager FragmentManager *@param fragments 控制显示的Fragments */ private fun loadFragmentsTransaction( @IdRes containerViewId: Int, showPosition: Int, fragmentManager: FragmentManager, vararg fragments: Fragment ) { if (fragments.isNotEmpty()) { fragmentManager.beginTransaction().apply { for (index in fragments.indices) { val fragment = fragments[index] add(containerViewId, fragment, fragment.javaClass.name) if (showPosition == index) { setMaxLifecycle(fragment, Lifecycle.State.RESUMED) } else { hide(fragment) setMaxLifecycle(fragment, Lifecycle.State.STARTED) } } }.commit() } else { throw IllegalStateException( &quot;fragments must not empty&quot; ) } } /** 显示需要显示的Fragment[showFragment]，并设置其最大Lifecycle为Lifecycle.State.RESUMED。 * 同时隐藏其他Fragment,并设置最大Lifecycle为Lifecycle.State.STARTED * @param fragmentManager * @param showFragment */ private fun showHideFragmentTransaction(fragmentManager: FragmentManager, showFragment: Fragment) { fragmentManager.beginTransaction().apply { show(showFragment) setMaxLifecycle(showFragment, Lifecycle.State.RESUMED) //获取其中所有的fragment,其他的fragment进行隐藏 val fragments = fragmentManager.fragments for (fragment in fragments) { if (fragment != showFragment) { hide(fragment) setMaxLifecycle(fragment, Lifecycle.State.STARTED) } } }.commit() } 上述代码的实现也非常简单： 将需要显示的 Fragment ，在调用 add 或 show 方法后，setMaxLifecycle(showFragment, Lifecycle.State.RESUMED) 将需要隐藏的 Fragment ，在调用 hide 方法后，setMaxLifecycle(fragment, Lifecycle.State.STARTED) 结合上述操作模式，查看使用 setMaxLifecycle 后，Fragment 生命周期函数调用的情况。 add Fragment_1、Fragment_2、Fragment_3，并 hide Fragment_2,Fragment_3 : show Fragment_2，hide 其他 Fragment: show Fragment_3 hide 其他 Fragment: 不知道是否是谷歌大大没有考虑到 Fragment 嵌套的情况，所以这里我们要对之前的方案就行修改，也就是如下所示： abstract class LazyFragment : Fragment() { private var isLoaded = false override fun onResume() { super.onResume() //增加了Fragment是否可见的判断 if (!isLoaded &amp;&amp; !isHidden) { lazyInit() Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;) isLoaded = true } } override fun onDestroyView() { super.onDestroyView() isLoaded = false } abstract fun lazyInit() } 在上述代码中，因为同级的 Fragment 在嵌套模式下，仍然要调用 onResume 方法，所以我们增加了 Fragment 可见性的判断，这样就能保证嵌套模式下，新方案也能完美的支持 Fragment 的懒加载。 ViewPager2 的处理方案ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法。关于 ViewPager2 的内部机制。感兴趣的小伙伴可以自行查看源码。 关于 ViewPager2 的懒加载测试，已上传至 AndroidxLazyLoad，大家可以结合项目查看Log日志。 两种方式的对比与总结老一套的懒加载 优点：不用去控制 FragmentManager的 add+show+hide 方法，所有的懒加载都是在Fragment 内部控制，也就是控制 setUserVisibleHint + onHiddenChanged 这两个函数。 缺点：实际不可见的 Fragment，其 onResume 方法任然会被调用，这种反常规的逻辑，无法容忍。 新一套的懒加载（Androidx下setMaxLifecycle） 优点：在非特殊的情况下(缺点1)，只有实际的可见 Fragment，其 onResume 方法才会被调用，这样才符合方法设计的初衷。 缺点： 对于 Fragment 的嵌套，及时使用了 setMaxLifecycle 方法。同级不可见的Fragment， 仍然要调用 onResume 方法。 需要在原有的 add+show+hide 方法中，继续调用 setMaxLifecycle 方法来控制Fragment 的最大生命状态。 最后这两种方案的优缺点已经非常明显了，到底该选择何种懒加载模式，还是要基于大家的意愿，作者我更倾向于使用新的方案。","categories":[],"tags":[]},{"title":"暗黑模式适配","slug":"Android 10 暗黑模式适配","date":"2020-06-13T17:32:15.000Z","updated":"2020-06-13T20:39:26.738Z","comments":true,"path":"2020/06/14/DayNight/","link":"","permalink":"https://jiyugithub.github.io/2020/06/14/DayNight/","excerpt":"暗黑模式在 Android 10 里，Dark theme 暗黑模式得到了系统级的支持。 暗黑模式不仅酷炫，而且有降低屏幕耗电、在光线较暗的环境中使用更舒适等好处。 今天带大家看一下如何适配暗黑模式，本文会从以下几点进行介绍： 动态开启暗黑模式 使用 DayNight 适配暗黑模式 使用 Force Dark 适配暗黑模式 Force Dark 系统源码解析 适配流程建议 相信本文会让你对暗黑模式有一个更全面的了解。","text":"暗黑模式在 Android 10 里，Dark theme 暗黑模式得到了系统级的支持。 暗黑模式不仅酷炫，而且有降低屏幕耗电、在光线较暗的环境中使用更舒适等好处。 今天带大家看一下如何适配暗黑模式，本文会从以下几点进行介绍： 动态开启暗黑模式 使用 DayNight 适配暗黑模式 使用 Force Dark 适配暗黑模式 Force Dark 系统源码解析 适配流程建议 相信本文会让你对暗黑模式有一个更全面的了解。 动态开启在 Android 10 系统设置里增加了暗黑模式的开关，但除了系统设置，我们也可以自己动态开启。 假如我们项目里面有一个按钮用来开关暗黑模式，可以这样做： btn.setOnClickListener { if (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_YES) { // 关闭暗黑模式 AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO) } else { // 开启暗黑模式 AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES) } } 如果当前开启了暗黑模式就关掉，反之开启。 你可能还看过另一种 delegate.localNightMode 的写法，同样也是可以生效的，它们的区别在于作用范围不同： // 作用于当前项目的所有组件 AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES) // 只作用于当前组件 delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_YES 另外需要注意的是，在默认情况下，设置暗黑模式会重走 Activity 生命周期，需要重新渲染整个页面，所以不要在 onCreate 里直接设置。 如果不想重走生命周期，可以给 Activity 配置 android:configChanges=”uiMode”，但这样一来就需要在 onConfigurationChanged() 方法里进行手动适配。 NightMode上面用到了 YES 和 NO 两种暗黑的状态，但其实还不止这两种，暗黑模式一共有这几种状态： MODE_NIGHT_FOLLOW_SYSTEM 跟随系统设置 MODE_NIGHT_NO 关闭暗黑模式 MODE_NIGHT_YES 开启暗黑模式 MODE_NIGHT_AUTO_BATTERY 系统进入省电模式时，开启暗黑模式 MODE_NIGHT_UNSPECIFIED 未指定，默认值 由于很多定制系统对省电模式进行了魔改，所以使用 MODE_NIGHT_AUTO_BATTERY 不一定会生效。 另外，当 DefaultNightMode 和 LocalNightMode 都是默认值 MODE_NIGHT_UNSPECIFIED 的时候，会作 MODE_NIGHT_FOLLOW_SYSTEM 跟随系统处理。 DayNight下面要开始对暗黑模式进行适配啦。我们使用 Android Studio 的 Basic Activity 模板创建一个项目，对它进行暗黑模式适配的改造。 DayNight 主题适配第一步，找到当前项目使用的主题，将默认使用的 Theme.AppCompat.Light 主题修改为 Theme.AppCompat.DayNight： &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; 第二步，没有第二步了，现在这个项目已经支持暗黑模式了，开启暗黑模式就能看到效果： 是不是很简单，但直觉告诉我们肯定没有这么简单。 硬编码我们进入 MainActivity 的布局文件 activity_main，可以发现这里面是完全没有使用硬编码的。 什么叫硬编码？就是我们平时所说的「写死」。要是我们写死了一个色值，暗黑模式还能生效吗？ 马上试一下，我们给根布局写死一个白色背景 android:background=”#FFFFFF”，切换暗黑模式就变成了这样： 可以看到，在写死色值的情况下暗黑模式就失效了。下面看看对于自定义的色值，要如何适配。 value-night在 colors.xml 里添加一个配置颜色，比如： &lt;color name=&quot;color_bg&quot;&gt;#FFFFFF&lt;/color&gt; 这个是在普通模式下使用的色值，为了适配暗黑模式，还需要一个在暗黑模式下对应的色值。 新建 values-night 目录，并把对应色值配置到这个目录下的 colors.xml 文件。 将根布局的背景颜色修改为 color_bg，这样就能使用我们自己想要的颜色进行适配了： 在暗黑模式下，系统会优先从 night 后缀的目录下找到对应的资源配置。 以上就是使用 DayNight 主题进行暗黑模式适配的全部内容了。 DayNight 弊端一些关于 Android 10 暗黑模式适配的文章到这里就结束了，但其实 DayNight 主题并不是 Android 10 新增的东西，它早在 Android 6.0 就已经出现。虽然它涉及的内容不多，但大家可能也发现了，在实际项目中它的可操作性并不高。 首先，使用这种适配方式，要求我们整个项目所有的色值都不能使用硬编码，要做到这一点已经很不容易了，很多项目连统一的设计规范都很难做到。再退一步讲，就算我们所有色值都是使用 xml 配置的，但 colors.xml 里配置了成百上千个色值，我们需要对所有这些色值配置一个对应的暗黑色值，并且要确保它们在暗黑模式下能比较美观的展示。 所以，除非项目本身已经有一套严格的设计规范并且严格执行了，否则使用 DayNight 主题适配暗黑模式基本是不具有可操作性的。 Android 10 新增的当然不只是一个暗黑模式的开关而已，下面我们看一下 Android 10 有什么新特性供我们适配。 Force Dark其实我们的需求很明确，就是使用了硬编码也能被适配成暗黑模式。Android 10 新增的 Force Dark 强制暗黑就实现了这个功能。 forceDarkAllowed还是回到刚才的项目，把背景写死白色，再次来到 styles.xml 的主题配置。这次我们不用 DayNight 主题了，把配置改成如下： &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:forceDarkAllowed&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 我们把主题换回 Light 亮色主题，至于为什么要用 Light 后面源码部分还会再讲到 另外，重点来了，这里还增加了一个 forceDarkAllowed 的配置，这是 compileSdkVersion 升级到 29 新增的配置，按字面意思就是「开启强制暗黑」。 这样就已经完成配置了，在 Android 10 的机器上运行一下，切换暗黑模式，记住这次的背景是写死白色的： 背景被强制转换成黑色了，细心的还会发现，右下角按钮的背景颜色也变深了。 Force Dark 这么暴力，连我们写死的色值都改了，虽然方便，但这也给我们一种不安全感。 要是 Force Dark 适配出来的颜色不是我们想要的怎么办？我们还能自定义暗黑色值吗？也是可以的。 Force Dark 自定义适配除了主题新增了 forceDarkAllowed 这个配置，View 里面也有。 如果某个 View 的需要使用自定义色值适配暗黑模式，我们需要对这个 View 添加这个配置，让 Force Dark 排除它： android:forceDarkAllowed=&quot;false&quot; 然后在代码里根据当前是否处于暗黑模式，对色值进行动态设置。 对于 View 的 forceDarkAllowed，有几点需要注意： 在 View 中使用这个配置的前提是，当前主题开启了 Force Dark 默认值是 true，所以设为 true 和不设是一样的 作用范围是当前 View 以及它所有的子 View 综上可以看出，其实目前并没有很好的 Force Dark 自定义方案。好在 Force Dark 的整体效果没什么大问题，就算要自定义，我们也尽量只对子 View 进行自定义。 Force Dark 源码解析下面我们看一下源码，看看系统在暗黑模式下是如何对颜色进行转换的。 这里仅展示几个关键源码片段，它们之间是如何调用的就不赘述啦。 updateForceDarkMode看源码首先我们要找到入口，入口就是主题的 forceDarkAllowed 配置，搜索一下可以发现这个配置会在 ViewRootImpl 被用到。 相关的说明已经用注释写在代码里了。 // android.view.ViewRootImpl.java private void updateForceDarkMode() { if (mAttachInfo.mThreadedRenderer == null) return; // 判断当前是否处于暗黑模式 boolean useAutoDark = getNightMode() == Configuration.UI_MODE_NIGHT_YES; if (useAutoDark) { // 这个是被用来作为默认值用的，这里先不管它，我们后面还会讲到。 boolean forceDarkAllowedDefault = SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false); TypedArray a = mContext.obtainStyledAttributes(R.styleable.Theme); // 判断当前是否为 Light 主题，这也是为什么我们前面要使用 Light 主题。这也很好理解，只有当前主题是亮色的时候，才需要进行暗黑的处理。 // 判断当前是否允许开启强制暗黑，我们就是靠它找到这个地方的。 useAutoDark = a.getBoolean(R.styleable.Theme_isLightTheme, true) &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault); a.recycle(); } if (mAttachInfo.mThreadedRenderer.setForceDark(useAutoDark)) { // TODO: Don&#39;t require regenerating all display lists to apply this setting invalidateWorld(mView); } } 总结一下，根据这个方法我们可以知道，Force Dark 生效有三个条件： 处于暗黑模式 使用了 Light 亮色主题 允许使用 Force Dark 源码再跟下去，发现调用了 Native 代码。 handleForceDark下一个关键代码是 RenderNode 的 handleForceDark 函数。RenderNode 是绘制节点，一个 View 可以有多个绘制节点，比如一个 TextView 的文字部分是一个绘制节点，它设置的背景也是一个绘制节点。看一下这个函数做了什么。 // frameworks/base/libs/hwui/RenderNode.cpp void RenderNode::handleForceDark(android::uirenderer::TreeInfo *info) { if (CC_LIKELY(!info || info-&gt;disableForceDark)) { return; } // 这个函数看似有点复杂，但其实我们只需要关注 usage 这个参数。 // usage 有两个取值，Foreground 前景和 Background 背景。 auto usage = usageHint(); const auto&amp; children = mDisplayList-&gt;mChildNodes; if (mDisplayList-&gt;hasText()) { // 如果当前节点 hasText() 含有文字，那它就是一个 Foreground 前景 usage = UsageHint::Foreground; } // 下面的判断都是设为 Background 背景 if (usage == UsageHint::Unknown) { if (children.size() &gt; 1) { usage = UsageHint::Background; } else if (children.size() == 1 &amp;&amp; children.front().getRenderNode()-&gt;usageHint() != UsageHint::Background) { usage = UsageHint::Background; } } if (children.size() &gt; 1) { // Crude overlap check SkRect drawn = SkRect::MakeEmpty(); for (auto iter = children.rbegin(); iter != children.rend(); ++iter) { const auto&amp; child = iter-&gt;getRenderNode(); // We use stagingProperties here because we haven&#39;t yet sync&#39;d the children SkRect bounds = SkRect::MakeXYWH(child-&gt;stagingProperties().getX(), child-&gt;stagingProperties().getY(), child-&gt;stagingProperties().getWidth(), child-&gt;stagingProperties().getHeight()); if (bounds.contains(drawn)) { // This contains everything drawn after it, so make it a background child-&gt;setUsageHint(UsageHint::Background); } drawn.join(bounds); } } // 根据分类，如果是背景会被设为 Dark 深色，否则是 Light 亮色。 mDisplayList-&gt;mDisplayList.applyColorTransform( usage == UsageHint::Background ? ColorTransform::Dark : ColorTransform::Light); } 这个函数做的就是对当前绘制节点进行 Foreground 还是 Background 的分类。 为了保证文字的可视度，需要保证一定的对比度，在背景切换成深色的情况下，需要把文字部分切换成亮色。 transformColor根据分好的颜色类型，会进入 CanvasTransform 对颜色进行转换处理。这里也是 Force Dark 最核心的地方了。 // frameworks/base/libs/hwui/CanvasTransform.cpp static SkColor transformColor(ColorTransform transform, SkColor color) { switch (transform) { case ColorTransform::Light: // 转换为亮色 return makeLight(color); case ColorTransform::Dark: // 转换为暗色 return makeDark(color); default: return color; } } 根据类型调用了对应的函数转换颜色，我们看一下 makeDark 吧。 static SkColor makeDark(SkColor color) { Lab lab = sRGBToLab(color); float invertedL = std::min(110 - lab.L, 100.0f); if (invertedL &lt; lab.L) { lab.L = invertedL; return LabToSRGB(lab, SkColorGetA(color)); } else { return color; } } 这里把 RGB 色值转换成了 Lab 的格式。 Lab 格式含有 L、a、b 三个参数，ab 对应色彩学上的两个维度，不用管它，我们要关注的是里面的 L。 L 就是亮度，它的取值范围是 0 - 100，数值越小颜色就越暗，反之就越亮。这篇文章封面的安卓机器人右边颜色就是降低亮度后的效果。 回到代码来，这里用 110 减去当前亮度，可以说是对亮度做了取反。至于为什么是用 110 而不是用 100，我猜测是为了避免使用纯黑色。 在官方暗黑模式设计规范可以看到，建议使用深灰色作为背景，而不是用纯黑色。 最后比对取反的色值和原色值的亮度，将较暗的那个色值返回。 makeLight 函数也是类似的。 static SkColor makeLight(SkColor color) { Lab lab = sRGBToLab(color); float invertedL = std::min(110 - lab.L, 100.0f); if (invertedL &gt; lab.L) { lab.L = invertedL; return LabToSRGB(lab, SkColorGetA(color)); } else { return color; } } 所以到这里我们发现，其实 Force Dark 强制暗黑转换颜色的规则，或者说是它的本质，就是亮度取反。 适配流程建议如果你的项目 compileSdkVersion 已经升级到 29，那现在就可以开启 Force Dark 适配暗黑模式了。但很多项目要升级到 29 还有一段路要走，我们有没有办法提前适配呢？ Debug Force Dark回到我们开始看源码的地方: boolean forceDarkAllowedDefault = SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false); TypedArray a = mContext.obtainStyledAttributes(R.styleable.Theme); useAutoDark = a.getBoolean(R.styleable.Theme_isLightTheme, true) &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault); 当取不到 Theme_forceDarkAllowed 的时候，会取 DEBUG_FORCE_DARK 作为默认值，在哪里可以开启这个 DEBUG_FORCE_DARK 呢？ 在 Android 10 的开发者选项里面，可以发现多了一个这样的选项： 这里的「强制启用 SmartDark 功能」就是 DEBUG_FORCE_DARK 的开关，虽然我们看了源码都知道它也没有多智能。 开启后会对所有项目生效，这样就可以提前用 Force Dark 进行适配了。 适配流程开启 Force Dark 后大概率会发现一些有问题的图片资源，比如带有固定背景的 icon 等。 如果项目有适配暗黑模式的计划，个人建议可以按以下几步走： 开发者选项开启「强制启用 SmartDark」 替换有问题的资源，进行初步适配 compileSdkVersion 升级到 29 开启 Force Dark 和设计师沟通，对部分控件单独适配 总结使用 DayNight 主题可以实现暗黑模式的适配，但这种方法在实际项目中可操作性不高。 Android 10 新增的暗黑模式特性叫 Force Dark 强制暗黑，只需给主题添加一个允许开启的配置即可。 Force Dark 的实现方式是降低背景亮度，提高字体亮度，本质是对色值进行亮度取反。 最后，在 Android 10 的设备上，可以开启开发者选项中的「强制启用 SmartDark」，提前用 Force Dark 适配。","categories":[],"tags":[]},{"title":"使用Kotlin从零开始写一个现代Android","slug":"使用Kotlin从零开始写一个现代Android","date":"2020-06-11T22:48:13.000Z","updated":"2020-06-13T20:43:57.370Z","comments":true,"path":"2020/06/12/0_kotlin/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/0_kotlin/","excerpt":"前言经常在medium.com上看到一些高质量的技术帖子，但是由于国内的上网环境或者有的同学对于看英文比较排斥，错过了不少好文章。因此，西哥决定弄一个《优质译文专栏》，花一些时间翻译一些优质技术文给大家。这篇文章是一个小系列，用Kotlin开发现代Android APP,总共四篇，后面的会陆续翻译！以下是正文。","text":"前言经常在medium.com上看到一些高质量的技术帖子，但是由于国内的上网环境或者有的同学对于看英文比较排斥，错过了不少好文章。因此，西哥决定弄一个《优质译文专栏》，花一些时间翻译一些优质技术文给大家。这篇文章是一个小系列，用Kotlin开发现代Android APP,总共四篇，后面的会陆续翻译！以下是正文。 现在，真的很难找到一个涵盖所有Android新技术的项目，因此我决定自己来写一个，在本文中，我们将用到如下技术： 0 、Android Studio 1、Kotlin 语言 2、构建变体 3、ConstraintLayout 4、DataBinding库 5、MVVM+repository+Android Manager架构模式 6、RxJava2及其对架构的帮助 7、Dagger 2.11，什么是依赖注入？为什么要使用它？ 8、Retrofit + RxJava2 实现网络请求 9、RooM + RxJava2 实现储存 我们的APP最终是什么样子？我们的APP是一个非常简单的应用程序，它涵盖了上面提到的所有技术。只有一个简单的功能：从Github 获取googlesamples用户下的所有仓库，将数据储存到本地数据库，然后在界面展示它。 我将尝试解释更多的代码，你也可以看看你Github上的代码提交。 Github:github.com/mladenrakon… 让我们开始吧。 0、Android Studio首先安卓Android Studio 3 beta 1(注：现在最新版为Android Studio 4.0),Android Studio 已经支持Kotlin，去到Create Android Project界面，你将在此处看到新的内容：带有标签的复选框include Kotlin support。默认情况下选中。按两次下一步，然后选择EmptyActivity，然后完成了。 恭喜！你用Kotlin开发了第一个Android app) 1、Kotlin在刚才新建的项目中，你可以看到一个MainActivity.kt: package me.mladenrakonjac.modernandroidapp import android.support.v7.app.AppCompatActivity import android.os.Bundle class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } .kt后缀代表了这是一个Kotlin文件 MainActivity : AppCompatActivity()表示我们的MainActivity继承自AppCompatActivity 。 此外，所有的方法都必须有一个关键字fun,在Kotlin 中，你不能使用@override注解，如果你要表明方法是复写父类或者接口的方法的话，直接使用override关键字，注意：它和Java不一样，不是一个注解了。 然后，savedInstanceState: Bundle? 中的?代表什么呢？它代表了savedInstanceState这个参数可以是Bundle或者null。Kotlin是一门null 安全语言，如果你像下面这样写： var a : String 你将会得到一个编译错误。因为a变量必须被初始化，并且不能为null，因此你要像这样写： var a : String = &quot;Init value&quot; 并且，如果你执行以下操作，也会报编译错误： a = null 要想使a变量为null ,你必须这样写： var a : String? 为什么这是Kotlin语言的一个重要功能呢？因为它帮我们避免了NPE,Androd开发者已经对NPE感到厌倦了，甚至是null的发明者-Tony Hoare先生，也为发明它而道歉。假设我们有一个可以为空的nameTextView。如果为null，以下代码将会发生NPE： nameTextView.setEnabled(true) 但实际上，Kotlin做得很好，它甚至不允许我们做这样的事情。它会强制我们使用?或者!!操作符。如果我们使用?操作符： nameTextView?.setEnabled(true) 仅当nameTextView不为null时，这行代码才会继续执行。另一种情况下，如果我们使用!!操作符： nameTextView!!.setEnabled(true) 如果nameTextView为null，它将为我们提供NPE。它只适合喜欢冒险的家伙) 这是对Kotlin的一些介绍。我们继续进行，我将停止描述其他Kotlin特定代码。 2、构建变体通常，在开发中，如果你有两套环境，最常见的是测试环境和生产环境。这些环境在服务器URL，图标，名称，目标api等方面可能有所不同。通常，在开始的每个项目中我都有以下内容： finalProduction: 上传Google Play 使用 demoProduction:该版本使用生产环境服务器Url,并且它有着GP上的版本没有的新功能，用户可以在Google play 旁边安装，然后可以进行新功能测试和提供反馈。 demoTesting:和demoProduction一样，只不过它用的是测试地址 mock: 对于我来说，作为开发人员和设计师而言都是很有用的。有时我们已经准备好设计，而我们的API仍未准备好。等待API准备就绪后再开始开发可不是好的解决方案。此构建变体为提供有mock数据，因此设计团队可以对其进行测试并提供反馈。对于保证项目进度真的很有帮助,一旦API准备就绪，我们便将开发转移到demoTesting环境。 在此应用程序中，我们将拥有所有这些变体。它们的applicationId和名称不同。 gradle 3.0.0 flavourDimension中有一个新的api，可让您混合不同的产品风味，因此您可以混合demo和minApi23风味。在我们的应用程序中，我们将仅使用“默认” 的flavorDimension。早app的build.gradle中，将此代码插入android {}下： flavorDimensions &quot;default&quot; productFlavors { finalProduction { dimension &quot;default&quot; applicationId &quot;me.mladenrakonjac.modernandroidapp&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App&quot; } demoProduction { dimension &quot;default&quot; applicationId &quot;me.mladenrakonjac.modernandroidapp.demoproduction&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Demo P&quot; } demoTesting { dimension &quot;default&quot; applicationId &quot;me.mladenrakonjac.modernandroidapp.demotesting&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Demo T&quot; } mock { dimension &quot;default&quot; applicationId &quot;me.mladenrakonjac.modernandroidapp.mock&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Mock&quot; } } 打开string.xml文件，删掉app_namestring资源，因此，我们才不会发生资源冲突，然后点击Sync Now,如果转到屏幕左侧的“构建变体”，则可以看到4个不同的构建变体，其中每个都有两种构建类型：“Debug”和“Release”,切换到demoProduction构建变体并运行它。然后切换到另一个并运行它。您就可以看到两个名称不同的应用程序。 3、ConstraintLayout如果你打开activity_main.xml,你可以看到跟布局是ConstraintLayout,如果你开发过iOS应用程序，你可能知道AutoLayout，ConstraintLayout和它非常的相似，他们甚至用了相同的Cassowary算法。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; Constraints可以帮我们描述View之间的关系。对于每一个View来说，应该有4个约束，每一边一个约束，在这种情况下，我们的View就被约束在了父视图的每一边了。 在Design Tab中，如果你将Hello World文本稍微向上移动，则在TextTab中将增加下面这行代码： app:layout_constraintVertical_bias=&quot;0.28&quot; Design tab 和 Text tab是同步的，我们在Design中移动视图，则会影响Text中的xml，反之亦然。垂直偏差描述了视图对其约束的垂直趋势。如果要使视图垂直居中，则应使用： app:layout_constraintVertical_bias=&quot;0.28&quot; 我们让Activity只显示一个仓库，它有仓库的名字，star的数量，作者，并且还会显示是否有issue 要得到上面的布局设计，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/repository_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:textSize=&quot;20sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.083&quot; tools:text=&quot;Modern Android app&quot; /&gt; &lt;TextView android:id=&quot;@+id/repository_has_issues&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:text=&quot;@string/has_issues&quot; android:textStyle=&quot;bold&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/repository_name&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1.0&quot; app:layout_constraintStart_toEndOf=&quot;@+id/repository_name&quot; app:layout_constraintTop_toTopOf=&quot;@+id/repository_name&quot; app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt; &lt;TextView android:id=&quot;@+id/repository_owner&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;8dp&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/repository_name&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; tools:text=&quot;Mladen Rakonjac&quot; /&gt; &lt;TextView android:id=&quot;@+id/number_of_starts&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;8dp&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/repository_owner&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; tools:text=&quot;0 stars&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 不要被tools:text搞迷惑了，它的作用仅仅是让我们可以预览我们的布局。 我们可以注意到，我们的布局是扁平的，没有任何嵌套，你应该尽量少的使用布局嵌套，因为它会影响我们的性能。ConstraintLayout也可以在不同的屏幕尺寸下正常工作。 我有种预感，很快就能达到我们想要的布局效果了。 上面只是一些关于ConstraintLayout的少部分介绍，你也可以看一下关于ConstraintLayout使用的google code lab: codelabs.developers.google.com/codelabs/co… 4. Data binding library当我听到Data binding 库的时候，我的第一反应是：Butterknife已经很好了，再加上，我现在使用一个插件来从xml中获取View,我为啥要改变，来使用Data binding呢？但当我对Data binding有了更多的了解之后，我的它的感觉就像我第一次见到Butterknife一样，无法自拔。 Butterknife能帮我们做啥？ButterKnife帮助我们摆脱无聊的findViewById。因此，如果您有5个视图，而没有Butterknife，则你有5 + 5行代码来绑定您的视图。使用ButterKnife，您只有我行代码就搞定。就是这样。 Butterknife的缺点是什么？Butterknife仍然没有解决代码可维护问题，使用ButterKnife时，我经常发现自己遇到运行时异常，这是因为我删除了xml中的视图，而没有删除Activity/Fragment类中的绑定代码。另外，如果要在xml中添加视图，则必须再次进行绑定。真的很不好维护。你将浪费大量时间来维护View绑定。 那与之相比，Data Binding 怎么样呢？有很多好处，使用Data Binding，你可以只用一行代码就搞定View的绑定，让我们看看它是如何工作的，首先，先将Data Binding 添加到项目： // at the top of file apply plugin: &#39;kotlin-kapt&#39; android { //other things that we already used dataBinding.enabled = true } dependencies { //other dependencies that we used kapt &quot;com.android.databinding:compiler:3.0.0-beta1&quot; } 请注意，数据绑定编译器的版本与项目build.gradle文件中的gradle版本相同： classpath &#39;com.android.tools.build:gradle:3.0.0-beta1&#39; 然后，点击Sync Now,打开activity_main.xml,将Constraint Layout用layout标签包裹 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;android.support.constraint.ConstraintLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/repository_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:textSize=&quot;20sp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;0.083&quot; tools:text=&quot;Modern Android app&quot; /&gt; &lt;TextView android:id=&quot;@+id/repository_has_issues&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; android:text=&quot;@string/has_issues&quot; android:textStyle=&quot;bold&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/repository_name&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1.0&quot; app:layout_constraintStart_toEndOf=&quot;@+id/repository_name&quot; app:layout_constraintTop_toTopOf=&quot;@+id/repository_name&quot; app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt; &lt;TextView android:id=&quot;@+id/repository_owner&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;8dp&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/repository_name&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; tools:text=&quot;Mladen Rakonjac&quot; /&gt; &lt;TextView android:id=&quot;@+id/number_of_starts&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;8dp&quot; android:layout_marginEnd=&quot;16dp&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginTop=&quot;8dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;1&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/repository_owner&quot; app:layout_constraintVertical_bias=&quot;0.0&quot; tools:text=&quot;0 stars&quot; /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; &lt;/layout&gt; 注意，你需要将所有的xml移动到layout 标签下面，然后点击Build图标或者使用快捷键Cmd + F9,我们需要构建项目来使Data Binding库为我们生成ActivityMainBinding类，后面在MainActivity中将用到它。 如果没有重新编译项目，你是看不到ActivityMainBinding的，因为它在编译时生成。 我们还没有完成绑定，我们只是定义了一个非空的 ActivityMainBinding 类型的变量。你会注意到我没有把? 放在 ActivityMainBinding 的后面，而且也没有初始化它。这怎么可能呢？lateinit 关键字允许我们使用非空的延迟被初始化的变量。和 ButterKnife 类似，在我们的布局准备完成后，初始化绑定需要在 onCreate 方法中进行。此外，你不应该在 onCreate 方法中声明绑定，因为你很有可能在 onCreate 方法外使用它。我们的 binding 不能为空，所以这就是我们使用 lateinit 的原因。使用 lateinit 修饰，我们不需要在每次访问它的时候检查 binding 变量是否为空。 我们初始化binding变量，你需要替换: setContentView(R.layout.activity_main) 为： binding = DataBindingUtil.setContentView(this, R.layout.activity_main) 就是这样，你成功的绑定了所有View,现在你可以访问它并且做一些更改，例如，我们将仓库名字改为Modern Android Medium Article: binding.repositoryName.text = &quot;Modern Android Medium Article&quot; 如你所见，现在我们可以通过bingding变量来访问main_activity.xml的所有View了（前提是它们有id）,这就是Data Binding 比ButterKnife 好用的原因。 kotlin的 Getters 和 setters大概，你已经注意到了，我们没有像Java那样使用.setText()，我想在这里暂停一下，以说明与Java相比，Kotlin中的getter和setter方法如何工作的。 首先，你需要知道，我们为什么要使用getters和setters，我们用它来隐藏类中的变量，仅允许使用方法来访问这些变量，这样我们就可以向用户隐藏类中的细节，并禁止用户直接修改我们的类。假设我们用 Java 写了一个 Square 类： public class Square { private int a; Square(){ a = 1; } public void setA(int a){ this.a = Math.abs(a); } public int getA(){ return this.a; } } 使用setA()方法，我们禁止了用户向Square类的a变量设置一个负数,因为正方形的边长一定是正数，要使用这种方法，我们必须将其设为私有，因此不能直接设置它。这也意味着我们不能直接获得a，需要给它定一个get方法来返回a，如果有10个变量，那么我们就得定义10个相似的get方法，写这样无聊的样板代码，通常会影响我们的心情。 Kotling使我们的开发人员更轻松了。如果你调用下面的代码： var side: Int = square.a 这并不意味着你是在直接访问a变量，它和Java中调用getA()是相同的 int side = square.getA(); 因为Kotlin自动生成默认的getter和setter。在Kotlin中，只有当您有特殊的setter或getter时，才应指定它。否则，Kotlin会为您自动生成： var a = 1 set(value) { field = Math.abs(value) } field ? 这又是个什么东西？为了更清楚明白，请看下面代码： var a = 1 set(value) { a = Math.abs(value) } 这表明你在调用set方法中的set(value){}，因为Kotlin的世界中，没有直接访问属性，这就会造成无限递归，当你调用a = something,会自动调用set方法。使用filed就能避免无限递归，我希望这能让你明白为什么要用filed关键字，并且了解getters和setters是如何工作的。 回到代码中继续，我将向你介绍Kotlin语言的另一个重要功能:apply函数： class MainActivity : AppCompatActivity() { lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.apply { repositoryName.text = &quot;Medium Android Repository Article&quot; repositoryOwner.text = &quot;Mladen Rakonjac&quot; numberOfStarts.text = &quot;1000 stars&quot; } } } apply 允许你在一个实例上调用多个方法，我们仍然还没有完成数据绑定，还有更棒的事儿，让我们为仓库定义一个UI模型（这个是github仓库的数据模型Repository,它持有要展示的数据，请不要和Repository模式的中的Repository搞混淆了哈），要创建一个Kotlin class，点击New -&gt; Kotlin File/Class : class Repository(var repositoryName: String?,var repositoryOwner: String?,var numberOfStars: Int? ,var hasIssues: Boolean = false) 在Kotlin中，主构造函数是类头的一部分，如果你不想定义次构造函数，那就是这样了，数据类到此就完成了，构造函数没有参数分配给字段，没有setters和getters,整个类就一行代码。 回到MainActivity.kt，为Repository创建一个实例。 var repository = Repository(&quot;Medium Android Repository Article&quot;, &quot;Mladen Rakonjac&quot;, 1000, true) 你应该注意到了，创建类实例，没有用new 现在，我们在activity_main.xml中添加data标签。 &lt;data&gt; &lt;variable name=&quot;repository&quot; type=&quot;me.mladenrakonjac.modernandroidapp.uimodels.Repository&quot; /&gt; &lt;/data&gt; 我们可以在布局中访问存储的变量repository,例如，我们可以如下使用id是repository_name的TextView,如下： android:text=&quot;@{repository.repositoryName}&quot; repository_name文本视图将显示从repository变量的属性repositoryName获取的文本。剩下的唯一事情就是将repository变量从xml绑定到MainActivity.kt中的repository。 点击Build使DataBinding 为我们生成类，然后在MainActivity中添加两行代码： binding.repository = repository binding.executePendingBindings() 如果你运行APP,你会看到TextView上显示的是：“Medium Android Repository Article”,非常棒的功能，是吧？ 但是，如果我们像下面这样改一下呢？ Handler().postDelayed({repository.repositoryName=&quot;New Name&quot;}, 2000) 新的文本将会在2000ms后显示吗？不会的，你必须重新设置一次repository,像这样： Handler().postDelayed({repository.repositoryName=&quot;New Name&quot; binding.repository = repository binding.executePendingBindings()}, 2000) 但是，如果我们每次更改一个属性都要这么写的话，那就非常蛋疼了，这里有一个更好的方案叫做Property Observer。 让我们首先解释一下什么是观察者模式，因为在rxJava部分中我们也将需要它： 可能你已经听说过http://androidweekly.net/,这是一个关于Android开发的周刊。如果您想接收它，则必须订阅它并提供您的电子邮件地址。过了一段时间，如果你不想看了，你可以去网站上取消订阅。 这就是一个观察者/被观察者的模式,在这个例子中， Android 周刊是被观察者,它每周都会发布新闻通讯。读者是观察者，因为他们订阅了它，一旦订阅就会收到数据，如果不想读了，则可以停止订阅。 Property Observer在这个例子中就是 xml layout,它将会监听Repository实例的变化。因此，Repository是被观察者,例如，一旦在Repository类的实例中更改了repository nane 属性后，xml不调用下面的代码也会更新： binding.repository = repository binding.executePendingBindings() 如何让它使用Data Binding 库呢？，Data Binding库提供了一个BaseObservable类，我们的Repostory类必须继承它。 class Repository(repositoryName : String, var repositoryOwner: String?, var numberOfStars: Int? , var hasIssues: Boolean = false) : BaseObservable(){ @get:Bindable var repositoryName : String = &quot;&quot; set(value) { field = value notifyPropertyChanged(BR.repositoryName) } } 当我们使用了 Bindable 注解时，就会自动生成 BR 类。你会看到，一旦设置新值，就会通知它更新。现在运行 app 你将看到仓库的名字在 2 秒后改变而不必再次调用 executePendingBindings()。","categories":[],"tags":[]},{"title":"Android 11 Beta 版正式发布！以及众多面向开发者的重磅更新","slug":"Android 11 Beta 版正式发布！以及众多面向开发者的重磅更新","date":"2020-06-11T22:15:11.000Z","updated":"2020-06-13T20:39:39.871Z","comments":true,"path":"2020/06/12/android11/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/android11/","excerpt":"Android 11 Beta 版现已发布自二月以来，大家通过 Android 11 开发者预览版为我们提供了众多反馈。今天发布的 Android 11 第一个 Beta 版聚焦于三个主题: 以人为本、灵活控制以及隐私安全。","text":"Android 11 Beta 版现已发布自二月以来，大家通过 Android 11 开发者预览版为我们提供了众多反馈。今天发布的 Android 11 第一个 Beta 版聚焦于三个主题: 以人为本、灵活控制以及隐私安全。 以人为本 Android 现在更突显人的要素，更善于沟通。我们重塑了您在手机上进行沟通的方式，也让操作系统能识别出那些对您来说更重要的人，让您能更快速地和他们联系。 会话通知会显示在通知栏顶部的专门区域，其设计更凸显联系对象，且提供了会话特定的操作，例如以 Bubbles 的形式打开聊天、在主屏幕中创建会话快捷方式，以及设置提醒。 Bubbles 可以让用户在手机上多任务切换时依然保持对话可见及可用。消息和聊天应用可以通过基于通知的 Bubbles API，在 Android 11 上提供这种全新体验。 键盘提示整合功能为用户带来了更便利的输入补全和提示。自动填写应用以及 IME (输入法编辑器) 可以通过这个功能在 IME 提示列表中安全地给出基于上下文的实体和字符串建议。 Voice Access (语音操作)。对完全使用语音操作设备的用户，Android 现在提供设备集成的屏幕内容感知功能 (visual cortex)，该功能可以理解屏幕中呈现的内容及其上下文，从而为无障碍指令生成标签和操作点。 灵活控制 最新版的 Android 现在可帮您快速访问所有的智能设备，并集中控制它们: Device Controls (设备控制) 让用户得以更快、更轻松地访问和控制他们连接的设备。只需长按电源按钮就可以调出设备控制菜单，一站式完成设备控制。应用也可以通过新的 API 出现在这个控制菜单中。阅读官方文档了解更多。 Media Controls (媒体控制) 让用户得以更快捷地切换音频和视频内容的播放设备——不论是耳机、麦克风还是电视。您现在可以在开发者选项中启用此功能，在后续的 Beta 版本中本功能会默认启用。阅读官方文档了解更多。 隐私安全 在 Android 11 中我们为用户带来了更高的掌控能力，让他们能更好地管理敏感权限。我们还会通过更快速的系统更新来持续确保设备安全。 单次授权: 用户现在可以授予应用一次性的权限来访问设备的麦克风、摄像头或者位置信息。应用下次被使用时需要再次请求权限才能进行访问。阅读官方文档了解更多。 权限自动重置: 如果用户在很长一段时间里未使用某应用，Android 11 将自动重置所有与该应用关联的权限并通知用户。在用户下次使用该应用时，应用可以再次请求权限。阅读官方文档了解更多。 后台位置: 我们在今年二月宣布，开发者需要获得批准后才可以让应用在后台访问位置信息，从而避免该信息遭到不当使用。现在我们为开发者提供更长的时间来做出修改，在 2021 年之前我们不会强行要求既有的应用遵守本政策。阅读官方文档了解更多。 Google Play 系统更新自去年发布以来，让我们得以更快速地更新操作系统核心组件，并覆盖 Android 生态系统中的众多设备。在 Android 11 中，可更新的模块数量增加了一倍有余，新增的 12 个可更新模块会更有力地确保隐私和安全，以及为用户和开发者带来更好的一致性。 开发者友好 我们希望让开发者能更轻松地用好新版 Android。在兼容性测试方面，有这些举措来减少大家的工作量: 有破坏性的行为变更 (breaking changes) 只在您针对 Android 11 发布应用时才生效。所以在您明确修改应用的清单文件之前，这些变更不会对您造成影响。 在开发者选项中加入了全新的界面，来让您逐一开关这些更新选项，以更好地完成测试。 新增了平台稳定性里程碑，在这个版本中所有的 API 和行为变更都已调整完毕并进入稳定状态，这时您可以放心地对应用做出最终更新。 版本发布时间表 developer.android.google.cn/preview/ove… Android 11 还带来了其他提升开发效率的改进，比如 ADB 无线调试、能更快安装大型 APK 的 ADB Incremental (ADB 增量安装)，以及在平台 API 上加入更多的可空性注解 (从而在构建时就发现问题，不用等到运行时才出错)，等等。 Android 11 第一个 Beta 版本现已发布，您可以在自己的应用中体验终版 SDK 和 NDK API，以及各种全新功能。如果您使用的是 Pixel 2、3、3a 或 4 系列设备，请参加测试并获取 Android 11 Beta 的 OTA 更新。和以往一样，您可以直接下载系统并安装至 Pixel 设备以及 Android 模拟器。请访问 Android 11 开发者网站查看完整的 Android 11 开发者功能。 现代化 Android 开发 (Modern Android development)在过去数年中，Android 团队通过卓绝的努力持续改善移动开发者的体验，提升大家的开发效率。这些努力包括 Android Studio IDE、一种优秀的开发语言 (没错，就是 Kotlin)、让日常任务更加轻松的 Jetpack 库，以及可以更好地进行应用分发的 Android App Bundle。我们将这些努力统称为现代化 Android 开发 (Modern Android development)，一切都是为了让您能提升效率，从而尽情释放出 Android 的潜力。 Android Studio今天，我们也通过 Android Studio 4.1 Beta 版和 4.2 Canary 版为大家带来了许多全新功能，主要聚焦于开发者们提出的这些关键诉求: 调试更简单，通过 ADB 无线调试功能更轻松地在 Android 设备上进行调试。我们还新增了 Database Inspector 和依赖注入 (Dagger) 工具。 设备测试体验更佳。Android 模拟器现在直接集成在 IDE 中，您可以并排显示测试中的应用，同时查看不同设备上的运行结果。我们还改进了设备管理器，让您更轻松地管理多个设备。 更易用的机器学习: 您现在可以将 ML Kit 和 TensorFlow Lite 模型直接导入 IDE。 更快速的构建与部署: Kotlin 符号处理可以将任务图缓存在 Gradle 中，使得应用部署到 Android 11 设备中的速度更快。全新的 Build Analyzer 让您可以很快找到应用构建的性能瓶颈。 更强大的游戏工具: 改进性能分析界面，并为大家带来了全新的 System Trace 工具，以及原生内存分析功能。 即刻体验 Android Studio 4.1 Beta 版和 Android Studio 4.2 Canary 版。 Kotlin 和 Jetpack现代化 Android 开发中的重要环节之一就是编程语言和开发库: Kotlin 是一种现代且简洁的编程语言，Jetpack 则提供了颇具特色且功能强大的开发库，二者都专注于提升开发者的工作效率。 腾讯视频链接 v.qq.com/x/page/h098… Bilibili 视频链接 www.bilibili.com/video/BV1Xk… Kotlin 的迅速普及 (目前 Google Play 排名前 1,000 的应用中超过 70% 都使用 Kotlin) 和众多开发者的青睐，使得我们可以通过该语言以全新的方式优化开发体验。Kotlin 协程是 Kotlin 语言的诸多强大功能之一，它可以让您更轻松地编写并发调用，同时获得更高的可读性。现在，我们正式推荐开发者使用协程。我们还在 3 个最常用的 Jetpack 库 (Lifecycle、WorkManager 和 Room) 中使用了协程，以便您可以利用这些库编写更优质的代码。 Kotlin 自身也随着版本演进而愈发出色，这离不开 Jetbrains 团队的杰出贡献。Kotlin 1.4 带来了更快的代码补全功能、更强大的类型推断 (默认启用)、各类函数接口，以及各种提升开发者体验的改进，比如可以混合使用命名参数和定位参数。 我们也在持续推动 Jetpack 的演进，这套开发库涵盖了多个 Android 版本，并帮助大家更快速、更轻松地实现常见的移动开发范式。很多用户一直对 Dagger 情有独钟，因此我们联合 Dagger 团队推出了 Hilt，这是基于 Dagger 的封装方案，且易于开发者使用。我们推荐使用 Hilt 作为 Android 的依赖注入解决方案，并提供了 Alpha 试用版。我们还新增了一个 App Startup 库，帮助应用和库开发者优化库的初始化，进而缩短应用启动时间。此外，我们还更新了许多现有的开发库，包括对 Paging 3 进行的重大更新——优先使用 Kotlin 进行了重写，并且完全支持协程！ 全新 UI 工具包: Compose 的最新进展想要进一步提升开发效率，您还需要强大的界面工具包，以便快速简便地在 Android 上构建精美的界面，同时还能原生访问系统 API。为此，我们构建了 Jetpack Compose，这是一款全新的现代界面工具包，通过强大的工具和直观的 Kotlin API，帮助您用更少的代码打造心目中的理想应用。 今天，我们为大家带来 Jetpack Compose 开发者预览版 2，其中包含开发者们一直要求的诸多功能: 与 View 的互操作性 (开始在当前应用中混合使用 Composable 方法) (新！) 动画 (新！) 测试 (新！) 约束布局 (新！) 适配器列表 (新！) Material UI 组件 文本以及可编辑文本 (新！) 主题和图像 窗口管理 输入和手势 通过与 Jetbrains Kotlin 团队的紧密合作，我们在 Android Studio 4.2 中加入了许多新功能，来帮助您通过 Compose 构建应用: 用于生成代码的 Kotlin 编译器插件 Compose 预览注解 实时交互式 Compose 预览 将单个的 Composable 部署至设备 Compose 代码补全 适用于 Compose 的示例数据 API Compose 尚未准备好用于生产环境。我们虽然进行了性能优化，但还需要通过大家试用以获得反馈。我们计划于今年夏天发布 alpha 版，并于明年发布 1.0 版。 Google Play Console 全新改版Google Play 致力于帮助开发者发展业务。为了更好地达成这一目的，我们重新设计了 Google Play Console，让您可以在我们的平台上获得进一步的成功。除了更简洁、更易用之外，新版 Play Console 还增添了不少功能，让您可以: 找到、发现和理解 Play Console 的功能，从而在 Google Play 上收获成功 获取政策变化、发布状态和用户反馈的最新指导信息 通过全新的用户获取报告更好地解读数据表现 通过全新的用户管理选项，让团队中的每个人都能用好 Play Console 提供的功能 请阅读文章《Google Play Console beta 版全新发布》进一步了解详情，您也可以访问 play.google.com/console 参与 Beta 版体验。您的反馈能帮助我们为每一个人打造更好的 Google Play Console，我们期待着您的声音。 腾讯视频链接 v.qq.com/x/page/x098… Bilibili 视频链接 www.bilibili.com/video/BV1EC… 总结我们带来的更新远不止这些！欢迎大家继续关注我们接下来将要发布的内容: 我们为大家准备了 12 场精彩演讲，会在接下来一段时间陆续发布。 我们会通过 “11 Weeks of Android“ 系列内容持续吸引大家对 Android 11 的热情，每周都会带来大家关注的全新开发者内容，比如 UI、Jetpack 和机器学习。请前往官方网站查看发布日程。 我们将在全球举办一系列线上活动，来和大家一起探讨 Android 11 的新内容、应用兼容性，以及现代化 Android 开发的基本知识和最佳实践。请前往 官方网站了解详情。同时，也可以直接参与到您所在的 GDG 社区的本地活动: 7 月 4 日上海 GDG 社区 www.meetup.com/Shanghai-GD… 其他的社区活动将在后续发布，敬请关注。 点击这里前往 Android 11 Beta 版官方网站","categories":[],"tags":[]},{"title":"10+个很酷的Vue.js组件，模板和demo示例","slug":"10-个很酷的Vue-js组件，模板和demo示例","date":"2020-06-11T22:12:47.000Z","updated":"2020-06-13T20:38:28.341Z","comments":true,"path":"2020/06/12/vue_js/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/vue_js/","excerpt":"众所周知，Vue.js 组件是Vue创建自定义元素的重要功能之一，同时，模板可帮助你避免从头开始创建网页设计。总之，这些工具对于希望其开发过程更快，更高效的任何Web开发人员都是必不可少的。","text":"众所周知，Vue.js 组件是Vue创建自定义元素的重要功能之一，同时，模板可帮助你避免从头开始创建网页设计。总之，这些工具对于希望其开发过程更快，更高效的任何Web开发人员都是必不可少的。 此外，在过去的几年中，Vue.js 变得非常流行，许多企业将其添加到他们的技术栈中。该框架的优点是它具有内置的数据绑定和MVC模型（模型、视图、控制器），与Angular.js和React.js相比，它使配置更加容易。另外，Vue.js的学习曲线很小，与 Angular.js 相比，Vue更易于学习，理解和使用。 知道了这一点，我们收集了一份Vue.js组件、模板和实验清单，如果你是一个初学者，可以帮助你对这个框架的意义有一个概念，如果你是一个Vue.js开发者，也可以为你的下一个项目找到一些灵感。 BootstrapVue Argon Dashboard PROBootstrapVue Argon Dashboard PRO 是BootstrapVue和Vue.js的高级仪表板。这是一种全新产品，它基于我们从头开始重新构建的最新框架结构，这种结构旨在使产品更直观，更具适应性，并且更易于定制。让Argon以其酷炫的功能给你带来惊喜，让你的项目达到一个全新的水平。 Vue White DashboardVue White Dashboard 是一个免费的开源Bootstrap 4和Vue.js Admin仪表板，其中包含大量的组件，这些组件可以组合在一起并看起来非常漂亮。Vue White仪表板具有16个以上的独立组件，可让你自由选择和组合。所有组件的颜色都可以不同，你可以使用Sass文件轻松进行修改。 Vue QRcode ReaderVue QRcode Reader是一组用于检测和解码QR(二维码)码的Vue.js组件。它使你无需离开浏览器即可检测和解码QR码，所有组件都具有响应能力。除此之外，它接近零样式，因此你可以使它们适合你的布局。使用方法简单明了。 VueJS ExpoVueJS Expo是使用Vue.js框架收集的漂亮的网站，应用程序和实验。如果你是Vue.js框架的粉丝，那么这里可能是你获得灵感的地方。展示包括基于VueJS的主题，元素，仪表板等。 Vue Paper Dashboard PROVue Paper Dashboard PRO 是一个基于Bootstrap和Vue构建的漂亮资源，它将帮助你在短时间内开始开发仪表盘。Vue Paper Dashboard Pro是Original Paper Dashboard Pro的VueJS移植版本。使用仪表板非常简单，但是需要具备Javascript，Vue和Vue-Router的基础知识。 KoelKoel是一种简单的基于Web的个人音频流服务，在客户端用Vue编写，在服务器端用Laravel编写。针对Web开发人员，Koel采用了一些更现代的Web技术——CSS grid，音频和拖放API等来完成其工作。 Vue Argon DashboardVue Argon Dashboard是Bootstrap 4和Vue.js的仪表板。它是开源的，免费的，并且具有许多组件，可以帮助你创建出色的网站。Vue Argon仪表板内置了100多个单独的组件，因此你可以选择和组合，因为实现了所有元素，所以从原型化到全功能代码将节省大量时间。该仪表板附带了预先构建的示例，因此开发过程是无缝的，从我们的页面切换到真实的网站非常容易。 PagekitPagekit是使用Symfony组件和VueJS构建的模块化，轻量级CMS。无论是个人博客还是你公司的网站，都可以使用Pagekit来为网络创建功能强大的内容，使其在每台设备上都能完美运行。它具有干净直观的界面，它也有一个很棒的内置市场。 Vue Material Dashboard PROVue Material Dashboard PRO是一个出色的高级管理模板，建立在Vue Material和VueJS之上。它是通过考虑你在仪表板中实际需要的东西而创建的。Vue Material Dashboard PRO包含精选和优化的VueJS插件，一切都旨在相互配合。使用仪表板非常简单，但是需要具备Javascript，VueJS和Vue Router的基础知识。 Vue-ColorVue-Color是一款来自Sketch、Photoshop、Chrome、Github、Twitter、Material Design等的酷炫的采色器。 Vue Material KitVue Material Kit 是基于Vue Material和VueJS构建的令人惊叹的免费开源资源。它将帮助你立即开始开发UI工具包。Vue Material Kit是原始Material Kit的官方VueJS版本。使用UI Kit非常简单，但是需要Javascript，VueJS和Vue Router的基础知识。 RetrospectifyRetrospectify 是一个用 Vue 编写的很棒的工具，用于以数字方式进行敏捷团队回顾。当与远程团队进行回顾时，或者当您希望随时间跟踪回顾结果时，这将很有用。它有三种类型的笔记，你可以移动笔记或添加点到个别的笔记。 Code NotesCode Notes 是使用Electron＆Vue.js构建的开发人员的简单代码段管理器。使用它，你可以将多个片段保存在一个便笺中，按名称/语言/标签进行搜索，还可以管理Github要点。 希望这份清单对您的下一个开发项目有帮助 🙂","categories":[],"tags":[]},{"title":"TypeScript泛型及应用","slug":"TypeScript泛型及应用","date":"2020-06-11T22:08:33.000Z","updated":"2020-06-13T20:42:23.190Z","comments":true,"path":"2020/06/12/typescript/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/typescript/","excerpt":"觉得 TypeScript 泛型有点难，想系统学习 TypeScript 泛型相关知识的小伙伴们看过来，本文从八个方面入手，全方位带你一步步学习 TypeScript 中泛型，详细的内容大纲请看下图： 动静（图）结合，在泛型学习之路助你一臂之力，还在犹豫什么，赶紧开启 TypeScript 泛型的学习之旅吧！","text":"觉得 TypeScript 泛型有点难，想系统学习 TypeScript 泛型相关知识的小伙伴们看过来，本文从八个方面入手，全方位带你一步步学习 TypeScript 中泛型，详细的内容大纲请看下图： 动静（图）结合，在泛型学习之路助你一臂之力，还在犹豫什么，赶紧开启 TypeScript 泛型的学习之旅吧！ 一、泛型是什么软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。 为了便于大家更好地理解上述的内容，我们来举个例子，在这个例子中，我们将一步步揭示泛型的作用。首先我们来定义一个通用的 identity 函数，该函数接收一个参数并直接返回它： function identity (value) { return value; } console.log(identity(1)) // 1 现在，我们将 identity 函数做适当的调整，以支持 TypeScript 的 Number 类型的参数： function identity (value: Number) : Number { return value; } console.log(identity(1)) // 1 这里 identity 的问题是我们将 Number 类型分配给参数和返回类型，使该函数仅可用于该原始类型。但该函数并不是可扩展或通用的，很明显这并不是我们所希望的。 我们确实可以把 Number 换成 any，我们失去了定义应该返回哪种类型的能力，并且在这个过程中使编译器失去了类型保护的作用。我们的目标是让 identity 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用泛型来解决这个问题，具体实现方式如下： function identity &lt;T&gt;(value: T) : T { return value; } console.log(identity&lt;Number&gt;(1)) // 1 对于刚接触 TypeScript 泛型的读者来说，首次看到 &lt;T&gt; 语法会感到陌生。但这没什么可担心的，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。 参考上面的图片，当我们调用 identity&lt;Number&gt;(1) ，Number 类型就像参数 1 一样，它将在出现 T 的任何位置填充该类型。图中 &lt;T&gt; 内部的 T 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 value 参数用来代替它的类型：此时 T 充当的是类型，而不是特定的 Number 类型。 其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。除了 T 之外，以下是常见泛型变量代表的意思： K（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数： function identity &lt;T, U&gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity&lt;Number, string&gt;(68, &quot;Semlinker&quot;)); 除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如： function identity &lt;T, U&gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity(68, &quot;Semlinker&quot;)); 对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。下面我们来看张动图，直观地感受一下类型传递的过程： ![generic-type-filled](data:image/svg+xml;utf8,) （图片来源：medium.com/better-prog… 感谢 @仑（前端搬砖党）指出，该动图有bug。 动态图最后一句错了吗？console.log(identity([1,2,3]))这里注入类型应该是number[]吧？ 如你所见，该函数接收你传递给它的任何类型，使得我们可以为不同类型创建可重用的组件。现在我们再来看一下 identity 函数： function identity &lt;T, U&gt;(value: T, message: U) : T { console.log(message); return value; } 相比之前定义的 identity 函数，新的 identity 函数增加了一个类型变量 U，但该函数的返回类型我们仍然使用 T。如果我们想要返回两种类型的对象该怎么办呢？针对这个问题，我们有多种方案，其中一种就是使用元组，即为元组设置通用的类型： function identity &lt;T, U&gt;(value: T, message: U) : [T, U] { return [value, message]; } 虽然使用元组解决了上述的问题，但有没有其它更好的方案呢？答案是有的，你可以使用泛型接口。 二、泛型接口为了解决上面提到的问题，首先让我们创建一个用于的 identity 函数通用 Identities 接口： interface Identities&lt;V, M&gt; { value: V, message: M } 在上述的 Identities 接口中，我们引入了类型变量 V 和 M，来进一步说明有效的字母都可以用于表示类型变量，之后我们就可以将 Identities 接口作为 identity 函数的返回类型： function identity&lt;T, U&gt; (value: T, message: U): Identities&lt;T, U&gt; { console.log(value + &quot;: &quot; + typeof (value)); console.log(message + &quot;: &quot; + typeof (message)); let identities: Identities&lt;T, U&gt; = { value, message }; return identities; } console.log(identity(68, &quot;Semlinker&quot;)); 以上代码成功运行后，在控制台会输出以下结果： 68: number Semlinker: string {value: 68, message: &quot;Semlinker&quot;} 泛型除了可以应用在函数和接口之外，它也可以应用在类中，下面我们就来看一下在类中如何使用泛型。 三、泛型类在类中使用泛型也很简单，我们只需要在类名后面，使用 &lt;T, ...&gt; 的语法定义任意多个类型变量，具体示例如下： interface GenericInterface&lt;U&gt; { value: U getIdentity: () =&gt; U } class IdentityClass&lt;T&gt; implements GenericInterface&lt;T&gt; { value: T constructor(value: T) { this.value = value } getIdentity(): T { return this.value } } const myNumberClass = new IdentityClass&lt;Number&gt;(68); console.log(myNumberClass.getIdentity()); // 68 const myStringClass = new IdentityClass&lt;string&gt;(&quot;Semlinker!&quot;); console.log(myStringClass.getIdentity()); // Semlinker! 接下来我们以实例化 myNumberClass 为例，来分析一下其调用过程： 在实例化 IdentityClass 对象时，我们传入 Number 类型和构造函数参数值 68； 之后在 IdentityClass 类中，类型变量 T 的值变成 Number 类型； IdentityClass 类实现了 GenericInterface&lt;T&gt;，而此时 T 表示 Number 类型，因此等价于该类实现了 GenericInterface&lt;Number&gt; 接口； 而对于 GenericInterface&lt;U&gt; 接口来说，类型变量 U 也变成了 Number。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。 泛型类可确保在整个类中一致地使用指定的数据类型。比如，你可能已经注意到在使用 Typescript 的 React 项目中使用了以下约定： type Props = { className?: string ... }; type State = { submitted?: bool ... }; class MyComponent extends React.Component&lt;Props, State&gt; { ... } 在以上代码中，我们将泛型与 React 组件一起使用，以确保组件的 props 和 state 是类型安全的。 相信看到这里一些读者会有疑问，我们在什么时候需要使用泛型呢？通常在决定是否使用泛型时，我们有以下两个参考标准： 当你的函数、接口或类将处理多种数据类型时； 当函数、接口或类在多个地方使用该数据类型时。 很有可能你没有办法保证在项目早期就使用泛型的组件，但是随着项目的发展，组件的功能通常会被扩展。这种增加的可扩展性最终很可能会满足上述两个条件，在这种情况下，引入泛型将比复制组件来满足一系列数据类型更干净。 我们将在本文的后面探讨更多满足这两个条件的用例。不过在这样做之前，让我们先介绍一下 Typescript 泛型提供的其他功能。 四、泛型约束有时我们可能希望限制每个类型变量接受的类型数量，这就是泛型约束的作用。下面我们来举几个例子，介绍一下如何使用泛型约束。 4.1 确保属性存在有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。 一个很好的例子是在处理字符串或数组时，我们会假设 length 属性是可用的。让我们再次使用 identity 函数并尝试输出参数的长度： function identity&lt;T&gt;(arg: T): T { console.log(arg.length); // Error return arg; } 在这种情况下，编译器将不会知道 T 确实含有 length 属性，尤其是在可以将任何类型赋给类型变量 T 的情况下。我们需要做的就是让类型变量 extends 一个含有我们所需属性的接口，比如这样： interface Length { length: number; } function identity&lt;T extends Length&gt;(arg: T): T { console.log(arg.length); // 可以获取length属性 return arg; } T extends Length 用于告诉编译器，我们支持已经实现 Length 接口的任何类型。之后，当我们使用不含有 length 属性的对象作为参数调用 identity 函数时，TypeScript 会提示相关的错误信息： identity(68); // Error // Argument of type &#39;68&#39; is not assignable to parameter of type &#39;Length&#39;.(2345) 此外，我们还可以使用 , 号来分隔多种约束类型，比如：&lt;T extends Length, Type2, Type3&gt;。而对于上述的 length 属性问题来说，如果我们显式地将变量设置为数组类型，也可以解决该问题，具体方式如下： function identity&lt;T&gt;(arg: T[]): T[] { console.log(arg.length); return arg; } // or function identity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; { console.log(arg.length); return arg; } 4.2 检查对象上的键是否存在泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 keyof 操作符，keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。 “耳听为虚，眼见为实”，我们来举个 keyof 的使用示例： interface Person { name: string; age: number; location: string; } type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot; type K2 = keyof Person[]; // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ... type K3 = keyof { [x: string]: Person }; // string | number 通过 keyof 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 extends 约束，即限制输入的属性名包含在 keyof 返回的联合类型中。具体的使用方式如下： function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]; } 在以上的 getProperty 函数中，我们通过 K extends keyof T 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 let value = obj[key]; 不同。 下面我们来看一下如何使用 getProperty 函数： enum Difficulty { Easy, Intermediate, Hard } function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]; } let tsInfo = { name: &quot;Typescript&quot;, supersetOf: &quot;Javascript&quot;, difficulty: Difficulty.Intermediate } let difficulty: Difficulty = getProperty(tsInfo, &#39;difficulty&#39;); // OK let supersetOf: string = getProperty(tsInfo, &#39;superset_of&#39;); // Error 在以上示例中，对于 getProperty(tsInfo, &#39;superset_of&#39;) 这个表达式，TypeScript 编译器会提示以下错误信息： Argument of type &#39;&quot;superset_of&quot;&#39; is not assignable to parameter of type &#39;&quot;difficulty&quot; | &quot;name&quot; | &quot;supersetOf&quot;&#39;.(2345) 很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。接下来，我们来介绍一下泛型参数默认类型。 五、泛型参数默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。 泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 &lt;T=Default Type&gt;，对应的使用示例如下： interface A&lt;T=string&gt; { name: T; } const strA: A = { name: &quot;Semlinker&quot; }; const numB: A&lt;number&gt; = { name: 101 }; 泛型参数的默认类型遵循以下规则： 有默认类型的类型参数被认为是可选的。 必选的类型参数不能在可选的类型参数后。 如果类型参数有约束，类型参数的默认类型必须满足这个约束。 当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。 如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。 一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。 一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。 六、泛型条件类型在 TypeScript 2.8 中引入了条件类型，使得我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 extends 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。 条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一： T extends U ? X : Y 以上表达式的意思是：若 T 能够赋值给 U，那么类型是 X，否则为 Y。在条件类型表达式中，我们通常还会结合 infer 关键字，实现类型抽取： interface Dictionary&lt;T = any&gt; { [key: string]: T; } type StrDict = Dictionary&lt;string&gt; type DictMember&lt;T&gt; = T extends Dictionary&lt;infer V&gt; ? V : never type StrDictMember = DictMember&lt;StrDict&gt; // string 在上面示例中，当类型 T 满足 T extends Dictionary 约束时，我们会使用 infer 关键字声明了一个类型变量 V，并返回该类型，否则返回 never 类型。 在 TypeScript 中，never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。 另外，需要注意的是，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 除了上述的应用外，利用条件类型和 infer 关键字，我们还可以方便地实现获取 Promise 对象的返回值类型，比如： async function stringPromise() { return &quot;Hello, Semlinker!&quot;; } interface Person { name: string; age: number; } async function personPromise() { return { name: &quot;Semlinker&quot;, age: 30 } as Person; } type PromiseType&lt;T&gt; = (args: any[]) =&gt; Promise&lt;T&gt;; type UnPromisify&lt;T&gt; = T extends PromiseType&lt;infer U&gt; ? U : never; type extractStringPromise = UnPromisify&lt;typeof stringPromise&gt;; // string type extractPersonPromise = UnPromisify&lt;typeof personPromise&gt;; // Person 七、泛型工具类型为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍其中几个常用的工具类型。 7.1 PartialPartial&lt;T&gt; 的作用就是将某个类型里的属性全部变为可选项 ?。 定义： /** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial&lt;T&gt; = { [P in keyof T]?: T[P]; }; 在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。 示例： interface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) { return { ...todo, ...fieldsToUpdate }; } const todo1 = { title: &quot;organize desk&quot;, description: &quot;clear clutter&quot; }; const todo2 = updateTodo(todo1, { description: &quot;throw out trash&quot; }); 在上面的 updateTodo 方法中，我们利用 Partial&lt;T&gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial&lt;Todo&gt;，即： { title?: string | undefined; description?: string | undefined; } 7.2 RecordRecord&lt;K extends keyof any, T&gt; 的作用是将 K 中所有的属性的值转化为 T 类型。 定义： /** * node_modules/typescript/lib/lib.es5.d.ts * Construct a type with a set of properties K of type T */ type Record&lt;K extends keyof any, T&gt; = { [P in K]: T; }; 示例： interface PageInfo { title: string; } type Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;; const x: Record&lt;Page, PageInfo&gt; = { about: { title: &quot;about&quot; }, contact: { title: &quot;contact&quot; }, home: { title: &quot;home&quot; } }; 7.3 PickPick&lt;T, K extends keyof T&gt; 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。 定义： // node_modules/typescript/lib/lib.es5.d.ts /** * From T, pick a set of properties whose keys are in the union K */ type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]; }; 示例： interface Todo { title: string; description: string; completed: boolean; } type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;; const todo: TodoPreview = { title: &quot;Clean room&quot;, completed: false }; 7.4 ExcludeExclude&lt;T, U&gt; 的作用是将某个类型中属于另一个的类型移除掉。 定义： // node_modules/typescript/lib/lib.es5.d.ts /** * Exclude from T those types that are assignable to U */ type Exclude&lt;T, U&gt; = T extends U ? never : T; 如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型。最终实现的效果就是将 T 中某些属于 U 的类型移除掉。 示例： type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &quot;b&quot; | &quot;c&quot; type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &quot;c&quot; type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number 7.5 ReturnTypeReturnType&lt;T&gt; 的作用是用于获取函数 T 的返回类型。 定义： // node_modules/typescript/lib/lib.es5.d.ts /** * Obtain the return type of a function type */ type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any; 示例： type T0 = ReturnType&lt;() =&gt; string&gt;; // string type T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // void type T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // {} type T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // number[] type T4 = ReturnType&lt;any&gt;; // any type T5 = ReturnType&lt;never&gt;; // any type T6 = ReturnType&lt;string&gt;; // Error type T7 = ReturnType&lt;Function&gt;; // Error 简单介绍了泛型工具类型，最后我们来介绍如何使用泛型来创建对象。 八、使用泛型创建对象8.1 构造签名有时，泛型类可能需要基于传入的泛型 T 来创建其类型相关的对象。比如： class FirstClass { id: number | undefined; } class SecondClass { name: string | undefined; } class GenericCreator&lt;T&gt; { create(): T { return new T(); } } const creator1 = new GenericCreator&lt;FirstClass&gt;(); const firstClass: FirstClass = creator1.create(); const creator2 = new GenericCreator&lt;SecondClass&gt;(); const secondClass: SecondClass = creator2.create(); 在以上代码中，我们定义了两个普通类和一个泛型类 GenericCreator&lt;T&gt;。在通用的 GenericCreator 泛型类中，我们定义了一个名为 create 的成员方法，该方法会使用 new 关键字来调用传入的实际类型的构造函数，来创建对应的对象。但可惜的是，以上代码并不能正常运行，对于以上代码，在 TypeScript v3.9.2 编译器下会提示以下错误： &#39;T&#39; only refers to a type, but is being used as a value here. 这个错误的意思是：T 类型仅指类型，但此处被用作值。那么如何解决这个问题呢？根据 TypeScript 文档，为了使通用类能够创建 T 类型的对象，我们需要通过其构造函数来引用 T 类型。对于上述问题，在介绍具体的解决方案前，我们先来介绍一下构造签名。 在 TypeScript 接口中，你可以使用 new 关键字来描述一个构造函数： interface Point { new (x: number, y: number): Point; } 以上接口中的 new (x: number, y: number) 我们称之为构造签名，其语法如下： ConstructSignature: new TypeParametersopt ( ParameterListopt ) TypeAnnotationopt 在上述的构造签名中，TypeParametersopt 、ParameterListopt 和 TypeAnnotationopt 分别表示：可选的类型参数、可选的参数列表和可选的类型注解。与该语法相对应的几种常见的使用形式如下： new C new C ( ... ) new C &lt; ... &gt; ( ... ) 介绍完构造签名，我们再来介绍一个与之相关的概念，即构造函数类型。 8.2 构造函数类型在 TypeScript 语言规范中这样定义构造函数类型： An object type containing one or more construct signatures is said to be a constructor type. Constructor types may be written using constructor type literals or by including construct signatures in object type literals. 通过规范中的描述信息，我们可以得出以下结论： 包含一个或多个构造签名的对象类型被称为构造函数类型； 构造函数类型可以使用构造函数类型字面量或包含构造签名的对象类型字面量来编写。 那么什么是构造函数类型字面量呢？构造函数类型字面量是包含单个构造函数签名的对象类型的简写。具体来说，构造函数类型字面量的形式如下： new &lt; T1, T2, ... &gt; ( p1, p2, ... ) =&gt; R 该形式与以下对象类型字面量是等价的： { new &lt; T1, T2, ... &gt; ( p1, p2, ... ) : R } 下面我们来举个实际的示例： // 构造函数类型字面量 new (x: number, y: number) =&gt; Point 等价于以下对象类型字面量： { new (x: number, y: number): Point; } 8.3 构造函数类型的应用在介绍构造函数类型的应用前，我们先来看个例子： interface Point { new (x: number, y: number): Point; x: number; y: number; } class Point2D implements Point { readonly x: number; readonly y: number; constructor(x: number, y: number) { this.x = x; this.y = y; } } const point: Point = new Point2D(1, 2); 对于以上的代码，TypeScript 编译器会提示以下错误信息： Class &#39;Point2D&#39; incorrectly implements interface &#39;Point&#39;. Type &#39;Point2D&#39; provides no match for the signature &#39;new (x: number, y: number): Point&#39;. 相信很多刚接触 TypeScript 不久的小伙伴都会遇到上述的问题。要解决这个问题，我们就需要把对前面定义的 Point 接口进行分离，即把接口的属性和构造函数类型进行分离： interface Point { x: number; y: number; } interface PointConstructor { new (x: number, y: number): Point; } 完成接口拆分之后，除了前面已经定义的 Point2D 类之外，我们又定义了一个 newPoint 工厂函数，该函数用于根据传入的 PointConstructor 类型的构造函数，来创建对应的 Point 对象。 class Point2D implements Point { readonly x: number; readonly y: number; constructor(x: number, y: number) { this.x = x; this.y = y; } } function newPoint( pointConstructor: PointConstructor, x: number, y: number ): Point { return new pointConstructor(x, y); } const point: Point = newPoint(Point2D, 1, 2); 8.4 使用泛型创建对象了解完构造签名和构造函数类型之后，下面我们来开始解决上面遇到的问题，首先我们需要重构一下 create 方法，具体如下所示： class GenericCreator&lt;T&gt; { create&lt;T&gt;(c: { new (): T }): T { return new c(); } } 在以上代码中，我们重新定义了 create 成员方法，根据该方法的签名，我们可以知道该方法接收一个参数，其类型是构造函数类型，且该构造函数不包含任何参数，调用该构造函数后，会返回类型 T 的实例。 如果构造函数含有参数的话，比如包含一个 number 类型的参数时，我们可以这样定义 create 方法： create&lt;T&gt;(c: { new(a: number): T; }, num: number): T { return new c(num); } 更新完 GenericCreator 泛型类，我们就可以使用下面的方式来创建 FirstClass 和 SecondClass 类的实例： const creator1 = new GenericCreator&lt;FirstClass&gt;(); const firstClass: FirstClass = creator1.create(FirstClass); const creator2 = new GenericCreator&lt;SecondClass&gt;(); const secondClass: SecondClass = creator2.create(SecondClass); 九、参考资源 typescript-generics typescript-generics-explained typescript-tip-of-the-week-generics","categories":[],"tags":[]},{"title":"如何快速搭建好看的个人博客","slug":"如何快速搭建好看的个人博客","date":"2020-06-11T22:04:28.000Z","updated":"2020-06-13T20:43:42.437Z","comments":true,"path":"2020/06/12/blog/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/blog/","excerpt":"如何快速搭建好看的个人博客(完整配置与源码) 博客地址 程序员成长指北 就是这样搭建出来的! 可以先体验下。","text":"如何快速搭建好看的个人博客(完整配置与源码) 博客地址 程序员成长指北 就是这样搭建出来的! 可以先体验下。 为什么选择vuepress之前使用docsify部署过个人博客, 在此之前也使用过gitbook, 这次使用vuepress来改版, 根据自己的体验, 将这三者做一个对比 从阅读体验来说(个人感觉): gitbook &gt; docsify =vuepress 从配置上来说, docsify相比于vuepress和gitbook都要简单一些. 从性能上来说: vuepress &gt; docsify 虽然docsify也是基于vue的, docsify是运行时解析, vuepress是预先渲染HTML 灵活性上, vuepress也是相当占优势的, 对vue熟悉的朋友可以编写vue组件实现你想要的功能样式 vuepress特性 为技术文档而优化的内置Markdown拓展 在Markdown文件中使用Vue组件的能力 Vue驱动的自定义主题系统 自动生成Service Worker(支持PWA) Google Analytics集成 基于Git的”最后更新时间 多语言支持 响应式布局 支持PWA模式 总的来说, 使用vuepress优势有挺多的, 特别是我之前使用docsify搭建的网站, 是一点也没有被浏览器收录啊, 怎么都搜不到,受到一万点打击,所以决心改一改 其实vuepress的官网已经写的挺好的了, 但是我这篇文章也有优势啊,是一步步的教你搭建, 这样就不用来回在文档中去找什么配置.(当然如果你想直接通过官网来学习, 可以直接看官网,点击链接就可以喔) 项目搭建安装vuepress第一步就是进行vuepress进行安装: 如果使用npm来安装, Node.js版本需要 &gt;=8 才可以 yarn global add vuepress # 或者：npm install -g vuepress 注意如果你的现有项目依赖了 webpack 3.x，推荐使用 Yarn而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。 初始化项目创建项目目录blog mkdir blog cd blog 初始化 yarn init -y # 或者 npm init -y 初始化完成后, 会创建一个package.json { &quot;name&quot;:&quot;blog&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot; &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; } } 在package.json中, 配置启动命令 &quot;scripts&quot;: { &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;, &quot;docs:build&quot;: &quot;vuepress build docs&quot; } 启动项目: npm run docs:dev这条命令就等于vuepress dev docs 打包项目: npm run build 这条命令就等于 vuepress build docs 创建docs目录, 主要用于放置我们写的.md类型的文章以及.vuepress相关的配置 mkdir docs 接着在docs文件夹中创建.vuepress文件夹 cd docs mkdir .vuepress 这个文件主要就是放vuepress相关的配置 到这一步, 我们的项目大体架子已经搭建出来了,接下来进行配置. 页面具体内容配置基本配置接下来要让页面显示内容, 就需要进行配置, 新建一个总的配置文件config.js, 这个文件的名字是固定的. cd .vuepress touch config.js config.js最基础的配置文件内容如下: module.exports = { title: &#39;koala的博客&#39;, description: &#39;专注 Node.js 技术栈分享，从前端到Node.js再到数据库&#39;, } 如果这时运行npm run docs:dev或者yarn docs:dev, 会出现页面404页面,vuepress默认打开的是docs下的readme.md文件, 由于你没有创建,所以找到的是vuepress默认提供的404页面, 关于这有点,我们借助vue-devtools工具来查看一下vue的结构 在docs目录下创建README.md文件, 再运行,就可以看到运行起来的效果, 如下图所示: blog001.jpg 设置封面页此时README文件中没有内容,封面页是空的, 我们可以通过在这个markdown文件中写一些内容, 同时官方也给我们提供了封面页的模板(个人觉得还是比较实用的): --- home: true heroImage: /home.png actionText: Get Started → actionLink: /node/ features: - title: day day up details: 记录每一天的进步, 一分耕耘，一分收获. - title: 程序员成长指北 details: 专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师 - title: koala details: 一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。 footer: MIT Licensed | Copyright © 2018-present Evan You --- 效果图如下: 配置导航栏nav在config.js中添加: themeConfig:{ nav: [{text: &quot;主页&quot;, link: &quot;/&quot; }, { text: &quot;node&quot;, link: &quot;/node/&quot; }, { text: &quot;前端&quot;, link: &quot;/webframe/&quot;}, { text: &quot;数据库&quot;, link: &quot;/database/&quot; }, { text: &quot;android&quot;, link: &quot;/android/&quot; }, { text: &quot;面试问题&quot;, link: &quot;/interview/&quot; } ], } 效果如下图: 如果想要展示二级导航, 可以这样配置: themeConfig:{ nav: [{text: &quot;主页&quot;, link: &quot;/&quot; }, { text: &quot;node&quot;, link: &quot;/node/&quot; }, { text: &quot;前端&quot;, items: [ { text: &quot;html&quot;, link:&quot;/web/html/&quot;}, { text: &quot;css&quot;, link:&quot;/web/css/&quot;}, ] }, { text: &quot;数据库&quot;, link: &quot;/database/&quot; }, { text: &quot;android&quot;, link: &quot;/android/&quot; }, { text: &quot;面试问题&quot;, link: &quot;/interview/&quot; } ], } 效果如图所示: 当你使用上面的方式配置nav时, 目录结构最好和我创建的一样 项目目录结构如下: 导航栏创建好了, 接下来就是配置页面内容中的侧边栏slider 配置侧边栏slider1.自动获取侧边栏内容如果你希望自动生成当前页面标题的侧边栏, 可以在config.js中配置来启用 // .vuepress/config.js module.exports = { themeConfig:{ sidebar: &#39;auto&#39;, // sidebarDepth: 1 } } 2.展示每个页面的侧边栏如果你希望为不同的页面组显示不同的侧边栏, 就和官网一样, 点击指南显示的是对应的侧边栏,目前目录有node \\ database \\ web等, 这些目录下都存放着多个md文件: module.exports = { themeConfig:{ sidebar:{ &quot;/node/&quot;:[ [&quot;&quot;, &quot;node目录&quot;], [&quot;path&quot;, &quot;作为前端也需要知道的路径知识&quot;], [&quot;stream&quot;, &quot;node核心模块-stream&quot;] ], &quot;/web/&quot;:[ [&quot;&quot;, &quot;前端&quot;], { title: &quot;css&quot;, name: &quot;css&quot;, collabsable: false, children: [ [&quot;css/&quot;, &quot;目录&quot;], [&#39;css/1&#39;, &quot;css常考面试题&quot;] ] } ] } } } 设置的效果图如下: 在node导航下: 在前端导航下的效果: 上面采用了两个方式配置侧边栏, 一个侧边栏是node目录下直接是写的markdown文章, 而在web下又有多个分类, 所有有进行了分栏配置, 其实这两种方式在我们博客中都是比较常见的 自定义布局内容网站的导航和侧边栏都已经配置好之后, 如果你觉得页面不是很符合你的预期, 你也可以自定修改成你想要的效果。比如就像我的博客中左侧固定的内容, 就是自定义的全局组件. 这里使用vuepress提供的插件机制来实现 在.vuepress文件夹下创建components文件夹, 在components下再创建fixed.vue文件 &lt;template&gt; &lt;div class=&quot;fixed_container&quot;&gt; &lt;div class=&quot;tencent_code&quot;&gt; &lt;h4&gt;关注作者公众&lt;/h4&gt; &lt;p&gt;和万千小伙伴一起学习&lt;/p&gt; &lt;img src=&quot;/ggh.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;group_code&quot;&gt; &lt;h4&gt;加入技术交流群&lt;/h4&gt; &lt;p&gt;扫描二维码 备注 &lt;span&gt; 加群&lt;/span&gt; &lt;/p&gt; &lt;img src=&quot;/wechat.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;fixed&#39; } &lt;/script&gt; .... // 这里省略了部分样式代码, 想看全部的小伙伴点开github地址就可以了 然后在配置文件中以插件的形式配置即可: // 插件 plugins:[ { name:&quot;page-plugin&quot;, globalUIComponents:[&quot;fixed&quot;], } ] globalUIComponents是用于注入全局的UI, 它以数组的形式接收参数名字, 这里的名字必须与components文件夹下的.vue文件同名, 全局UI就是一个Vue组件; 其实vuepress也提供了一些内置的全局UI组件, 例如:back-to-top, popup, nprogress等. 配置插件UI插件配置内置的全局UI,首先需要插件: yarn add -D @vuepress/plugin-back-to-top @vuepress/plugin-nprogress # OR npm install -D @vuepress/plugin-back-to-top @vuepress/plugin-nprogress 在config.js中配置: plugins:[ [&quot;@vuepress/back-to-top&quot;], // 返回顶部 [&quot;@vuepress/nprogress&quot;], // 加载进度条 ] 这里需要注意一点就是看你项目中是否安装了vuepress, 由于我之前是全局安装的, 在项目下还没有安装, 插件是依赖于vuepress的, 所有没有安装的需要安装上, 插件才有效. 支持PWAvuepress还有一个我比较看重的优势, 就是支持PWA, 当用户没有网的情况下,一样能继续的访问我们的网站 在0.x 版本中我们只要配置serviceWorker: true 即可, 但是我们现在使用的是1.2.0版本, 这个版本中已经将这个功能抽离出来作为插件的方式使用, 下面就看一下具体如何使用的: 首先需要安装插件: yarn add -D @vuepress/plugin-pwa # 或者 npm install -D @vuepress/plugin-pwa 在config.js中配置: module.exports = { plugins: [&#39;@vuepress/pwa&#39;, { serviceWorker: true, updatePopup: true }] } 注意点: 为了让你的网站完全地兼容 PWA，你需要: 在 .vuepress/public 提供 Manifest 和 icons 在 .vuepress/config.js 添加正确的 head links // 配置 module.exports = { head: [ [&#39;link&#39;, { rel: &#39;icon&#39;, href: `/favicon.ico` }], //增加manifest.json [&#39;link&#39;, { rel: &#39;manifest&#39;, href: &#39;/manifest.json&#39; }], ], } manifest.json 文件 { &quot;name&quot;: &quot;koala_blog&quot;, &quot;short_name&quot;: &quot;blog&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;程序员成长指北博主, koala的博客&quot;, &quot;manifest_version&quot;: 2 } 配置评论由于之前有小伙伴说过,『程序员成长指北』公众号上不能评论，所有这次我在博客中增加了评论功能，刚开始本来打算使用gitTalk, 但是我的博客采用的是部署到自己的服务器, 并没有部署成 GitHub Pages, 所有我使用的是valine, 它除了评论功能还可以统计阅读量, 请大家看: 但是我后面也会将gitTalk配置方式写出来, 方便使用gitTalk的小伙伴 valine 使用点击进入 Valine官网 ，需要先注册才能使用. 然后创建应用, 获取APP ID 和APP KEY 应用创建好以后，进入刚刚创建的应用，选择左下角的设置 &gt; 应用Key，然后就能看到你的APP ID 和APP Key了 安装: yarn add vuepress-plugin-comment -D 快速使用 在.vuepress下的config.js插件配置中: module.exports = { plugins: [ [ &#39;vuepress-plugin-comment&#39;, { choosen: &#39;valine&#39;, // options选项中的所有参数，会传给Valine的配置 options: { el: &#39;#valine-vuepress-comment&#39;, appId: &#39;Your own appId&#39;, appKey: &#39;Your own appKey&#39; } } ] ] } appid和appkey为你创建的应用的APP ID 和APP Key gitTalk 使用主题样式修改vuepress默认是主题颜色是绿色, 如果你不喜欢可以对其进行更改. 如果要对默认设置的样式进行简单颜色替换, 或者自定义一些颜色变量供以后使用, 可以在.vuepress/styles下创建palette.styl文件. 你可以调整的颜色变量: // 颜色 $textColor ?= #2c3e50 $accentColor ?= #1e90ff $grayTextColor ?= #666 $lightTextColor ?= #999 $borderColor ?= #eaecef $codeBgColor ?= #282c34 $arrowBgColor ?= #ccc $navbarColor ?= #fff $headerColor ?= #fff $headerTitleColor ?= #fff $nprogressColor ?= $accentColor // 布局 bannerHeight ?= 12rem // 响应式 breakpoints MQNarrow ?= 1024px MQMobileNarrow ?= 480px 注意点:你应该只在这个文件中写入颜色变量。因为 palette.styl 将在根的 stylus 配置文件的末尾引入，作为配置，它将被多个文件使用，所以一旦你在这里写了样式，你的样式就会被多次复制 如果要添加额外的样式, vuepress也是提供了简便方法的, 只要在.vuepress/styles文件下创建一个 index.styl, 在里面写css样式即可, 注意文件命名是固定的. 部署nginx部署我的博客采用的是静态文件部署, 感觉方便又便捷, 之前部署在Github Pages上, 访问速度不是很理想. 第一步: 确保你满足下面几个条件 你有一台服务器 已经安装好nginx, 如果不会的小伙伴请看如何安装nginx 解析了一个可用的域名 第二步: 打包你的项目 运行npm run docs:build将项目打包, 默认打包文件在docs/.vuepress/dist目录下 第三步: 配置nginx 进入到nginx 配置目录, 找到conf.d文件, 添加下面的配置: server { listen 80; server_name www.inode.club; root /usr/web/inode/dist; error_log /var/log/nginx/inode-error.log; access_log /var/log/nginx/inode-access.log; # deny all; index index.php index.html index.htm; } server_name 是你解析的域名地址 root 配置文件将访问的静态资源文件的路径 *第四步: 上传静态资源文件 * 将静态资源文件放置到服务器上, 路径为配置的/usr/web/inode/dist, 可以借助xftp工具上传也可以通过git克隆, 选择适合自己的方式就可以 *第五步: 重启nginx * # 重启之前务必检查配置是否正确 sudo nginx -t // 检查配置 sudo nginx -s reload // 重启 然后你就可以通过域名来访问你的网站啦! github部署将代码部署到 Github Pages, 你可以看vuepress文档: vuepress部署, 也参照我这里写的的步骤来部署 第一步: 首先确保你的项目满足以下几个条件: 文档放置在docs目录中 使用的是默认的构建输出位置 vuepress以本地依赖的形式被安装到你的项目中, 在根目录package.json文件中包含如下代码: // 配置npm scripts &quot;scripts&quot;: { &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;, &quot;docs:build&quot;: &quot;vuepress build docs&quot; } // VuePress 以本地依赖的形式被安装 &quot;devDependencies&quot;: { &quot;vuepress&quot;: &quot;^1.2.0&quot; } 第二步: 创建github仓库 在github上创建一个名为blog的仓库, 并将代码提交到github上 第三步: 配置仓库名称 配置docs/.vuepress/config.js文件中的base, 如果打算发布到https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/(也就是说你的仓库在: https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt; ), 此处我的仓库为: blog, 则将base按照如下配置即可: module.exports = { base: &quot;/blog/&quot; } 第四步: 在项目根目录中,创建一个如下的脚本文件deploy.sh #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist git init git add -A git commit -m &#39;deploy&#39; # 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt; git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages # 例如 git push -f git@github.com:koala-coding/blog.git master:gh-pages cd - 第五步: 双击 deploy.sh 运行脚本 会自动在我们的 GitHub 仓库中，创建一个名为 gh-pages 的分支，而我们要部署到 GitHub Pages 的正是这个分支 **第六步: setting Github Pages 这是最后一步了，在 GitHub 项目点击 Setting 按钮，找到 GitHub Pages - Source，选择 gh-pages 分支，点击 Save 按钮后，静静地等待它部署完成即可。 项目地址我的网站 程序员成长指北 就是这样搭建出来的! 本文章实现的内容都已经上传到github, 如果不想一步步进行配置的, 可以直接下载下来使用,就不用重复造轮子啦! 需要博客源码的小伙伴可以直接公众后台回复【博客】领取，或者直接联系我。 参考文章 https://juejin.im/post/5c94ddf35188252d65344cfe","categories":[],"tags":[]},{"title":"动态代理设计模式","slug":"动态代理设计模式","date":"2020-06-11T22:00:05.000Z","updated":"2020-06-13T20:42:55.308Z","comments":true,"path":"2020/06/12/agent/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/agent/","excerpt":"10分钟看懂动态代理设计模式 动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。","text":"10分钟看懂动态代理设计模式 动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。 什么是代理从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。 是的，你没有看错，代理就是这么简单！ 理解了代理的意思，你脑海中恐怕还有两个巨大的疑问： 怎么实现代理模式 代理模式有什么实际用途 要理解这两个问题，看一个简单的例子： public interface Flyable { void fly(); } public class Bird implements Flyable { @Override public void fly() { System.out.println(&quot;Bird is flying...&quot;); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } 很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？ 有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。 @Override public void fly() { long start = System.currentTimeMillis(); System.out.println(&quot;Bird is flying...&quot;); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } 的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？ 一定会有人说，我可以在调用的地方这样写： public static void main(String[] args) { Bird bird = new Bird(); long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } 这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？ a）使用继承继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。 为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差： public class Bird2 extends Bird { @Override public void fly() { long start = System.currentTimeMillis(); super.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } } 这是一种解决方案，还有一种解决方案叫做：聚合，其实也是比较容易想到的。 我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法： public class Bird3 implements Flyable { private Bird bird; public Bird3(Bird bird) { this.bird = bird; } @Override public void fly() { long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } } 为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！ 继续深入思考，用问题推导来解答这个问题： 问题一：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？ 有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。 问题二：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？ 有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。 问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 聚合 是否可以避免这个问题呢？ 答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable public class Bird3 implements Flyable { private Flyable flyable; public Bird3(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { long start = System.currentTimeMillis(); flyable.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } } 为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志： public class BirdLogProxy implements Flyable { private Flyable flyable; public BirdLogProxy(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { System.out.println(&quot;Bird fly start...&quot;); flyable.fly(); System.out.println(&quot;Bird fly end...&quot;); } } 接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做： public static void main(String[] args) { Bird bird = new Bird(); BirdLogProxy p1 = new BirdLogProxy(bird); BirdTimeProxy p2 = new BirdTimeProxy(p1); p2.fly(); } 反过来，可以这么做： public static void main(String[] args) { Bird bird = new Bird(); BirdTimeProxy p2 = new BirdTimeProxy(bird); BirdLogProxy p1 = new BirdLogProxy(p2); p1.fly(); } 看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 聚合 可以做到，而继承不行呢。我们用一张图来解释一下： 静态代理接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。 从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题： 如果同时代理多个类，依然会导致类无限制扩展 如果类中有多个方法，同样的逻辑需要反复实现 那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：动态代理。 动态代理继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。 这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么： 动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 JavaPoet 这个第三方库帮我们生成TimeProxy的源码。希望 JavaPoet 不要成为你的负担，不理解 JavaPoet 没有关系，你只要把它当成一个Java源码生成工具使用即可。 PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。 第一步：生成TimeProxy源码public class Proxy { public static Object newProxyInstance() throws IOException { TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;) .addSuperinterface(Flyable.class); FieldSpec fieldSpec = FieldSpec.builder(Flyable.class, &quot;flyable&quot;, Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(Flyable.class, &quot;flyable&quot;) .addStatement(&quot;this.flyable = flyable&quot;) .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = Flyable.class.getDeclaredMethods(); for (Method method : methods) { MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addStatement(&quot;long start = $T.currentTimeMillis()&quot;, System.class) .addCode(&quot;\\n&quot;) .addStatement(&quot;this.flyable.&quot; + method.getName() + &quot;()&quot;) .addCode(&quot;\\n&quot;) .addStatement(&quot;long end = $T.currentTimeMillis()&quot;, System.class) .addStatement(&quot;$T.out.println(\\&quot;Fly Time =\\&quot; + (end - start))&quot;, System.class) .build(); typeSpecBuilder.addMethod(methodSpec); } JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 javaFile.writeTo(new File(&quot;/Users/ouyangfeng/Desktop/&quot;)); return null; } } 在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下： package com.youngfeng.proxy; import java.lang.Override; import java.lang.System; class TimeProxy implements Flyable { private Flyable flyable; public TimeProxy(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { long start = System.currentTimeMillis(); this.flyable.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly Time =&quot; + (end - start)); } } 第二步：编译TimeProxy源码编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作： public class JavaCompiler { public static void compile(File javaFile) throws IOException { javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(javaFile); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); } } 在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成： // 为了看的更清楚，我将源码文件生成到桌面 String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;; javaFile.writeTo(new File(sourcePath)); // 编译 JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;)); 第三步：加载到内存中并创建对象 URL[] urls = new URL[] {new URL(&quot;file:/&quot; + sourcePath)}; URLClassLoader classLoader = new URLClassLoader(urls); Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;); Constructor constructor = clazz.getConstructor(Flyable.class); Flyable flyable = (Flyable) constructor.newInstance(new Bird()); flyable.fly(); 通过以上三个步骤，我们至少解决了下面两个问题： 不再需要手动创建TimeProxy 可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间 可是，说好的任意对象呢？ 第四步：增加InvocationHandler接口查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入： 接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！ 为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增InvocationHandler接口，用于处理自定义逻辑： public interface InvocationHandler { void invoke(Object proxy, Method method, Object[] args); } 想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）： proxy =&gt; 这个参数指定动态生成的代理类，这里是TimeProxy method =&gt; 这个参数表示传入接口中的所有Method对象 args =&gt; 这个参数对应当前method方法中的参数 引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样： MyInvocationHandler handler = new MyInvocationHandler(); Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler); proxy.fly(); 方法执行流：proxy.fly() =&gt; handler.invoke() 为此，我们需要在Proxy.newProxyInstance()方法中做如下改动： 在newProxyInstance方法中传入InvocationHandler 在生成的代理类中增加成员变量handler 在生成的代理类方法中，调用invoke方法 public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception { TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;) .addModifiers(Modifier.PUBLIC) .addSuperinterface(inf); FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, &quot;handler&quot;, Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, &quot;handler&quot;) .addStatement(&quot;this.handler = handler&quot;) .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = inf.getDeclaredMethods(); for (Method method : methods) { MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addCode(&quot;try {\\n&quot;) .addStatement(&quot;\\t$T method = &quot; + inf.getName() + &quot;.class.getMethod(\\&quot;&quot; + method.getName() + &quot;\\&quot;)&quot;, Method.class) // 为了简单起见，这里参数直接写死为空 .addStatement(&quot;\\tthis.handler.invoke(this, method, null)&quot;) .addCode(&quot;} catch(Exception e) {\\n&quot;) .addCode(&quot;\\te.printStackTrace();\\n&quot;) .addCode(&quot;}\\n&quot;) .build(); typeSpecBuilder.addMethod(methodSpec); } JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;; javaFile.writeTo(new File(sourcePath)); // 编译 JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;)); // 使用反射load到内存 URL[] urls = new URL[] {new URL(&quot;file:&quot; + sourcePath)}; URLClassLoader classLoader = new URLClassLoader(urls); Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;); Constructor constructor = clazz.getConstructor(InvocationHandler.class); Object obj = constructor.newInstance(handler); return obj; } 上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码： 测试代码 Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird())); 生成的TimeProxy.java源码 package com.youngfeng.proxy; import java.lang.Override; import java.lang.reflect.Method; public class TimeProxy implements Flyable { private InvocationHandler handler; public TimeProxy(InvocationHandler handler) { this.handler = handler; } @Override public void fly() { try { Method method = com.youngfeng.proxy.Flyable.class.getMethod(&quot;fly&quot;); this.handler.invoke(this, method, null); } catch(Exception e) { e.printStackTrace(); } } } MyInvocationHandler.java public class MyInvocationHandler implements InvocationHandler { private Bird bird; public MyInvocationHandler(Bird bird) { this.bird = bird; } @Override public void invoke(Object proxy, Method method, Object[] args) { long start = System.currentTimeMillis(); try { method.invoke(bird, new Object[] {}); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } } 至此，整个方法栈的调用栈变成了这样： 看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。 其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。 如何使用上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳： Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象 InvocationHandler：这个接口主要用于自定义代理逻辑处理 为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。 查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。 这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？ 想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！ 只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。 事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。 JDK实现揭秘通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。 Proxy.java InvocationHandler 可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义： Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。 Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。 最后一个参数就不用说了，和我们实现的版本完全是一样的。 仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档： 核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。 遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。 答疑解惑invoke方法的第一个参数proxy到底有什么作用？这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。 动态代理到底有什么用？学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 AOP。所谓的AOP，就像刀一样，抓住时机，趁机插入。 基于这样一种动态特性，我们可以用它做很多事情，例如： 事务提交或回退（Web开发中很常见） 权限管理 自定义缓存逻辑处理 SDK Bug修复 … 如果你阅读过 Android_Slide_To_Close 的源码会发现，它也在某个地方使用了动态代理设计模式。 总结到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。 为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点： 至少已经理解了面向对象语言的多态特性 了解简单的反射用法 会简单使用 JavaPoet 生成Java源码","categories":[],"tags":[]},{"title":"手把手教你写Socket长连接","slug":"手把手教你写Socket长连接","date":"2020-06-11T21:55:57.000Z","updated":"2020-06-13T20:44:11.336Z","comments":true,"path":"2020/06/12/socket/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/socket/","excerpt":"本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。","text":"本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。 TCP/IP 协议简介IP首先我们看 IP（Internet Protocol）协议。IP 协议提供了主机和主机间的通信。 为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的IP地址。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。 TCP前面我们说过，IP 协议提供了主机和主机间的通信。TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上进程对进程的通信。 有了 IP，不同主机就能够交换数据。但是，计算机收到数据后，并不知道这个数据属于哪个进程（简单讲，进程就是一个正在运行的应用程序）。TCP 的作用就在于，让我们能够知道这个数据属于哪个进程，从而完成进程间的通信。 为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的端口号。 TCP 的全称是 Transmission Control Protocol，大家对它说得最多的，大概就是面向连接的特性了。之所以说它是有连接的，是说在进行通信前，通信双方需要先经过一个三次握手的过程。三次握手完成后，连接便建立了。这时候我们才可以开始发送/接收数据。（与之相对的是 UDP，不需要经过握手，就可以直接发送数据）。 下面我们简单了解一下三次握手的过程。 首先，客户向服务端发送一个 SYN，假设此时 sequence number 为 x。这个 x 是由操作系统根据一定的规则生成的，不妨认为它是一个随机数。 服务端收到 SYN 后，会向客户端再发送一个 SYN，此时服务器的 seq number = y。与此同时，会 ACK x+1，告诉客户端“已经收到了 SYN，可以发送数据了”。 客户端收到服务器的 SYN 后，回复一个 ACK y+1，这个 ACK 则是告诉服务器，SYN 已经收到，服务器可以发送数据了。 经过这 3 步，TCP 连接就建立了。这里需要注意的有三点： 连接是由客户端主动发起的 在第 3 步客户端向服务器回复 ACK 的时候，TCP 协议是允许我们携带数据的。之所以做不到，是 API 的限制导致的。 TCP 协议还允许 “四次握手” 的发生，同样的，由于 API 的限制，这个极端的情况并不会发生。 TCP/IP 相关的理论知识我们就先了解到这里。关于 TCP，还有诸如可靠性、流量控制、拥塞控制等非常有趣的特性，强烈推荐读者看一看 Richard 的名著《TCP/IP 详解 - 卷1》（注意，是第1版，不是第2版）。 下面我们看一些偏实战的东西。 Socket 基本用法Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。 在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 ServerSocket 和用于通信的 Socket。使用 socket 的步骤如下： 创建 ServerSocket 并监听客户连接 使用 Socket 连接服务端 通过 Socket 获取输入输出流进行通信 下面，我们通过实现一个简单的 echo 服务来学习 socket 的使用。所谓的 echo 服务，就是客户端向服务端写入任意数据，服务器都将数据原封不动地写回给客户端。 1. 创建 ServerSocket 并监听客户连接 public class EchoServer { private final ServerSocket mServerSocket; public EchoServer(int port) throws IOException { // 1. 创建一个 ServerSocket 并监听端口 port mServerSocket = new ServerSocket(port); } public void run() throws IOException { // 2. 开始接受客户连接 Socket client = mServerSocket.accept(); handleClient(client); } private void handleClient(Socket socket) { // 3. 使用 socket 进行通信 ... } public static void main(String[] argv) { try { EchoServer server = new EchoServer(9877); server.run(); } catch (IOException e) { e.printStackTrace(); } } } 2. 使用 Socket 连接服务端 public class EchoClient { private final Socket mSocket; public EchoClient(String host, int port) throws IOException { // 创建 socket 并连接服务器 mSocket = new Socket(host, port); } public void run() { // 和服务端进行通信 } public static void main(String[] argv) { try { // 由于服务端运行在同一主机，这里我们使用 localhost EchoClient client = new EchoClient(&quot;localhost&quot;, 9877); client.run(); } catch (IOException e) { e.printStackTrace(); } } } 3. 通过 socket.getInputStream()/getOutputStream() 获取输入/输出流进行通信 首先，我们来实现服务端： public class EchoServer { // ... private void handleClient(Socket socket) throws IOException { InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); byte[] buffer = new byte[1024]; int n; while ((n = in.read(buffer)) &gt; 0) { out.write(buffer, 0, n); } } } 可以看到，服务端的实现其实很简单，我们不停地读取输入数据，然后写回给客户端。 下面我们看看客户端。 public class EchoClient { // ... public void run() throws IOException { Thread readerThread = new Thread(this::readResponse); readerThread.start(); OutputStream out = mSocket.getOutputStream(); byte[] buffer = new byte[1024]; int n; while ((n = System.in.read(buffer)) &gt; 0) { out.write(buffer, 0, n); } } private void readResponse() { try { InputStream in = mSocket.getInputStream(); byte[] buffer = new byte[1024]; int n; while ((n = in.read(buffer)) &gt; 0) { System.out.write(buffer, 0, n); } } catch (IOException e) { e.printStackTrace(); } } } 客户端会稍微复杂一点点，在读取用户输入的同时，我们又想读取服务器的响应。所以，这里创建了一个线程来读服务器的响应。 不熟悉 lambda 的读者，可以把 Thread readerThread = new Thread(this::readResponse) 换成下面这个代码： Thread readerThread = new Thread(new Runnable() { @Override public void run() { readResponse(); } }); 打开两个 terminal 分别执行如下命令： $ javac EchoServer.java $ java EchoServer $ javac EchoClient.java $ java EchoClient hello Server hello Server foo foo 在客户端，我们会看到，输入的所有字符都打印了出来。 最后需要注意的有几点： 在上面的代码中，我们所有的异常都没有处理。实际应用中，在发生异常时，需要关闭 socket，并根据实际业务做一些错误处理工作 在客户端，我们没有停止 readThread。实际应用中，我们可以通过关闭 socket 来让线程从阻塞读中返回。推荐读者阅读《Java并发编程实战》 我们的服务端只处理了一个客户连接。如果需要同时处理多个客户端，可以创建线程来处理请求。这个作为练习留给读者来完全。 Socket、ServerSocket 傻傻分不清楚在进入这一节的主题前，读者不妨先考虑一个问题：在上一节的实例中，我们运行 echo 服务后，在客户端连接成功时，一个有多少个 socket 存在？ 答案是 3 个 socket。客户端一个，服务端有两个。跟这个问题的答案直接关联的是本节的主题——Socket 和 ServerSocket 的区别是什么。 眼尖的读者，可能会注意到在上一节我是这样描述他们的： 在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 ServerSocket 和用于通信的 Socket。 注意，我只说 ServerSocket 是用于监听客户连接，而没有说它也可以用来通信。下面我们来详细了解一下他们的区别。 注：以下描述使用的是 UNIX/Linux 系统的 API 首先，我们创建 ServerSocket 后，内核会创建一个 socket。这个 socket 既可以拿来监听客户连接，也可以连接远端的服务。由于 ServerSocket 是用来监听客户连接的，紧接着它就会对内核创建的这个 socket 调用 listen 函数。这样一来，这个 socket 就成了所谓的 listening socket，它开始监听客户的连接。 接下来，我们的客户端创建一个 Socket，同样的，内核也创建一个 socket 实例。内核创建的这个 socket 跟 ServerSocket 一开始创建的那个没有什么区别。不同的是，接下来 Socket 会对它执行 connect，发起对服务端的连接。前面我们说过，socket API 其实是 TCP 层的封装，所以 connect 后，内核会发送一个 SYN 给服务端。 现在，我们切换角色到服务端。服务端的主机在收到这个 SYN 后，会创建一个新的 socket，这个新创建的 socket 跟客户端继续执行三次握手过程。 三次握手完成后，我们执行的 serverSocket.accept() 会返回一个 Socket 实例，这个 socket 就是上一步内核自动帮我们创建的。 所以说，在一个客户端连接的情况下，其实有 3 个 socket。 关于内核自动创建的这个 socket，还有一个很有意思的地方。它的端口号跟 ServerSocket 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。 前面我说的TCP 通过端口号来区分数据属于哪个进程的说法，在 socket 的实现里需要改一改。Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 &lt;peer addr:peer port, local addr:local port&gt; 这个四元组。 在上面的例子中，我们的 ServerSocket 长这样：&lt;*:*, *:9877&gt;。意思是，可以接受任何的客户端，和本地任何 IP。 accept 返回的 Socket 则是这样： &lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;，其中xxxx 是客户端的端口号。 如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。 如果是客户端要发起连接，这时候只有 &lt;*:*, *:9877&gt; 会匹配成功，所以 SYN 也准确发送给了监听套接字。 Socket/ServerSocket 的区别我们就讲到这里。如果读者觉得不过瘾，可以参考《TCP/IP 详解》卷1、卷2。 Socket 长连接的实现背景知识 Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。 比较熟悉 Socket 的读者，可能知道有这样一个 API： socket.setKeepAlive(true); 嗯……keep alive，“保持活着”，这个应该就是让 TCP 不断开的意思。那么，我们要实现一个 socket 的长连接，只需要这一个调用即可。 遗憾的是，生活并不总是那么美好。对于 4.4BSD 的实现来说，Socket 的这个 keep alive 选项如果打开并且两个小时内没有通信，那么底层会发一个心跳，看看对方是不是还活着。 注意，两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。 在说明如果实现长连接前，我们先来理一理我们面临的问题。假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用： 某一端关闭是 socket（这不是废话吗）。主动关闭的一方会发送 FIN，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 EoF（End of File）。于是我们知道对方关闭了 socket。 应用程序奔溃。此时 socket 会由内核关闭，结果跟情况1一样。 系统奔溃。这时候系统是来不及发送 FIN 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。 电缆被挖断、网线被拔。跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用。 在上面的几种情形中，有一个共同点就是，只要去读、写 socket，只要 socket 连接不正常，我们就能够知道。基于这一点，要实现一个 socket 长连接，我们需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的心跳。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。 心跳包不是实际的业务数据，根据通信协议的不同，需要做不同的处理。 比方说，我们使用 JSON 进行通信，那么，我们可以加一个 type 字段，表面这个 JSON 是心跳还是业务数据。 { &quot;type&quot;: 0, // 0 表示心跳 // ... } 使用二进制协议的情况类似。要求就是，我们能够区别一个数据包是心跳还是真实数据。这样，我们便实现了一个 socket 长连接。 实现示例 这一小节我们一起来实现一个带长连接的 Android echo 客户端。 首先了接口部分： public final class LongLiveSocket { /** * 错误回调 */ public interface ErrorCallback { /** * 如果需要重连，返回 true */ boolean onError(); } /** * 读数据回调 */ public interface DataCallback { void onData(byte[] data, int offset, int len); } /** * 写数据回调 */ public interface WritingCallback { void onSuccess(); void onFail(byte[] data, int offset, int len); } public LongLiveSocket(String host, int port, DataCallback dataCallback, ErrorCallback errorCallback) { } public void write(byte[] data, WritingCallback callback) { } public void write(byte[] data, int offset, int len, WritingCallback callback) { } public void close() { } } 我们这个支持长连接的类就叫 LongLiveSocket 好了。如果在 socket 断开后需要重连，只需要在对应的接口里面返回 true 即可（在真实场景里，我们还需要让客户设置重连的等待时间，还有读写、连接的 timeout等。为了简单，这里就直接不支持了。 另外需要注意的一点是，如果要做一个完整的库，需要同时提供阻塞式和回调式API。同样由于篇幅原因，这里直接省掉了。 首先我们看看 write() 方法： public void write(byte[] data, int offset, int len, WritingCallback callback) { mWriterHandler.post(() -&gt; { Socket socket = getSocket(); if (socket == null) { // initSocket 失败而客户说不需要重连，但客户又叫我们给他发送数据 throw new IllegalStateException(&quot;Socket not initialized&quot;); } try { OutputStream outputStream = socket.getOutputStream(); DataOutputStream out = new DataOutputStream(outputStream); out.writeInt(len); out.write(data, offset, len); callback.onSuccess(); } catch (IOException e) { Log.e(TAG, &quot;write: &quot;, e); // 关闭 socket，避免资源泄露 closeSocket(); // 这里我们把发生失败的数据返回给客户端，这样客户可以更方便地重新发送数据 callback.onFail(data, offset, len); if (!closed() &amp;&amp; mErrorCallback.onError()) { // 重连 initSocket(); } } }); } 由于我们需要定时写心跳，这里使用一个 HandlerThread 来处理写请求。通信使用的协议，只是简单地在用户数据前加一个 len 字段，用于确定消息的长度。 下面我们看心跳的发送： private final Runnable mHeartBeatTask = new Runnable() { private byte[] mHeartBeat = new byte[0]; @Override public void run() { // 我们使用长度为 0 的数据作为 heart beat write(mHeartBeat, new WritingCallback() { @Override public void onSuccess() { // 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次 mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS); mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS); } @Override public void onFail(byte[] data, int offset, int len) { // nop // write() 方法会处理失败 } }); } }; private final Runnable mHeartBeatTimeoutTask = () -&gt; { Log.e(TAG, &quot;mHeartBeatTimeoutTask#run: heart beat timeout&quot;); closeSocket(); }; 发送心跳使用我们上面实现的 write() 方法。在发送成功后，post delay 一个 timeout task，如果到期后还没收到服务器的响应，我们将认为 socket 出现异常，这里直接关闭 socket。最后是对心跳的处理： int nbyte = in.readInt(); if (nbyte == 0) { Log.i(TAG, &quot;readResponse: heart beat received&quot;); mUIHandler.removeCallbacks(mHeartBeatTimeoutTask); } 由于用户数据的长度总是会大于 1，这里我们就使用 len == 0 的数据作为心跳。收到心跳后，移除 mHeartBeatTimeoutTask。 剩余代码跟我们的主题没有太大关系，读者在这里[3]可以找到完整的代码或者自己完成这个例子。 最后需要说明的是，如果想节省资源，在有客户发送数据的时候可以省略 heart beat。 我们对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。heart beat timeout 的情况类似。 跟 TCP/IP 学协议设计如果仅仅是为了使用是 socket，我们大可以不去理会协议的细节。之所以推荐大家去看一看《TCP/IP 详解》，是因为它们有太多值得学习的地方。很多我们工作中遇到的问题，都可以在这里找到答案。 以下每一个小节的标题都是一个小问题，建议读者独立思考一下，再继续往下看。如果你发现你的答案比我的更好，请一定发送邮件到 ljtong64 AT gmail DOT com 告诉我。 协议版本如何升级？有这么一句流行的话：这个世界唯一不变的，就是变化。当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？ 答案可以在 IP 协议找到。 IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。 再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。 如何发送不定长数据的数据包举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？ 还是一样，看看 IP。IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。 跟这个相对的，还有另一个方案，那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 \\0 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 \\0。此时，我们就需要对用户的数据进行转义。比方说，把用户数据的所有 \\0 都变成 \\0\\0。读消息的过程总，如果遇到 \\0\\0，那它就代表 \\0，如果只有一个 \\0，那就是消息尾部。 使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。 终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。 当然，这两个方法不是互斥的，可以一起使用。 上传多个文件，只有所有文件都上传成功时才算成功现在我们有一个需求，需要一次上传多个文件到服务器，只有在所有文件都上传成功的情况下，才算成功。我们该如何来实现呢？ IP 在数据报过大的时候，会把一个数据报拆分成多个，并设置一个 MF （more fragments）位，表示这个包只是被拆分后的数据的一部分。 好，我们也学一学 IP。这里，我们可以给每个文件从 0 开始编号。上传文件的同时，也携带这个编号，并额外附带一个 MF 标志。除了编号最大的文件，所有文件的 MF 标志都置位。因为 MF 没有置位的是最后一个文件，服务器就可以根据这个得出总共有多少个文件。 另一种不使用 MF 标志的方法是，我们在上传文件前，就告诉服务器总共有多少个文件。 如果读者对数据库比较熟悉，学数据库用事务来处理，也是可以的。这里就不展开讨论了。 如何保证数据的有序性这里讲一个我曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。 我们看看 TCP/IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。 一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。 更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。工作线程要将结果放入，有两种可能： 刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去。 所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。 如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。 如何保证对方收到了消息我们说，TCP 提供了可靠的传输。这样不就能够保证对方收到消息了吗？ 很遗憾，其实不能。在我们往 socket 写入的数据，只要对端的内核收到后，就会返回 ACK，此时，socket 就认为数据已经写入成功。然而要注意的是，这里只是对方所运行的系统的内核成功收到了数据，并不表示应用程序已经成功处理了数据。 解决办法还是一样，我们学 TCP，添加一个应用层的 APP ACK。应用接收到消息并处理成功后，发送一个 APP ACK 给对方。 有了 APP ACK，我们需要处理的另一个问题是，如果对方真的没有收到，需要怎么做？ TCP 发送数据的时候，消息一样可能丢失。TCP 发送数据后，如果长时间没有收到对方的 ACK，就假设数据已经丢失，并重新发送。 我们也一样，如果长时间没有收到 APP ACK，就假设数据丢失，重新发送一个。","categories":[],"tags":[]},{"title":"Android目前最稳定和高效的UI适配方案","slug":"Android目前最稳定和高效的UI适配方案","date":"2020-06-11T21:53:01.000Z","updated":"2020-06-13T20:40:29.781Z","comments":true,"path":"2020/06/12/undefined/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/undefined/","excerpt":"Android系统发布十多年以来，关于Android的UI的适配一直是开发环节中最重要的问题，但是我看到还是有很多小伙伴对Android适配方案不了解。刚好，近期准备对糗事百科Android客户端设计一套UI尺寸适配方案，可以和小伙伴们详细的聊一聊这个问题。","text":"Android系统发布十多年以来，关于Android的UI的适配一直是开发环节中最重要的问题，但是我看到还是有很多小伙伴对Android适配方案不了解。刚好，近期准备对糗事百科Android客户端设计一套UI尺寸适配方案，可以和小伙伴们详细的聊一聊这个问题。 Android适配最核心的问题有两个，其一，就是适配的效率，即把设计图转化为App界面的过程是否高效，其二如何保证实现UI界面在不同尺寸和分辨率的手机中UI的一致性。这两个问题都很重要，一个是保证我们开发的高效，一个是保证我们适配的成效；今天我们就这两个核心的问题来聊一聊Android的适配方案。 首先，大家都知道，在标识尺寸的时候，Android并不推荐我们使用px这个真实像素单位，因为不同的手机之间，分辨率是不同的，比如一个96*96像素的控件在分辨率越来越高的手机上会在整体UI中看起来越来越小。 出现类似于上图这样这样，整体的布局效果可能会变形，所以px这个单位在布局文件中是不推荐的。 dp直接适配针对这种情况，Android推荐使用dp作为尺寸单位来适配UI. 那么什么是dp？dp指的是设备独立像素，以dp为尺寸单位的控件，在不同分辨率和尺寸的手机上代表了不同的真实像素，比如在分辨率较低的手机中，可能1dp=1px,而在分辨率较高的手机中，可能1dp=2px，这样的话，一个96*96dp的控件，在不同的手机中就能表现出差不多的大小了。那么这个dp是如何计算的呢？ 我们都知道一个公式： px = dp(dpi/160) 系统都是通过这个来判断px和dp的数学关系， 那么这里又出现了一个问题，dpi是什么呢？ dpi是像素密度，指的是在系统软件上指定的单位尺寸的像素数量，它往往是写在系统出厂配置文件的一个固定值。 我为什么要强调它是软件系统上的概念？因为大家买手机的时候，往往会听到另一个叫ppi的参数，这个在手机屏幕中指的也是像素密度，但是这个是物理上的概念，它是客观存在的不会改变。dpi是软件参考了物理像素密度后，人为指定的一个值，这样保证了某一个区间内的物理像素密度在软件上都使用同一个值。这样会有利于我们的UI适配。 比如，几部相同分辨率不同尺寸的手机的ppi可能分别是是430,440,450,那么在Android系统中，可能dpi会全部指定为480.这样的话，dpi/160就会是一个相对固定的数值，这样就能保证相同分辨率下不同尺寸的手机表现一致。 而在不同分辨率下，dpi将会不同，比如： … 1080*720 1920*1080 dpi 320 480 dpi/160 2 3 根据上面的表格，我们可以发现，720P,和1080P的手机，dpi是不同的，这也就意味着，不同的分辨率中，1dp对应不同数量的px(720P中，1dp=2px，1080P中1dp=3px)，这就实现了，当我们使用dp来定义一个控件大小的时候，他在不同的手机里表现出相应大小的像素值。 我们可以说，通过dp加上自适应布局和weight比例布局可以基本解决不同手机上适配的问题，这基本是最原始的Android适配方案。 这种方式存在两个小问题，第一，这只能保证我们写出来的界面适配绝大部分手机，部分手机仍然需要单独适配，为什么dp只解决了90%的适配问题，因为并不是所有的1080P的手机dpi都是480，比如Google 的Pixel2（19201080）的dpi是420，也就是说，在Pixel2中，1dp=2.625px,这样会导致相同分辨率的手机中，这样，一个100dp100dp的控件，在一般的1080P手机上，可能都是300px,而Pixel 2 中 ，就只有262.5px,这样控件的实际大小会有所不同。 为了更形象的展示，假设我们在布局文件中把一个ImageView的宽度设置为360dp,那么在下面两张图中表现是不一样的： 图一是1080P,480dpi的手机，图二是1080P,420dpi的手机 从上面的布局中可以看到，同样是1080P的手机，差异是比较明显的。在这种情况下，我们的UI可能需要做一些微调甚至单独适配。 第二个问题，这种方式无法快速高效的把设计师的设计稿实现到布局代码中，通过dp直接适配，我们只能让UI基本适配不同的手机,但是在设计图和UI代码之间的鸿沟，dp是无法解决的，因为dp不是真实像素。而且，设计稿的宽高往往和Android的手机真实宽高差别极大，以我们的设计稿为例，设计稿的宽高是375px750px，而真实手机可能普遍是10801920, 那么在日常开发中我们是怎么跨过这个鸿沟的呢？基本都是通过百分比啊，或者通过估算，或者设定一个规范值等等。总之，当我们拿到设计稿的时候，设计稿的ImageView是128px128px，当我们在编写layout文件的时候，却不能直接写成128dp128dp。在把设计稿向UI代码转换的过程中，我们需要耗费相当的精力去转换尺寸，这会极大的降低我们的生产力，拉低开发效率。 宽高限定符适配为了高效的实现UI开发，出现了新的适配方案，我把它称作宽高限定符适配。简单说，就是穷举市面上所有的Android手机的宽高像素值： 设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件。 比如以480x320为基准分辨率 宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320 高度为480，将任何分辨率的高度整分为480份，取值为y1-y480 那么对于800*480的分辨率的dimens文件来说， x1=(480/320)*1=1.5px x2=(480/320)*2=3px … 这个时候，如果我们的UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens引用了,而当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。这样基本解决了我们的适配问题，而且极大的提升了我们UI开发的效率， 但是这个方案有一个致命的缺陷，那就是需要精准命中才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。 不过这个方案有一些团队用过，我们可以认为它是一个比较成熟有效的方案了。 UI适配框架（已经停止维护）鸿洋大佬的适配方案的项目也来自于宽高限定符方案的启发。 使用方法也很简单： 第一步： 在你的项目的AndroidManifest中注明你的设计稿的尺寸。 &lt;meta-data android:name=&quot;design_width&quot; android:value=&quot;768&quot;&gt; &lt;/meta-data&gt; &lt;meta-data android:name=&quot;design_height&quot; android:value=&quot;1280&quot;&gt; &lt;/meta-data&gt;第二步： 让你的Activity继承自AutoLayoutActivity. 然后我们就可以直接在布局文件里面使用具体的像素值了，比如，设计稿上是96*96,那么我们可以直接写96px，APP运行时，框架会帮助我们根据不同手机的具体尺寸按比例伸缩。 这可以说是一个极好的方案，因为它在宽高限定符适配的基础上更进一步，并且解决了容错机制的问题，可以说完美的达成了开发高效和适配精准的两个要求。 但是我们能够想到，因为框架要在运行时会在onMeasure里面做变换，我们自定义的控件可能会被影响或限制，可能有些特定的控件，需要单独适配，这里面可能存在的暗坑是不可预见的，还有一个比较重要的问题，那就是整个适配工作是有框架完成的，而不是系统完成的，一旦使用这个框架，未来一旦遇到很难解决的问题，替换起来是非常麻烦的，而且项目一旦停止维护，后续的升级就只能靠你自己了，这种代价团队能否承受？当然，它已经停止维护了。 不过仅仅就技术方案而言，不可否认，这是一个很好的开源项目。 小结讨论的上述几种适配方案都是可以实际用于开发中的比较成熟的方案，而且确实有很多开发者正在使用。不过由于他们各自都存在一些缺陷，所以我们使用了上述方案后还需要花费额外的精力着手解决这些可能存在的缺陷。 那么，是否存在一种相对比较完美，没有明显的缺陷的方案呢？ smallestWidth适配smallestWidth适配，或者叫sw限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。 这种机制和上文提到的宽高限定符适配原理上是一样的，都是系统通过特定的规则来选择对应的文件。 举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。 smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。这个特性就完美的解决了上文提到的宽高限定符的容错问题。 这套方案是上述几种方案中最接近完美的方案。 首先，从开发效率上，它不逊色于上述任意一种方案。根据固定的放缩比例，我们基本可以按照UI设计的尺寸不假思索的填写对应的dimens引用。 我们还有以375个像素宽度的设计稿为例，在values-sw360dp文件夹下的diemns文件应该怎么编写呢？这个文件夹下，意味着手机的最小宽度的dp值是360，我们把360dp等分成375等份，每一个设计稿中的像素，大概代表smallestWidth值为360dp的手机中的0.96dp，那么接下来的事情就很简单了，假如设计稿上出现了一个10px*10px的ImageView,那么，我们就可以不假思索的在layout文件中写下对应的尺寸。 而这种diemns引用，在不同的values-swdp文件夹下的数值是不同的，比如values-sw360dp和values-sw400dp, 当系统识别到手机的smallestWidth值时，就会自动去寻找和目标数据最近的资源文件的尺寸。 其次，从稳定性上，它也优于上述方案。原生的dp适配可能会碰到Pixel 2这种有些特别的手机需要单独适配，但是在smallestWidth适配中，通过计算Pixel 2手机的的smallestWidth的值是411，我们只需要生成一个values-sw411dp(或者取整生成values-sw410dp也没问题)就能解决问题。 smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，不会出现什么难以解决的问题，也根本不会影响我们的业务逻辑代码，而且只要我们生成的资源文件分布合理，，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。 当然，smallestWidth适配方案有一个小问题，那就是它是在Android 3.2 以后引入的，Google的本意是用它来适配平板的布局文件（但是实际上显然用于diemns适配的效果更好），不过目前所有的项目应该最低支持版本应该都是4.0了（糗事百科这么老的项目最低都是4.0哦），所以，这问题其实也不重要了。 评论中还说到了一个缺陷我忘了提，那就是多个dimens文件可能导致apk变大，这是事实，根据生成的dimens文件的覆盖范围和尺寸范围，apk可能会增大300kb-800kb左右，目前糗百的dimens文件大小是406kb，我认为这是可以接受的。 今日头条适配方案（更新）文章链接，之前确实没有接触过，我简单看了一遍，可以说，这也是相对比较完美的方案，我先简单说一下这个方案的思路，它是通过修改density值，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就解决了所有的适配问题。 比如，设计稿宽度是360px，那么开发这边就会把目标dp值设为360dp，在不同的设备中，动态修改density值，从而保证(手机像素宽度)px/density这个值始终是360dp,这样的话，就能保证UI在不同的设备上表现一致了。 这个方案侵入性很低，而且也没有涉及私有API，应该也是极不错的方案，我暂时也想不到强行修改density是否会有其他影响，既然有今日头条的大厂在用，稳定性应当是有保证的。 但是根据我的观察，这套方案对老项目是不太友好的，因为修改了系统的density值之后，整个布局的实际尺寸都会发生改变，如果想要在老项目文件中使用，恐怕整个布局文件中的尺寸都可能要重新按照设计稿修改一遍才行。因此，如果你是在维护或者改造老项目，使用这套方案就要三思了。 福利赠送生成diemns文件的过程以及数据计算方法上面已经讲清楚了，大家完全可以自己去生成这些文件，我在这里附赠生成values-sw的项目代码，大家直接拿去用，是Java工程。点击这里获取项目地址 关于一些问题Q: 该适配方案怎么用？ A:点击进入上文的github项目，下载到本地，然后运行该Java工程，会在本地根目录下生成相应的文件，如果需要生成更多尺寸，在DimenTypes 文件中填写你需要的尺寸即可。 Q： 是否有推荐的尺寸？ A 300,320,360,390,411，450，这几个尺寸是比较必要的，然后在其中插入一些其他的尺寸即可，如果不放心，可以在300-450之间，以10为步长生成十几个文件就OK了。 Q:平板适配的问题？ A: 这个可以分成两个问题，第一，团队有没有专门针对平板设计UI?第二，才是如何对平板适配。如果团队内部没有针对平板设计UI,那么大家对于App在平板上运行的要求大抵也就是不要太难看即可。针对这种情况的适配方法是被动适配，即不要生成480以上的适配文件，这样在平板上，系统就会使用480这个尺寸的dimens文件，这样效果比主动适配更好；而如果团队主动设计了平板的UI，那么我们就需要主动生成平板的适配文件，大概在600-800之间，关键尺寸是640,768。然后按照UI设计的图来写即可。 Q：用了这套方案是否就不需要使用wrap_content等来布局了？ A:这是绝对错误的做法！如果UI设计上明显更适合使用wrap_content,match_parent,layout_weight等,我们就要毫不犹豫的使用，而且在高这个维度上，我们要依照情况设计为可滑动的方式，或者match_parent,尽量不要写死。总之，所有的适配方案都不是用来取代match_parent,wrap_content的，而是用来完善他们的。","categories":[],"tags":[]},{"title":"Java反射真的很慢吗","slug":"Java反射真的很慢吗","date":"2020-06-11T21:49:50.000Z","updated":"2020-06-13T20:41:18.224Z","comments":true,"path":"2020/06/12/javafs/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/javafs/","excerpt":"反射到底是好是坏说到Java 中的反射，初学者在刚刚接触到反射的各种高级特性时，往往表示十分兴奋，甚至会在一些不需要使用反射的场景中强行使用反射来「炫技」。而经验较为丰富的长者，看到反射时往往会发出灵魂三问：为什么要用反射？反射不会降低性能么？不用还有什么办法可以解决这个问题？","text":"反射到底是好是坏说到Java 中的反射，初学者在刚刚接触到反射的各种高级特性时，往往表示十分兴奋，甚至会在一些不需要使用反射的场景中强行使用反射来「炫技」。而经验较为丰富的长者，看到反射时往往会发出灵魂三问：为什么要用反射？反射不会降低性能么？不用还有什么办法可以解决这个问题？ 那么今天我们就来深入探讨下，反射到底对性能有多大影响？顺便探讨下，反射为什么对性能有影响？ 编码试验在我们分析具体原理之前，我们可以通过编写代码做实验得出结论。 反射可能会涉及多种类型的操作，比如生成实例，获取/设置变量属性，调用方法等。经过简单的思考，我们认为生成实例对性能的影响相对其他操作要大一些，所以我们采用生成实例来做试验。 在如下代码中，我们定义了一个类 InnerClass，我们测试分别使用new和反射来生成 MAX_TIMES个实例，并打印出耗时时间。 public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;MainAc&quot;; private final int MAX_TIMES = 100 * 1000; private InnerClass innerList[]; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); innerList = new InnerClass[MAX_TIMES]; long startTime = SystemClock.elapsedRealtime(); for (int i=0; i &lt; MAX_TIMES; i++) { innerList[i] = new InnerClass(); } Log.e(TAG, &quot;totalTime: &quot; + (SystemClock.elapsedRealtime() - startTime)); long startTime2 = SystemClock.elapsedRealtime(); for (int i=0; i &lt; MAX_TIMES; i++) { innerList[i] = newInstanceByReflection(); } Log.e(TAG, &quot;totalTime2: &quot; + (SystemClock.elapsedRealtime() - startTime2)); } public InnerClass newInstanceByReflection() { Class clazz = InnerClass.class; try { return (InnerClass) clazz.getDeclaredConstructor().newInstance(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return null; } static class InnerClass { } } 输出日志： 2020-03-19 22:34:49.738 2151-2151/? E/MainAc: totalTime: 15 2020-03-19 22:34:50.409 2151-2151/? E/MainAc: totalTime2: 670 使用反射生成 10万 个实例，耗时 670ms，明显高于直接使用 new关键字的 15ms，所以反射性能低。别急，这个结论总结的还有点早，我们将要生成的实例总数改为 1000个试试，输出日志： 2020-03-19 22:39:21.287 3641-3641/com.example.myapplication E/MainAc: totalTime: 2 2020-03-19 22:39:21.296 3641-3641/com.example.myapplication E/MainAc: totalTime2: 9 使用反射生成 1000 个实例，虽然需要9ms，高于new的 2ms，但是 9ms 和 2ms 的差距本身肉眼不可见，而且通常我们在业务中写的反射一般来说执行频率也未必会超过 1000 次，这种场景下，我们还能理直气壮地说反射性能很低么？ 很显然，不能。 除了代码执行耗时，我们再看看反射对内存的影响。我们仍然以生成 10万 个实例为目标，对上述代码做略微改动，依次只保留 new 方式和反射方式，然后运行程序，观察内存占用情况。 使用 new 方式 使用反射 对比两图，我们可以看到第二张图中多了很多 Constructor和Class对象实例，这两部分占用的内存2.7M。因此，我们可以得出结论，反射会产生大量的临时对象，并且会占用额外内存空间。 刨根问底：反射原理是什么我们以前面试验中反射生成实例的代码为入口。 首先回顾下虚拟机中类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载。在加载的过程 中，虚拟机会把类的字节码转换成运行时数据结构，并保存在方法区，在内存中会生成一个代表这个类数据结构的 java.lang.Class 对象，后续访问这个类的数据结构就可以通过这个 Class 对象来访问。 public InnerClass newInstanceByReflection() { // 获取虚拟机中 InnerClass 类的 Class 对象 Class clazz = InnerClass.class; try { return (InnerClass) clazz.getDeclaredConstructor().newInstance(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } return null; } 代码中 clazz.getDeclaredConstructor() 用于获取类中定义的构造方法，由于我们没有显式定义构造方法，所以会返回编译器为我们自己生成的默认无参构造方法。 下面我们看下 getDeclaredConstructor是如何返回构造方法的。以下均以 jdk 1.8代码为源码。 @CallerSensitive public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException { // 权限检查 checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); return getConstructor0(parameterTypes, Member.DECLARED); } getDeclaredConstructor 方法首先做了权限检查，然后直接调用 getConstructor0 方法。 private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes, int which) throws NoSuchMethodException { // privateGetDeclaredConstructors 方法是获取所有的构造方法数组 Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC)); // 遍历所有的构造方法数组，根据传入的参数类型依次匹配，找到合适的构造方法后就会拷贝一份作为返回值 for (Constructor&lt;T&gt; constructor : constructors) { if (arrayContentsEq(parameterTypes, constructor.getParameterTypes())) { // 拷贝构造方法 return getReflectionFactory().copyConstructor(constructor); } } // 没有找到的话，就抛出异常 throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes)); } getConstructor0 方法主要做了两件事： 获取所有构造方法组成的数组 遍历构造方法数组，找到匹配的 遍历匹配没啥好说的，我们重点看下第一件事，怎么获取的所有构造方法数组，也就是这个方法 privateGetDeclaredConstructors。 private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) { checkInitted(); Constructor&lt;T&gt;[] res; // 获取缓存的 ReflectionData 数据 ReflectionData&lt;T&gt; rd = reflectionData(); // 如果缓存中有 ReflectionData，就先看看 ReflectionData 中的 publicConstructors 或 declaredConstructors是否为空 if (rd != null) { res = publicOnly ? rd.publicConstructors : rd.declaredConstructors; if (res != null) return res; } // 如果没有缓存，或者缓存中构造方法数组为空 // No cached value available; request value from VM // 对接口类型的字节码特殊处理 if (isInterface()) { @SuppressWarnings(&quot;unchecked&quot;) // 如果是接口类型，那么生成一个长度为0的构造方法数组 Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0]; res = temporaryRes; } else { // 如果不是接口类型，就调用 getDeclaredConstructors0 获取构造方法数组 res = getDeclaredConstructors0(publicOnly); } // 获取到构造方法数组后，再赋值给缓存 ReflectionData 中的对应属性 if (rd != null) { if (publicOnly) { rd.publicConstructors = res; } else { rd.declaredConstructors = res; } } return res; } 上述代码中我已经对关键代码进行了注释，在讲解整个流程之前，我们看到了一个陌生的类型 ReflectionData。它对应的数据结构是： private static class ReflectionData&lt;T&gt; { volatile Field[] declaredFields; volatile Field[] publicFields; volatile Method[] declaredMethods; volatile Method[] publicMethods; volatile Constructor&lt;T&gt;[] declaredConstructors; volatile Constructor&lt;T&gt;[] publicConstructors; // Intermediate results for getFields and getMethods volatile Field[] declaredPublicFields; volatile Method[] declaredPublicMethods; volatile Class&lt;?&gt;[] interfaces; // Value of classRedefinedCount when we created this ReflectionData instance final int redefinedCount; ReflectionData(int redefinedCount) { this.redefinedCount = redefinedCount; } } ReflectionData 这个类就是用来保存从虚拟机中获取到的一些数据。同时我们可以看到所有反射属性都使用了 volatile关键字修饰。 获取缓存的 ReflectionData 数据是通过调用reflectionData()方法获取的。 // 定义在 Class 类中的反射缓存对象 private volatile transient SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData; private ReflectionData&lt;T&gt; reflectionData() { SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData; int classRedefinedCount = this.classRedefinedCount; ReflectionData&lt;T&gt; rd; if (useCaches &amp;&amp; reflectionData != null &amp;&amp; (rd = reflectionData.get()) != null &amp;&amp; rd.redefinedCount == classRedefinedCount) { return rd; } // else no SoftReference or cleared SoftReference or stale ReflectionData // -&gt; create and replace new instance return newReflectionData(reflectionData, classRedefinedCount); } 我们可以看到 reflectionData实际上是一个软引用，软引用会在内存不足的情况下被虚拟机回收，所以reflectionData()方法在开始的地方，先判断了是否可以使用缓存以及缓存是否失效，如果失效了，就会调用 newReflectionData方法生成一个新的 ReflectionData 实例。 接下来看看 newReflectionData 方法。 private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData, int classRedefinedCount) { // 如果不允许使用缓存，直接返回 null if (!useCaches) return null; while (true) { ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount); // try to CAS it... if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) { return rd; } // else retry oldReflectionData = this.reflectionData; classRedefinedCount = this.classRedefinedCount; if (oldReflectionData != null &amp;&amp; (rd = oldReflectionData.get()) != null &amp;&amp; rd.redefinedCount == classRedefinedCount) { return rd; } } } newReflectionData中使用 volatile + 死循环 + CAS 机制 保证线程安全。注意到这里的死循环每执行一次都会构造一个新的 ReflectionData 实例。 你可能会有疑问，Class 中 reflectionData属性什么时候被赋值的，其实是封装在Atomic.casReflectionData这个方法里了，他会检测当前Class对象中的reflectionData是否与oldReflectionData相等，如果相等，就会把new SoftReference&lt;&gt;(rd)赋值给 reflectionData。 到现在为止，关于 ReflectionData的背景知识都介绍完了。我们再回到 privateGetDeclaredConstructors中看看获取构造方法的流程。 privateGetDeclaredConstructors流程图 可以看到对于普通类，最终通过调用 getDeclaredConstructors0方法获取的构造方法列表。 private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly); 这个方法是 native 的，具体逻辑在 jdk 源码中。 在 native/java/lang/Class_getDeclaredConstructors0.c 文件中， void getDeclaredConstructors0(Frame * frame) { // Frame 可以理解为调用native方法时，java层传递过来的数据的一种封装 LocalVars * vars = frame-&gt;localVars; Object * classObj = getLocalVarsThis(vars); // 取得java方法的入参 bool publicOnly = getLocalVarsBoolean(vars, 1); uint16_t constructorsCount = 0; // 获取要查询的类的 Class 对象 Class * c = classObj-&gt;extra; // 获取这个类的所有构造方法，且数量保存在 constructorsCount 中 Method* * constructors = getClassConstructors(c, publicOnly, &amp;constructorsCount); // 获取 java 方法调用所属的 classLoader ClassLoader * classLoader = frame-&gt;method-&gt;classMember.attachClass-&gt;classLoader; // 拿到 Constructor 对应的 class 对象 Class * constructorClass = loadClass(classLoader, &quot;java/lang/reflect/Constructor&quot;); //创建一个长度为 constructorsCount 的数组保存构造方法 Object * constructorArr = newArray(arrayClass(constructorClass), constructorsCount); pushOperandRef(frame-&gt;operandStack, constructorArr); // 后面是具体的赋值逻辑。将native中的Method对象转化为java层的Constructor对象 if (constructorsCount &gt; 0) { Thread * thread = frame-&gt;thread; Object* * constructorObjs = getObjectRefs(constructorArr); Method * constructorInitMethod = getClassConstructor(constructorClass, _constructorConstructorDescriptor); for (uint16_t i = 0; i &lt; constructorsCount; i++) { Method * constructor = constructors[i]; Object * constructorObj = newObject(constructorClass); constructorObj-&gt;extra = constructor; constructorObjs[i] = constructorObj; OperandStack * ops = newOperandStack(9); pushOperandRef(ops, constructorObj); pushOperandRef(ops, classObj); pushOperandRef(ops, toClassArr(classLoader, methodParameterTypes(constructor), constructor-&gt;parsedDescriptor-&gt;parameterTypesCount)); if (constructor-&gt;exceptions != NULL) pushOperandRef(ops, toClassArr(classLoader, methodExceptionTypes(constructor), constructor-&gt;exceptions-&gt;number_of_exceptions)); else pushOperandRef(ops, toClassArr(classLoader, methodExceptionTypes(constructor), 0)); pushOperandInt(ops, constructor-&gt;classMember.accessFlags); pushOperandInt(ops, 0); pushOperandRef(ops, getSignatureStr(classLoader, constructor-&gt;classMember.signature)); // signature pushOperandRef(ops, toByteArr(classLoader, constructor-&gt;classMember.annotationData, constructor-&gt;classMember.annotationDataLen)); pushOperandRef(ops, toByteArr(classLoader, constructor-&gt;parameterAnnotationData, constructor-&gt;parameterAnnotationDataLen)); Frame * shimFrame = newShimFrame(thread, ops); pushThreadFrame(thread, shimFrame); // init constructorObj InvokeMethod(shimFrame, constructorInitMethod); } } } 从上面的逻辑，可以知道获取构造方法的核心方法是 getClassConstructors ，所在文件为 rtda/heap/class.c。 Method* * getClassConstructors(Class * self, bool publicOnly, uint16_t * constructorsCount) { // 分配大小为 sizeof(Method) 的长度为 methodsCount 的连续内存地址，即数组 Method* * constructors = calloc(self-&gt;methodsCount, sizeof(Method)); *constructorsCount = 0; // 在native 层，构造方法和普通方法都存在 methods 中，逐一遍历 for (uint16_t i = 0; i &lt; self-&gt;methodsCount; i++) { Method * method = self-&gt;methods + i; // 判断是否是构造方法 if (isMethodConstructor(method)) { // 检查权限 if (!publicOnly || isMethodPublic(method)) { // 符合条件的构造方法依次存到数组中 constructors[*constructorsCount] = method; (*constructorsCount)++; } } } return constructors; } 可以看到getClassConstructors实际上就是对 methods 进行了一次过滤，过滤的条件为：1.是构造方法；2.权限一致。 isMethodConstructor 方法的判断逻辑也是十分简单，不是静态方法，而且方法名是&lt;init&gt;即可。 bool isMethodConstructor(Method * self) { return !isMethodStatic(self) &amp;&amp; strcmp(self-&gt;classMember.name, &quot;&lt;init&gt;&quot;) == 0; } 所以核心的逻辑变成了Class中的 methods数组何时被初始化赋值的？我们刨根问底的追踪下。 我们先找到类加载到虚拟机中的入口方法 loadNonArrayClass： Class * loadNonArrayClass(ClassLoader * classLoader, const char * className) { int32_t classSize = 0; char * classContent = NULL; Class * loadClass = NULL; classSize = readClass(className, &amp;classContent); if (classSize &gt; 0 &amp;&amp; classContent != NULL){ #if 0 printf(&quot;class size:%d,class data:[&quot;, classSize); for (int32_t i = 0; i &lt; classSize; i++) { printf(&quot;0x%02x &quot;, classContent[i]); } printf(&quot;]\\n&quot;); #endif } if (classSize &lt;= 0) { printf(&quot;Could not found target class\\n&quot;); exit(127); } // 解析字节码文件 loadClass = parseClassFile(classContent, classSize); loadClass-&gt;classLoader = classLoader; // 加载 defineClass(classLoader, loadClass); // 链接 linkClass(classLoader, loadClass); //printf(&quot;[Loaded %s\\n&quot;, loadClass-&gt;name); return loadClass; } 在 parseClassFile方法中，调用了newClass方法。 Class * parseClassFile(char * classContent, int32_t classSize) { ClassFile * classFile = NULL; classFile = parseClassData(classContent, classSize); return newClass(classFile); } newClass方法在rtda/heap/class.c文件中。 Class * newClass(ClassFile * classFile) { Class * c = calloc(1, sizeof(Class)); c-&gt;accessFlags = classFile-&gt;accessFlags; c-&gt;sourceFile = getClassSourceFileName(classFile); newClassName(c, classFile); newSuperClassName(c, classFile); newInterfacesName(c, classFile); newConstantPool(c, classFile); newFields(c, classFile); newMethods(c, classFile); return c; } 可以看到，在native层创建了一个Class对象，我们重点看newMethods(c, classFile)方法啊，这个方法定义在rtda/heap/method.c中。 Method * newMethods(struct Class * c, ClassFile * classFile) { c-&gt;methodsCount = classFile-&gt;methodsCount; c-&gt;methods = NULL; if (c-&gt;methodsCount == 0) return NULL; c-&gt;methods = calloc(classFile-&gt;methodsCount, sizeof(Method)); for (uint16_t i = 0; i &lt; c-&gt;methodsCount; i++) { c-&gt;methods[i].classMember.attachClass = c; copyMethodInfo(&amp;c-&gt;methods[i], &amp;classFile-&gt;methods[i], classFile); copyAttributes(&amp;c-&gt;methods[i], &amp;classFile-&gt;methods[i], classFile); MethodDescriptor * md = parseMethodDescriptor(c-&gt;methods[i].classMember.descriptor); c-&gt;methods[i].parsedDescriptor = md; calcArgSlotCount(&amp;c-&gt;methods[i]); if (isMethodNative(&amp;c-&gt;methods[i])) { injectCodeAttribute(&amp;c-&gt;methods[i], md-&gt;returnType); } } return NULL; } 上述代码可以看出，实际上就是把ClassFile中解析到的方法逐一赋值给了 Class 对象的 methods 数组。 总算梳理清楚了，反射创建对象的调用链为： loadClass -&gt; loadNonArrayClass -&gt; parseClassFile -&gt; newMethods -&gt; Class 的 methods数组 privateGetDeclaredConstructors -&gt; getDeclaredConstructors0 -&gt; getClassConstructors (过滤Class 的 methods数组) 到目前为止，我们搞明白反射时如何找到对应的构造方法的。下面我们来看 newInstance 方法。 (InnerClass) clazz.getDeclaredConstructor().newInstance(); public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 构造方法是否被重载了 if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class&lt;?&gt; caller = Reflection.getCallerClass(); // 检查权限 checkAccess(caller, clazz, null, modifiers); } } // 枚举类型报错 if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); // ConstructorAccessor 是缓存的，如果为空，就去创建一个 ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { // 创建 ConstructorAccessor ca = acquireConstructorAccessor(); } @SuppressWarnings(&quot;unchecked&quot;) // 使用 ConstructorAccessor 的 newInstance 构造实例 T inst = (T) ca.newInstance(initargs); return inst; } 接着看下 acquireConstructorAccessor 方法。 private ConstructorAccessor acquireConstructorAccessor() { // First check to see if one has been created yet, and take it // if so. ConstructorAccessor tmp = null; // 可以理解为缓存的对象 if (root != null) tmp = root.getConstructorAccessor(); if (tmp != null) { constructorAccessor = tmp; } else { // Otherwise fabricate one and propagate it up to the root // 生成一个 ConstructorAccessor，并缓存起来 tmp = reflectionFactory.newConstructorAccessor(this); setConstructorAccessor(tmp); } return tmp; } 继续走到newConstructorAccessor方法。 public ConstructorAccessor newConstructorAccessor(Constructor&lt;?&gt; var1) { checkInitted(); Class var2 = var1.getDeclaringClass(); // 如果是抽象类，报错 if (Modifier.isAbstract(var2.getModifiers())) { return new InstantiationExceptionConstructorAccessorImpl((String)null); } // 如果 Class 类报错 else if (var2 == Class.class) { return new InstantiationExceptionConstructorAccessorImpl(&quot;Can not instantiate java.lang.Class&quot;); } // 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl else if (Reflection.isSubclassOf(var2, ConstructorAccessorImpl.class)) { return new BootstrapConstructorAccessorImpl(var1); } // 判断 noInflation , 后面是判断不是匿名类 else if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) { return (new MethodAccessorGenerator()).generateConstructor(var1.getDeclaringClass(), var1.getParameterTypes(), var1.getExceptionTypes(), var1.getModifiers()); } // 使用 NativeConstructorAccessorImpl 来生成实例 else { NativeConstructorAccessorImpl var3 = new NativeConstructorAccessorImpl(var1); DelegatingConstructorAccessorImpl var4 = new DelegatingConstructorAccessorImpl(var3); var3.setParent(var4); return var4; } } 具体逻辑，在上述代码中已经注释了。这里提一下 noInflation。 ReflectionFactory在执行所有方法前会检查下是否执行过了checkInitted方法，这个方法会把noInflation的值和inflationThreshold从虚拟机的环境变量中读取出来并赋值。 当noInflation 为 false而且不是匿名类时，就会使用MethodAccessorGenerator方式。否则就是用 NativeConstructorAccessorImpl的方式来生成。 默认noInflation 为false，所以我们先看native调用的方式。关注 NativeConstructorAccessorImpl类。 class NativeConstructorAccessorImpl extends ConstructorAccessorImpl { private final Constructor&lt;?&gt; c; private DelegatingConstructorAccessorImpl parent; private int numInvocations; NativeConstructorAccessorImpl(Constructor&lt;?&gt; var1) { this.c = var1; } public Object newInstance(Object[] var1) throws InstantiationException, IllegalArgumentException, InvocationTargetException { if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.c.getDeclaringClass())) { ConstructorAccessorImpl var2 = (ConstructorAccessorImpl)(new MethodAccessorGenerator()).generateConstructor(this.c.getDeclaringClass(), this.c.getParameterTypes(), this.c.getExceptionTypes(), this.c.getModifiers()); this.parent.setDelegate(var2); } return newInstance0(this.c, var1); } void setParent(DelegatingConstructorAccessorImpl var1) { this.parent = var1; } private static native Object newInstance0(Constructor&lt;?&gt; var0, Object[] var1) throws InstantiationException, IllegalArgumentException, InvocationTargetException; } 我们可以看到 NativeConstructorAccessorImpl 中维护了一个计数器numInvocations,在每次调用newInstance方法生成实例时，就会对计数器自增，当计数器超过ReflectionFactory.inflationThreshold()的阈值，默认为15，就会使用 ConstructorAccessorImpl替换 NativeConstructorAccessorImpl,后面就会直接调用MethodAccessorGenerator中的方法了。 我们先看看没到达阈值前，会调用native方法 newInstance0,这个方法定义在native/sun/reflect/NativeConstructorAccessorImpl.c中，具体newInstance0的流程我就不分析了，大致逻辑是操作堆栈执行方法。 然后我们再看看超过阈值后，执行的是 MethodAccessorGenerator生成构造器的方式。这种方式与newConstructorAccessor方法中noInflation 为 false的处理方式一样。所以可以解释为：java虚拟机在执行反射操作时，如果同一操作执行次数超过阈值，会从native生成实例的方式转变为java生成实例的方式。 MethodAccessorGenerator的MethodAccessorGenerator方法如下。 public ConstructorAccessor generateConstructor(Class&lt;?&gt; var1, Class&lt;?&gt;[] var2, Class&lt;?&gt;[] var3, int var4) { return (ConstructorAccessor)this.generate(var1, &quot;&lt;init&gt;&quot;, var2, Void.TYPE, var3, var4, true, false, (Class)null); } 继续跟踪下去可以发现，反射调用构造方法实际上是动态编写字节码，并且在虚拟机中把编好的字节码加载成一个Class，这个Class实际上是 ConstructorAccessorImpl 类型的，然后调用这个动态类的newInstance方法。回看刚刚我们梳理的newConstructorAccessor代码，可以看到第三个逻辑： // 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl else if (Reflection.isSubclassOf(var2, ConstructorAccessorImpl.class)) { return new BootstrapConstructorAccessorImpl(var1); } 最终执行的是 BootstrapConstructorAccessorImpl的newInstance方法。 class BootstrapConstructorAccessorImpl extends ConstructorAccessorImpl { private final Constructor&lt;?&gt; constructor; BootstrapConstructorAccessorImpl(Constructor&lt;?&gt; var1) { this.constructor = var1; } public Object newInstance(Object[] var1) throws IllegalArgumentException, InvocationTargetException { try { return UnsafeFieldAccessorImpl.unsafe.allocateInstance(this.constructor.getDeclaringClass()); } catch (InstantiationException var3) { throw new InvocationTargetException(var3); } } } 最后是通过使用Unsafe类分配了一个实例。 反射带来的问题到现在为止，我们已经把反射生成实例的所有流程都搞清楚了。回到文章开头的问题，我们现在反思下，反射性能低么？为什么？ 反射调用过程中会产生大量的临时对象，这些对象会占用内存，可能会导致频繁 gc，从而影响性能。 反射调用方法时会从方法数组中遍历查找，并且会检查可见性等操作会耗时。 反射在达到一定次数时，会动态编写字节码并加载到内存中，这个字节码没有经过编译器优化，也不能享受JIT优化。 反射一般会涉及自动装箱/拆箱和类型转换，都会带来一定的资源开销。 在Android中，我们可以在某些情况下对反射进行优化。举个例子，EventBus 2.x 会在 register 方法运行时，遍历所有方法找到回调方法；而EventBus 3.x 则在编译期间，将所有回调方法的信息保存的自己定义的 SubscriberMethodInfo 中，这样可以减少对运行时的性能影响。 本文的结论如下： 不要在性能敏感的应用中，频繁调用反射。 如果反射执行的次数小于1000这个数量级，反射的耗时实际上与正常调用无太大差异。 反射对内存占用还有一定影响的，在内存敏感的场景下，谨慎使用反射。","categories":[],"tags":[]},{"title":"HashMap原理技术知识整理","slug":"HashMap原理技术知识整理","date":"2020-06-11T21:47:26.000Z","updated":"2020-06-13T20:40:50.411Z","comments":true,"path":"2020/06/12/hashmap/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/hashmap/","excerpt":"HashMap涉及的技术点非常多，典型的数据结构和算法有机结合，JDK对HashMap优化变化中不断权衡时间复杂和空间复杂度。","text":"HashMap涉及的技术点非常多，典型的数据结构和算法有机结合，JDK对HashMap优化变化中不断权衡时间复杂和空间复杂度。 一. 存储结构1.JDK1.8之前 HashMap = 数组(O(1)）+ 单向链表（O(n)） 2.JDK1.8之后 HashMap = 数组(O(1)）+ 单向链表（O(n)）+ 红黑树(O(log n) 关于结构的几个关键数字： 1.默认初始化数组容量大小是16。 2.数组扩容刚好是2的次幂。 3.默认的加载因子是0.75。 4.链表长度超过8时将链表转化成红黑树结构。 5.红黑树节点数减少到6的时候退化成链表。 以上几个数字关系，又为什么是上边的几个数字接下来一个个分析。 二. 操作原理1. put储存流程①计算桶的位置，根据key的hashcode求出hash值，位置index = hash%length。 ②判断是否达到扩容条件，threshold=DEFAULT_INITIAL_CAPACITY * loadFactor（16*0.75=12）大于这个阀门值就需要扩容，否则下一步。 ③判断桶位置是否为空，如果为空直接在数据插入数据。如果不为空，下一步。 ④判断是链表还是红黑树，链表是否到达转化红黑树，当前链表节点数&lt;=8，插入节点；如果是红黑树插入节点，否则下一步。 ⑤链表转化成红黑树，插入节点。 ⑥插入节点后计算当前size是否需要扩容，如果大于阀门值需要扩容resize。 /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 以上是JDK1.8的HashMap的get调用关键方法源码。 2. get获取过程①计算桶的位置，根据key的hashcode求出hash值，位置index = hash%length。 ②无论是数值，链表还是红黑树，for循环判断hash值冲突就比对key是否相等，相等就返回对应的value。 /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 以上是JDK1.8的HashMap的put调用关键方法源码。 三. 数据结构和算法思考1.为什么选择数组和链表结构？①数组内存连续块分配，效率体现查询更快。HashMap中用作查找数组桶的位置，利用元素的key的hash值对数组长度取模得到。 ②链表效率体现增加和删除。HashMap中链表是用来解决hash冲突，增删空间消耗平衡。 扩展： 为什么不是ArrayList而是使用Node&lt;K,V&gt;[] tab？因为ArrayList的扩容机制是1.5倍扩容，而HashMap扩容是2的次幂。 2.为什么扩容是2次幂，根据key的hashcode再求hash值？①key的hash值计算static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 代码意思是hash = hashcode的高16位异化低16位，而不是直接hashcode。 ②计算桶的位置代码index = (n - 1) &amp; hash 思想： 一是，为了减少hash冲突使用hash%length计算，求模计算保证了得到的结果一定在0-length范围之内。 二是，为了提高运算速度，模运算比不上位运算，当n是2的次幂才满足hash%length == （n-1）&amp;hash。 确定公式中（n-1）符合最优等式，剩下考虑hash值的最优，hash值这个因子考虑影响结果尽可能不冲突。 因为计算速度体现在位运算上，条件n是2的次幂，那么n-1的换算成二进制前边都是连续的0，后边都是连续的1,。比如n=16，则n-1=15，15的二进制1111。hash &amp; 1111 = 只要关注的hash的二进制的最后四位数进行&amp;运算。 如上图，最终会与15的二进制进行1111四位运算，如果与key.hashcode进行与运算的话，只要key的hashcode最后四位为0000前边无论是什么都没关系，这样出现相同值的概率高很多。所以，引入hashcode先高低16位进行异或运算，减少hash冲突。 扩展： hashcode与equals相等判断对比： 两个key的hashcode相等，key不一定equals。 两个key的equals，hashcode一定相等。 3.为什么加载因子为0.75，链表长度大于8转成红黑树？思想： 上边问题不是两个独立问题而是相互相关，目的尽量减少冲突前提提高空间利用率和减少查询成本的折中。 加载因子决定了HashMap的扩容的阀门值，如果桶是16，那么扩容值16* 0.75=12，也就是12的时候就要考虑扩容，还有4个没有被利用到，牺牲的空间。如果加载因子是1，空间利用率高，但是查询速度变慢。 原理： 权衡依据是以上情况符合泊松分布（一种统计与概率学里常见到的离散概率分布，适合于描述单位时间（或空间）内随机事件发生的次数），用0.75作为加载因子，每个碰撞位置的链表长度超过８个概率非常低，少于千万分之一。 源码说明： * Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million 扩展： 为什么不一开始选择红黑树？ 红黑树近乎于平衡二叉树，结构适合均匀分布节点，减少树的深度像链表长度情况。原因主要是插入效率上，红黑树增加节点很可能需要进行左旋，右旋，着色操作，这些时间效率并没有链表形式高。 4.HashMap的key选择1）选择不可变的对象，比如字符串或int类型。 2）如果要用一个自定义实体类作为key： ①类添加final修饰符，保证类不被继承。 ②保证所有成员变量必须私有，并且加上final修饰。 ③不提供改变成员变量的方法，包括setter。 ④通过构造器初始化所有成员，进行深拷贝(deep copy)。 5.String类中的hashcode计算public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 哈希计算公式：s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1] 四. 横向扩展1.HashMap出现线程问题①多线程扩容，引起的死循环问题（jdk1.8中，死循环问题已经解决）。 ②多线程put的时候可能导致元素丢失。 ③put非null元素后get出来的却是null。 2.使用线程安全Map①HashMap并不是线程安全，要实现线程安全可以用Collections.synchronizedMap(m)获取一个线程安全的HashMap。 ②CurrentHashMap和HashTable是线程安全的。CurrentHashMap使用分段锁技术，要操作节点先获取段锁，在修改节点。 3.Android提倡使用ArrayMap①ArrayMap数据结构是两个数组，一个存放hash值，另一个存放key和value。 ②根据key的hash值利用二分查找在hash数组中找出index。 ③根据index在key-value数组中对应位置查找，如果不相等认为冲突了，会以key为中心，分别上下展开，逐一查找。 优势，数据量少时（少于1000）相比HashMap更节省内存。劣势，删除和插入时效率要比HashMap要低。","categories":[],"tags":[]},{"title":"Rxjava只看这一篇文章就够了","slug":"Rxjava只看这一篇文章就够了","date":"2020-06-11T21:43:39.000Z","updated":"2020-06-13T20:42:25.990Z","comments":true,"path":"2020/06/12/Rxjava/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/Rxjava/","excerpt":"0. 简介RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。","text":"0. 简介RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。 RxJava 有以下三个基本的元素： 被观察者（Observable） 观察者（Observer） 订阅（subscribe） 下面来说说以上三者是如何协作的： 首先在 gradle 文件中添加依赖： implementation &#39;io.reactivex.rxjava2:rxjava:2.1.4&#39; implementation &#39;io.reactivex.rxjava2:rxandroid:2.0.2&#39; 创建被观察者： Observable observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }); 创建观察者： Observer observer = new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;======================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;======================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;======================onError&quot;); } @Override public void onComplete() { Log.d(TAG, &quot;======================onComplete&quot;); } }; 订阅 observable.subscribe(observer); 这里其实也可以使用链式调用： Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;======================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;======================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;======================onError&quot;); } @Override public void onComplete() { Log.d(TAG, &quot;======================onComplete&quot;); } }); 被观察者发送的事件有以下几种，总结如下表： 事件种类 作用 onNext() 发送该事件时，观察者会回调 onNext() 方法 onError() 发送该事件时，观察者会回调 onError() 方法，当发送该事件之后，其他事件将不会继续发送 onComplete() 发送该事件时，观察者会回调 onComplete() 方法，当发送该事件之后，其他事件将不会继续发送 其实可以把 RxJava 比喻成一个做果汁，家里有很多种水果（要发送的原始数据），你想榨点水果汁喝一下，这时候你就要想究竟要喝什么水果汁呢？如果你想喝牛油果雪梨柠檬汁，那你就要把这三种水果混在一起榨汁（使用各种操作符变换你想发送给观察者的数据），榨完后，你就可以喝上你想要的果汁了（把处理好的数据发送给观察者）。 总结如下图： ![img](data:image/svg+xml;utf8,) 下面就来讲解 RxJava 各种常见的操作符。 1. 创建操作符以下就是讲解创建被观察者的各种操作符。 1.1 create()方法预览：public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) 有什么用：创建一个被观察者 怎么用：Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception { e.onNext(&quot;Hello Observer&quot;); e.onComplete(); } }); 上面的代码非常简单，创建 ObservableOnSubscribe 并重写其 subscribe 方法，就可以通过 ObservableEmitter 发射器向观察者发送事件。 以下创建一个观察者，来验证这个被观察者是否成功创建。 Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { Log.d(&quot;chan&quot;,&quot;=============onNext &quot; + s); } @Override public void onError(Throwable e) { } @Override public void onComplete() { Log.d(&quot;chan&quot;,&quot;=============onComplete &quot;); } }; observable.subscribe(observer); 打印结果： 05-20 16:16:50.654 22935-22935/com.example.louder.rxjavademo D/chan: =============onNext Hello Observer =============onComplete 1.2 just()方法预览：public static &lt;T&gt; Observable&lt;T&gt; just(T item) ...... public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) 有什么用？创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。 怎么用？Observable.just(1, 2, 3) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;=================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;=================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;=================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;=================onComplete &quot;); } }); 上面的代码直接使用链式调用，代码也非常简单，这里就不细说了，看看打印结果： 05-20 16:27:26.938 23281-23281/? D/chan: =================onSubscribe =================onNext 1 =================onNext 2 =================onNext 3 =================onComplete 1.3 From 操作符1.3.1 fromArray()方法预览：public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items) 有什么用？这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。 怎么用？Integer array[] = {1, 2, 3, 4}; Observable.fromArray(array) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;=================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;=================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;=================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;=================onComplete &quot;); } }); 代码和 just() 基本上一样，直接看打印结果： 05-20 16:35:23.797 23574-23574/com.example.louder.rxjavademo D/chan: =================onSubscribe =================onNext 1 =================onNext 2 =================onNext 3 =================onNext 4 =================onComplete 1.3.2 fromCallable()方法预览：public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier) 有什么用？这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。 怎么用？Observable.fromCallable(new Callable &lt; Integer &gt; () { @Override public Integer call() throws Exception { return 1; } }) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;================accept &quot; + integer); } }); 打印结果： 05-26 13:01:43.009 6890-6890/? D/chan: ================accept 1 1.3.3 fromFuture()方法预览：public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future) 有什么用？参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。 怎么用？FutureTask &lt; String &gt; futureTask = new FutureTask &lt; &gt; (new Callable &lt; String &gt; () { @Override public String call() throws Exception { Log.d(TAG, &quot;CallableDemo is Running&quot;); return &quot;返回结果&quot;; } }); Observable.fromFuture(futureTask) .doOnSubscribe(new Consumer &lt; Disposable &gt; () { @Override public void accept(Disposable disposable) throws Exception { futureTask.run(); } }) .subscribe(new Consumer &lt; String &gt; () { @Override public void accept(String s) throws Exception { Log.d(TAG, &quot;================accept &quot; + s); } }); doOnSubscribe() 的作用就是只有订阅时才会发送事件，具体会在下面讲解。 打印结果： 05-26 13:54:00.470 14429-14429/com.example.rxjavademo D/chan: CallableDemo is Running ================accept 返回结果 1.3.4 fromIterable()方法预览：public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source) 有什么用？直接发送一个 List 集合数据给观察者 怎么用？List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(0); list.add(1); list.add(2); list.add(3); Observable.fromIterable(list) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;=================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;=================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;=================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;=================onComplete &quot;); } }); 打印结果如下： 05-20 16:43:28.874 23965-23965/? D/chan: =================onSubscribe =================onNext 0 =================onNext 1 =================onNext 2 =================onNext 3 =================onComplete 1.4 defer()方法预览：public static &lt;T&gt; Observable&lt;T&gt; defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier) 有什么用？这个方法的作用就是直到被观察者被订阅后才会创建被观察者。 怎么用？// i 要定义为成员变量 Integer i = 100; Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() { @Override public ObservableSource&lt;? extends Integer&gt; call() throws Exception { return Observable.just(i); } }); i = 200; Observer observer = new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;================onNext &quot; + integer); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }; observable.subscribe(observer); i = 300; observable.subscribe(observer); 打印结果如下： 05-20 20:05:01.443 26622-26622/? D/chan: ================onNext 200 ================onNext 300 因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。 1.5 timer()方法预览：public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) ...... 有什么用？当到指定时间后就会发送一个 0L 的值给观察者。 怎么用？Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Observer &lt; Long &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Long aLong) { Log.d(TAG, &quot;===============onNext &quot; + aLong); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-20 20:27:48.004 27204-27259/com.example.louder.rxjavademo D/chan: ===============onNext 0 1.6 interval()方法预览：public static Observable&lt;Long&gt; interval(long period, TimeUnit unit) public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit) ...... 有什么用？每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。 怎么用？Observable.interval(4, TimeUnit.SECONDS) .subscribe(new Observer &lt; Long &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==============onSubscribe &quot;); } @Override public void onNext(Long aLong) { Log.d(TAG, &quot;==============onNext &quot; + aLong); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-20 20:48:10.321 28723-28723/com.example.louder.rxjavademo D/chan: ==============onSubscribe 05-20 20:48:14.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 0 05-20 20:48:18.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 1 05-20 20:48:22.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 2 05-20 20:48:26.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 3 05-20 20:48:30.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 4 05-20 20:48:34.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 5 从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。 1.7 intervalRange()方法预览：public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) 有什么用？可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。 怎么用？Observable.intervalRange(2, 5, 2, 1, TimeUnit.SECONDS) .subscribe(new Observer &lt; Long &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==============onSubscribe &quot;); } @Override public void onNext(Long aLong) { Log.d(TAG, &quot;==============onNext &quot; + aLong); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-21 00:03:01.672 2504-2504/com.example.louder.rxjavademo D/chan: ==============onSubscribe 05-21 00:03:03.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 2 05-21 00:03:04.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 3 05-21 00:03:05.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 4 05-21 00:03:06.673 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 5 05-21 00:03:07.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 6 可以看出收到5次 onNext 事件，并且是从 2 开始的。 1.8 range()方法预览：public static Observable&lt;Integer&gt; range(final int start, final int count) 有什么用？同时发送一定范围的事件序列。 怎么用？Observable.range(2, 5) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==============onSubscribe &quot;); } @Override public void onNext(Integer aLong) { Log.d(TAG, &quot;==============onNext &quot; + aLong); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-21 00:09:17.202 2921-2921/? D/chan: ==============onSubscribe ==============onNext 2 ==============onNext 3 ==============onNext 4 ==============onNext 5 ==============onNext 6 1.9 rangeLong()方法预览：public static Observable&lt;Long&gt; rangeLong(long start, long count) 有什么用？作用与 range() 一样，只是数据类型为 Long 怎么用？用法与 range() 一样，这里就不再赘述了。 1.10 empty() &amp; never() &amp; error()方法预览：public static &lt;T&gt; Observable&lt;T&gt; empty() public static &lt;T&gt; Observable&lt;T&gt; never() public static &lt;T&gt; Observable&lt;T&gt; error(final Throwable exception) 有什么用？ empty() ： 直接发送 onComplete() 事件 never()：不发送任何事件 error()：发送 onError() 事件 怎么用？Observable.empty() .subscribe(new Observer &lt; Object &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe&quot;); } @Override public void onNext(Object o) { Log.d(TAG, &quot;==================onNext&quot;); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot; + e); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete&quot;); } }); 打印结果： 05-26 14:06:11.881 15798-15798/com.example.rxjavademo D/chan: ==================onSubscribe ==================onComplete 换成 never() 的打印结果： 05-26 14:12:17.554 16805-16805/com.example.rxjavademo D/chan: ==================onSubscribe 换成 error() 的打印结果： 05-26 14:12:58.483 17817-17817/com.example.rxjavademo D/chan: ==================onSubscribe ==================onError java.lang.NullPointerException 2. 转换操作符2.1 map()方法预览：public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) 有什么用？map 可以将被观察者发送的数据类型转变成其他的类型 怎么用？以下代码将 Integer 类型的数据转换成 String。 Observable.just(1, 2, 3) .map(new Function &lt; Integer, String &gt; () { @Override public String apply(Integer integer) throws Exception { return &quot;I&#39;m &quot; + integer; } }) .subscribe(new Observer &lt; String &gt; () { @Override public void onSubscribe(Disposable d) { Log.e(TAG, &quot;===================onSubscribe&quot;); } @Override public void onNext(String s) { Log.e(TAG, &quot;===================onNext &quot; + s); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-21 09:16:03.490 5700-5700/com.example.rxjavademo E/chan: ===================onSubscribe ===================onNext I&#39;m 1 ===================onNext I&#39;m 2 ===================onNext I&#39;m 3 2.2 flatMap()方法预览：public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) ...... 有什么用？这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。 怎么用？flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。现在用一个例子来说明 flatMap() 的用法。 假设一个有一个 Person 类，这个类的定义如下： public class Person { private String name; private List&lt;Plan&gt; planList = new ArrayList&lt;&gt;(); public Person(String name, List&lt;Plan&gt; planList) { this.name = name; this.planList = planList; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;Plan&gt; getPlanList() { return planList; } public void setPlanList(List&lt;Plan&gt; planList) { this.planList = planList; } } Person 类有一个 name 和 planList 两个变量，分别代表的是人名和计划清单。 Plan 类的定义如下： public class Plan { private String time; private String content; private List&lt;String&gt; actionList = new ArrayList&lt;&gt;(); public Plan(String time, String content) { this.time = time; this.content = content; } public String getTime() { return time; } public void setTime(String time) { this.time = time; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public List&lt;String&gt; getActionList() { return actionList; } public void setActionList(List&lt;String&gt; actionList) { this.actionList = actionList; } } 现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。 首先用 map() 来实现这个需求看看： Observable.fromIterable(personList) .map(new Function &lt; Person, List &lt; Plan &gt;&gt; () { @Override public List &lt; Plan &gt; apply(Person person) throws Exception { return person.getPlanList(); } }) .subscribe(new Observer &lt; List &lt; Plan &gt;&gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(List &lt; Plan &gt; plans) { for (Plan plan: plans) { List &lt; String &gt; planActionList = plan.getActionList(); for (String action: planActionList) { Log.d(TAG, &quot;==================action &quot; + action); } } } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。 现在看下使用 flatMap() 实现： Observable.fromIterable(personList) .flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () { @Override public ObservableSource &lt; Plan &gt; apply(Person person) { return Observable.fromIterable(person.getPlanList()); } }) .flatMap(new Function &lt; Plan, ObservableSource &lt; String &gt;&gt; () { @Override public ObservableSource &lt; String &gt; apply(Plan plan) throws Exception { return Observable.fromIterable(plan.getActionList()); } }) .subscribe(new Observer &lt; String &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { Log.d(TAG, &quot;==================action: &quot; + s); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。 2.3 concatMap()方法预览：public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch) 有什么用？concatMap() 和 flatMap() 基本上是一样的，只不过 concatMap() 转发出来的事件是有序的，而 flatMap() 是无序的。 怎么用？还是使用上面 flatMap() 的例子来讲解，首先来试下 flatMap() 来验证发送的事件是否是无序的，代码如下： Observable.fromIterable(personList) .flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () { @Override public ObservableSource &lt; Plan &gt; apply(Person person) { if (&quot;chan&quot;.equals(person.getName())) { return Observable.fromIterable(person.getPlanList()).delay(10, TimeUnit.MILLISECONDS); } return Observable.fromIterable(person.getPlanList()); } }) .subscribe(new Observer &lt; Plan &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Plan plan) { Log.d(TAG, &quot;==================plan &quot; + plan.getContent()); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 为了更好的验证 flatMap 是无序的，使用了一个 delay() 方法来延迟，直接看打印结果： 05-21 13:57:14.031 21616-21616/com.example.rxjavademo D/chan: ==================plan chan 上课 ==================plan chan 写作业 ==================plan chan 打篮球 05-21 13:57:14.041 21616-21641/com.example.rxjavademo D/chan: ==================plan Zede 开会 ==================plan Zede 写代码 ==================plan Zede 写文章 可以看到本来 Zede 的事件发送顺序是排在 chan 事件之前，但是经过延迟后， 这两个事件序列发送顺序互换了。 现在来验证下 concatMap() 是否是有序的，使用上面同样的代码，只是把 flatMap() 换成 concatMap()，打印结果如下： 05-21 13:58:42.917 21799-21823/com.example.rxjavademo D/chan: ==================plan Zede 开会 ==================plan Zede 写代码 ==================plan Zede 写文章 ==================plan chan 上课 ==================plan chan 写作业 ==================plan chan 打篮球 这就代表 concatMap() 转换后发送的事件序列是有序的了。 2.4 buffer()方法预览：public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip) ...... 有什么用？从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。 怎么用？buffer 有两个参数，一个是 count，另一个 skip。count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素。这样说可能还是有点抽象，直接看代码： Observable.just(1, 2, 3, 4, 5) .buffer(2, 1) .subscribe(new Observer &lt; List &lt; Integer &gt;&gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(List &lt; Integer &gt; integers) { Log.d(TAG, &quot;================缓冲区大小： &quot; + integers.size()); for (Integer i: integers) { Log.d(TAG, &quot;================元素： &quot; + i); } } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-21 14:09:34.015 22421-22421/com.example.rxjavademo D/chan: ================缓冲区大小： 2 ================元素： 1 ================元素： 2 ================缓冲区大小： 2 ================元素： 2 ================元素： 3 ================缓冲区大小： 2 ================元素： 3 ================元素： 4 ================缓冲区大小： 2 ================元素： 4 ================元素： 5 ================缓冲区大小： 1 ================元素： 5 从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。 2.5 groupBy()方法预览：public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector) 有什么用？将发送的数据进行分组，每个分组都会返回一个被观察者。 怎么用？Observable.just(5, 2, 3, 4, 1, 6, 8, 9, 7, 10) .groupBy(new Function &lt; Integer, Integer &gt; () { @Override public Integer apply(Integer integer) throws Exception { return integer % 3; } }) .subscribe(new Observer &lt; GroupedObservable &lt; Integer, Integer &gt;&gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;====================onSubscribe &quot;); } @Override public void onNext(GroupedObservable &lt; Integer, Integer &gt; integerIntegerGroupedObservable) { Log.d(TAG, &quot;====================onNext &quot;); integerIntegerGroupedObservable.subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;====================GroupedObservable onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;====================GroupedObservable onNext groupName: &quot; + integerIntegerGroupedObservable.getKey() + &quot; value: &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;====================GroupedObservable onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;====================GroupedObservable onComplete &quot;); } }); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;====================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;====================onComplete &quot;); } }); 在 groupBy() 方法返回的参数是分组的名字，每返回一个值，那就代表会创建一个组，以上的代码就是将1~10的数据分成3组，来看看打印结果： 05-26 14:38:02.062 21451-21451/com.example.rxjavademo D/chan: ====================onSubscribe 05-26 14:38:02.063 21451-21451/com.example.rxjavademo D/chan: ====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext groupName: 2 value: 5 ====================GroupedObservable onNext groupName: 2 value: 2 ====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext groupName: 0 value: 3 05-26 14:38:02.064 21451-21451/com.example.rxjavademo D/chan: ====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext groupName: 1 value: 4 ====================GroupedObservable onNext groupName: 1 value: 1 ====================GroupedObservable onNext groupName: 0 value: 6 ====================GroupedObservable onNext groupName: 2 value: 8 ====================GroupedObservable onNext groupName: 0 value: 9 ====================GroupedObservable onNext groupName: 1 value: 7 ====================GroupedObservable onNext groupName: 1 value: 10 05-26 14:38:02.065 21451-21451/com.example.rxjavademo D/chan: ====================GroupedObservable onComplete ====================GroupedObservable onComplete ====================GroupedObservable onComplete ====================onComplete 可以看到返回的结果中是有3个组的。 2.6 scan()方法预览：public final Observable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator) 有什么用？将数据以一定的逻辑聚合起来。 怎么用？Observable.just(1, 2, 3, 4, 5) .scan(new BiFunction &lt; Integer, Integer, Integer &gt; () { @Override public Integer apply(Integer integer, Integer integer2) throws Exception { Log.d(TAG, &quot;====================apply &quot;); Log.d(TAG, &quot;====================integer &quot; + integer); Log.d(TAG, &quot;====================integer2 &quot; + integer2); return integer + integer2; } }) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;====================accept &quot; + integer); } }); 打印结果： 05-26 14:45:27.784 22519-22519/com.example.rxjavademo D/chan: ====================accept 1 ====================apply ====================integer 1 ====================integer2 2 ====================accept 3 ====================apply 05-26 14:45:27.785 22519-22519/com.example.rxjavademo D/chan: ====================integer 3 ====================integer2 3 ====================accept 6 ====================apply ====================integer 6 ====================integer2 4 ====================accept 10 ====================apply ====================integer 10 ====================integer2 5 ====================accept 15 2.7 window()方法预览：public final Observable&lt;Observable&lt;T&gt;&gt; window(long count) ...... 有什么用？发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。 怎么用？Observable.just(1, 2, 3, 4, 5) .window(2) .subscribe(new Observer &lt; Observable &lt; Integer &gt;&gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;=====================onSubscribe &quot;); } @Override public void onNext(Observable &lt; Integer &gt; integerObservable) { integerObservable.subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;=====================integerObservable onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;=====================integerObservable onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;=====================integerObservable onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;=====================integerObservable onComplete &quot;); } }); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;=====================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;=====================onComplete &quot;); } }); 打印结果： 05-26 15:02:20.654 25838-25838/com.example.rxjavademo D/chan: =====================onSubscribe 05-26 15:02:20.655 25838-25838/com.example.rxjavademo D/chan: =====================integerObservable onSubscribe 05-26 15:02:20.656 25838-25838/com.example.rxjavademo D/chan: =====================integerObservable onNext 1 =====================integerObservable onNext 2 =====================integerObservable onComplete =====================integerObservable onSubscribe =====================integerObservable onNext 3 =====================integerObservable onNext 4 =====================integerObservable onComplete =====================integerObservable onSubscribe =====================integerObservable onNext 5 =====================integerObservable onComplete =====================onComplete 从结果可以发现，window() 将 1~5 的事件分成了3组。 3. 组合操作符3.1 concat()方法预览：public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4) ...... 有什么用？可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。 怎么用？Observable.concat(Observable.just(1, 2), Observable.just(3, 4), Observable.just(5, 6), Observable.just(7, 8)) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;================onNext &quot; + integer); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印如下： 05-21 15:40:26.738 7477-7477/com.example.rxjavademo D/chan: ================onNext 1 ================onNext 2 05-21 15:40:26.739 7477-7477/com.example.rxjavademo D/chan: ================onNext 3 ================onNext 4 ================onNext 5 ================onNext 6 ================onNext 7 ================onNext 8 3.2 concatArray()方法预览：public static &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource&lt;? extends T&gt;... sources) 有什么用？与 concat() 作用一样，不过 concatArray() 可以发送多于 4 个被观察者。 怎么用？Observable.concatArray(Observable.just(1, 2), Observable.just(3, 4), Observable.just(5, 6), Observable.just(7, 8), Observable.just(9, 10)) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;================onNext &quot; + integer); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果： 05-21 15:47:18.581 9129-9129/com.example.rxjavademo D/chan: ================onNext 1 ================onNext 2 ================onNext 3 ================onNext 4 ================onNext 5 ================onNext 6 ================onNext 7 ================onNext 8 ================onNext 9 ================onNext 10 3.3 merge()方法预览： public static &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4) ...... 有什么用？这个方法月 concat() 作用基本一样，知识 concat() 是串行发送事件，而 merge() 并行发送事件。 怎么用？现在来演示 concat() 和 merge() 的区别。 Observable.merge( Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () { @Override public String apply(Long aLong) throws Exception { return &quot;A&quot; + aLong; } }), Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () { @Override public String apply(Long aLong) throws Exception { return &quot;B&quot; + aLong; } })) .subscribe(new Observer &lt; String &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { Log.d(TAG, &quot;=====================onNext &quot; + s); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 打印结果如下： 05-21 16:10:31.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B0 05-21 16:10:31.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A0 05-21 16:10:32.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A1 05-21 16:10:32.126 12801-12850/com.example.rxjavademo D/chan: =====================onNext B1 05-21 16:10:33.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A2 05-21 16:10:33.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B2 05-21 16:10:34.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A3 05-21 16:10:34.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B3 05-21 16:10:35.124 12801-12849/com.example.rxjavademo D/chan: =====================onNext A4 05-21 16:10:35.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B4 05-21 16:10:36.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A5 05-21 16:10:36.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B5 ...... 从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果： 05-21 16:17:52.352 14597-14621/com.example.rxjavademo D/chan: =====================onNext A0 05-21 16:17:53.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A1 05-21 16:17:54.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A2 05-21 16:17:55.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A3 05-21 16:17:56.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A4 05-21 16:17:57.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A5 ...... 从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。 mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者，这里就不再赘述了。 3.4 concatArrayDelayError() &amp; mergeArrayDelayError()方法预览：public static &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource&lt;? extends T&gt;... sources) public static &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource&lt;? extends T&gt;... sources) 有什么用？在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 onError() 事件延迟到所有被观察者都发送完事件后再执行的话，就可以使用 concatArrayDelayError() 和 mergeArrayDelayError() 怎么用？首先使用 concatArray() 来验证一下发送 onError() 事件是否会中断其他被观察者发送事件，代码如下： Observable.concatArray( Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onError(new NumberFormatException()); } }), Observable.just(2, 3, 4)) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;===================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;===================onError &quot;); } @Override public void onComplete() { } }); 打印结果： 05-21 16:38:59.725 17985-17985/com.example.rxjavademo D/chan: ===================onNext 1 ===================onError 从结果可以知道，确实中断了，现在换用 concatArrayDelayError()，代码如下： Observable.concatArrayDelayError( Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onError(new NumberFormatException()); } }), Observable.just(2, 3, 4)) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;===================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;===================onError &quot;); } @Override public void onComplete() { } }); 打印结果如下： 05-21 16:40:59.329 18199-18199/com.example.rxjavademo D/chan: ===================onNext 1 ===================onNext 2 ===================onNext 3 ===================onNext 4 ===================onError 从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用，这里不再赘述。 3.5 zip()方法预览：public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper) ...... 有什么用？会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。 怎么用？Observable.zip(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS) .map(new Function&lt;Long, String&gt;() { @Override public String apply(Long aLong) throws Exception { String s1 = &quot;A&quot; + aLong; Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1); return s1; }}), Observable.intervalRange(1, 6, 1, 1, TimeUnit.SECONDS) .map(new Function&lt;Long, String&gt;() { @Override public String apply(Long aLong) throws Exception { String s2 = &quot;B&quot; + aLong; Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2); return s2; } }), new BiFunction&lt;String, String, String&gt;() { @Override public String apply(String s, String s2) throws Exception { String res = s + s2; return res; } }) .subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;===================onSubscribe &quot;); } @Override public void onNext(String s) { Log.d(TAG, &quot;===================onNext &quot; + s); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;===================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;===================onComplete &quot;); } }); 上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果： 05-22 09:10:39.952 5338-5338/com.example.rxjavademo D/chan: ===================onSubscribe 05-22 09:10:40.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A1 05-22 09:10:40.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B1 ===================onNext A1B1 05-22 09:10:41.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A2 05-22 09:10:41.954 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B2 ===================onNext A2B2 05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A3 05-22 09:10:42.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B3 05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================onNext A3B3 05-22 09:10:43.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A4 05-22 09:10:43.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B4 05-22 09:10:43.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A4B4 05-22 09:10:44.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A5 05-22 09:10:44.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B5 05-22 09:10:44.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A5B5 ===================onComplete 可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。 3.6 combineLatest() &amp; combineLatestDelayError()方法预览：public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner) ....... 有什么用？combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送，这样可能还是比较抽象，看看以下例子代码。 怎么用？Observable.combineLatest( Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS) .map(new Function &lt; Long, String &gt; () {@Override public String apply(Long aLong) throws Exception { String s1 = &quot;A&quot; + aLong; Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1); return s1; } }), Observable.intervalRange(1, 5, 2, 2, TimeUnit.SECONDS) .map(new Function &lt; Long, String &gt; () {@Override public String apply(Long aLong) throws Exception { String s2 = &quot;B&quot; + aLong; Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2); return s2; } }), new BiFunction &lt; String, String, String &gt; () {@Override public String apply(String s, String s2) throws Exception { String res = s + s2; return res; } }) .subscribe(new Observer &lt; String &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;===================onSubscribe &quot;); } @Override public void onNext(String s) { Log.d(TAG, &quot;===================最终接收到的事件 &quot; + s); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;===================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;===================onComplete &quot;); } }); 分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果： 05-22 11:41:20.859 15104-15104/? D/chan: ===================onSubscribe 05-22 11:41:21.859 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A1 05-22 11:41:22.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A2 05-22 11:41:22.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B1 05-22 11:41:22.862 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1 05-22 11:41:23.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A3 ===================最终接收到的事件 A3B1 05-22 11:41:24.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A4 05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B2 05-22 11:41:24.861 15104-15128/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1 05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2 05-22 11:41:26.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B3 05-22 11:41:26.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3 05-22 11:41:28.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B4 05-22 11:41:28.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4 05-22 11:41:30.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B5 05-22 11:41:30.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5 ===================onComplete 分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。 因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。 3.7 reduce()方法预览：public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer) 有什么用？与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。 怎么用？Observable.just(0, 1, 2, 3) .reduce(new BiFunction &lt; Integer, Integer, Integer &gt; () { @Override public Integer apply(Integer integer, Integer integer2) throws Exception { int res = integer + integer2; Log.d(TAG, &quot;====================integer &quot; + integer); Log.d(TAG, &quot;====================integer2 &quot; + integer2); Log.d(TAG, &quot;====================res &quot; + res); return res; } }) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;==================accept &quot; + integer); } }); 打印结果： 05-22 14:21:46.042 17775-17775/? D/chan: ====================integer 0 ====================integer2 1 ====================res 1 ====================integer 1 ====================integer2 2 ====================res 3 ====================integer 3 ====================integer2 3 ====================res 6 ==================accept 6 从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。 3.8 collect()方法预览：public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector) 有什么用？将数据收集到数据结构当中。 怎么用？Observable.just(1, 2, 3, 4) .collect(new Callable &lt; ArrayList &lt; Integer &gt;&gt; () { @Override public ArrayList &lt; Integer &gt; call() throws Exception { return new ArrayList &lt; &gt; (); } }, new BiConsumer &lt; ArrayList &lt; Integer &gt; , Integer &gt; () { @Override public void accept(ArrayList &lt; Integer &gt; integers, Integer integer) throws Exception { integers.add(integer); } }) .subscribe(new Consumer &lt; ArrayList &lt; Integer &gt;&gt; () { @Override public void accept(ArrayList &lt; Integer &gt; integers) throws Exception { Log.d(TAG, &quot;===============accept &quot; + integers); } }); 打印结果： 05-22 16:47:18.257 31361-31361/com.example.rxjavademo D/chan: ===============accept [1, 2, 3, 4] 3.9 startWith() &amp; startWithArray()方法预览：public final Observable&lt;T&gt; startWith(T item) public final Observable&lt;T&gt; startWithArray(T... items) 有什么用？在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。 怎么用？Observable.just(5, 6, 7) .startWithArray(2, 3, 4) .startWith(1) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;================accept &quot; + integer); } }); 打印结果： 05-22 17:08:21.282 4505-4505/com.example.rxjavademo D/chan: ================accept 1 ================accept 2 ================accept 3 ================accept 4 ================accept 5 ================accept 6 ================accept 7 3.10 count()方法预览：public final Single&lt;Long&gt; count() 有什么用？返回被观察者发送事件的数量。 怎么用？Observable.just(1, 2, 3) .count() .subscribe(new Consumer &lt; Long &gt; () { @Override public void accept(Long aLong) throws Exception { Log.d(TAG, &quot;=======================aLong &quot; + aLong); } }); 打印结果： 05-22 20:41:25.025 14126-14126/? D/chan: =======================aLong 3 4. 功能操作符4.1 delay()方法预览：public final Observable&lt;T&gt; delay(long delay, TimeUnit unit) 有什么用？延迟一段事件发送事件。 怎么用？Observable.just(1, 2, 3) .delay(2, TimeUnit.SECONDS) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;=======================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;=======================onNext &quot; + integer); } @Override public void onError(Throwable e) { } @Override public void onComplete() { Log.d(TAG, &quot;=======================onSubscribe&quot;); } }); 这里延迟了两秒才发送事件，来看看打印结果： 05-22 20:53:43.618 16880-16880/com.example.rxjavademo D/chan: =======================onSubscribe 05-22 20:53:45.620 16880-16906/com.example.rxjavademo D/chan: =======================onNext 1 05-22 20:53:45.621 16880-16906/com.example.rxjavademo D/chan: =======================onNext 2 =======================onNext 3 =======================onSubscribe 从打印结果可以看出 onSubscribe 回调2秒之后 onNext 才会回调。 4.2 doOnEach()方法预览：public final Observable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) 有什么用？Observable 每发送一件事件之前都会先回调这个方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); // e.onError(new NumberFormatException()); e.onComplete(); } }) .doOnEach(new Consumer &lt; Notification &lt; Integer &gt;&gt; () { @Override public void accept(Notification &lt; Integer &gt; integerNotification) throws Exception { Log.d(TAG, &quot;==================doOnEach &quot; + integerNotification.getValue()); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:07:05.547 19867-19867/? D/chan: ==================onSubscribe ==================doOnEach 1 ==================onNext 1 ==================doOnEach 2 ==================onNext 2 ==================doOnEach 3 ==================onNext 3 ==================doOnEach null ==================onComplete 从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。 4.3 doOnNext()方法预览：public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext) 有什么用？Observable 每发送 onNext() 之前都会先回调这个方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doOnNext(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;==================doOnNext &quot; + integer); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:09:36.769 20020-20020/com.example.rxjavademo D/chan: ==================onSubscribe ==================doOnNext 1 ==================onNext 1 ==================doOnNext 2 ==================onNext 2 ==================doOnNext 3 ==================onNext 3 ==================onComplete 4.4 doAfterNext()方法预览：public final Observable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext) 有什么用？Observable 每发送 onNext() 之后都会回调这个方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doAfterNext(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;==================doAfterNext &quot; + integer); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:15:49.215 20432-20432/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================doAfterNext 1 ==================onNext 2 ==================doAfterNext 2 ==================onNext 3 ==================doAfterNext 3 ==================onComplete 4.5 doOnComplete()方法预览：public final Observable&lt;T&gt; doOnComplete(Action onComplete) 有什么用？Observable 每发送 onComplete() 之前都会回调这个方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doOnComplete(new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doOnComplete &quot;); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:32:18.031 20751-20751/? D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================doOnComplete ==================onComplete 4.6 doOnError()方法预览：public final Observable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError) 有什么用？Observable 每发送 onError() 之前都会回调这个方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onError(new NullPointerException()); } }) .doOnError(new Consumer &lt; Throwable &gt; () { @Override public void accept(Throwable throwable) throws Exception { Log.d(TAG, &quot;==================doOnError &quot; + throwable); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:35:04.150 21051-21051/? D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================doOnError java.lang.NullPointerException ==================onError 4.7 doOnSubscribe()方法预览：public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe) 有什么用？Observable 每发送 onSubscribe() 之前都会回调这个方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doOnSubscribe(new Consumer &lt; Disposable &gt; () { @Override public void accept(Disposable disposable) throws Exception { Log.d(TAG, &quot;==================doOnSubscribe &quot;); } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:39:25.778 21245-21245/? D/chan: ==================doOnSubscribe ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onComplete 4.8 doOnDispose()方法预览：public final Observable&lt;T&gt; doOnDispose(Action onDispose) 有什么用？当调用 Disposable 的 dispose() 之后回调该方法。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doOnDispose(new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doOnDispose &quot;); } }) .subscribe(new Observer &lt; Integer &gt; () { private Disposable d; @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); this.d = d; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); d.dispose(); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 09:55:48.122 22023-22023/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================doOnDispose 4.9 doOnLifecycle()方法预览：public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose) 有什么用？在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。 怎么用？doOnLifecycle() 第二个参数的回调方法的作用与 doOnDispose() 是一样的，现在用下面的例子来讲解： Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doOnLifecycle(new Consumer&lt;Disposable&gt;() { @Override public void accept(Disposable disposable) throws Exception { Log.d(TAG, &quot;==================doOnLifecycle accept&quot;); } }, new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doOnLifecycle Action&quot;); } }) .doOnDispose( new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doOnDispose Action&quot;); } }) .subscribe(new Observer&lt;Integer&gt;() { private Disposable d; @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); this.d = d; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); d.dispose(); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 10:20:36.345 23922-23922/? D/chan: ==================doOnLifecycle accept ==================onSubscribe ==================onNext 1 ==================doOnDispose Action ==================doOnLifecycle Action 可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。 如果使用 doOnLifecycle 进行取消订阅，来看看打印结果： 05-23 10:32:20.014 24652-24652/com.example.rxjavademo D/chan: ==================doOnLifecycle accept ==================onSubscribe 可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。 4.10 doOnTerminate() &amp; doAfterTerminate()方法预览：public final Observable&lt;T&gt; doOnTerminate(final Action onTerminate) public final Observable&lt;T&gt; doAfterTerminate(Action onFinally) 有什么用？doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。 怎么用？Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); // e.onError(new NullPointerException()); e.onComplete(); } }) .doOnTerminate(new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doOnTerminate &quot;); } }) .subscribe(new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 10:00:39.503 22398-22398/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 05-23 10:00:39.504 22398-22398/com.example.rxjavademo D/chan: ==================onNext 3 ==================doOnTerminate ==================onComplete doAfterTerminate 也是差不多，这里就不再赘述。 4.11 doFinally()方法预览：public final Observable&lt;T&gt; doFinally(Action onFinally) 有什么用？在所有事件发送完毕之后回调该方法。 怎么用？这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 doFinally() 无论怎么样都会被回调，且都会在事件序列的最后。 现在用以下例子说明下： Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .doFinally(new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doFinally &quot;); } }) .doOnDispose(new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doOnDispose &quot;); } }) .doAfterTerminate(new Action() { @Override public void run() throws Exception { Log.d(TAG, &quot;==================doAfterTerminate &quot;); } }) .subscribe(new Observer&lt;Integer&gt;() { private Disposable d; @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); this.d = d; } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); d.dispose(); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 10:10:10.469 23196-23196/? D/chan: ==================onSubscribe 05-23 10:10:10.470 23196-23196/? D/chan: ==================onNext 1 ==================doOnDispose ==================doFinally 可以看到如果调用了 dispose() 方法，doAfterTerminate() 不会被回调。 现在试试把 dispose() 注释掉看看，看看打印结果： 05-23 10:13:34.537 23439-23439/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onComplete ==================doAfterTerminate ==================doFinally doAfterTerminate() 已经成功回调，doFinally() 还是会在事件序列的最后。 4.12 onErrorReturn()方法预览：public final Observable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier) 有什么用？当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。 怎么用？Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onError(new NullPointerException()); } }) .onErrorReturn(new Function&lt;Throwable, Integer&gt;() { @Override public Integer apply(Throwable throwable) throws Exception { Log.d(TAG, &quot;==================onErrorReturn &quot; + throwable); return 404; } }) .subscribe(new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 18:35:18.175 19239-19239/? D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onErrorReturn java.lang.NullPointerException ==================onNext 404 ==================onComplete 4.13 onErrorResumeNext()方法预览：public final Observable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction) 有什么用？当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。 怎么用？Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onError(new NullPointerException()); } }) .onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() { @Override public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception { Log.d(TAG, &quot;==================onErrorResumeNext &quot; + throwable); return Observable.just(4, 5, 6); } }) .subscribe(new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 18:43:10.910 26469-26469/? D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onErrorResumeNext java.lang.NullPointerException ==================onNext 4 ==================onNext 5 ==================onNext 6 ==================onComplete 4.14 onExceptionResumeNext()方法预览：public final Observable&lt;T&gt; onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next) 有什么用？与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。 怎么用？先来试试 onExceptionResumeNext() 是否能捕捉 Error。 Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onError(new Error(&quot;404&quot;)); } }) .onExceptionResumeNext(new Observable&lt;Integer&gt;() { @Override protected void subscribeActual(Observer&lt;? super Integer&gt; observer) { observer.onNext(333); observer.onComplete(); } }) .subscribe(new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 22:23:08.873 1062-1062/com.example.louder.rxjavademo D/chan: ==================onSubscribe 05-23 22:23:08.874 1062-1062/com.example.louder.rxjavademo D/chan: ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onError 从打印结果可以知道，观察者收到 onError() 事件，证明 onErrorResumeNext() 不能捕捉 Error 事件。 将被观察者的 e.onError(new Error(“404”)) 改为 e.onError(new Exception(“404”))，现在看看是否能捕捉 Exception 事件： 05-23 22:32:14.563 10487-10487/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onNext 333 ==================onComplete 从打印结果可以知道，这个方法成功捕获 Exception 事件。 4.15 retry()方法预览：public final Observable&lt;T&gt; retry(long times) ...... 有什么用？如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。 怎么用？Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onError(new Exception(&quot;404&quot;)); } }) .retry(2) .subscribe(new Observer&lt;Integer&gt;() { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 22:46:18.537 22239-22239/com.example.louder.rxjavademo D/chan: ==================onSubscribe 05-23 22:46:18.538 22239-22239/com.example.louder.rxjavademo D/chan: ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onError 4.16 retryUntil()方法预览：public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop) 有什么用？出现错误事件之后，可以通过此方法判断是否继续发送事件。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onError(new Exception(&quot;404&quot;)); } }) .retryUntil(new BooleanSupplier() { @Override public boolean getAsBoolean() throws Exception { if (i == 6) { return true; } return false; } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-23 22:57:32.905 23063-23063/com.example.louder.rxjavademo D/chan: ==================onSubscribe 05-23 22:57:32.906 23063-23063/com.example.louder.rxjavademo D/chan: ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onError 4.17 retryWhen()方法预览：public final void safeSubscribe(Observer&lt;? super T&gt; s) 有什么用？当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。 怎么用？Observable.create(new ObservableOnSubscribe &lt; String &gt; () { @Override public void subscribe(ObservableEmitter &lt; String &gt; e) throws Exception { e.onNext(&quot;chan&quot;); e.onNext(&quot;ze&quot;); e.onNext(&quot;de&quot;); e.onError(new Exception(&quot;404&quot;)); e.onNext(&quot;haha&quot;); } }) .retryWhen(new Function &lt; Observable &lt; Throwable &gt; , ObservableSource &lt;? &gt;&gt; () { @Override public ObservableSource &lt;? &gt; apply(Observable &lt; Throwable &gt; throwableObservable) throws Exception { return throwableObservable.flatMap(new Function &lt; Throwable, ObservableSource &lt;? &gt;&gt; () { @Override public ObservableSource &lt;? &gt; apply(Throwable throwable) throws Exception { if(!throwable.toString().equals(&quot;java.lang.Exception: 404&quot;)) { return Observable.just(&quot;可以忽略的异常&quot;); } else { return Observable.error(new Throwable(&quot;终止啦&quot;)); } } }); } }) .subscribe(new Observer &lt; String &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(String s) { Log.d(TAG, &quot;==================onNext &quot; + s); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot; + e.toString()); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-24 09:13:25.622 28372-28372/com.example.rxjavademo D/chan: ==================onSubscribe 05-24 09:13:25.623 28372-28372/com.example.rxjavademo D/chan: ==================onNext chan ==================onNext ze ==================onNext de 05-24 09:13:25.624 28372-28372/com.example.rxjavademo D/chan: ==================onError java.lang.Throwable: 终止啦 将 onError(new Exception(“404”)) 改为 onError(new Exception(“303”)) 看看打印结果： ==================onNext chan 05-24 09:54:08.653 29694-29694/? D/chan: ==================onNext ze ==================onNext de ==================onNext chan ==================onNext ze ==================onNext de ==================onNext chan ==================onNext ze ==================onNext de ==================onNext chan ==================onNext ze ==================onNext de ==================onNext chan ==================onNext ze ==================onNext de ==================onNext chan ...... 从结果可以看出，会不断重复发送消息。 4.18 repeat()方法预览：public final Observable&lt;T&gt; repeat(long times) ...... 有什么用？重复发送被观察者的事件，times 为发送次数。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .repeat(2) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;===================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;===================onNext &quot; + integer); } @Override public void onError(Throwable e) { } @Override public void onComplete() { Log.d(TAG, &quot;===================onComplete &quot;); } }); 打印结果： 05-24 11:33:29.565 8544-8544/com.example.rxjavademo D/chan: ===================onSubscribe ===================onNext 1 ===================onNext 2 ===================onNext 3 ===================onNext 1 ===================onNext 2 ===================onNext 3 05-24 11:33:29.565 8544-8544/com.example.rxjavademo D/chan: ===================onComplete 从结果可以看出，该事件发送了两次。 4.19 repeatWhen()方法预览：public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler) 有什么用？这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。 怎么用？这里分三种情况，如果新的被观察者返回 onComplete 或者 onError 事件，则旧的被观察者不会继续发送事件。如果被观察者返回其他事件，则会重复发送事件。 现在试验发送 onComplete 事件，代码如下： Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .repeatWhen(new Function &lt; Observable &lt; Object &gt; , ObservableSource &lt;? &gt;&gt; () { @Override public ObservableSource &lt;? &gt; apply(Observable &lt; Object &gt; objectObservable) throws Exception { return Observable.empty(); // return Observable.error(new Exception(&quot;404&quot;)); // return Observable.just(4); null; } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;===================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;===================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;===================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;===================onComplete &quot;); } }); 打印结果： 05-24 11:44:33.486 9379-9379/com.example.rxjavademo D/chan: ===================onSubscribe 05-24 11:44:33.487 9379-9379/com.example.rxjavademo D/chan: ===================onComplete 下面直接看看发送 onError 事件和其他事件的打印结果。 发送 onError 打印结果： 05-24 11:46:29.507 9561-9561/com.example.rxjavademo D/chan: ===================onSubscribe 05-24 11:46:29.508 9561-9561/com.example.rxjavademo D/chan: ===================onError 发送其他事件的打印结果： 05-24 11:48:35.844 9752-9752/com.example.rxjavademo D/chan: ===================onSubscribe ===================onNext 1 ===================onNext 2 ===================onNext 3 ===================onComplete 4.20 subscribeOn()方法预览：public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) 有什么用？指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) //.subscribeOn(Schedulers.newThread()) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;======================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;======================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;======================onError&quot;); } @Override public void onComplete() { Log.d(TAG, &quot;======================onComplete&quot;); } }); 现在不调用 subscribeOn() 方法，来看看打印结果： 05-26 10:40:42.246 21466-21466/? D/chan: ======================onSubscribe 05-26 10:40:42.247 21466-21466/? D/chan: =========================currentThread name: main ======================onNext 1 ======================onNext 2 ======================onNext 3 ======================onComplete 可以看到打印被观察者的线程名字是主线程。 接着调用 subscribeOn(Schedulers.newThread()) 来看看打印结果： 05-26 10:43:26.964 22530-22530/com.example.rxjavademo D/chan: ======================onSubscribe 05-26 10:43:26.966 22530-22569/com.example.rxjavademo D/chan: =========================currentThread name: RxNewThreadScheduler-1 05-26 10:43:26.967 22530-22569/com.example.rxjavademo D/chan: ======================onNext 1 ======================onNext 2 ======================onNext 3 ======================onComplete 可以看到打印结果被观察者是在一条新的线程。 现在看看多次调用会不会有效，代码如下： Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName()); e.onNext(1); e.onNext(2); e.onNext(3); e.onComplete(); } }) .subscribeOn(Schedulers.computation()) .subscribeOn(Schedulers.newThread()) .subscribe(new Observer &lt; Integer &gt; () {@Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;======================onSubscribe&quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;======================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;======================onError&quot;); } @Override public void onComplete() { Log.d(TAG, &quot;======================onComplete&quot;); } }); 打印结果： 05-26 10:47:20.925 23590-23590/com.example.rxjavademo D/chan: ======================onSubscribe 05-26 10:47:20.930 23590-23629/com.example.rxjavademo D/chan: =========================currentThread name: RxComputationThreadPool-1 ======================onNext 1 ======================onNext 2 ======================onNext 3 ======================onComplete 可以看到第二次调动的 subscribeOn(Schedulers.newThread()) 并没有效果。 4.21 observeOn()方法预览：public final Observable&lt;T&gt; observeOn(Scheduler scheduler) 有什么用？指定观察者的线程，每指定一次就会生效一次。 怎么用？Observable.just(1, 2, 3) .observeOn(Schedulers.newThread()) .flatMap(new Function &lt; Integer, ObservableSource &lt; String &gt;&gt; () { @Override public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception { Log.d(TAG, &quot;======================flatMap Thread name &quot; + Thread.currentThread().getName()); return Observable.just(&quot;chan&quot; + integer); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer &lt; String &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;======================onSubscribe&quot;); } @Override public void onNext(String s) { Log.d(TAG, &quot;======================onNext Thread name &quot; + Thread.currentThread().getName()); Log.d(TAG, &quot;======================onNext &quot; + s); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;======================onError&quot;); } @Override public void onComplete() { Log.d(TAG, &quot;======================onComplete&quot;); } }); 打印结果： 05-26 10:58:04.593 25717-25717/com.example.rxjavademo D/chan: ======================onSubscribe 05-26 10:58:04.594 25717-25753/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler-1 05-26 10:58:04.595 25717-25753/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler-1 ======================flatMap Thread name RxNewThreadScheduler-1 05-26 10:58:04.617 25717-25717/com.example.rxjavademo D/chan: ======================onNext Thread name main ======================onNext chan1 ======================onNext Thread name main ======================onNext chan2 ======================onNext Thread name main ======================onNext chan3 05-26 10:58:04.618 25717-25717/com.example.rxjavademo D/chan: ======================onComplete 从打印结果可以知道，observeOn 成功切换了线程。 下表总结了 RxJava 中的调度器： 调度器 作用 Schedulers.computation( ) 用于使用计算任务，如事件循环和回调处理 Schedulers.immediate( ) 当前线程 Schedulers.io( ) 用于 IO 密集型任务，如果异步阻塞 IO 操作。 Schedulers.newThread( ) 创建一个新的线程 AndroidSchedulers.mainThread() Android 的 UI 线程，用于操作 UI。 5. 过滤操作符5.1 filter()方法预览：public final Observable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) 有什么用？通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。 怎么用？ Observable.just(1, 2, 3) .filter(new Predicate &lt; Integer &gt; () { @Override public boolean test(Integer integer) throws Exception { return integer &lt; 2; } }) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 以上代码只有小于2的事件才会发送，来看看打印结果： 05-24 22:57:32.562 12776-12776/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================onComplete 5.2 ofType()方法预览：public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz) 有什么用？可以过滤不符合该类型事件 怎么用？Observable.just(1, 2, 3, &quot;chan&quot;, &quot;zhide&quot;) .ofType(Integer.class) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-24 23:04:24.752 13229-13229/? D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 05-24 23:04:24.753 13229-13229/? D/chan: ==================onComplete 5.3 skip()方法预览：public final Observable&lt;T&gt; skip(long count) ....... 有什么用？跳过正序某些事件，count 代表跳过事件的数量 怎么用？Observable.just(1, 2, 3) .skip(2) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-24 23:13:50.448 13831-13831/? D/chan: ==================onSubscribe 05-24 23:13:50.449 13831-13831/? D/chan: ==================onNext 3 ==================onComplete skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件，这里就不再讲解了。 5.4 distinct()方法预览：public final Observable&lt;T&gt; distinct() 有什么用?过滤事件序列中的重复事件。 怎么用?Observable.just(1, 2, 3, 3, 2, 1) .distinct() .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果: 05-24 23:19:44.334 14206-14206/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onComplete 5.5 distinctUntilChanged()方法预览：public final Observable&lt;T&gt; distinctUntilChanged() 有什么用？过滤掉连续重复的事件 怎么用?Observable.just(1, 2, 3, 3, 2, 1) .distinctUntilChanged() .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果: 05-24 23:22:35.985 14424-14424/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onNext 2 ==================onNext 1 ==================onComplete 因为事件序列中连续出现两次3，所以第二次3并不会发出。 5.6 take()方法预览：public final Observable&lt;T&gt; take(long count) ...... 有什么用?控制观察者接收的事件的数量。 怎么用?Observable.just(1, 2, 3, 4, 5) .take(3) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;==================onSubscribe &quot;); } @Override public void onNext(Integer integer) { i += integer; Log.d(TAG, &quot;==================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;==================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;==================onComplete &quot;); } }); 打印结果： 05-24 23:28:32.899 14704-14704/? D/chan: ==================onSubscribe ==================onNext 1 ==================onNext 2 ==================onNext 3 ==================onComplete takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情，这里就不再讲解了，大家可以自己试试。 5.7 debounce()方法预览：public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit) ...... 有什么用？如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onNext(1); Thread.sleep(900); e.onNext(2); } }) .debounce(1, TimeUnit.SECONDS) .subscribe(new Observer &lt; Integer &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;===================onSubscribe &quot;); } @Override public void onNext(Integer integer) { Log.d(TAG, &quot;===================onNext &quot; + integer); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;===================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;===================onComplete &quot;); } }); 打印结果： 05-25 20:39:10.512 17441-17441/com.example.rxjavademo D/chan: ===================onSubscribe 05-25 20:39:12.413 17441-17478/com.example.rxjavademo D/chan: ===================onNext 2 可以看到事件1并没有发送出去，现在将间隔时间改为1000，看看打印结果： 05-25 20:42:10.874 18196-18196/com.example.rxjavademo D/chan: ===================onSubscribe 05-25 20:42:11.875 18196-18245/com.example.rxjavademo D/chan: ===================onNext 1 05-25 20:42:12.875 18196-18245/com.example.rxjavademo D/chan: ===================onNext 2 throttleWithTimeout() 与此方法的作用一样，这里就不再赘述了。 5.8 firstElement() &amp;&amp; lastElement()方法预览：public final Maybe&lt;T&gt; firstElement() public final Maybe&lt;T&gt; lastElement() 有什么用？firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。 怎么用？Observable.just(1, 2, 3, 4) .firstElement() .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;====================firstElement &quot; + integer); } }); Observable.just(1, 2, 3, 4) .lastElement() .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;====================lastElement &quot; + integer); } }); 打印结果： 05-25 20:47:22.189 19909-19909/? D/chan: ====================firstElement 1 ====================lastElement 4 5.9 elementAt() &amp; elementAtOrError()方法预览：public final Maybe&lt;T&gt; elementAt(long index) public final Single&lt;T&gt; elementAtOrError(long index) 有什么用？elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。 怎么用？Observable.just(1, 2, 3, 4) .elementAt(0) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;====================accept &quot; + integer); } }); 打印结果： 05-25 20:56:22.266 23346-23346/com.example.rxjavademo D/chan: ====================accept 1 将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。 替换 elementAt() 为 elementAtOrError()，代码如下： Observable.just(1, 2, 3, 4) .elementAtOrError(5) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;====================accept &quot; + integer); } }); 打印结果： io.reactivex.exceptions.OnErrorNotImplementedException at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java: 704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java: 701) at io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java: 47) at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onComplete(ObservableElementAtSingle.java: 117) at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java: 110) at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java: 36) at io.reactivex.Observable.subscribe(Observable.java: 10903) at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java: 37) at io.reactivex.Single.subscribe(Single.java: 2707) at io.reactivex.Single.subscribe(Single.java: 2693) at io.reactivex.Single.subscribe(Single.java: 2664) at com.example.rxjavademo.MainActivity.onCreate(MainActivity.java: 103) at android.app.Activity.performCreate(Activity.java: 6942) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java: 1126) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java: 2880) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java: 2988) at android.app.ActivityThread. - wrap14(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java: 1631) at android.os.Handler.dispatchMessage(Handler.java: 102) at android.os.Looper.loop(Looper.java: 154) at android.app.ActivityThread.main(ActivityThread.java: 6682) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: 1520) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java: 1410) Caused by: java.util.NoSuchElementException at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onComplete(ObservableElementAtSingle.java: 117) at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java: 110) at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java: 36) at io.reactivex.Observable.subscribe(Observable.java: 10903) at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java: 37) at io.reactivex.Single.subscribe(Single.java: 2707) at io.reactivex.Single.subscribe(Single.java: 2693) at io.reactivex.Single.subscribe(Single.java: 2664) at com.example.rxjavademo.MainActivity.onCreate(MainActivity.java: 103) at android.app.Activity.performCreate(Activity.java: 6942) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java: 1126) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java: 2880) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java: 2988) at android.app.ActivityThread. - wrap14(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java: 1631) at android.os.Handler.dispatchMessage(Handler.java: 102) at android.os.Looper.loop(Looper.java: 154) at android.app.ActivityThread.main(ActivityThread.java: 6682) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: 1520) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java: 1410) 这时候会抛出 NoSuchElementException 异常。 6. 条件操作符6.1 all()方法预览：public final Observable&lt;T&gt; ambWith(ObservableSource&lt;? extends T&gt; other) 有什么用？判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。 怎么用？Observable.just(1, 2, 3, 4) .all(new Predicate &lt; Integer &gt; () { @Override public boolean test(Integer integer) throws Exception { return integer &lt; 5; } }) .subscribe(new Consumer &lt; Boolean &gt; () { @Override public void accept(Boolean aBoolean) throws Exception { Log.d(TAG, &quot;==================aBoolean &quot; + aBoolean); } }); 打印结果： 05-26 09:39:51.644 1482-1482/com.example.rxjavademo D/chan: ==================aBoolean true 6.2 takeWhile()方法预览：public final Observable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) 有什么用？可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送。 怎么用？Observable.just(1, 2, 3, 4) .takeWhile(new Predicate &lt; Integer &gt; () { @Override public boolean test(Integer integer) throws Exception { return integer &lt; 3; } }) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;========================integer &quot; + integer); } }); 打印结果： 05-26 09:43:14.634 3648-3648/com.example.rxjavademo D/chan: ========================integer 1 ========================integer 2 6.3 skipWhile()方法预览：public final Observable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate) 有什么用？可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。 怎么用？Observable.just(1, 2, 3, 4) .skipWhile(new Predicate &lt; Integer &gt; () { @Override public boolean test(Integer integer) throws Exception { return integer &lt; 3; } }) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;========================integer &quot; + integer); } }); 打印结果： 05-26 09:47:32.653 4861-4861/com.example.rxjavademo D/chan: ========================integer 3 ========================integer 4 6.4 takeUntil()方法预览：public final Observable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate 有什么用？可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。 怎么用？Observable.just(1, 2, 3, 4, 5, 6) .takeUntil(new Predicate &lt; Integer &gt; () { @Override public boolean test(Integer integer) throws Exception { return integer &gt; 3; } }) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;========================integer &quot; + integer); } }); 打印结果： 05-26 09:55:12.918 7933-7933/com.example.rxjavademo D/chan: ========================integer 1 ========================integer 2 05-26 09:55:12.919 7933-7933/com.example.rxjavademo D/chan: ========================integer 3 ========================integer 4 6.5 skipUntil()方法预览：public final &lt;U&gt; Observable&lt;T&gt; skipUntil(ObservableSource&lt;U&gt; other) 有什么用？当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。 怎么用？Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS) .skipUntil(Observable.intervalRange(6, 5, 3, 1, TimeUnit.SECONDS)) .subscribe(new Observer &lt; Long &gt; () { @Override public void onSubscribe(Disposable d) { Log.d(TAG, &quot;========================onSubscribe &quot;); } @Override public void onNext(Long along) { Log.d(TAG, &quot;========================onNext &quot; + along); } @Override public void onError(Throwable e) { Log.d(TAG, &quot;========================onError &quot;); } @Override public void onComplete() { Log.d(TAG, &quot;========================onComplete &quot;); } }); 打印结果： 05-26 10:08:50.574 13023-13023/com.example.rxjavademo D/chan: ========================onSubscribe 05-26 10:08:53.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 4 05-26 10:08:54.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 5 ========================onComplete 从结果可以看出，skipUntil() 里的 Observable 并不会发送事件给观察者。 6.6 sequenceEqual()方法预览：public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2) ...... 有什么用？判断两个 Observable 发送的事件是否相同。 怎么用？Observable.sequenceEqual(Observable.just(1, 2, 3), Observable.just(1, 2, 3)) .subscribe(new Consumer &lt; Boolean &gt; () { @Override public void accept(Boolean aBoolean) throws Exception { Log.d(TAG, &quot;========================onNext &quot; + aBoolean); } }); 打印结果： 05-26 10:11:45.975 14157-14157/? D/chan: ========================onNext true 6.7 contains()方法预览：public final Single&lt;Boolean&gt; contains(final Object element) 有什么用？判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。 怎么用？Observable.just(1, 2, 3) .contains(3) .subscribe(new Consumer &lt; Boolean &gt; () { @Override public void accept(Boolean aBoolean) throws Exception { Log.d(TAG, &quot;========================onNext &quot; + aBoolean); } }); 打印结果： 05-26 10:14:23.522 15085-15085/com.example.rxjavademo D/chan: ========================onNext true 6.8 isEmpty()方法预览：public final Single&lt;Boolean&gt; isEmpty() 有什么用？判断事件序列是否为空。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onComplete(); } }) .isEmpty() .subscribe(new Consumer &lt; Boolean &gt; () { @Override public void accept(Boolean aBoolean) throws Exception { Log.d(TAG, &quot;========================onNext &quot; + aBoolean); } }); 打印结果： 05-26 10:17:16.725 16109-16109/com.example.rxjavademo D/chan: ========================onNext true 6.9 amb()方法预览：public static &lt;T&gt; Observable&lt;T&gt; amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources) 有什么用？amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃。 怎么用？ArrayList &lt; Observable &lt; Long &gt;&gt; list = new ArrayList &lt; &gt; (); list.add(Observable.intervalRange(1, 5, 2, 1, TimeUnit.SECONDS)); list.add(Observable.intervalRange(6, 5, 0, 1, TimeUnit.SECONDS)); Observable.amb(list) .subscribe(new Consumer &lt; Long &gt; () { @Override public void accept(Long aLong) throws Exception { Log.d(TAG, &quot;========================aLong &quot; + aLong); } }); 打印结果： 05-26 10:21:29.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 6 05-26 10:21:30.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 7 05-26 10:21:31.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 8 05-26 10:21:32.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 9 05-26 10:21:33.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 10 6.10 defaultIfEmpty()方法预览：public final Observable&lt;T&gt; defaultIfEmpty(T defaultItem) 有什么用？如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值。 怎么用？Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () { @Override public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception { e.onComplete(); } }) .defaultIfEmpty(666) .subscribe(new Consumer &lt; Integer &gt; () { @Override public void accept(Integer integer) throws Exception { Log.d(TAG, &quot;========================onNext &quot; + integer); } }); 打印结果： 05-26 10:26:56.376 19249-19249/com.example.rxjavademo D/chan: ========================onNext 666 RxJava 常见的使用方式都已经介绍的差不多，相信大家如果都掌握这些操作符的用法的话，那么使用 RxJava 将不会再是难题了。","categories":[],"tags":[]},{"title":"一文彻底了解Android自定义控件3","slug":"一文彻底了解Android自定义控件3","date":"2020-06-11T21:37:27.000Z","updated":"2020-06-13T20:45:10.590Z","comments":true,"path":"2020/06/12/view3/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/view3/","excerpt":"Android自定控件的步骤为什么自定义控件要步骤化呢？因为很多新手同学，根据产品的要求做一些控件时，无从下手。 有了步骤以后，就可以按套路走了，再也不用害怕了。","text":"Android自定控件的步骤为什么自定义控件要步骤化呢？因为很多新手同学，根据产品的要求做一些控件时，无从下手。 有了步骤以后，就可以按套路走了，再也不用害怕了。 判断控件类型首先我们要判断这个控件是属于自定义控件里的哪种类型，如果不知道分类的话，同学们可以看这篇文章自定义控件分类 获取相关的属性其实这玩意在自定义控件里叫自定义属性。什么是属性呢？ 来我们看，android控件原有的属性： 比如说我们的LinearLayout &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginBottom=&quot;41px&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;/LinearLayout&gt;这里面的属性就有origintation,layout_width,layout_height…. 而origintation是LinearLayout特有的，而其他的则是View都有的 那么我们在写自己的控件时，有些值，也是通过xml里的属性进行配置的，所以我们要有自定义属性。 自定义控件里如何自定义属性呢？ 自定义属性步骤： 声明属性 在res的values目录下的attrs.xml文件中(没有就自己新建一个)，使用declare-styleable标签自定义属性。 在attrs.xml里进行声明，其实都行，都是resourse，举例： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;!--属性集合--&gt; &lt;declare-styleable name=&quot;SearchView&quot; &gt; &lt;!--hint--&gt; &lt;attr name=&quot;hint&quot; format=&quot;string&quot;/&gt; &lt;!--搜索图标 可以通过typedArray.getResourceId获取资源id--&gt; &lt;attr name=&quot;search_ico&quot; format=&quot;reference&quot; /&gt; &lt;!--清空图标--&gt; &lt;attr name=&quot;clear_ico&quot; format=&quot;reference&quot; /&gt; &lt;!--语音图标--&gt; &lt;attr name=&quot;voice_ico&quot; format=&quot;reference&quot; /&gt; &lt;!--输入类型--&gt; &lt;attr name=&quot;input_type&quot;&gt; &lt;!--value值只能是int类型的 所以获取时通过typeArray.getInt获取--&gt; &lt;enum name=&quot;text&quot; value=&quot;0&quot;/&gt; &lt;enum name=&quot;passwordText&quot; value=&quot;1&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;gravity&quot;&gt; &lt;!--区别于enum enum只能选择一个 flag可以多选 如：left|top--&gt; &lt;flag name=&quot;left&quot; value=&quot;0&quot; /&gt; &lt;flag name=&quot;top&quot; value=&quot;1&quot; /&gt; &lt;flag name=&quot;center&quot; value=&quot;2&quot; /&gt; &lt;flag name=&quot;right&quot; value=&quot;3&quot; /&gt; &lt;flag name=&quot;bottom&quot; value=&quot;4&quot; /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; &lt;/resources&gt;其中declare-styleable标签代表一个属性集合，name属性要与自定义的控件同名。 attr则是每条属性了，name是属性值，format是指定属性类型,目前可支持11种类型： reference:引用资源 string:字符串 Color：颜色 boolean：布尔值 dimension：尺寸值 float：浮点型 integer：整型 fraction：百分数 enum：枚举类型 flag：位或运算 布局文件中使用 首先需要加上一个命名空间xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; 然后直接利用这个命名空间设置属性即可 &lt;com.searchview.SearchView android:id=&quot;@+id/searchView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_marginEnd=&quot;8dp&quot; android:layout_marginStart=&quot;8dp&quot; android:layout_marginTop=&quot;8dp&quot; app:hint=&quot;aaa&quot; app:search_ico=&quot;@drawable/ic_search&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;测量测量是重点要掌握的，如果是ViewGroup则测量自己(设置自己大小，因为ViewGroup也可以是子view呀)跟设置期望孩子的大小。 如果是View则需要测量自己（设置自己大小） 这两个参数要理解 自定义控件的本质","categories":[],"tags":[]},{"title":"一文彻底了解Android自定义控件2","slug":"一文彻底了解Android自定义控件2","date":"2020-06-11T21:37:19.000Z","updated":"2020-06-13T20:44:54.631Z","comments":true,"path":"2020/06/12/view2/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/view2/","excerpt":"经过前面对Android自定义控件初步了解以后，我们接下来就在前面的基础上更加深入了解所谓的Android自定义控件！ AndroidView体系在学习自定义控件之前，我们先了解一下Android的View体系","text":"经过前面对Android自定义控件初步了解以后，我们接下来就在前面的基础上更加深入了解所谓的Android自定义控件！ AndroidView体系在学习自定义控件之前，我们先了解一下Android的View体系 打开Android Studio –&gt; ctrl+N –&gt; 输入View 这样子，我们就找到了View这个类了！ View的继承关系进到View这个类里， 选中类名，按ctrl+H，显示类的继承关系： 我们可以看到一些熟悉的控件，比如说ProgressBar,ImageView,TextView 所以我们得到如下的继承关系: 继续打开ViewGroup 所以我们是又可以得到以下这张关系转图： View和ViewGrop的区别先看ViewGroup，就是View组的意思是吧！也就是说，ViewGrop里面有很多子View，用于管理/摆放子View的View就叫ViewGroup。 什么是View呢？严格上来说，都是View，为什么呢？有了前面的定义，ViewGroup里面的全是View，因为你是View-Group呀！而ViewGrop里也可以方ViewGrop，所以说，ViewGroup也可以认为是View。比如说LinearLayout里面还可以放LinearLayout吧！ 但是通常来说，我们说自定义View指的是定那些需要自己绘制的控件，重点是绘制，比如说时钟呀，波浪效果这些…View里面不再摆放其他的子View，我们把这种称为View 而ViewGroup，则是用于控制View的摆放，比如说LinearLayout，让子View成线性摆放，RelativeLayout让子View以相对的位置进行摆放.. 总结对于Android的View体系，了解继承关系，知道怎么区分是View，什么是ViewGroup即可。View注重的是绘制内容，ViewGropu注重子View的摆放。 有了这些基础知识，我们后面写自定义控件就可以步骤化了。第一步就是要判断你写的这个控件属于ViewGrop还是View.","categories":[],"tags":[]},{"title":"一文彻底了解Android自定义控件1","slug":"一文彻底了解Android自定义控件1","date":"2020-06-11T21:37:09.000Z","updated":"2020-06-13T20:44:41.992Z","comments":true,"path":"2020/06/12/view1/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/view1/","excerpt":"AndroidView体系了解android的View体系，才知道后面我们步骤写Android自定义控件做准备。 要明白View和ViewGroup。 要能判断常用的控件是属于View还是ViewGrop，接着才有自己要写的控件属于View还是ViewGroup。 为什么呢？ 因为自定义View跟自定义ViewGroup的步骤，套路不一样。","text":"AndroidView体系了解android的View体系，才知道后面我们步骤写Android自定义控件做准备。 要明白View和ViewGroup。 要能判断常用的控件是属于View还是ViewGrop，接着才有自己要写的控件属于View还是ViewGroup。 为什么呢？ 因为自定义View跟自定义ViewGroup的步骤，套路不一样。 Android自定义控件类型Android自定义控件呢，我们可以分为三类： 自定义View（包括对现有View的修改）; 自定义ViewGrop（包括对现有ViewGroup的修改）; 自定义ViewGrop; 自定义组合控件例子自定义组合控件，其实就是把多个现在有控件整合在一起，把复杂的操作封装起来，把简单的操作暴露出去。 比如说我们要做以下这个控件： 当然可以重头开始绘制，从无到有。 我们也可以使用两个button + 一个TextView或者EditText组合起来。 然后把复杂的逻辑封装起来，比如说，上限和下限的判断，比如说增加梯度，比如说阀值，达到一定的值会改变颜色之类的。这些复杂的操作封装起来。对外只暴露数据变会的回调通知和设置数值/获取数值的方法即可。 别人拿到你的控件，不关心怎么实现，只关心使用即可。 自定义View例子自定义View，什么是View，从控件的角度来理解，我们可以这样判断。如果控件里没有孩子的，没有子View的，就是View，比如说Button,TextView,ProgressBar,ImageView,这些都是View. 自定义ViewGroup例子自定义ViewGrop，什么是ViewGroup,用来包含孩子的，控制子View的摆放的，是容器。ViewGrop里还可以包含着ViewGroup和View。比如说，LinearLayout,RetiveLayout,RecyclerView,ListView,ViewPager…这些都是ViewGrop。","categories":[],"tags":[]},{"title":"Android 复杂的列表视图新写法 MultiType","slug":"Android-复杂的列表视图新写法-MultiType","date":"2020-06-11T19:57:58.000Z","updated":"2020-06-11T20:20:32.405Z","comments":true,"path":"2020/06/12/multitype/","link":"","permalink":"https://jiyugithub.github.io/2020/06/12/multitype/","excerpt":"Android 复杂的列视图新写法 MultiType前言在开发我的 TimeMachine 时，我有一个复杂的聊天页面，于是我设计了我的类型池系统，它是完全解耦的，因此我能够轻松将它抽离出来分享，并给它取名为 MultiType.","text":"Android 复杂的列视图新写法 MultiType前言在开发我的 TimeMachine 时，我有一个复杂的聊天页面，于是我设计了我的类型池系统，它是完全解耦的，因此我能够轻松将它抽离出来分享，并给它取名为 MultiType. 从前，比如我们写一个类似微博列表页面，这样的列表是十分复杂的：有纯文本的、带转发原文的、带图片的、带视频的、带文章的等等，甚至穿插一条可以横向滑动的好友推荐条目。不同的 item 类型众多，而且随着业务发展，还会更多。如果我们使用传统的开发方式，经常要做一些繁琐的工作，代码可能都堆积在一个 Adapter 中：我们需要覆写 RecyclerView.Adapter 的 getItemViewType 方法，罗列一些 type 整型常量，并且 ViewHolder 转型、绑定数据也比较麻烦。一旦产品需求有变，或者产品设计说需要增加一种新的 item 类型，我们需要去代码堆里找到原来的逻辑去修改，或找到正确的位置去增加代码。这些过程都比较繁琐，侵入较强，需要小心翼翼，以免改错影响到其他地方。 现在好了，我们有了 MultiType，简单来说，MultiType 就是一个多类型列表视图的中间分发框架，它能帮助你快速并且清晰地开发一些复杂的列表页面。 它本是为聊天页面开发的，聊天页面的消息类型也是有大量不同种类，且新增频繁，而 MultiType 能够轻松胜任。 MultiType 以灵活直观为第一宗旨进行设计，它内建了 类型 - View 的复用池系统，支持 RecyclerView，随时可拓展新的类型进入列表当中，使用简单，令代码清晰、模块化、灵活可变。 因此，我写了这篇文章，目的有几个：一是以作者的角度对 MultiType 进行入门和进阶详解。二是传递我开发过程中的思想、设计理念，这些偏细腻的内容，即使不使用 MultiType，想必也能带来很多启发。最后就是把自我觉得不错的东西分享给大家，试想如果你制造的东西很多人在用，即使没有带来任何收益，也是一件很自豪的事情。 MultiType 的特性 轻盈，整个类库只有 14 个类文件，aar 或 jar 包大小只有 13 KB 周到，支持 data type &lt;--&gt; item view binder 之间 一对一 和 一对多 的关系绑定 灵活，几乎所有的部件(类)都可被替换、可继承定制，面向接口 / 抽象编程 纯粹，只负责本分工作，专注多类型的列表视图 类型分发，绝不会去影响 views 的内容或行为 高效，没有性能损失，内存友好，最大限度发挥 RecyclerView 的复用性 可读，代码清晰干净、设计精巧，极力避免复杂化，可读性很好，为拓展和自行解决问题提供了基础 总览MultiType 能轻松实现如下页面，它们将在示例篇章具体提供: MultiType 的源码关系： MultiType 基础用法可能有的新手看到以上特性介绍说什么 “一对多”、抽象编程等等，都不太懂，我想说完全不要紧，不懂可以回过头来再看，我们先从基础用法入手，其实 MultiType 使用起来特别简单。使用 MultiType 一般情况下只要 maven 引入 + 三个小步骤。之后还会介绍使用插件生成代码方式，步骤将更加简化： 引入在你的 build.gradle: dependencies { compile &#39;me.drakeet.multitype:multitype:3.0.0&#39; } 注：MultiType 内部引用了 recyclerview-v7:25.3.1，如果你不想使用这个版本，可以使用 exclude 将它排除掉，再自行引入你选择的版本。示例如下： dependencies { compile(&#39;me.drakeet.multitype:multitype:3.0.0&#39;, { exclude group: &#39;com.android.support&#39; }) compile &#39;com.android.support:recyclerview-v7:你选择的版本&#39; }使用Step 1. 创建一个 class，它将是你的数据类型或 Java bean / model. 对这个类的内容没有任何限制。示例如下： public class Category { @NonNull public final String text; public Category(@NonNull String text) { this.text = text; } }Step 2. 创建一个 class 继承 ItemViewBinder. ItemViewBinder 是个抽象类，其中 onCreateViewHolder 方法用于生产你的 Item View Holder, onBindViewHolder 用于绑定数据到 Views. 一般一个 ItemViewBinder 类在内存中只会有一个实例对象，MultiType 内部将复用这个 binder 对象来生产所有相关的 item views 和绑定数据。示例： public class CategoryViewBinder extends ItemViewBinder&lt;Category, CategoryViewBinder.ViewHolder&gt; { @NonNull @Override protected ViewHolder onCreateViewHolder(@NonNull LayoutInflater inflater, @NonNull ViewGroup parent) { View root = inflater.inflate(R.layout.item_category, parent, false); return new ViewHolder(root); } @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull Category category) { holder.category.setText(category.text); } static class ViewHolder extends RecyclerView.ViewHolder { @NonNull private final TextView category; ViewHolder(@NonNull View itemView) { super(itemView); this.category = (TextView) itemView.findViewById(R.id.category); } } }Step 3. 在 Activity 中加入 RecyclerView 和 List 并注册你的类型，示例： public class MainActivity extends AppCompatActivity { private MultiTypeAdapter adapter; /* Items 等同于 ArrayList&lt;Object&gt; */ private Items items; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.list); adapter = new MultiTypeAdapter(); /* 注册类型和 View 的对应关系 */ adapter.register(Category.class, new CategoryViewBinder()); adapter.register(Song.class, new SongViewBinder()); recyclerView.setAdapter(adapter); /* 模拟加载数据，也可以稍后再加载，然后使用 * adapter.notifyDataSetChanged() 刷新列表 */ items = new Items(); for (int i = 0; i &lt; 20; i++) { items.add(new Category(&quot;Songs&quot;)); items.add(new Song(&quot;小艾大人&quot;, R.drawable.avatar_dakeet)); items.add(new Song(&quot;许岑&quot;, R.drawable.avatar_cen)); } adapter.setItems(items); adapter.notifyDataSetChanged(); } }大功告成！这就是 MultiType 的基础用法了。其中 onCreateViewHolder 和 onBindViewHolder 方法名沿袭了使用 RecyclerView 的习惯，令人一目了然，减少了新人的学习成本。 设计思想MultiType 设计伊始，我给它定了几个原则： 要简单，便于他人阅读代码 因此我极力避免将它复杂化，避免加入许多不相干的内容。我想写人人可读的代码，使用简单的方式，去实现复杂的需求。过多不相干、没必要的代码，将会使项目变得令人晕头转向，难以阅读，遇到需要定制、解决问题的时候，无从下手。 要灵活，便于拓展和适应各种需求 很多人会得意地告诉我，他们把 MultiType 源码精简成三四个类，甚至一个类，以为代码越少就是越好，这我不能赞同。MultiType 考虑得更远，这是一个提供给大众使用的类库，过度的精简只会使得大幅失去灵活性。它或许不是使用起来最简单的，但很可能是使用起来最灵活的。 在我看来，”直观”、”灵活”优先级大于”简单”。因此，MultiType 以接口或抽象进行连接，这意味着它的角色、组件都可以被替换，或者被拓展和继承。如果你觉得它使用起来还不够简单，完全可以通过继承封装出更具体符合你使用需求的方法。它已经暴露了足够丰富、周到的接口以供拓展，我们不应该直接去修改源码，这会导致一旦后续发现你的精简版满足不了你的需求时，已经没有回头路了。 要直观，使用起来能令项目代码更清晰可读，一目了然 MultiType 提供的 ItemViewBinder 沿袭了 RecyclerView Adapter 的接口命名，使用起来更加舒适，符合习惯。另外，MultiType 很多地方放弃使用反射而是让用户显式指明一些关系，如：MultiTypeAdapter#register 方法，需要传递一个数据模型 class 和 ItemViewBinder 对象，虽然有很多方法可以把它精简成单一参数方法，但我们认为显式声明数据模型类与对应关系，更具直观。 高级用法介绍了基础用法和设计思想后，我们可以来介绍一下 MultiType 的高级用法。这是一些典型需求和案例，它们是基础用法的延伸，也是设计思想的体现。也许一开始并不会使用到，但如若了解，能够拓宽使用 MultiType 的思路，也能过了解到我们考虑问题的角度。 使用 MultiTypeTemplates 插件自动生成代码在基础用法中，我们了通过 3 个步骤完成 MultiType 的初次接入使用，实际上这个过程可以更加简化，MultiType 提供了 Android Studio 插件来自动生成代码： MultiTypeTemplates，源码也是开源的，https://github.com/drakeet/MultiTypeTemplates。这个插件不仅提供了一键生成 item 类文件和 ItemViewBinder，而且是一个很好的利用代码模版自动生成代码的示例。其中使用到了官方提供的代码模版 API，也用到了我自己发明的更灵活修改模版内容的方法，有兴趣做这方面插件的可以看看。 话说回来，安装和使用 MultiTypeTemplates 非常简单： Step 1. 打开 Android Studio 的设置 -&gt; Plugin -&gt; Browse repositories，搜索 MultiTypeTemplates 即可获得下载安装： Step 2. 安装完成后，重启 Android Studio. 右键点击你的 package，选择 New -&gt; MultiType Item，然后输入你的 item 名字，它就会自动生成 item 模型类 和 ItemViewBinder 文件和代码。 比如你输入的是 “Category”，它就会自动生成 Category.java 和 CategoryViewBinder.java. 特别方便，相信你会很喜欢它。未来这个插件也将会支持自动生成布局文件，这是目前欠缺的，但不要紧，其实 AS 在这方面已经很方便了，对布局 R.layout.item_category 使用 alt + enter 快捷键即可自动生成布局文件。 一个类型对应多个 ItemViewBinderMultiType 天然支持一个类型对应多个 ItemViewBinder，注册方式也很简单，如下： adapter.register(Data.class).to( new DataType1ViewBinder(), new DataType2ViewBinder() ).withClassLinker(new ClassLinker&lt;Data&gt;() { @NonNull @Override public Class&lt;? extends ItemViewBinder&lt;Data, ?&gt;&gt; index(@NonNull Data data) { if (data.type == Data.TYPE_2) { return DataType2ViewBinder.class; } else { return DataType1ViewBinder.class; } } });或者： adapter.register(Data.class).to( new DataType1ViewBinder(), new DataType2ViewBinder() ).withLinker(new Linker&lt;Data&gt;() { @Override public int index(@NonNull Data data) { if (data.type == Data.TYPE_2) { return 1; } else return 0; } });如果你使用 Lambda 表达式，以上代码可以更简洁： 解释： 如上示例代码，对于一对多，我们需要使用 MultiType#register(class) 方法，它会返回一个 OneToManyFlow 让你紧接着绑定多个 ItemViewBinder 实例，最后再调用 OneToManyEndpoint#withLinker 或 OneToManyEndpoint#withClassLinker 操作符方法类设置 linker. 所谓 linker，是负责动态连接这个 “一” 对应 “多” 中哪一个 binder 的角色。 这个方案具有很好的性能表现，而且可谓十分直观。另外，我使用了 @CheckResult 注解来让编译器督促开发者一定要完整调用方法链才不至于出错。 更详细的”一对多”示例可以参考我的 sample 源码 使用 全局类型池MultiType 在 3.0 版本之前一直是支持全局类型池的，你可以往一个全局类型池中 register 类型和 view binder，然后让你的各个 MultiTypeAdapter 都能使用它。 但在 MultiType 3.0 之后，我们废弃并删除了内置的全局类型池。原因在于全局类型池容易对全局产生不可见影响，比如你注册了一堆全局类型关系并在多处引用它，某一天你的伙伴不小心修改了全局类型池的某个内容，将导致所有使用的地方皆受到变化，是我们不希望发生的。一个好的模块，应该是高内聚、自包含的，如果过多下放权力到外围，很容易遭受破坏或影响。 另外，全局类型池一般都是 static 形式的，如果我们给这个 static 容器传递了 Activity 或 Context 对象，而没有在退出时释放，就容易造出内存泄漏，这对新手来说很容易触犯。 因此我们删除了内置的全局类型池，当你创建一个 MultiTypeAdapter 对象时，默认情况下，它内部会自动创建一个局部类型池以供你接下来注册类型。当然了，如果你实在需要它，完全可以自己创建一个 static 的 MultiTypePool，然后通过 MultiTypeAdapter#registerAll(pool) 将这个类型池传入，以此达到多个地方共同使用。 与 ItemViewBinder 通讯ItemViewBinder 对象可以接受外部类型、回调函数，只要在使用之前，传递进去即可，例如： OnClickListener listener = new OnClickListener() { @Override public void onClick(View v) { // ... } } adapter.register(Post.class, new PostViewBinder(xxx, listener));但话说回来，对于点击事件，能不依赖 binder 外部内容的话，最好就在 binder 内部完成。binder 内部能够拿到 Views 和 数据，大部分情况下，完全有能力不依赖外部 独立完成逻辑。这样能使代码更加模块化，实现解耦和内聚。例如下面便是一个完全自包含的例子： public class SquareViewBinder extends ItemViewBinder&lt;Square, SquareViewBinder.ViewHolder&gt; { @NonNull @Override protected ViewHolder onCreateViewHolder( @NonNull LayoutInflater inflater, @NonNull ViewGroup parent) { View root = inflater.inflate(R.layout.item_square, parent, false); return new ViewHolder(root); } @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull Square square) { holder.square = square; holder.squareView.setText(valueOf(square.number)); holder.squareView.setSelected(square.isSelected); } public class ViewHolder extends RecyclerView.ViewHolder { private TextView squareView; private Square square; ViewHolder(final View itemView) { super(itemView); squareView = (TextView) itemView.findViewById(R.id.square); itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { itemView.setSelected(square.isSelected = !square.isSelected); } }); } } }使用断言，比传统 Adapter 更加易于调试众所周知，如果一个传统的 RecyclerView Adapter 内部有异常导致崩溃，它的异常栈是不会指向到你的 Activity，这给我们开发调试过程中带来了麻烦。如果我们的 Adapter 是复用的，就不知道是哪一个页面崩溃。而对于 MultiTypeAdapter，我们显然要用于多个地方，而且可能出现开发者忘记注册类型等等问题。为了便于调试，开发期快速失败，MultiType 提供了很方便的断言 API: MultiTypeAsserts，使用方式如下： import static me.drakeet.multitype.MultiTypeAsserts.assertAllRegistered; import static me.drakeet.multitype.MultiTypeAsserts.assertHasTheSameAdapter; public class SimpleActivity extends MenuBaseActivity { private Items items; private MultiTypeAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.list); items = new Items(); adapter = new MultiTypeAdapter(items); adapter.register(TextItem.class, new TextItemViewBinder()); for (int i = 0; i &lt; 20; i++) { items.add(new TextItem(valueOf(i))); } /* 断言所有使用的类型都已注册 */ assertAllRegistered(adapter, items); recyclerView.setAdapter(adapter); /* 断言 recyclerView 使用的是正确的 adapter */ assertHasTheSameAdapter(recyclerView, adapter); } }assertAllRegistered 和 assertHasTheSameAdapter 都是可选择性使用，assertAllRegistered 需要在加载或更新数据之后， assertHasTheSameAdapter 必须在 recyclerView.setAdapter(adapter) 之后。 这样做以后，MultiTypeAdapter 相关的异常都会报到你的 Activity，并且会详细注明出错的原因，而如果符合断言，断言代码不会有任何副作用或影响你的代码逻辑，这时你可以把它当作废话。关于这个类的源代码是很简单的，有兴趣可以直接看看源码：drakeet/multitype/MultiTypeAsserts.java 支持 Google AutoValueAutoValue 是 Google 提供的一个在 Java 实体类中自动生成代码的类库，使你更专注于处理项目的其他逻辑，它可使代码更少，更干净，以及更少的 bug. 当我们使用传统方式创建一个 Java 模型类的时候，经常需要写一堆 toString()、hashCode()、getter、setter 等等方法，而且对于 Android 开发，大多情况下还需要实现 Parcelable 接口。这样的结果是，我本来想要一个只有几个属性的小模型类，但出于各种原因，这个模型类方法数变得十分繁复，阅读起来很不清爽，并且难免会写错内容。AutoValue 的出现解决了这个问题，我们只需定义一些抽象类交给 AutoValue，AutoValue 会自动生成该抽象类的具体实现子类，并携带各种样板代码。 更详细的介绍内容和使用教程，我会在文章末尾会给出 AutoValue 的相关链接，不熟悉 AutoValue 可以借此机会看一下，在这里就不做过多介绍了。新手暂时看不懂也不必纠结，了解之后都是十分容易的。 MultiType 支持了 Google AutoValue，支持自动映射某个已经注册的类型的子类到同一 ItemViewBinder，规则是：如果子类有注册，就用注册的映射关系；如果子类没注册，则该子类对象使用注册过的父类映射关系。 FlatTypeAdapter(已废弃)MultiType 3.0 之前提供了一个 FlatTypeAdapter 类，3.0 之后，这个类已经被删除了，你可以完全不必关心它。如果你使用过它，现在它已经被一对多方案替代了，请转成使用一对多功能实现。 MultiType 与下拉刷新、加载更多、HeaderView、FooterView、DiffMultiType 设计从始至终，都极力避免往复杂化方向发展，一开始我的设计宗旨就是它应该是一个非常纯粹的、专一的项目，而非各种乱七八糟的功能都要囊括进来的多合一大型库，因此它很克制，期间有许多人给我发过一些无关特性的 Pull Request，表示感谢，但全被拒绝了。 对于很多人关心的 下拉刷新、加载更多、HeaderView、FooterView、Diff 这些功能特性，其实都不应该是 MultiType 的范畴，MultiType 的分内之事是做类型、事件与 View 的分发、连接工作，其余无关的需求，都是可以在 MultiType 外部完成，或者通过继承 进行自行封装和拓展，而作为一个基础、公共类库，我想它是不应该包含这些内容。 但很多新手可能并不习惯代码分工、模块化，因此在此我有必要对这几个点简单示范下如何在 MultiType 之外去实现： 下拉刷新： 对于下拉刷新，Android 官方提供了 support.v4 SwipeRefreshLayout，在 Activity 层面，可以拿到 SwipeRefreshLayout 调用 setOnRefreshListener 设置监听器即可. 或者参考我的 rebase-android 项目编写的 SwipeRefreshDelegate.java. 加载更多： RecyclerView 提供了 addOnScrollListener 滚动位置变化监听，要实现加载更多，只要监听并检测列表是否滚动到底部即可，有多种方式，鉴于 LayoutManager 本应该只做布局相关的事务，因此我们推荐直接在 OnScrollListener 层面进行判断。提供一个简单版 OnScrollListener 继承类： public abstract class OnLoadMoreListener extends RecyclerView.OnScrollListener { private LinearLayoutManager layoutManager; private int itemCount, lastPosition, lastItemCount; public abstract void onLoadMore(); @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (recyclerView.getLayoutManager() instanceof LinearLayoutManager) { layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); itemCount = layoutManager.getItemCount(); lastPosition = layoutManager.findLastCompletelyVisibleItemPosition(); } else { Log.e(&quot;OnLoadMoreListener&quot;, &quot;The OnLoadMoreListener only support LinearLayoutManager&quot;); return; } if (lastItemCount != itemCount &amp;&amp; lastPosition == itemCount - 1) { lastItemCount = itemCount; this.onLoadMore(); } } }或者参考我的 rebase-android 项目编写的 LoadMoreDelegate.java. 获取数据后做 Diff 更新： MultiType 支持 onBindViewHolder with payloads，详情见 ItemViewBinder 类文档。对于 Diff，可以在 Activity 中进行 Diff，或者继承 MultiTypeAdapter 提供接收数据方法，在方法中进行 Diff. MultiType 不提供内置 Diff 方案，不然需要依赖 v4 包，并且这也不应该属于它的范畴。 示例代码：https://github.com/drakeet/MultiType/issues/56 HeaderView、FooterView MultiType 其实本身就支持 HeaderView、FooterView，只要创建一个 Header.class - HeaderViewBinder 和 Footer.class - FooterViewBinder 即可，然后把 new Header() 添加到 items 第一个位置，把 new Footer() 添加到 items 最后一个位置。需要注意的是，如果使用了 Footer View，在底部插入数据的时候，需要添加到 最后位置 - 1，即倒二个位置，或者把 Footer remove 掉，再添加数据，最后再插入一个新的 Footer. 实现 RecyclerView 嵌套横向 RecyclerViewMultiType 天生就适合实现类似 Google Play 或 iOS App Store 那样复杂的首页列表，这种页面通常会在垂直列表中嵌套横向列表，其实横向列表我们完全可以把它视为一种 Item 类型，这个 item 持有一个列表数据和当前横向列表滑动到的位置，类似这样： public class PostList { public final List&lt;Post&gt; posts; public int currentPosition; public PostList(@NonNull List&lt;Post&gt; posts) {this.posts = posts;} }对应的 HorizontalItemViewBinder 类似这样： public class HorizontalItemViewBinder extends ItemViewBinder&lt;PostList, HorizontalItemViewBinder.ViewHolder&gt; { @NonNull @Override protected ViewHolder onCreateViewHolder( @NonNull LayoutInflater inflater, @NonNull ViewGroup parent) { /* item_horizontal_list 就是一个只有 RecyclerView 的布局 */ View view = inflater.inflate(R.layout.item_horizontal_list, parent, false); return new ViewHolder(view); } @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull PostList postList) { holder.setPosts(postList.posts); } static class ViewHolder extends RecyclerView.ViewHolder { private RecyclerView recyclerView; private PostsAdapter adapter; private ViewHolder(@NonNull View itemView) { super(itemView); recyclerView = (RecyclerView) itemView.findViewById(R.id.post_list); LinearLayoutManager layoutManager = new LinearLayoutManager(itemView.getContext()); layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); recyclerView.setLayoutManager(layoutManager); /* adapter 只负责灌输、适配数据，布局交给 LayoutManager，可复用 */ adapter = new PostsAdapter(); // 或者直接使用 MultiTypeAdapter 更加方便 recyclerView.setAdapter(adapter); /* 在此设置横向滑动监听器，用于记录和恢复当前滑动到的位置，略 */ ... } private void setPosts(List&lt;Post&gt; posts) { adapter.setPosts(posts); adapter.notifyDataSetChanged(); } } }实现线性布局和网格布局混排列表这个课题其实也不属于 MultiType 的范畴，MultiType 的职责是做数据类型分发，而不是布局，但鉴于很多复杂页面都会需要线性布局和网格布局混排，我就简单讲一讲，关键在于 RecyclerView 的 LayoutManager. 虽然是线性和网格混合，但实现起来其实只要一个网格布局 GridLayoutManager，如果你查看 GridLayoutManager 的官方源码，你会发现它其实继承自 LinearLayoutManager. 以下是示例和解释： public class MultiGridActivity extends MenuBaseActivity { private final static int SPAN_COUNT = 5; private MultiTypeAdapter adapter; private Items items; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_multi_grid); items = new Items(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.list); final GridLayoutManager layoutManager = new GridLayoutManager(this, SPAN_COUNT); /* 关键内容：通过 setSpanSizeLookup 来告诉布局，你的 item 占几个横向单位， 如果你横向有 5 个单位，而你返回当前 item 占用 5 个单位，那么它就会看起来单独占用一行 */ layoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { return (items.get(position) instanceof Category) ? SPAN_COUNT : 1; } }); recyclerView.setLayoutManager(layoutManager); adapter = new MultiTypeAdapter(items); adapter.applyGlobalMultiTypePool(); adapter.register(Square.class, new SquareViewBinder()); assertAllRegistered(adapter, items); recyclerView.setAdapter(adapter); loadData(); } private void loadData() { // ... } }数据扁平化处理在一个垂直 RecyclerView 中，item 们都是同级的，没有任何嵌套关系，但我们的数据结构往往存在嵌套关系，比如 Post 内部包含了 Comments 数据，或换句话说 Post 嵌套了 Comment，就像微信朋友圈一样，”动态” 伴随着 “评论”。那么如何把 非扁平化 的数据排布在 扁平 的列表中呢？必然需要一个数据扁平化处理的过程，就像 ListView 的数据需要一个 Adapter 来适配，Adapter 就像一个油漏斗，把油引入瓶子中。我们在面对嵌套数据结构的时候，可以采用如下的扁平化处理，关于扁平化这个词，不必太纠结，简单说，就是把嵌套数据都拉出来，摊平，让 Comment 和 Post 同级，最后把它们都 add 进同一个 Items 容器，交给 MultiTypeAdapter. 示例： 假设：你的 Post 是这样的： public class Post { public String content; public List&lt;Comment&gt; comments; }假设：你的 Comment 是这样的： public class Comment { public String content; }假设：你服务端返回的 JSON 数据是这样的： [ { &quot;content&quot;:&quot;I have released the MultiType v2.2.2&quot;, &quot;comments&quot;:[ {&quot;content&quot;:&quot;great&quot;}, {&quot;content&quot;:&quot;I love your post!&quot;} ] } ]那么你的 JSON 转成 Java Bean 之后，你拿到手应该是个 List&lt;Post&gt; posts 对象，现在我们写一个扁平化处理的方法： private List&lt;Object&gt; flattenData(List&lt;Post&gt; posts) { final List&lt;Object&gt; items = new ArrayList&lt;&gt;(); for (Post post : posts) { /* 将 post 加进 items，Binder 内部拿到它的时候， * 我们无视它的 comments 内容即可 */ items.add(post); /* 紧接着将 comments 拿出来插入进 items， * 评论就能正好处于该条 post 下面 */ items.addAll(post.comments); } return items; }最后我们所有的 posts 在加入全局 MultiType Items 之前，都需要经过扁平化处理： items.addAll(flattenData(posts)); adapter.notifyDataSetChanged();整个过程其实并不困难，相信大家都已经理解了。 更多示例MultiType 的开源项目提供了许多的 samples (示例) 程序，这些示例秉承了一贯的代码清晰、干净的风格，十分易于阅读： 仿造微博的数据结构和二级 ItemViewBinder 这是一个类似微博数据结构的示例，数据两层结构，Item 也是两层结构：一层框架（包含头像用户名等），一层 content view(微博内容)，内容嵌套于框架中。微博的每一条微博 item 都包含了这样两层嵌套关系，这样做的好处是，你不必每个 item 都去重复制造一遍外层框架。 或者换一个比喻，就像聊天消息，一条聊天消息也是两层的，一层头像、用户名、聊天气泡框，一层你的文字、图片等。另外，每一种消息都有左边和右边的样式，分别对应别人发来的消息和你发出的消息。如果左边算一种，右边又算一种，就是比较不好的设计了，会导致布局内容重复、冗余，修改操作都要做两遍。最好的方案是让他们视被为同一种类型，然后在 item 框层次进行左右边判断和框架相关数据绑定。 我提供的这个二级 ItemViewBinder 示例便是这样的两层结构。它能够让你每次新增加一个类型，只要实现内容即可，框不应该重复实现。 如果再不明白，或许你可以看看我的这个示例中 微博 Item 框的布局： 从我这个 frame 布局可以看出来，它内部有一个 FrameLayout 作为 container 将用于容纳不同的微博内容，而这一层框架则是共同的。 这个例子算高级中的高级，但实际上也是很简单，展示了 MultiType 优秀的可拓展能力。完整运行结果展示如下： 注：以上我们并没有提到服务端 JSON 数据转为我们定义的 Weibo 对象过程，实际上对于完整链路，这个过程是需要做数据转换，我们需要在 WeiboContent 层加一个 type 或 describe 字段用于描述微博内容类型，然后再将微博内容的 JSON 文本转为具体微博内容对象交给 Weibo. 这个内容建议直接阅读这个 sample 的 WeiboContentDeserializer 源码，我利用了一种很简单又巧妙的方式，在 JSON 解析底层便进行抽象数据具体化，使得客户端和服务端都能够轻松适应这种微博和微博内容嵌套关系。 drakeet/about-page 一个 Material Design 的关于页面，核心基于 MultiType，包含了多种 items，美观，容易使用。 线性和网格布局混排 使用 MultiType 和 GridLayoutManager 实现网格和线性混合布局，实现一个选集页面。 drakeet/TimeMachine TimeMachine 使用了 MultiType 来创建一个复杂的聊天页面，页面和需求虽然复杂，但使用 MultiType 显得轻松简单。 ) 类似 Bilibili iOS 端首页 使用 MultiType 实现类似 Bilibili iOS 端首页复杂的多类型列表视图，包括嵌套横向 RecyclerView. Q &amp; A Q: 觉得 MultiType 不够精简，应该怎么做？ A: 在前面 “设计思想” 中我们谈到：MultiType 或许不是使用起来最简单的，但很可能是使用起来最灵活的。其中的缘由是它高度可定制、可拓展，而不是把一些路封死。作为一个基础类库，简单和灵活需要一个均衡点，过度精简便要以失去灵活性为代价。如果觉得 MultiType 不够精简，想将它修改得更加容易使用，我推荐的方式是去继承 MultiTypeAdapter 或 ItemViewBinder，甚至你可以重新实现一个 TypePool 再设置给 MultiTypeAdapter. 我们不应该直接到底层去修改、破坏它们。总之，利用开放接口或继承的做法不管对于 MultiType 还是其它开源库，都应该是定制的首选。 Q: 在 ItemViewBinder 中如何拿到 Context 对象？ A: 有人问我说，他在 ItemViewBinder 里使用 Glide 来加载图片需要获取到 Activity Context 对象，要怎么才能拿到 Context 对象？这是一个特别简单的问题，但我想既然有人问，应该比较典型，我就详细解答下：首先，在 Android 开发中，任何 View 对象都能通过 view.getContext() 拿到 Context 对象，这些对象本质上都是 Activity 对象的引用。而在我们的 ItemViewBinder 中，可以通过 holder.itemView.getContext() 获取到 Context 对象，也可以通过 viewHolder 的任意 View 对象 getContext() 方法拿到 Context 对象. Context 中文释义是 *”上下文对象”*，一般情况下，都是由 Activity 传递给 Views，Views 内部再进行传递。比如我们使用 RecyclerView，Activity 会将它的 Context 传递给 RecyclerView，RecyclerView 再传递给 Adapter，Adapter 再传递给 ViewHolder 的 itemView，itemView 再传递给它的各个子 Views，传递来传递去，其实都是同一个对象的引用。 总而言之，拿到 Context 对象非常简单，只要你能拿到一个 View 对象，调用 view.getContext() 即可。另外，也可以参考 与 binder 通讯 章节，我们可以很方便地给 binder 传递任何对象进去，包括 Context 对象。 Q：如何在 ItemViewBinder 中获取到 item position？ A: 从 v2.3.5 版本开始，只需要在你的 ItemViewBinder 子类里调用 getPosition(holder) 方法即可。另外，ItemViewBinder 还提供了 getAdapter() 或许也是很多人想要的，比如调用 adapter 进行 notify 刷新视图等。","categories":[],"tags":[]},{"title":"从0到1教你搭建前端团队的组件系统（高级进阶必备）","slug":"从0到1教你搭建前端团队的组件系统（高级进阶必备）","date":"2020-06-11T04:57:45.000Z","updated":"2020-06-11T21:29:30.522Z","comments":true,"path":"2020/06/11/vue/","link":"","permalink":"https://jiyugithub.github.io/2020/06/11/vue/","excerpt":"前言随着vue/react这类以数据驱动为主的web框架的不断完善和壮大，越来越多的前端团队开始着手搭建内部的组件库。虽然目前市面上已经有很多功能强大且完善的组件库供我们使用，比如基于react的开源组件库ant-design，material，又比如基于vue的开源组件库elementUI，iView等。","text":"前言随着vue/react这类以数据驱动为主的web框架的不断完善和壮大，越来越多的前端团队开始着手搭建内部的组件库。虽然目前市面上已经有很多功能强大且完善的组件库供我们使用，比如基于react的开源组件库ant-design，material，又比如基于vue的开源组件库elementUI，iView等。 我们在开发管理系统或者中台产品时，完全可以使用这种第三方库来开发，因为首先其服务的用户群体比较小众，一般是企业或者运营人员来使用，重点在于功能和业务，所以在B端产品比较适合；另一点就是设计要求相对于C端产品会低一些，因为B端产品或者管理系统风格统一简单反而会降低使用者的学习成本。所以对于上述情况，我们完全可以使用ant-design-pro或者element-admin-vue这类集成管理框架开开发。 我们使用第三方组件库搭建一个企业级应用是完全没有问题的，但是另一方面，随着我们对用户体验以及网站性能的要求越来越高，流量及金钱，速度即王道，对于专注于做C端的企业来说，尽可能的减少用户等待才能留住更多的用户，比如我们在某宝，某东上买一个商品，结果我们花了一分钟商品列表还没有出来（形容的有点夸张），这种情况下客户可有可能直接选择某拼了。很明显像ant-design和elementUI这样的组件不适合做C端产品，因为体积太大了，除非用高性能服务器或者其他方式弥补。所以说采用轻量级组件库对于C端项目来说有以下几点好处： 打包体积小，高度可控 采用内部组件库安全性更高，防止嵌入攻击 构建和开发更灵活，且组合型更高 但是开发组件库还是需要投入时间和成本的，毕竟这东西不是每个团队都玩的起的。说了这么多，接下来我们就来分析和实现一个团队内部的组件库吧。 你将收获 如何从0搭建一个组件库 前端组件系统设计思路和模式 组件库的划分及设计思路 组件库的package.json文件配置说明 将组件库部署到github并发布到npm上 正文1. 开发组件库的几种方式 目前我们开发组件库的方式有很多，只要根据npm发包原则去配置就好了，我们可以用webpack自己大家一个library，也可以直接使用create-react-app/vue-cli3来快速改造一个组件库的脚手架，或者采用之前比较火且自动集成tree-shaking的rollup，这些方式都可以搭建我们组件库的脚手架。关于如何使用webpack4.0和rollup，可以参考笔者的以下几篇文章： 前端组件/库打包利器rollup使用与配置实战 基于create-react-app打包编译自己的第三方UI组件库并发布到npm 用 webpack 4.0 撸单页/多页脚手架 (jquery, react, vue, typescript) 其实还有一种最快的方式就是直接去ant-design或者elementUI的github仓库，把代码copy下来改成自己的组件库脚手架，当然，这也不是随便就能改好的，如果想尝试这种方案，建议大家先学好typescript和webpack。 笔者这里采用的是目前比较流行的工具链umi，umi的father专门是提供组件库或者工具库打包的集成工具，我们只需要更改配置文件就能轻松搭建一款自带说明文档的组件库。笔者接下来会具来教大家如何使用它。 2. 前端组件系统设计思路和模式 以上是笔者画的一个简陋的分层图，我们可以看到最底层的是我们的基础视图组件，它是上层建筑的基石。对于一个包含很多子系统的复杂的项目系统来说，要想设计一个好的架构，第一步就是合理划分组件，组件的粒度拆成的足够细，这样才能最大限度的复用组件。 对于任何一个复杂系统来说，最重要的就是实现错综复杂的业务功能，但是不同模块或者子系统之间很多业务往往是相通的或者相似的，如果这个时候我们每个页面对于实现类似的业务场景都去重复去写一遍业务代码，那完全是没必要的，对于可维护性来说也是一种打击，所以基于这种场景我们的 业务组件 就很有必要出场了。我们可以把功能或者需求类似的有机体封装成一个业务组件，并对外暴露接口来实现灵活的可定制性，这样的话我们就可以再不同页面不同子系统中复用同样的逻辑和功能了。 同理，不同页面中往往有可能出现视觉或者交互完全相同或者类似的区块，为了提高可复用性和提高开发效率，我们往往会基于基础组件和业务组件再进行一次封装，让其成为一个独立的区块以便直接复用。 通过这样一层层封装，我们就逐渐搭建了一套完整的组件化系统，基于这种模式的开发往往也是一个好的前端架构的开始。但要注意一点就是高层次的组件一定会依赖低层次的组件，但是低层次的组件不可以包含高层次的组件。（听起来有点像rudex的单向数据流法则），他们的关系就好像下图： 3. 组件库的划分及设计思路组件库的划分其实可以参考成熟组件库划分。由于业务组件和区块划分完全取决于不同公司的实际项目情况，这里不能形成一套统一的思维框架，所以我这里说的组件库划分主要指基础组件库的划分。我们先来看看antd的划分，它划分为：通用组件，布局组件，导航组件，数据录入和数据展示组件，反馈型组件和其他。elementUI的组件划分为：基础组件，表单组件，数据呈现组件，通知类组件，导航类组件和其他，这些分类发都是非常合理的划分，所以我们在设计组件库时也可以参考或者直接使用，具体总结如下： 通用型组件: 比如Button, Icon等. 布局型组件: 比如Grid, Layout布局等. 导航型组件: 比如面包屑Breadcrumb, 下拉菜单Dropdown, 菜单Menu等. 数据录入型组件: 比如form表单, Switch开关, Upload文件上传等. 数据展示型组件: 比如Avator头像, Table表格, List列表等. 反馈型组件: 比如Progress进度条, Drawer抽屉, Modal对话框等. 其他业务类型 至于组件实现的设计思路，其实笔者之前也写过很多文章来做铺垫，第一要义就是需求，一切要从需求出发。不仅仅是react的组件设计，vue或者angular等都是类似的方法和思路，这里简单给大家举一个组件开发的例子—— 弹窗组件（Modal）的开发思路： 需求分析 功能设计及实现思路 健壮性与组件测试 因为Modal设计是组件设计里一个很典型的案例，如果想学习具体实现细节，可以在读完本文之后移步 手摸手实现一个轻量级可扩展的模态框(Modal)组件 4. 从0搭建一个组件库这一步是文章的重点，我们将会了解到如何使用umi/father来搭建团队的组件库。至于umi这个前端集成解决方案，笔者从它的架构中受到了很多启发，并且基于umi+dva+react的前端开发流程应用非常广泛，感兴趣的朋友可以研究学习一下。 4.1 father介绍官方介绍就一句话：基于rollup和docz的库打包工具。它的特点主要有： 基于 docz 的文档功能 基于 rollup 和 babel 的组件打包功能 支持 TypeScript 支持 cjs、esm 和 umd 三种格式的打包 esm 支持生成 mjs，直接为浏览器使用 支持用 babel 或 rollup 打包 cjs 和 esm 支持多 entry 支持 lerna 支持 css 和 less，支持开启 css modules 支持 test 支持用 prettier 和 eslint 做 pre-commit 检查 所以作为一个开箱即用的组件库打包工具，已经为我们省去了很多中间步骤，比如说组件的测试，不同环境下的模块打包，而且还支持ts和文档功能，我们只需要掌握babel和rollup的知识，就能用它轻松配置出一个强大的组件库脚手架。如果对docz不太了解的可以在docz官网学习使用非常简单,只要你对markdown和react熟悉，分分钟入门。 4.2 使用father搭建组件库其实father的使用非常简单，首先我们先安装一下father： npm install father -D 或者使用yarn安装： yarn add father 接下来我们可以在package.json里配置如下脚本来使用： # 打包库 $ father build # 开发环境下启动文档服务 $ father doc dev # 打包编译文档 $ father doc build # 将文档部署到github $ father doc deploy # 组件库测试及测试覆盖率 $ father test $ father test --coverage 这里拿笔者之前已经发布到npm的组件库xui——基于react的轻量级UI组件库来举例。 首先我们看看xui的package.json中的script脚本如何配置的： &quot;scripts&quot;: { &quot;dev&quot;: &quot;npx --max_old_space_size=8096 father doc dev --host 0.0.0.0&quot;, &quot;build&quot;: &quot;father build&quot;, &quot;build:doc&quot;: &quot;father doc build&quot;, &quot;deploy&quot;: &quot;father doc deploy&quot; } 当我们执行npm run dev或者yarn dev时，father自动帮我们启动了doc服务器，我们接下来就能看到我们组件的测试文档了： 这些内容都是我们提前写好的mdx文档，语法类似于markdown，只不过增加了对react组件的编译支持，其实使用起来很简单，我们只需要把react组件包裹在Playground容器里就好了，具体使用可以参考以下方式： --- name: Button route: /Button order: 3 sidebar: true --- import { Playground } from &#39;docz&#39; import Button from &#39;./index&#39; # Button #### 基本用法 &lt;Playground&gt; &lt;Button&gt;按钮&lt;/Button&gt;&lt;br /&gt; &lt;Button type=&quot;primary&quot;&gt;按钮&lt;/Button&gt;&lt;br /&gt; &lt;Button type=&quot;warning&quot;&gt;按钮&lt;/Button&gt;&lt;br /&gt; &lt;Button type=&quot;info&quot;&gt;按钮&lt;/Button&gt;&lt;br /&gt; &lt;Button type=&quot;pure&quot;&gt;按钮&lt;/Button&gt;&lt;br /&gt; &lt;Button type=&quot;primary&quot; shape=&quot;circle&quot;&gt;按钮的命运&lt;/Button&gt;&lt;br /&gt; &lt;/Playground&gt; 头部的信息我需要介绍一下： name 组件的名称，也就是显示在左部导航栏里的导航文本 route 组件页面的路由 order 组件在导航条中显示的顺序 siderbar 当前页面是否显示导航条 我们根据案例可以知道mdx里面可以使用es6的导入方式来引入组件或者变量，其实还有很多配置，这里就不一一举例了，感兴趣的可以到docz官网学习。以下是官网的截图： 接下来介绍我们最重要的部分，.fatherrc.js文件的配置。初始化father项目时会自动生成一个默认配置，但是大多数情况下我们都需要自定义配置，官网的配置参数也很多，可以找到适合自己团队的配置，这里我主要介绍xui组件库的配置细节。先看看配置代码： // .fatherrc.js const options = { entry: &#39;src/index.js&#39;, doc: { title: &#39;xu_ui&#39;, themeConfig: { mode: &#39;light&#39; }, base: &#39;/xu_ui&#39; }, extraBabelPlugins: [ [&#39;babel-plugin-import&#39;, { libraryName: &#39;antd&#39;, libraryDirectory: &#39;es&#39;, style: true, }] ], // cssModules: true, extractCSS: true, lessInBabelMode: true, runtimeHelpers: true, esm: &#39;babel&#39;, cjs: &#39;babel&#39;, autoprefixer: { browsers: [&#39;ie&gt;9&#39;, &#39;Safari &gt;= 6&#39;], } }; export default options; entry 主要用来定义组件库的入口位置，通常我们会放在src目录下，以下是xui项目中src的目录结构： 大家可以参考以下，我们还可以在组件目录下加测试代码，这里就不举例了。 doc 主要用来配置文档的标题，主题色以及根路由 extraBabelPlugins 主要用来配置额外的babel插件，比如组件库的按需导入。xui虽然没用用到antd，但是大家如果有基于antd二次开发业务组件或者区块时，可以按照如上配置去按需导入第三方组件库，这样可以极大的降低代码体积 cssModules 是否开启css Module，这个按团队需求来定制，可以不用配置 extractCSS 是否将css抽离成单独的css文件，这个也是看组件库的体量，不过建议最好配置上 lessInBabelMode 在 babel 模式下做 less 编译，基于 gulp-less，默认不开启 runtimeHelpers 是否把 helper 方法提取到 @babel/runtime 里，推荐开启，能节约不少代码体积 esm 是否输出 esm 格式，以及指定 esm 格式的打包方式等，笔者这里使用babel的打包方式 cjs 是否输出 cjs 格式，以及指定 cjs 格式的打包方式等，笔者这里使用babel的打包方式 autoprefixer 主要用来配置打包后的组件对浏览器的兼容版本 通过以上的配置，我们就能愉快的开发组件啦。 4.3 编写组件说明文档组件说明文档是让其他人了解组件库的关键环节，包括组件库的适用范围（pc端，移动端，轻量级还是重量级），兼容浏览器的版本，设计原则和背景，以及社区生态，使用方法等。所以组件库说明文档的编写也是非常重要的，大家具体可以参考antd或者element的说明文档，可以说是写的非常专业了。如下是antd的例子： 大家可以参考以上笔者整理的核心部分去写组件说明文档。 5. 组件库的package.json文件配置说明如果你在为团队开发私有组件库，那么完全不需要在意接下来笔者写的内容，但是如果你要开发一个开源的，大家都能使用的组件库，一定要注意以下几点的编写： name package的包名，让人一眼就能知道这个库是用来做什么的 description 库的描述，一个精准而具体的组件库的描述有利于人们在npm或者github上的搜索，有点类似于SEO的感觉，没错，这就是组件库的SEO keywords 组件库的关键字说明，这一点也很重要，直接影响者用户对我们组件库的搜索排名 homepage 组件库的主页地址，更有利于用户了解组件库的用法，功能等 完整的在线例子可以参考： xui——基于react的轻量级UI组件库 6. 将组件库部署到github并发布到npm上首先我们需要在package.json中配置github的地址： &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com:MrXujiang/xu_ui.git&quot; } 大家可以复制以上代码改成自己的仓库地址。 其次我们需要登录进npm官网，如果你还没有账号可以直接申请一个，也很简单，然后在终端通过命令行登录。 接下来我们执行以下几个命令就能将自己的组件库打包发布到npm上了： // 打包编译组件库 yarn build // 编译组件库文档，该步骤可省略 yarn build:doc // 部署组件库文档到github, 该步骤可省略 yarn deploy // 发布到npm上 npm publish --access public 以上的yarn命令具体实现可参考xui的package.json,也可以自己配置。经过上述步骤我们就成功将自己的组件库发布到npm上了，是不是很简单呢？ 笔者已经将实现过的组件发布到npm上了,大家如果感兴趣可以直接用npm安装后使用,方式如下: npm i @alex_xu/xui // 导入xui import { Button, Skeleton, Empty, Progress, Message, Tag, Switch, Drawer, Badge, Alert } from &#39;@alex_xu/xui&#39; 该组件库支持按需导入,我们只需要在项目里配置babel-plugin-import即可,具体配置如下: // .babelrc &quot;plugins&quot;: [ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;@alex_xu/xui&quot;, &quot;style&quot;: true }] ] npm库截图如下: 组件系统与微前端架构初探笔者本篇文章并不会将微前端架构的知识，但是既然涉及到组件库，就一定要形成一个知识闭环，笔者特意画了如下脑图，供前端朋友或者正准备走向微前端架构的团队一些参考：","categories":[],"tags":[]},{"title":"Handler 机制","slug":"Handler-机制","date":"2020-06-09T02:19:36.000Z","updated":"2020-06-11T21:28:17.459Z","comments":true,"path":"2020/06/09/handler/","link":"","permalink":"https://jiyugithub.github.io/2020/06/09/handler/","excerpt":"面试官：“看你简历上写熟悉 Handler 机制，那聊聊 IdleHandler 吧？”","text":"面试官：“看你简历上写熟悉 Handler 机制，那聊聊 IdleHandler 吧？” 一. 序Handler 机制算是 Android 基本功，面试常客。但现在面试，多数已经不会直接让你讲讲 Handler 的机制，Looper 是如何循环的，MessageQueue 是如何管理 Message 等，而是基于场景去提问，看看你对 Handler 机制的掌握是否扎实。 本文就来聊聊 Handler 中的 IdleHandler，这个我们比较少用的功能。它能干什么？怎么使用？有什么合适的使用场景？哪些不是合适的使用场景？在 Android Framework 中有哪些地方用到了它？ 二. IdleHandler2.1 简单说说 Handler 机制在说 IdleHandler 之前，先简单了解一下 Handler 机制。 Handler 是标准的事件驱动模型，存在一个消息队列 MessageQueue，它是一个基于消息触发时间的优先级队列，还有一个基于此消息队列的事件循环 Looper，Looper 通过循环，不断的从 MessageQueue 中取出待处理的 Message，再交由对应的事件处理器 Handler/callback 来处理。 其中 MessageQueue 被 Looper 管理，Looper 在构造时同步会创建 MessageQueue，并利用 ThreadLocal 这种 TLS，将其与当前线程绑定。而 App 的主线程在启动时，已经构造并准备好主线程的 Looper 对象，开发者只需要直接使用即可。 Handler 类中封装了大部分「Handler 机制」对外的操作接口，可以通过它的 send/post 相关的方法，向消息队列 MessageQueue 中插入一条 Message。在 Looper 循环中，又会不断的从 MessageQueue 取出下一条待处理的 Message 进行处理。 IdleHandler 使用相关的逻辑，就在 MessageQueue 取消息的 next() 方法中。 2.2 IdleHandler 是什么？怎么用？IdleHandler 说白了，就是 Handler 机制提供的一种，可以在 Looper 事件循环的过程中，当出现空闲的时候，允许我们执行任务的一种机制。 IdleHandler 被定义在 MessageQueue 中，它是一个接口。 // MessageQueue.java public static interface IdleHandler { boolean queueIdle(); } 可以看到，定义时需要实现其 queueIdle() 方法。同时返回值为 true 表示是一个持久的 IdleHandler 会重复使用，返回 false 表示是一个一次性的 IdleHandler。 既然 IdleHandler 被定义在 MessageQueue 中，使用它也需要借助 MessageQueue。在 MessageQueue 中定义了对应的 add 和 remove 方法。 // MessageQueue.java public void addIdleHandler(@NonNull IdleHandler handler) { // ... synchronized (this) { mIdleHandlers.add(handler); } } public void removeIdleHandler(@NonNull IdleHandler handler) { synchronized (this) { mIdleHandlers.remove(handler); } } 可以看到 add 或 remove 其实操作的都是 mIdleHandlers，它的类型是一个 ArrayList。 既然 IdleHandler 主要是在 MessageQueue 出现空闲的时候被执行，那么何时出现空闲？ MessageQueue 是一个基于消息触发时间的优先级队列，所以队列出现空闲存在两种场景。 MessageQueue 为空，没有消息； MessageQueue 中最近需要处理的消息，是一个延迟消息（when&gt;currentTime），需要滞后执行； 这两个场景，都会尝试执行 IdleHandler。 处理 IdleHandler 的场景，就在 Message.next() 这个获取消息队列下一个待执行消息的方法中，我们跟一下具体的逻辑。 Message next() { // ... int pendingIdleHandlerCount = -1; int nextPollTimeoutMillis = 0; for (;;) { nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // ... if (msg != null) { if (now &lt; msg.when) { // 计算休眠的时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Other code // 找到消息处理后返回 return msg; } } else { // 没有更多的消息 nextPollTimeoutMillis = -1; } if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; } } 我们先解释一下 next() 中关于 IdleHandler 执行的主逻辑： 准备执行 IdleHandler 时，说明当前待执行的消息为 null，或者这条消息的执行时间未到； 当 pendingIdleHandlerCount &lt; 0 时，根据 mIdleHandlers.size() 赋值给 pendingIdleHandlerCount，它是后期循环的基础； 将 mIdleHandlers 中的 IdleHandler 拷贝到 mPendingIdleHandlers 数组中，这个数组是临时的，之后进入 for 循环； 循环中从数组中取出 IdleHandler，并调用其 queueIdle() 记录返回值存到 keep 中； 当 keep 为 false 时，从 mIdleHandler 中移除当前循环的 IdleHandler，反之则保留； 可以看到 IdleHandler 机制中，最核心的就是在 next() 中，当队列空闲的时候，循环 mIdleHandler 中记录的 IdleHandler 对象，如果其 queueIdle() 返回值为 false 时，将其从 mIdleHander 中移除。 需要注意的是，对 mIdleHandler 这个 List 的所有操作，都通过 synchronized 来保证线程安全，这一点无需担心。 2.3 IdleHander 是如何保证不进入死循环的？当队列空闲时，会循环执行一遍 mIdleHandlers 数组并执行 IdleHandler.queueIdle() 方法。而如果数组中有一些 IdleHander 的 queueIdle() 返回了 true，则会保留在 mIdleHanders 数组中，下次依然会再执行一遍。 注意现在代码逻辑还在 MessageQueue.next() 的循环中，在这个场景下 IdleHandler 机制是如何保证不会进入死循环的？ 有些文章会说 IdleHandler 不会死循环，是因为下次循环调用了 nativePollOnce() 借助 epoll 机制进入休眠状态，下次有新消息入队的时候会重新唤醒，但这是不对的。 注意看前面 next() 中的代码，在方法的末尾会重置 pendingIdleHandlerCount 和 nextPollTimeoutMillis。 Message next() { // ... int pendingIdleHandlerCount = -1; int nextPollTimeoutMillis = 0; for (;;) { nativePollOnce(ptr, nextPollTimeoutMillis); // ... // 循环执行 mIdleHandlers // ... pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; } } nextPollTimeoutMillis 决定了下次进入 nativePollOnce() 超时的时间，它传递 0 的时候等于不会进入休眠，所以说 natievPollOnce() 进入休眠所以不会死循环是不对的。 这很好理解，毕竟 IdleHandler.queueIdle() 运行在主线程，它执行的时间是不可控的，那么 MessageQueue 中的消息情况可能会变化，所以需要再处理一遍。 实际不会死循环的关键是在于 pendingIdleHandlerCount，我们看看下面的代码。 Message next() { // ... // Step 1 int pendingIdleHandlerCount = -1; int nextPollTimeoutMillis = 0; for (;;) { nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // ... // Step 2 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } // Step 3 if (pendingIdleHandlerCount &lt;= 0) { mBlocked = true; continue; } // ... } // Step 4 pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; } } 我们梳理一下： Step 1，循环开始前，pendingIdleHandlerCount 的初始值为 -1； Step 2，在 pendingIdleHandlerCount&lt;0 时，才会通过 mIdleHandlers.size() 赋值。也就是说只有第一次循环才会改变 pendingIdleHandlerCount 的值； Step 3，如果 pendingIdleHandlerCount&lt;=0 时，则循环 continus； Step 4，重置 pendingIdleHandlerCount 为 0； 在第二次循环时，pendingIdleHandlerCount 等于 0，在 Step 2 不会改变它的值，那么在 Step 3 中会直接 continus 继续下一次循环，此时没有机会修改 nextPollTimeoutMillis。 那么 nextPollTimeoutMillis 有两种可能：-1 或者下次唤醒的等待间隔时间，在执行到 nativePollOnce() 时就会进入休眠，等待再次被唤醒。 下次唤醒时，mMessage 必然会有一个待执行的 Message，则 MessageQueue.next() 返回到 Looper.loop() 的循环中，分发处理这个 Message，之后又是一轮新的 next() 中去循环。 2.4 framework 中如何使用 IdleHander？到这里基本上就讲清楚 IdleHandler 如何使用以及一些细节，接下来我们来看看，在系统中，有哪些地方会用到 IdleHandler 机制。 在 AS 中搜索一下 IdleHandler。 简单解释一下： ActivityThread.Idler 在 ActivityThread.handleResumeActivity() 中调用。 ActivityThread.GcIdler 是在内存不足时，强行 GC； Instrumentation.ActivityGoing 在 Activity onCreate() 执行前添加； Instrumentation.Idler 调用的时机就比较多了，是键盘相关的调用； TextToSpeechService.SynthThread 是在 TTS 合成完成之后发送广播； 有兴趣可以自己追一下源码，这些都是使用的场景，具体用 IdleHander 干什么，还是要看业务。 三.一些面试问题到这里我们就讲清楚 IdleHandler 干什么？怎么用？有什么问题？以及使用中一些原理的讲解。 下面准备一些基本的问题，供大家理解。 Q：IdleHandler 有什么用？ IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机； 当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler； Q：MessageQueue 提供了 add/remove IdleHandler 的方法，是否需要成对使用？ 不是必须； IdleHandler.queueIdle() 的返回值，可以移除加入 MessageQueue 的 IdleHandler； Q：当 mIdleHanders 一直不为空时，为什么不会进入死循环？ 只有在 pendingIdleHandlerCount 为 -1 时，才会尝试执行 mIdleHander； pendingIdlehanderCount 在 next() 中初始时为 -1，执行一遍后被置为 0，所以不会重复执行； Q：是否可以将一些不重要的启动服务，搬移到 IdleHandler 中去处理？ 不建议； IdleHandler 的处理时机不可控，如果 MessageQueue 一直有待处理的消息，那么 IdleHander 的执行时机会很靠后； Q：IdleHandler 的 queueIdle() 运行在那个线程？ 陷进问题，queueIdle() 运行的线程，只和当前 MessageQueue 的 Looper 所在的线程有关； 子线程一样可以构造 Looper，并添加 IdleHandler； 三. 小结时刻到这里就把 IdleHandler 的使用和原理说清除了。 IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机。但它执行的时机依赖消息队列的情况，那么如果 MessageQueue 一直有待执行的消息时，IdleHandler 就一直得不到执行，也就是它的执行时机是不可控的，不适合执行一些对时机要求比较高的任务。","categories":[],"tags":[]},{"title":"Flutter高级玩法-贝塞尔曲线的表象认知","slug":"【Flutter高级玩法】贝塞尔曲线的表象认知","date":"2020-06-08T01:38:19.000Z","updated":"2020-06-13T20:48:57.888Z","comments":true,"path":"2020/06/08/flutternm/","link":"","permalink":"https://jiyugithub.github.io/2020/06/08/flutternm/","excerpt":"– – 在玩贝塞尔之前先做点准备活动热热身。打个网格对学习贝塞尔曲线是很有帮助的。如下是以中心为原点的坐标系，x向右，y向下","text":"– – 在玩贝塞尔之前先做点准备活动热热身。打个网格对学习贝塞尔曲线是很有帮助的。如下是以中心为原点的坐标系，x向右，y向下 0.1 : 主程序void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( debugShowCheckedModeBanner: false, home:Paper()); } } 0.2 : 自定义Paper组件显示画布 为了绘制的纯粹和雅观，这里把状态量去掉，并且手机横向。 class Paper extends StatefulWidget { @override _PaperState createState() =&gt; _PaperState(); } class _PaperState extends State&lt;Paper&gt; { @override void initState() { //横屏 SystemChrome.setPreferredOrientations( [DeviceOrientation.landscapeLeft, DeviceOrientation.landscapeRight]); //全屏显示 SystemChrome.setEnabledSystemUIOverlays([]); super.initState(); } @override Widget build(BuildContext context) { return CustomPaint( painter: BezierPainter(), ); } } 0.3 : 绘制网格 注意: 这里永久的将画布原点移到画布的中心点，之后所以的绘制都将以中心为(0,0)点。 class BezierPainter extends CustomPainter { Paint _gridPaint; Path _gridPath; BezierPainter() { _gridPaint = Paint()..style=PaintingStyle.stroke; _gridPath = Path(); } @override void paint(Canvas canvas, Size size) { canvas.drawColor(Colors.white, BlendMode.color); canvas.translate(size.width/2, size.height/2); _drawGrid(canvas,size);//绘制格线 _drawAxis(canvas, size);//绘制轴线 } @override bool shouldRepaint(CustomPainter oldDelegate) =&gt; true; void _drawGrid(Canvas canvas, Size size) { _gridPaint ..color = Colors.grey ..strokeWidth = 0.5; _gridPath = _buildGridPath(_gridPath, size); canvas.drawPath(_buildGridPath(_gridPath, size), _gridPaint); canvas.save(); canvas.scale(1, -1); //沿x轴镜像 canvas.drawPath(_gridPath, _gridPaint); canvas.restore(); canvas.save(); canvas.scale(-1, 1); //沿y轴镜像 canvas.drawPath(_gridPath, _gridPaint); canvas.restore(); canvas.save(); canvas.scale(-1, -1); //沿原点镜像 canvas.drawPath(_gridPath, _gridPaint); canvas.restore(); } void _drawAxis(Canvas canvas, Size size) { canvas.drawPoints(PointMode.lines, [ Offset(-size.width/2, 0) , Offset(size.width/2, 0), Offset( 0,-size.height/2) , Offset( 0,size.height/2), Offset( 0,size.height/2) , Offset( 0-7.0,size.height/2-10), Offset( 0,size.height/2) , Offset( 0+7.0,size.height/2-10), Offset(size.width/2, 0) , Offset(size.width/2-10, 7), Offset(size.width/2, 0) , Offset(size.width/2-10, -7), ], _gridPaint..color=Colors.blue..strokeWidth=1.5); } Path _buildGridPath(Path path, Size size,{step = 20.0}) { for (int i = 0; i &lt; size.height / 2 / step; i++) { path.moveTo(0, step * i); path.relativeLineTo(size.width / 2, 0); } for (int i = 0; i &lt; size.width / 2 / step; i++) { path.moveTo( step * i,0); path.relativeLineTo(0,size.height / 2, ); } return path; } } 0.4、人生至美莫初见 先不看哪些花里胡哨的贝塞尔曲线的动画。让我们从实践中一点点去摸索。如此美丽的初见，为何要这么复杂？当你渐渐去认识她，了解她，熟悉她，便会明白:哦，原来如此如此，这般这般... 看到贝塞尔三个字，也不用觉得压力太大，满打满算也就两个函数而已。 ----&gt;[二次贝塞尔曲线]---- void quadraticBezierTo(double x1, double y1, double x2, double y2) void relativeQuadraticBezierTo(double x1, double y1, double x2, double y2) ----&gt;[三次贝塞尔曲线]---- void cubicTo(double x1, double y1, double x2, double y2, double x3, double y3) void relativeCubicTo(double x1, double y1, double x2, double y2, double x3, double y3) 一、二次贝塞尔曲线 二次贝塞尔曲线需要传入四个double类型的值。 1. 先画一笔看看 首先新准备个画笔和路径，在构造函数里初始化。准备两个测试点p1,p2,然后轻轻的用quadraticBezierTo描一笔，就出来一个曲线。 class BezierPainter extends CustomPainter { // 英雄所见... Paint _mainPaint; Path _mainPath; BezierPainter() { // 英雄所见... _mainPaint = Paint()..color=Colors.orange..style=PaintingStyle.stroke..strokeWidth=2; _mainPath = Path(); } Offset p0 =Offset(0, 0); Offset p1 =Offset(100, 100); Offset p2 =Offset( 120, -60); @override void paint(Canvas canvas, Size size) { // 英雄所见... _mainPath.moveTo(p0.dx, p0.dy); _mainPath.quadraticBezierTo(p1.dx, p1.dy, p2.dx, p2.dy); canvas.drawPath(_mainPath, _mainPaint); } 2.为什么曲线会是这样的? 为了更好的理解贝塞尔曲线，现在我们需要绘制辅助帮我们理解。现在想将与贝塞尔曲线有关系的三个点画出来。同样，我不想弄脏画笔，所以新拿一个_helpPaint。在_drawHelp方法里进行绘制辅助线。 class BezierPainter extends CustomPainter { // 英雄所见... Paint _helpPaint; BezierPainter() { // 英雄所见... _helpPaint = Paint() ..color=Colors.purple ..style=PaintingStyle.stroke ..strokeCap=StrokeCap.round; } void _drawHelp(Canvas canvas) { canvas.drawPoints(PointMode.points,[p0, p1, p1,p2], _helpPaint..strokeWidth=8); } 看到上图，你是不是发现的什么?如果还比较懵，再画一道辅助线 void _drawHelp(Canvas canvas) { canvas.drawPoints(PointMode.lines,[p0, p1, p1,p2], _helpPaint..strokeWidth=1); canvas.drawPoints(PointMode.points,[p0, p1, p1,p2], _helpPaint..strokeWidth=8); } 3. 来玩一下这个曲线 这不就是三个点嘛，要能拖拖看就好了。没问题，应你所求 现在有两个要点: 【1】 如何获取触点 【2】如何通过一个触点控制三个点位 简单讲解 由于点位需要变化，BezierPainter只承担绘制的责任，这里在组件中定义点位信息_pos和选中索引_selectIndex ，通过构造函数传入BezierPainter。为了方便大家玩耍，我单独写个文件play_bezier2.dart里面有个PlayBezier2Page组件。 ----&gt;[_PaperState]---- class PlayBezier2Page extends StatefulWidget { @override _PlayBezier2PageState createState() =&gt; _PlayBezier2PageState(); } class _PlayBezier2PageState extends State&lt;PlayBezier2Page&gt; { List _pos = []; int _selectPos; @override void initState() { //横屏 SystemChrome.setPreferredOrientations( [DeviceOrientation.landscapeLeft, DeviceOrientation.landscapeRight]); //全屏显示 SystemChrome.setEnabledSystemUIOverlays([]); _initPoints();//初始化点 super.initState(); } 获取触点信息通过GestureDetector组件可以获取触点信息，然后传给画布即可。这里的思路很清晰: 在点击时需要判断点击了哪个点，抬起时取消选中点，移动时变化选中点。 @override Widget build(BuildContext context) { return GestureDetector( onPanDown: (detail){ // Todo }, onPanEnd: (detail){ // Todo }, onPanUpdate: (detail) { // Todo }, child: CustomPaint( painter: BezierPainter(pos: _pos,selectPos:selectPos), ), ); } 一个触点控制三个点位 这就有点技术含量了。需要进行点域的判断来确定当前点击的是哪个点。比如在半径为6的区域内算作命中，就需要在点击时判断是否命中某个点。具体逻辑为: ///判断出是否在某点的半径为r圆范围内 bool judgeCircleArea(Offset src, Offset dst, double r) =&gt; (src - dst).distance &lt;= r; void judgeSelect(Offset src, {double x = 0, double y = 0}) { var p = src.translate(-x, -y); for (int i = 0; i &lt; _pos.length; i++) { if (judgeCircleArea(p, _pos[i], 15)) { selectPos = i; } } } void judgeZone(Offset src, {double x = 0, double y = 0}) { for (int i = 0; i &lt; _pos.length; i++) { if (judgeCircleArea(src, _pos[i], 15)) { selectPos = i; _pos[i] = src; } } } 前三个点需要用户点击，然后画出一段二贝曲线，之后再点击不会添加点，而是判断是否触点在期望的圆域内。这样数据的处理就完成了。根基【捷特第二定理】一切的界面交互和动态视觉效果都是连续时间点状态量的变化和刷新的结合。现在所有的状态量和刷新都已经实现，剩下的就是将这些量显示在界面上。 @override Widget build(BuildContext context) { return GestureDetector( onPanDown: (detail) { if (_pos.length &lt; 3) { _pos.add(detail.localPosition); } setState(() =&gt; judgeSelect(detail.localPosition)); }, onPanEnd: (detail) { setState(() =&gt; selectPos = null); }, onPanUpdate: (detail) { setState(() =&gt; judgeZone(detail.localPosition)); }, child: CustomPaint( painter: BezierPainter(pos: _pos, selectPos: selectPos), ), ); } 绘制 网格和辅助的和上面逻辑基本一致，详见源码，这里就不贴了。当点数小于三个时，仅绘制触点，否则绘制曲线和辅助线。 有一点需要注意: 我们的点位是相对于屏幕左上角的，需要平移到画布中心 class BezierPainter extends CustomPainter { Paint _mainPaint; Path _mainPath; int selectPos; List pos; BezierPainter({this.pos, this.selectPos}) { _mainPaint = Paint() ..color = Colors.orange ..style = PaintingStyle.stroke ..strokeWidth = 2; _mainPath = Path(); } @override void paint(Canvas canvas, Size size) { pos = pos.map((e)=&gt;e.translate(-size.width / 2, -size.height / 2)).toList(); canvas.drawColor(Colors.white, BlendMode.color); canvas.translate(size.width / 2, size.height / 2); _drawGrid(canvas, size); //绘制格线 _drawAxis(canvas, size); //绘制轴线 if(pos.length&lt;3){ canvas.drawPoints(PointMode.points, pos, _helpPaint..strokeWidth = 8); }else{ _mainPath.moveTo(pos[0].dx, pos[0].dy); _mainPath.quadraticBezierTo(pos[1].dx, pos[1].dy, pos[2].dx, pos[2].dy); canvas.drawPath(_mainPath, _mainPaint); _drawHelp(canvas); _drawSelectPos(canvas); } } // 英雄所见... void _drawSelectPos(Canvas canvas) { if (selectPos == null) return; canvas.drawCircle( pos[selectPos], 10, _helpPaint ..color = Colors.green ..strokeWidth = 2); } } 通过前面的介绍，一段二次的贝塞尔曲线有三个点决定，起点、控制点、终点关于起点，默认是（0，0），你也在绘制之前moveTo设置起点，当绘制连续的贝塞尔曲线，下一段曲线的起点就是上一段的终点。所以二次贝塞尔曲线至关重要的是两个点: 也就是入参中的控制点和终点。 二、三次贝塞尔曲线 前面的二次贝塞尔实现了，那现在来看三次的cubicTo。需要六个参数，也就是三个点。我们可以使用之前的代码，很快捷的生成如下效果。源代码在play_bezier3.dart 1.实现三贝单线操作 前面点集在_pos中维护,现在需要四个点，so easy 点击时将限制数改为4个 ----&gt;[_PlayBezier3PageState]---- onPanDown: (detail) { if (_pos.length &lt; 4) { _pos.add(detail.localPosition); } setState(() =&gt; judgeSelect(detail.localPosition)); } 绘制将限制数改为4个 if(pos.length&lt;4){ canvas.drawPoints(PointMode.points, pos, _helpPaint..strokeWidth = 8); }else{ _mainPath.moveTo(pos[0].dx, pos[0].dy); _mainPath.cubicTo(pos[1].dx, pos[1].dy, pos[2].dx, pos[2].dy, pos[3].dx, pos[3].dy); canvas.drawPath(_mainPath, _mainPaint); _drawHelp(canvas); _drawSelectPos(canvas); }That is all ,这就是分工明确的好处，变化时只变需变化待变化的，整体的流程和思路是恒定的。 2.三贝中的拟圆 三贝很厉害，可以说无所不能。只有你想不到，没有她做不到Ps中的钢笔路径就是多段的三贝曲线。所以还是很有玩头的。 -- 绘制拟圆 下面的图看着像个圆，但其实是四段三贝拟合而成的。目前我们的代码中最在意的就是点位数据。所以关键就是寻找点。本小节源码在:circle_bezier.dart中 第一段-左下 这里直接给出点，至于0.551915024494是什么，后面有机会会带你一起推导。有兴趣的话，你也可以自己查一查资料。和之前一样，核心的绘制就是那么一句。 ----&gt;[CircleBezierPage]---- class CircleBezierPage extends StatefulWidget { @override _CircleBezierPageState createState() =&gt; _CircleBezierPageState(); } class _CircleBezierPageState extends State { List _pos = []; int selectPos; //单位圆(即半径为1)控制线长 final rate = 0.551915024494; double _radius=150; @override void initState() { //横屏 SystemChrome.setPreferredOrientations( [DeviceOrientation.landscapeLeft, DeviceOrientation.landscapeRight]); //全屏显示 SystemChrome.setEnabledSystemUIOverlays([]); _initPoints(); super.initState(); } void _initPoints() { _pos = List(); //第一段线 _pos.add(Offset(0,rate)*_radius); _pos.add(Offset(1 - rate, 1)*_radius); _pos.add(Offset(1, 1)*_radius); } @override Widget build(BuildContext context) { return CustomPaint( painter: BezierPainter(pos: _pos, selectPos: selectPos), ), ); } ----&gt;[BezierPainter#paint]---- _mainPath.moveTo(0, 0); for (int i = 0; i &lt; pos.length / 3; i++) { _mainPath.cubicTo( pos[3*i+0].dx, pos[3*i+0].dy, pos[3*i+1].dx, pos[3*i+1].dy, pos[3*i+2].dx, pos[3*i+2].dy); } 其他三段 初始点时，将这12点放入列表。然后将赋值的点线绘制出来。 ----&gt;[CircleBezierPage#_initPoints]---- void _initPoints() { _pos = List(); //第一段线 _pos.add(Offset(0,rate)*_radius); _pos.add(Offset(1 - rate, 1)*_radius); _pos.add(Offset(1, 1)*_radius); //第二段线 _pos.add(Offset(1 + rate, 1)*_radius); _pos.add(Offset(2, rate)*_radius); _pos.add(Offset(2, 0)*_radius); //第三段线 _pos.add(Offset(2, -rate)*_radius); _pos.add(Offset(1 + rate, -1)*_radius); _pos.add(Offset(1, -1)*_radius); //第四段线 _pos.add(Offset(1 - rate, -1)*_radius); _pos.add(Offset(0, -rate)*_radius); _pos.add(Offset(0, 0)); } ----&gt;[BezierPainter#_drawHelp]---- void _drawHelp(Canvas canvas) { _helpPaint..strokeWidth = 1; canvas.drawLine(pos[0], pos[11],_helpPaint); canvas.drawLine(pos[1], pos[2],_helpPaint); canvas.drawLine(pos[2], pos[3],_helpPaint); canvas.drawLine(pos[4], pos[5],_helpPaint); canvas.drawLine(pos[5], pos[6],_helpPaint); canvas.drawLine(pos[7], pos[8],_helpPaint); canvas.drawLine(pos[8], pos[9],_helpPaint); canvas.drawLine(pos[10], pos[11],_helpPaint); canvas.drawLine(pos[11], pos[0],_helpPaint); canvas.drawPoints(PointMode.points, pos, _helpPaint..strokeWidth = 8); } 3.三贝中的拟圆的操作 看这控制柄，满满的拖动欲望，来实现一下吧有了之前的铺垫，下面的代码应该很容易接受吧。 @override Widget build(BuildContext context) { var x = MediaQuery.of(context).size.width/2; var y = MediaQuery.of(context).size.height/2; return GestureDetector( onPanDown: (detail) { setState(() =&gt; judgeSelect(detail.localPosition,x: x,y: y)); }, onPanEnd: (detail) { setState(() =&gt; selectPos = null); }, onPanUpdate: (detail) { setState(() =&gt; judgeZone(detail.localPosition,x: x,y: y)); }, child: CustomPaint( painter: BezierPainter(pos: _pos, selectPos: selectPos), ), ); } ///判断出是否在某点的半径为r圆范围内 bool judgeCircleArea(Offset src, Offset dst, double r) =&gt; (src - dst).distance &lt;= r; void judgeSelect(Offset src, {double x = 0, double y = 0}) { print(src); var p = src.translate(-x, -y); print(p); for (int i = 0; i &lt; _pos.length; i++) { if (judgeCircleArea(p, _pos[i], 15)) { selectPos = i; } } } void judgeZone(Offset src, {double x = 0, double y = 0}) { var p = src.translate(-x, -y); for (int i = 0; i &lt; _pos.length; i++) { if (judgeCircleArea(p, _pos[i], 15)) { selectPos = i; _pos[i] = p; } } } 三、贝塞尔曲线与路径操作 也许你觉得贝塞尔曲线也就那样。那么你忽略了一个很重要的东西。贝塞尔曲线是一条路径。路径是个什么东西，之前写了一篇关于路径使用的冰山一角【Flutter高级玩法-shape】Path在手，天下我有 现在再准备一条路径，看看路径间的如何操作 class BezierPainter extends CustomPainter { Path _clipPath; //英雄所见... BezierPainter({this.pos, this.selectPos}) { _clipPath=Path(); //英雄所见... @override void paint(Canvas canvas, Size size) { //英雄所见... _clipPath.addOval(Rect.fromCenter(center: Offset(0, 0),width: 100,height: 100)); canvas.drawPath(_clipPath, _mainPaint); //英雄所见... } 1.路径的相减: PathOperation.difference @override void paint(Canvas canvas, Size size) { //英雄所见... var drawPath = Path.combine(PathOperation.difference, _mainPath, _clipPath); canvas.drawPath(drawPath, _mainPaint); 2.路径的相加: PathOperation.union @override void paint(Canvas canvas, Size size) { //英雄所见... var drawPath = Path.combine(PathOperation.union, _mainPath, _clipPath); canvas.drawPath(drawPath, _mainPaint); 3.路径的反减: PathOperation.reverseDifference @override void paint(Canvas canvas, Size size) { //英雄所见... var drawPath = Path.combine(PathOperation.reverseDifference, _mainPath, _clipPath); canvas.drawPath(drawPath, _mainPaint); 4.路径的交集: PathOperation.intersect @override void paint(Canvas canvas, Size size) { //英雄所见... var drawPath = Path.combine(PathOperation.intersect, _mainPath, _clipPath); canvas.drawPath(drawPath, _mainPaint); 5.路径的反交集: PathOperation.xor 当然路径并非是线条,也可以进行填色。 @override void paint(Canvas canvas, Size size) { //英雄所见... var drawPath = Path.combine(PathOperation.xor, _mainPath, _clipPath); canvas.drawPath(drawPath, _mainPaint..style=PaintingStyle.fill); OK,本篇到这里就告一段落，下一篇会找几个实际的用途，来看看贝塞尔曲线的妙用。 敬请期待。","categories":[],"tags":[]},{"title":"hexo撰写文章","slug":"hexo撰写文章","date":"2020-06-05T16:37:27.000Z","updated":"2020-06-06T00:27:47.440Z","comments":true,"path":"2020/06/06/hexo-zhuan/","link":"","permalink":"https://jiyugithub.github.io/2020/06/06/hexo-zhuan/","excerpt":"在利用 Hexo 框架搭建一个属于我们自己的博客网站后，下面我们就来谈谈怎样在网站上书写我们的第一篇博客吧","text":"在利用 Hexo 框架搭建一个属于我们自己的博客网站后，下面我们就来谈谈怎样在网站上书写我们的第一篇博客吧 一、创建文章在站点文件夹中打开 git bash，输入如下命令创建文章，其中 title 为文章的标题 $ hexo new &quot;title&quot; 当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：title.md 这个文件就是将要发布到网站上的原始文件，用于记录文章内容 下面，我们将要在这个文件中写下我们的第一篇博客 二、编写文章（基于 Markdown）1、Markdown 简介但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？ Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式 基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言 2、Markdown 语法在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora 按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览 这里附上 Typora 的下载地址：https://www.typora.io/，有兴趣的朋友可以下载来试试 好，下面开始进入正题，介绍一些常用的 Markdown 语法 （1）标题Markdown 语法： 一级标题二级标题三级标题四级标题五级标题六级标题Typora 快捷键： Ctrl+1：一级标题 Ctrl+2：二级标题 Ctrl+3：三级标题 Ctrl+4：四级标题 Ctrl+5：五级标题 Ctrl+6 ：六级标题 Ctrl+0：段落 （2）粗体、斜体、删除线和下划线Markdown 语法： 斜体粗体加粗斜体删除线 Typora 快捷键： Ctrl+I：斜体 Ctrl+B：粗体 Ctrl+U：下划线 Alt+Shift+5：删除线 （3）引用块Markdown 语法： 文字引用 Typora 快捷键： Ctrl+Shift+Q （4）代码块Markdown 语法： 行内代码：Ctrl+Shift+` 多行代码：Ctrl+Shift+K （5）公式块Markdown 语法：$$数学公式Typora 快捷键： Ctrl+Shift$$（6）分割线Markdown 语法： 方法一：— 方法二：+++ 方法三：*** （7）列表Markdown 语法： Typora 快捷键： 有序列表项：Ctrl+Shift+[ 无序列表项：Ctrl+Shift+] （8）表格Markdown 语法： 表头1 表头2 内容11 内容12 内容21 内容22 Typora 快捷键： Ctrl+T （9）超链接Markdown语法： 方法一：链接文字例如：示例链接 方法二：&lt;链接地址&gt;例如：https://jiyugithub.github.io/ Typora快捷键： Ctrl+K （10）图片Markdown语法： 例如： Typora快捷键： Ctrl+Shift+I 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folder 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 添加图片 3、高级设置（1）模板设置当我们使用命令 hexo new “title” 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯 一个简单的示例如下： title: hexo撰写文章date: 1591375047000tags:categories:` （2）头部设置在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部 文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等 一个简单的示例如下： title: Titledate: YYYY-MM-DD HH:MM:SStags: [tag1, tag2, ...]categories: category 注意：属性和属性值之间必须有一个空格，否则会解析错误 （3）首页显示在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容 如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简 这时，我们只需在文章中使用 标志即可，表示只会显示标志前面的内容 三、部署发布在站点文件夹中打开 git bash，输入如下命令部署和发布文章 $ hexo g -d 建议：在使用 hexo g 部署之后，可以先使用 hexo s 运行本地站点，然后在浏览器输入地址 http://lacolhost:4000/ 查看运行结果，检查无误后再使用 hexo d 发布","categories":[],"tags":[]},{"title":"快速入门 Kotlin","slug":"快速入门-Kotlin","date":"2020-03-13T18:08:20.000Z","updated":"2020-06-13T20:43:15.330Z","comments":true,"path":"2020/03/14/TopKotlin/","link":"","permalink":"https://jiyugithub.github.io/2020/03/14/TopKotlin/","excerpt":"1.变量与函数 val：用于声明不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应 Java 中的 final 变量。 var：用于声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应 Java 中的非 final 变量。","text":"1.变量与函数 val：用于声明不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应 Java 中的 final 变量。 var：用于声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应 Java 中的非 final 变量。 1.1 使用 valfun main() { val a = 10 println(&quot;a = &quot; + a) } 运行结果： Kotlin 在赋值时会进行自动推导，可以根据值的类型推导出变量的类型，如果使用下面这种延迟赋值的方式，那么 Kotlin 将无法推到值得类型，这样程序就变报错 fun main() { val a: Int = 10 println(&quot;a = &quot; + a) } 1.2 使用 var由于上面使用的是不可变的变量，所以想要更改变量的值就会报错，所以需要将 val 改成 var 类型 fun main() { var a: Int = 10 a = a * 10 println(&quot;a = &quot; + a) } 总结：永远优先使用 val 来声明变量，当 val 无法满足你的需求时再使用 var，这样设计出来的程序更加健壮，也更加符合高质量的编码规范。 1.3 使用函数/** * 创建一个有两个参数的 Int 返回类型的方法 */ fun methodName(param1: Int, param2: Int): Int { return 0 } fun main() { val a = 37 val b = 40 val value = largerNumber(a, b) println(&quot;larger number is &quot; + value) } /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int): Int { return max(param1, param2) } 1.3.1 使用 Kotlin 语法糖/** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int): Int = max(param1, param2) 进一步简化版： /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int) = max(param1, param2) 2.程序的逻辑控制2.1 if 条件语句 Kotlin 中的条件语句有 if 和 when，其中 if 和 Java 中的 if 没有区别，这里简单了解一下。 /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int): Int { var value = 0 if (param1 &gt; param2) { value = param1 } else { value = param2 } return value } 2.1.1 if 的另一个用法 Kotlin 中的 if 用法和 Java 相比有一个额外的功能，它可以有返回值，返回值就是 if 语句每一个条件中最后一行代码的返回值，因此可以进行如下格式的书写: /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int): Int { val value = if (param1 &gt; param2) { param1 } else { param2 } return value } 在这里由于 value 只需要进行一次赋值，所以可以将 var 更改为 val。 进一步简写： /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int): Int { return if (param1 &gt; param2) { param1 } else { param2 } } 再一次精简： /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int) = if (param1 &gt; param2) { param1 } else { param2 } 或者 /** * 对比 param1 和 param2 返回较大的那个数 */ fun largerNumber(param1: Int, param2: Int) = if (param1 &gt; param2) param1 else param2 2.2 when 条件语句 Kotlin 中的 when 语句有点类似于 Java 中的 switch 语句，但是比 switch 更加精简。 使用格式：匹配值 -&gt; {执行逻辑} /** * 通过名字返回分数 */ fun getScore(name: String) = if (name == &quot;Tom&quot;) { 86 } else if (name == &quot;Jim&quot;) { 77 } else if (name == &quot;Jack&quot;) { 95 } else if (name == &quot;Lily&quot;) { 100 } else { 0 } /** * 使用 when 语句实现通过名字返回分数 */ fun getScore(name: String) = when (name) { &quot;Tom&quot; -&gt; 86 &quot;Jim&quot; -&gt; 77 &quot;Jack&quot; -&gt; 95 &quot;Lily&quot; -&gt; 100 else -&gt; 0 } 注意：Java 中的 switch语句支持的类型有限，再 JDK1.7 中支持了字符串类型，但是有些类型却仍然不支持，但是 when 语句却解决了以上 痛点。 2.2.1 使用 when 语句进行类型匹配/** * 判断传入的 number 是什么数据类型 */ fun checkNumber(num: Number) { when (num) { is Int -&gt; println(&quot;number is Int&quot;) is Double -&gt; println(&quot;number is Double&quot;) else -&gt; println(&quot;number not support&quot;) } } 上述代码中，is关键字是匹配类型的核心，它相当于 Java 中的 instanceof 关键字。由于 checkNumber() 函数接收一个 Number 类型的参数，这是 Kotlin 中内置的抽象类，比如 Int、Double、Float、Long 都属于它的子类。 2.2.2 when 语句的不常用用法/** * 使用 when 表达式实现通过名字返回分数 */ fun getScore(name: String) = when { name == &quot;Tom&quot; -&gt; 86 name == &quot;Jim&quot; -&gt; 77 name == &quot;Jack&quot; -&gt; 95 name == &quot;Lily&quot; -&gt; 100 else -&gt; 0 } 通常 when 语句的括号里都是有参数的，如果不在括号里写参数就要再匹配项前面添加参数。 3.循环语句 在 Java 中提供了 for、while 新欢，在 Kotlin 中同样也提供了这两种循环，其中 while 循环没有一点差异，所以这里直接讲解 for 循环。 3.1 使用 Kotlin 中的 for-in 循环在使用循环之前先说明一下如何声明区间，例如在 Kotlin 中声明 [0, 10] 之间的区间使用val range = 0..10的形式，其中 .. 是创建两端闭区间的关键字。 val range = 0..10 for (i in range) { println(i) } 如果想声明[0, 10)这个区间可以使用 until 替代 .. for (i in 0 until 10) { println(i) } 默认情况下，i 会每次自增 1，如果想让 i 一次加 2 的话可以使用 step 2实现，3，4，5.。。n 也是同样的道理。 for (i in 0 until 10 step 2) { println(i) } 注意：在进行遍历时左边的数值必须小于右边的数值，如果想实现降序的话要使用downTo替代。 for (i in 20 downTo 10 step 2) { println(i) } 4.面向对象编程4.1 类和对象/** * 创建 Person 实体类，由于需要创建对象后再给属性赋值， * 所以这里使用 var 而不是 val */ class Person { var name = &quot;&quot; var age = 0 fun eat() { println(name + &quot; is eating. He is &quot; + age + &quot; years old&quot;) } } fun main() { val p = Person() p.name = &quot;Jack&quot; p.age = 19 p.eat() } 在 Kotlin 中取消了 new 关键字，因为调用构造函数就是为了实例化，所以进行了精简。 4.2 继承和构造函数 如果定义一个学生类他的里面会包含如学号、年级等属性，但学生也是人，也需要姓名、年龄等属性，如果再重新添加姓名和年龄属性会有冗余代码。所以这里可以使用继承的概念，这样Student类就自动拥有了Person类的属性。 4.2.1 创建学生类class Student { var sno = &quot;&quot; var grade = 0 } 要是想继承 Person 类，必须让 Person 类具有可以被继承的能力，这也是 Kotlin 与 Java 不同的地方，这么设计的原因和 val 的设计理念时相同的，因为如果一个类可以随便被继承就有可能会产生风险，在 Effective Java 一书中就指出，如果一个类不是专门为继承而设计的，那么就应该主动加上 final 关键字，禁止它可以被继承。 很明显 Kotlin 在设计时就遵循了这个规范，默认所有非抽象类时不可以被继承的，之所以一直说非抽象类，是因为抽象类本身是无法创建实例的，一定要由子类去继承它才可以创建实例，因此抽象类必须要被继承，否则就没有意义了。 在 Kotlin 中要想让一个类有被继承的能力，只需要在类前面添加 open 关键字。 open class Student { var sno = &quot;&quot; var grade = 0 } 4.2.2 继承 Person 类/** * 创建 Person 实体类，由于需要创建对象后再给属性赋值， * 所以这里使用 var 而不是 val。 * 添加 open 让类可以被继承 */ open class Person { var name = &quot;&quot; var age = 0 fun eat() { println(name + &quot; is eating. He is &quot; + age + &quot; years old&quot;) } } /** * Kotlin 中的继承与 Java 不同，Java 中使用 extends 关键字， * 在 Kotlin 中使用 : 代替，被继承的类必须要调用它的构造函数， * 否则会报错 */ class Student : Person() { var sno = &quot;&quot; var grade = 0 } 在 Kotlin 中每个类都默认自带一个无参的主构造函数（在 Kotlin 中有主构造函数和次构造函数之分），你也可以主动的指明参数，主构造函数是最常用的构造函数，它没有函数体，直接定义在类名后面即可。 4.2.3 使用主构造函数class Student(val sno: String, val grade: Int) : Person() {} val student = Student(&quot;a123&quot;, 5) 构造函数的参数直接写在类后面即可，如果想在主构造函数中编写一些逻辑的话，可以使用 init 声明结构体， class Student(val sno: String, val grade: Int) : Person() { // 将主构造函数的逻辑写在 init 结构体中 init { println(&quot;sno is &quot; + sno) println(&quot;grade is &quot; + grade) } } val student = Student(&quot;a123&quot;, 5) 这样书写后可以在初始化 Student 类时打印 sno 和 grade 的值，这里的一个规范与 Java 中相同，就是在初始化子类时必须调用父类的构造函数。但是这么写会调用父类的哪个构造方法呢，这取决于 Person() 中的括号中有几个参数，这里没有传入参数，所以会调用父类的无参构造函数。 将 Person 和 Student 的构造函数进行一下修改 open class Person(val name: String, val age: Int) { } class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) { } val student = Student(&quot;a123&quot;, 5, &quot;Jack&quot;, 19) 注意：在 Student 的主构造函数中添加 name 和 age 字段时，不能再将它们声明为 val，因为在主构造函数中声明成 val 或者 var 的参数会自动成为该类的字段，这回导致和父类中同名的 name 和 age 字段造成冲突，因此在这里的 name 和 age 前面不需要加任何关键字，让它的作用域仅限定在主构造函数中即可。 4.2.4 使用次构造函数Kotlin 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用，但是考虑到知识结构的完整性，还是说一下此构造函数的相关知识并探讨一下括号的问题在次构造函数上的区别。 一个类只能有一个主构造函数，但是可以有多个次构造函数，次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它有函数体。 Kotlin 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用），这里通过一个例子进行简单的阐明。 class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) { constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age) { } constructor() : this(&quot;&quot;, 0){ } } 这里定义了两个次构造函数，第一个次构造函数接收 name 和 age 参数，然后又通过 this 调用主构造函数，并将 sno 和 grade 参数赋值，第二个次构造函数不接收任何参数，通过 this 调用了上面的次构造函数，并将 name 和 age 参数也成功进行了赋值，由于第二个次构造函数间接的调用了主构造函数，所以这也是合法的。 这么写完之后就拥有了三种初始化 Student 类的方式 val student1 = Student() val student2 = Student(&quot;Jack&quot;, 19) val student3 = Student(&quot;a123&quot;, 5, &quot;Jack&quot;, 19) 在一个类中显式的设置了次构造函数并且没有显式的设置主构造函数，此时是没有主构造函数的，这种操作在 Kotlin 中是允许的。 class Student : Person { constructor(name: String, age: Int) : super(name, age) { } } 这里的 Student 类的后面没有显式的定义主构造函数，同时又因为定义了次构造函数，所以现在 Student 类是没有主构造函数的，那么在继承 Person 类是就不需要再添加括号了，另外由于没有主构造函数，次构造函数只能显式的调用父类的构造函数，所以可以将 this 换成 super。 4.3 接口 Kotlin 中的接口和 Java 几乎完全一样，我们都知道 Java 是单继承结构的语言，任何一个类最多只能继承一个父类，但是却可以实现多个接口，Kotlin 也是如此。我们可以定义一系列抽象行为，然后由具体的类去实现。下面还是通过代码进行演示。 4.3.1 使用接口interface Study { fun readBooks() fun doHomework() } 让 Student 类实现 Study 接口 class Student(name: String, age: Int) : Person(name, age), Study { override fun readBooks() { println(name + &quot; is reading.&quot;) } override fun doHomework() { println(name + &quot; is doing homework&quot;) } } 在 Java 中实现接口使用 implements 关键字，在 Kotlin 中无论是继承还是实现接口都是用 “:” 替代，中间使用逗号（,）隔开即可，另外在实现接口时不需要在接口后面加括号，因为接口没有构造函数。 在 main 方法中调用方法 fun main() { val student = Student(&quot;Jack&quot;, 19) doStudy(student) } fun doStudy(study: Study) { study.readBooks() study.doHomework() } 4.3.2 对接口中的函数默认实现interface Study { fun readBooks() fun doHomework() { println(&quot;do homework default implementation.&quot;) } } 如果像之前那么写，在实现接口时里面的两个方法都必须实现，如果改成这样的话，只需要强制实现 readBooks() 函数了，doHomework()可以选择写或者不写，不写的话则会打印do homework default implementation.。 4.3.3 访问修饰符 在 Java 中一共由 public、private、protected、default（什么都不写）这四种修饰符，在 Kotlin 中有 public、private、protected、internal 这四种修饰符，想要使用那种修饰符时直接将修饰符写在 fun 前面即可。 首先 private 修饰符在两种语言中的作用一模一样，都表示只对当前类内部可见，public 修饰符的作用也是一致的，标识对所有类可见，但是在 Kotlin 中 public 修饰符是默认项，而在 Java 中是 default，前面书写的函数都没有加访问修饰符，那么这些函数的访问权限全部是 public。protected 在 Java 中表示对当前类，子类和同一个包路径下的类可见，在 Kotlin 中则表示只对当前类和子类可见。Kotlin 抛弃了 Java 中的 default 可见性（同一包路径下的类可见）。引入了一种新的可见性概念，只对同一模块中的类可见，使用的是 internal 修饰符。 比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将函数声明为 internal修饰的。 Java 和 Kotlin 可见性修饰符对照表 4.4 数据类和单例类 在一个规范的系统中，数据类通常占据者非常重要的角色，它们用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。其中常用的 MVC、MVP、MVVM 这些架构模式中的 M 值得就是数据类。 4.4.1 Java 中的数据类在 Java 中数据类需要重写 equals()、hashCode()、toString()方法，其中equals()用于判断两个数据类是否相等，hashCode()和 equals() 方法配套使用，toString()方法可以让输出打印更加清晰。 public class Cellphone { String brand; double price; public Cellphone(String brand, double price) { this.brand = brand; this.price = price; } @Override public boolean equals(Object obj) { if (obj instanceof Cellphone) { Cellphone other = (Cellphone) obj; return other.brand.equals(brand) &amp;&amp; other.price == price; } return false; } @Override public int hashCode() { return brand.hashCode() + (int) price; } @Override public String toString() { return &quot;Cellphone(brand=&quot; + brand + &quot;, price&quot; + price + &quot;)&quot;; } } 4.4.2 Kotlin 中的数据类data class Cellphone(val brand: String, val price: Double) 在 Kotlin 中只需要这一行代码即可，其中神奇的地方在于 class 前面的 data 关键字，有了这个关键字就表明我们想要声明一个数据类，Kotlin 会根据主构造函数中的参数帮你将 equals()、hashCode()、toString()方法自动生成，从而减少了开发的工作量。 编写 main 函数进行测试 fun main() { val cellphone1 = Cellphone(&quot;Samsung&quot;, 1299.99) val cellphone2 = Cellphone(&quot;Samsung&quot;, 1299.99) println(cellphone1) println(&quot;cellphone1 equals cellphone2 &quot; + (cellphone1 == cellphone2)) } 注意：如果将 class 前面的 data 去掉，那么它们的返回值就会变为 false。 4.4.3 单例类 在讲解单例类之前先说一下 Java 中的单例模式，单例模式主要是为了防止为一个对象创建多个实例，在 Kotlin 中如果想实现类似功能可以使用单例类 4.4.4 Java 中的单例类public class Singleton { private static Singleton INSTANCE = null; private Singleton() {} public synchronized static Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); } return INSTANCE; } public void singletonTest() { System.out.println(&quot;singletonTest is called.&quot;); } } 4.4.5 Kotlin 中的单例类object Singleton { fun singletonTest() { println(&quot;singletonTest is called.&quot;) } } 在 Kotlin 中实现单例要比 Java 中简单的多，只需要使用 object 关键字即可，在这其中 Kotlin 帮我们创建了一个 Singleton 类的实例，并且保证全局只存在一个 Singleton 实例。 5.Lambda 表达式 在 JDK1.8 中引入了 lambda 表达式，实现相同的功能时 lambda 表达式写法会使用更少的代码，从而提升开发效率。在 Kotlin 中也有 lambda 表达式，下面将对此进行介绍。 5.1 集合的创建和遍历现在有一个需求，创建一个包含许多水果名称的集合，如果在 Java 中会创建一个 ArrayList 然将水果的名称一个个的添加进集合中，当然在 Kotlin 中也可以这么做。 fun main() { val list = ArrayList&lt;String&gt;() list.add(&quot;Apple&quot;) list.add(&quot;Banana&quot;) list.add(&quot;Orange&quot;) list.add(&quot;Pear&quot;) list.add(&quot;Grape&quot;) } 数据少的时候这么写一点问题都没有，但是问题在于数据量多的时候这么写就会显得很罗嗦，所以可以使用 Kotlin 中内置的 listOf() 函数来简化初始化集合的写法，写法如下： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) for (fruit in list) { println(fruit) } 注意：在这里使用 listOf()函数创建的是一个不可变的集合。在 Java 中没有不可变的集合，但是在 Kotlin 中不可变的集合指的是，该集合中的元素只能用于读取，不能进行添加、修改或者删除。 这么设计的理由和 val、类默认不可继承是一样的，可见 Kotlin 在不可变性方面的控制及其严格。那么如果我们确实需要创建一个可变的集合，可以使用mutableListOf()函数即可。 val list = mutableListOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) list.add(&quot;Watermelon&quot;) for (fruit in list) { println(fruit) } 前面介绍的 List 集合的用法其实和 Set 一模一样，只需要将创建集合的方法换成 setOf()和 mutableSetOf() 即可。 val set = setOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) for (fruit in set) { println(fruit) } println(&quot;==========================&quot;) val mutableSet = mutableSetOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) mutableSet.add(&quot;Watermelon&quot;) for (fruit in mutableSet) { println(fruit) } 接下来讲解的 Map 和前面的 List 和 Set 有很大的不同，传统的 Map 用法是先创建一个 HashMap 的实例，然后将一个个的键值对添加到 Map 中，比如给每个水果一个对应的编号。 val map = HashMap&lt;String, Int&gt;() map.put(&quot;Apple&quot;, 1) map.put(&quot;Banana&quot;, 2) map.put(&quot;Orange&quot;, 3) map.put(&quot;Pear&quot;, 4) map.put(&quot;Grape&quot;, 5) 这种写法与 Java 中的写法相似，但是在 Kotlin 中并不建议使用 put() 和 get() 方法对 Map 进行添加和读取操作，而是更加建议使用一种类似于数组下标的语法结构，比如向 Map 中添加一条数据可以这么写： map[&quot;Apple&quot;] = 1 从 Map 中读取一条数据可以这么写 val number = map[&quot;Apple&quot;] 因此可以将代码优化为一下形式 val map = HashMap&lt;String, Int&gt;() map[&quot;Apple&quot;] = 1 map[&quot;Banana&quot;] = 2 map[&quot;Orange&quot;] = 3 map[&quot;Pear&quot;] = 4 map[&quot;Grape&quot;] = 5 这样的写法也不是最简便的，在 Kotlin 中提供了一个 mapOf() 和 mutableMapOf() 函数来继续简化 Map 的用法。在 mapOf() 函数中，我们可以直接传入初始化的键值对组合来完成对 Map 集合的创建： val map = mapOf(&quot;Apple&quot; to 1, &quot;Banana&quot; to 2, &quot;Orange&quot; to 3, &quot;Pear&quot; to 4, &quot;Grape&quot; to 5) // for (entry in map) { // println(entry.key + &quot;\\t&quot; + entry.value) // } for ((fruit, number) in map) { println(&quot;fruit is &quot; + fruit + &quot;, number is &quot; + number) } 5.2 集合的函数式 API需求：如何在一个水果集合中找到单词最长的哪个水果？ 传统实现方式 val list = mutableListOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) var maxLengthFruit = &quot;&quot;; for (fruit in list) { if (fruit.length &gt; maxLengthFruit.length) { maxLengthFruit = fruit } } println(&quot;max length fruit is &quot; + maxLengthFruit) 使用集合 API 实现 val list = mutableListOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val maxLengthFruit = list.maxBy { it.length } println(&quot;max length fruit is &quot; + maxLengthFruit) 5.2.1 Lambda 表达式语法结构{参数名1： 参数类型, 参数名2: 参数类型 -&gt; 函数体} 这是 Lambda 表达式最完整的语法结构定义，首先最外层是一对大括号，如果有参数传入到 Lambda 表达式中的话，还需要声明参数列表，参数列表的结尾使用 -&gt; 符号，表示参数列表的结束以及函数体的开始，函数体中可以编写任意行代码，并且最后一行代码自动作为返回值。 5.2.2 Lambda 表达式写法演进 最初写法 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val lambda = { fruit: String -&gt; fruit.length } val maxLengthFruit = list.maxBy(lambda) 简化版本1 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val maxLengthFruit = list.maxBy({ fruit: String -&gt; fruit.length }) 简化版本2 Kotlin 规定当函数的最后一个参数是 Lambda 时，可以将 Lambda 表达式写在最外面. val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val maxLengthFruit = list.maxBy() { fruit: String -&gt; fruit.length } 简化版本3 当 Lambda 参数是函数的唯一一个参数的话，可以省略函数的括号。 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val maxLengthFruit = list.maxBy { fruit: String -&gt; fruit.length } 简化版本4 由于 Kotlin 的推导机制，Lambda 的参数列表在大多数情况下不必声明参数类型，因此代码可以进一步简化。 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val maxLengthFruit = list.maxBy { fruit -&gt; fruit.length } 简化版本5 当 Lambda 表达式的参数列表中只有一个参数时，可以不必声明参数名，可以用 it 代替。 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val maxLengthFruit = list.maxBy { it.length } 5.2.3 使用 map 函数 集合中的 map 函数时最常用的一种函数式 API，它用于将集合中的每一个元素都映射成一个另外的值，映射的规则在 Lambda 表达式中指出，最终生成一个新的集合。 需求：让所有的水果命都变成大写模式 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val newList = list.map { it.toUpperCase() } for (fruit in newList) { println(fruit) } 5.2.4 使用 filter 函数 filter 函数是用来过滤集合中的数据的，它可以单独使用。 需求：只保留集合中字符长度大于5的水果名，并将符合条件的水果名转换为大写 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val newList = list.filter { it.length &lt;= 5 }.map { it.toUpperCase() } for (fruit in newList) { println(fruit) } 在这个例子中如果先调用 map() 再调用 filter() 也是可以的，但是效率会有影响，因为这么做会让转换的次数增加。 5.2.5 使用 any 和 all 函数 any 函数用于判断集合种是否至少存在一个元素满足指定条件，all 函数用于判断集合中是否所有元素都满足给定条件。 val list = listOf(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val anyResult = list.any { it.length &lt;= 5 } val allResult = list.all {it.length &lt;= 5 } println(&quot;anyResult is &quot; + anyResult + &quot;, allResult is &quot; + allResult) 5.3 Java 函数式 API 的使用 如果我们再 Kotlin 代码中调用了一个 Java 方法，并且该方法接收一个 Java 单抽象方法接口参数，就可以使用函数式 API。 5.3.1 演示单抽象接口 Java 中 @FunctionalInterface public interface Runnable { public abstract void run(); } 对于任何一个 Java 方法，只要它接收 Runnable 参数，就可以使用函数时 API。不过 Runnable 接口主要还是结合线程来一起使用的，因此这里就通过 Java 的线程类 Thread 进行学习。 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;Thread is running.&quot;); } }).start(); Kotlin 中 Thread(object : Runnable { override fun run() { println(&quot;Thread is running.&quot;) } }).start() 与 Java 写法不同的是，Kotlin 中使用 object 关键字代替了 new 关键字。 简化1 Thread(Runnable { println(&quot;Thread is running.&quot;) }).start() 由于 Runnable 接口中只有一个方法，所以没有手动实现的话，Kotlin 就会推导出 Lambda 表达式里要写的是 run() 方法中的内容。 简化2 由于 Java 方法的参数列表中不存在一个以上 Java 单抽象方法接口参数，所以可以将接口名省略。 Thread({ println(&quot;Thread is running.&quot;) }).start() 简化3 由于 Lambda 中只有一个参数，所以可以将括号花括号内的内容移动到外面，并且还可以将函数的括号省略，所以简写成如下形式： Thread { println(&quot;Thread is running.&quot;) }.start() 总结：本小节学习的 Java 函数式 API 的使用都现定于 Kotlin 中调用 Java 方法，并且单抽象方法接口也必须是用 Java 语言定义的，这么设计是因为 Kotlin 中有专门的高阶函数来实现更加强大的自定义函数式 API 功能，从而不需要像 Java 这样借助单抽象方法接口来实现。 6.空指针检查 Java 程序在运行时遇到空指针异常导致运行崩溃的例子数不胜数，究其原因是因为空指针异常时一种运行时异常，需要开发者手动进行检测。 6.1 处理空指针异常public void doStudy(Study study) { study.readBooks(); study.doHomework(); } 以上的代码就很有可能出现空指针异常，具体能否出现完全要看传入的 study 是否为空，为 了避免空指针异常的发生，通常都会做如下操作： public void doStudy(Study study) { if (study != null) { study.readBooks(); study.doHomework(); } } 这只是一小段代码，如果在一个比较大的工程中要想完全避免空指针异常并不现实。 6.2 可空类型系统 Kotlin 就很科学的解决了这个问题，它利用编译时判空检查的机制几乎杜绝了空指针异常。虽然编译时判空检查的机制会导致代码变得比较难写，但是不用担心，Kotlin 提供了一整套辅助工具，让我们可以轻松的完成判空任务。 6.2.1 回到 Kotlin 代码fun doStudy(study: Study) { study.readBooks() study.doHomework() } 这段代码看上去和 Java 的没有什么区别，但是在 Kotlin 中所有参数和变量都不能为空，所以这段代码不可能出现空指针。 经过 Kotlin 的检测，避免了所有对象为空的可能，但是有时候就是需要传入空对象，这该怎么办呢？ Kotlin 提供了一套可为空的类型系统，只不过在使用可为空的类型系统时，我们需要在编译时期就将所有潜在的空指针异常处理掉。 使用可为空类型的系统时只需要在类型参数后面添加一个 ? 即可，例如 6.3 判空辅助工具6.3.1 ?. 操作符当对象不为空时进行正常调用，为空就什么都不做 传统写法： fun doStudy(study: Study?) { if (study != null) { study.readBooks() study.doHomework() } } 优化写法： fun doStudy(study: Study?) { study?.readBooks() study?.doHomework() } 6.3.2 ?: 操作符这个操作符两边都接收一个表达式，如果左边表达式的结果不为空就返回左边的结果，否则返回右边的。 传统写法 val c = if (a != null) { a } else { b } 优化写法 val c = a ?: b 需求：编写一个函数用来获得一段文本的长度 传统写法： fun getTextLength(text: String?): Int { if (text != null) { return text.length } return 0 } 优化写法： fun getTextLength(text: String?) = text?.length ?: 0 6.3.3 !!. 操作符Kotlin 有的时候也不很智能，比如已经做了非空判断，但是调用时依然无法通过编译，那么此时可以使用非空断言工具!!。即可。 注意：这种写法存在风险，这样写意在告诉 Kotlin，我这里一定不为空，如果为空后果我自己承担。 6.3.4 let 函数 let 函数提供了函数式 API 的编程接口，并将原始调用对象作为参数传递到 Lambda 表达式中。 obj.let { obj2 -&gt; // 编写具体的业务逻辑 } 可以看到这里调用了 obj 对象的 let 函数，然后 Lambda 表达式中的代码就会立即执行，并且这个 obj 对象本身还会作为参数传递到 Lambda 表达式中。不过为了防止变量重名，我将 obj 改为了 obj2 ，但是它们是同一个对象。 使用 let 函数配合 ?. 操作符检查空指针 原代码 fun doStudy(study: Study?) { study?.readBooks() study?.doHomework() } 这种写法与传统的 if 判断的写法的区别在于使用 ?. 替代了 if，但是这里要调用的方法很多的话就需要写多次 ?.，这种重复的操作就可以使用 let 函数配合解决。 优化版本1： fun doStudy(study: Study?) { study?.let { stu -&gt; stu.readBooks() stu.doHomework() } } 这样会在对象不为空时调用 let 函数，并且只需要写一遍 ?.。 优化版本2： 在 Kotlin 中，Lambda 表达式如果只有一个参数，可以省略，使用 it 代替。 fun doStudy(study: Study?) { study?.let { it.readBooks() it.doHomework() } } 7.Kotlin 中的小魔术7.1 字符串内嵌表达式使用字符串表达式再也不需要傻傻的拼接 字符串了，在 Kotlin 中，可以直接使用字符串内嵌表达式，即使是非常复杂的字符串也可以轻而易举地完成。 7.1.1 内嵌表达式语法&quot;hello, ${obj.name}. nice to meet you!&quot; 在 Kotlin 中允许我们在字符串里嵌入 ${}这种语法结构的表达式，并在运行时使用表达式的执行结果替代这一部分的内容。另外，当表达式中只有一个变量的时候，可以直接使用 $name 的形式进行简写，无需添加花括号了。 val brand = &quot;Samsung&quot; val price = 1299.00 println(&quot;Cellphone(brand=$brand, price=$price)&quot;) // 使用字符串表达式 println(&quot;Cellphone(brand = &quot;+ brand +&quot;, price = &quot; + price + &quot;)&quot;) // 不使用 7.2 函数的参数默认值 前面学习次构造函数的用法时提到过，次构造函数在 Kotlin 中很少使用，因为 Kotlin 提供了给函数设定参数默认值的功能，它在很大程度上能够替代次构造函数的作用。 具体来讲，我们可以在定义函数的时候给任意参数设定一个默认值，这样当调用此函数时就不会强制要求调用方为此参数传值，在没有传值的情况下会自动使用参数的默认值。 7.2.1 给函数设定默认值fun printParams(num: Int, str: String = &quot;hello&quot;) { println(&quot;num is $num, str is $str&quot;) } printParams(1) printParams(1, &quot;哈哈&quot;) fun printParams(num: Int = 100, str: String) { println(&quot;num is $num, str is $str&quot;) } 如果我们想为 num 设置默认值，只传字符串的参数值的话，像上面那么写就会报错了 解决：将传递的参数指定参数名 fun printParams(num: Int = 100, str: String) { println(&quot;num is $num, str is $str&quot;) } printParams(str = &quot;world&quot;) 7.2.2 用默认值替代次构造函数 原来的代码 class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) { constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age) { } constructor() : this(&quot;&quot;, 0){ } } 这个构造函数的功能主要就是在调用无参构造函数时会对两个参数的构造函数进行调用，并赋初始值，两个参数的构造函数会调用四个参数的构造函数，并赋初始值，这完全可以使用函数默认值的方式进行替代。 优化后的代码 class Student(val sno: String = &quot;&quot;, val grade: Int = 0, name: String = &quot;&quot;, age: Int = 0) : Person(name, age) { }","categories":[],"tags":[]}],"categories":[{"name":"Category1","slug":"Category1","permalink":"https://jiyugithub.github.io/categories/Category1/"},{"name":"Category2","slug":"Category1/Category2","permalink":"https://jiyugithub.github.io/categories/Category1/Category2/"}],"tags":[{"name":"Tag1","slug":"Tag1","permalink":"https://jiyugithub.github.io/tags/Tag1/"},{"name":"Tag2","slug":"Tag2","permalink":"https://jiyugithub.github.io/tags/Tag2/"}]}