<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Apocalypse&#39;s Blog">
<meta property="og:url" content="https://jiyugithub.github.io/index.html">
<meta property="og:site_name" content="Apocalypse&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Apocalypse">
<meta name="twitter:card" content="summary"><meta name="keywords" content="Apocalypse, Apocalypse's Blog"><meta name="description" content=""><title>Apocalypse's Blog</title><link ref="canonical" href="https://jiyugithub.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Apocalypse's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/switcher/">炫酷！从未见过如此Q弹的Switcher</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/switcher/" data-flag-title="炫酷！从未见过如此Q弹的Switcher"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>
      <p>最近逛<code>Dribbble</code>的时候，看到了一个非常酷的<code>Switcher</code>动画，特别喜欢，本想着试着用代码在Android平台来实现一下，没想到已经有实现的版本，并且作者还写了文章分享，思路清晰，各个实现关键点都讲的特别清楚，因此就译诚中文，分享大家，正如作者最后所说，大家一定要运行试试，效果非常赞！</p>
<blockquote>
<p>原作者：<span class="exturl"><a class="exturl__link"   href="https://android.jlelse.eu/@bitvale?source=post_page-----433258cbb80f----------------------"  target="_blank" rel="noopener">Alexander Kolpakov</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 译者：<span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/u/35167a70aa39"  target="_blank" rel="noopener">依然范特稀西</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 地址：<span class="exturl"><a class="exturl__link"   href="http://suo.im/60UJjT"  target="_blank" rel="noopener">http://suo.im/60UJjT</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="正文开始"   >
          <a href="#正文开始" class="heading-link"><i class="fas fa-link"></i></a>正文开始</h3>
      <p>最近，我写了一篇关于实现Dribbble上的一个漂亮设计的文章。得到了很多积极的反馈，对我来说，这给了我很大的动力。我非常高兴能获得这些反馈，同时我也很乐意分享我的经验。</p>
<p>在本文中，我们将尝试逐步实现由<code>Oleg Frolov</code>创建的另一个精美的动画。这与上一篇文章中的复杂动画UI无关，它是一个自定义小控件。但是它有着非常精美漂亮的动画设计，如下所示：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/12/170cd50c1a6eecc9?imageslim" style=""  alt="swicher.gif">swicher.gif</p>
<p>乍一看，实现这样的切换似乎并不简单，但我认为那是因为动画非常漂亮。如 你所见，创建相同的动画并不难。让我们一步一步地来实现它。</p>
<p>第一步，我们需要自定义View,并且实现它的3个构造方法：</p>
<pre><code>class Switcher @JvmOverloads constructor(
        context: Context,
        attrs: AttributeSet ? = null,
        defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    init {
        attrs?.let { retrieveAttributes(attrs, defStyleAttr) }
    }

    private fun retrieveAttributes(attrs: AttributeSet, defStyleAttr: Int) {
        // retrieve cutom attributes
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        // setup switcher width and height
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        // setup helper sizes every time switcher size changed (radius, icon width...)
    }

    override fun onDraw(canvas: Canvas ?) {
        // just draw
    }
}
</code></pre>
        <h3 id="接下来开始绘制"   >
          <a href="#接下来开始绘制" class="heading-link"><i class="fas fa-link"></i></a>接下来开始绘制</h3>
      <p>在默认（选中）状态下，我们的开关由2个圆角矩形（绿色和白色）组成</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/12/170cd50c1f123a19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>绘制它们非常简单，我们只需要计算白色矩形的位置并将偏移量<code>iconTranslateX</code>传递给Android KTX <code>Canvas.withTranslation</code>扩展即可：</p>
<pre><code>override fun onDraw(canvas: Canvas ?) {
  // draw switcher (green rect)
  canvas?.drawRoundRect(switcherRect, switcherCornerRadius, switcherCornerRadius, switcherPaint)

  // draw icon (white rect)
  canvas?.withTranslation(x = iconTranslateX) {
      drawRoundRect(iconRect, switcherCornerRadius, switcherCornerRadius, iconPaint)
  }
}
</code></pre>
        <h3 id="开始分解动画"   >
          <a href="#开始分解动画" class="heading-link"><i class="fas fa-link"></i></a>开始分解动画</h3>
      <p>动画部分，我们使用<code>ValueAnimator</code>来实现，使用它的<code>ofFloat(float... values)</code>方法,我们需要三个动画：</p>
<ul>
<li>1、<code>switcherAnimator</code>: 切换器图标动画，从白色矩形到圆形，反之亦然</li>
<li>2、<code>translateAnimator</code>: 为切换器图标从左到右的过渡设置动画，反之亦然；</li>
<li>3、<code>colorAnimator</code>: 将颜色从绿色（选中）更改为红色，反之亦然。</li>
</ul>
<p>让我们先看一下<code>switcherAnimator</code>动画，设置<code>0</code>为动画的开始值，<code>1</code>为动画的结束值。</p>
<pre><code>// ...
var amplitude = BOUNCE_ANIM_AMPLITUDE_IN
var frequency = BOUNCE_ANIM_FREQUENCY_IN
var newProgress = 1f

if (!checked) {
    amplitude = BOUNCE_ANIM_AMPLITUDE_OUT
    frequency = BOUNCE_ANIM_FREQUENCY_OUT
    newProgress = 0f
}

val switcherAnimator = ValueAnimator.ofFloat(iconProgress, newProgress).apply {
    addUpdateListener {
        iconProgress = it.animatedValue as Float
    }
    interpolator = BounceInterpolator(amplitude, frequency)
    duration = SWITCHER_ANIMATION_DURATION
}
// ...
</code></pre><p>我们可以使用 <span class="exturl"><a class="exturl__link"   href="https://github.com/evgenyneu"  target="_blank" rel="noopener">Evgenii Neumerzhitckii</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 写的<code>BounceInterpolator</code>来实现反弹效果，这非常适合我们的动画场景，不了解的可以看一下这片文章：<span class="exturl"><a class="exturl__link"   href="https://evgenii.com/blog/spring-button-animation-on-android/"  target="_blank" rel="noopener">evgenii.com/blog/spring…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，它解释了<code>BounceInterpolator</code>是如何工作的。</p>
<p>在Android KTX <code>addUpdateListener</code>扩展中，我们更新了<code>progress</code>的值，然后触发<code>invalidate</code>方法，最后重新绘制了视图。</p>
<pre><code>private var iconProgress = 0f
  set(value) {
      if (field != value) {
          field = value

          val iconOffset = lerp(0f, iconRadius - iconCollapsedWidth / 2, value)
          iconRect.left = width - switcherCornerRadius - iconCollapsedWidth / 2 - iconOffset
          iconRect.right = width - switcherCornerRadius + iconCollapsedWidth / 2 + iconOffset

          postInvalidateOnAnimation()
      }
  }
</code></pre><p><code>lerp</code>方法类似一个线性插值器，它用于计算<code>iconOffset</code>,反过来，它也用于计算<code>Swicher</code>图标的圆角矩形坐标。此图标的矩形从一个圆角矩形变为一个圆形（圆角半径较大的圆角矩形）。</p>
<blockquote>
<p>我们使用了<code>postInvalidateOnAnimation()</code>代替<code>postIvalidate</code>,是因为我们需要平滑的动画，并且第一个方法有优势，详情请看：<span class="exturl"><a class="exturl__link"   href="https://stackoverflow.com/questions/29219372/postinvalidateonanimation-vs-postinvalidate/42648958#42648958"  target="_blank" rel="noopener">stackoverflow.com/questions/2…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><code>translateAnimator</code>的工作方式相同，但是会更新<code>Swicher</code>图标的<code>x</code>位置。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/12/170cd50c209a787a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>如你所见，我们的白色圆圈就像百吉饼。我们有2种制作方法：</p>
<ul>
<li>裁剪一个较小的圆圈</li>
<li>最简单的圆圈，只需在顶部绘制另一个小圆圈，然后用切换器颜色填充即可。</li>
</ul>
<p>我选择较简单的一种。</p>
<p>这一切，没什么难的！我们现在有一个漂亮的自定义小控件并且带有精美的动画！</p>

        <h3 id="至此，我们一切都可以了"   >
          <a href="#至此，我们一切都可以了" class="heading-link"><i class="fas fa-link"></i></a>至此，我们一切都可以了</h3>
      <p>现在，我们可以使用任何类型的动画来创建自定义视图，而且我们可以稍微更改代码以创建另一个由<code>Oleg Frolov</code>设计的<code>Swicher</code>小部件。仅需将视图轮廓从圆角矩形更新为圆形，并禁用平移动画。就是这么简单。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/12/170cd50c223d523d?imageslim" style=""  alt="swicherX.gif">swicherX.gif</p>

        <h3 id="Talk-is-Chep，Just-show-Code"   >
          <a href="#Talk-is-Chep，Just-show-Code" class="heading-link"><i class="fas fa-link"></i></a>Talk is Chep，Just show Code</h3>
      <p>随意获取GitHub上的源代码，查看我的其他实现，别忘了尝试一下！ Github: <span class="exturl"><a class="exturl__link"   href="https://github.com/bitvale/Switcher"  target="_blank" rel="noopener">github.com/bitvale/Swi…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/Kotlinyf/">Kotlin实战 | 语法糖</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/Kotlinyf/" data-flag-title="Kotlin实战 | 语法糖"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>学习了 Kotlin 后，写代码时常有一种“闹革命”的冲动，总是希望运用语法糖推翻“旧世界”（这样不好，项目会 delay 的~）。本文归纳了 Kotlin 语法糖在项目实战中的综合运用，以实际问题为索引，在分析解决方案的同时介绍相关语法知识。</p>

        <h2 id="将-px-值转换成-dp-值"   >
          <a href="#将-px-值转换成-dp-值" class="heading-link"><i class="fas fa-link"></i></a>将 px 值转换成 dp 值</h2>
      <p>在非 xml 环境下构建布局，需要将 px 转换为 dp 来进行多屏幕适配。Java 的做法是在<code>Util</code>类中新增一个静态函数。利用 Kotlin 的扩展属性可以更简洁地实现：</p>
<pre><code>val Int.dp: Int
    get() {
        return TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP,
            this.toFloat(),
            Resources.getSystem().displayMetrics
        ).toInt()
    }
</code></pre><p>为 Int 扩展一个属性<code>dp</code>，它的类型是 Int。在<code>get()</code>中定义该属性的取值算法。</p>
<p>然后就可以像这样动态地将 Int 值 dp 化：</p>
<pre><code>viewGroup.addView( textView, LayoutParam( 40.dp, 50.dp ) )
</code></pre>
        <h2 id="弃用Builder模式"   >
          <a href="#弃用Builder模式" class="heading-link"><i class="fas fa-link"></i></a>弃用Builder模式</h2>
      <p>当构造复杂对象时，需要很多参数，如果将所有参数都通过一个构造函数来传递，缺乏灵活性，但如果重载若干个带有不同参数的构造函数，代码就变得臃肿。Builder 模式可以简化构建过程。</p>
<p>在 Java 中 Builder模式 代码如下：</p>
<pre><code>public class Person {
    //&#39;必选参数&#39;
    private String name;
    //&#39;以下都是可选参数&#39;
    private int gender;
    private int age;
    private int height;
    private int weight;

    //&#39;私有构造函数，限制必须通过构造者构建对象&#39;
    private Person(Builder builder) {
        this.name = builder.name;
        this.gender = builder.gender;
        this.age = builder.age;
        this.height = builder.height;
        this.weight = builder.weight;
    }

    //&#39;构造者&#39;
    public static class Builder {
        private String name;
        private int gender;
        private int age;
        private int height;
        private int weight;

        //&#39;必选参数必须在构造函数中传入&#39;
        public Builder(String name) {
            this.name = name;
        }

        //&#39;以下是每个非必要属性的设值函数，它返回构造者本身用于链式调用&#39;
        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder gender(int gender) {
            this.gender = gender;
            return this;
        }

        public Builder height(int height) {
            this.height = height;
            return this;
        }

        public Builder weight(int weight) {
            this.weight = weight;
            return this;
        }

        //&#39;构建对象&#39;
        public Person build() {
            return new Person(this);
        }
    }

</code></pre><p>然后就可以像这样构建<code>Person</code>实例：</p>
<pre><code>//&#39;使用 Builder模式&#39;
Person p = new Person.Builder(&quot;taylor&quot;)
            .age(50)
            .gender(1)
            .weight(43)
            .build();

//&#39;使用构造函数&#39;
Person p2 = new Person(&quot;taylor&quot;, 50, 1, 0, 43);
</code></pre><p>对比之下，Builder模式 有两个优势：</p>
<ol>
<li>为参数标注语义：在Builder模式中，每个属性的赋值都是一个函数，函数名标注了属性语义。而直接使用构造函数时，很难分辨<code>50</code>，<code>43</code>哪个是年龄，哪个是体重。</li>
<li>可选参数：Builder模式中，除了必选参数，其他参数是可选的。但直接使用构造函数必须为所有参数赋值，比如上例中第四个参数身高被赋值为0。</li>
</ol>
<p>但 Builder模式 也有代价，新增了一个中间类<code>Builder</code>。</p>
<p>使用 Kotlin 的<code>命名参数</code>+<code>参数默认值</code>+<code>数据类</code>语法，在没有任何副作用的情况下就能实现 Builder模式：</p>
<pre><code>//&#39;将Person定义为数据类&#39;
data class Person(
    var name: String,
    //&#39;为以下可选参数设置默认值&#39;
    var gender: Int = 1,
    var age: Int= 0,
    var height: Int = 0,
    var weight: Int = 0
)

//&#39;使用命名参数构建Person实例&#39;
val p  = Person(name = “taylor”,gender = 1,weight = 43)
</code></pre><p>关于<code>数据类</code>、<code>参数默认值</code>、<code>命名参数</code>更详细的介绍可以点击<span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/5cdb9536e51d456e5c5babd4"  target="_blank" rel="noopener">这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>如果想增加参数约束条件可以调用<code>require()</code>方法：</p>
<pre><code>data class Person(
    var name: String,
    var gender: Int = 1,
    var age: Int= 0,
    var height: Int = 0,
    var weight: Int = 0
){
    //&#39;在构造函数被调用的时候执行参数合法检查&#39;
    init {
        require(name.isNotEmpty()){”name cant be empty“}
    }
}
</code></pre><p>此时如果像下面这样构造 Person，则会抛出异常：</p>
<pre><code>val p = Person(name=&quot;&quot;,gender = 1)
java.lang.IllegalArgumentException: name cant be empty
</code></pre>
        <h2 id="打印列表、map"   >
          <a href="#打印列表、map" class="heading-link"><i class="fas fa-link"></i></a>打印列表、map</h2>
      <p>调试程序时，经常需要打印列表内容，通常会这样打印：</p>
<pre><code>for (String str:list) {
    Log.v(&quot;test&quot;, &quot;str=&quot;+str);
}
</code></pre><p>不同业务界面的数据类型不同，为了调试，这样的 for 循环就会散落在各处，而且列表内容会分若干条 log 输出，中间极有可能被别的log打断。</p>
<p><strong>有没有一个函数可以打印包含任意数据类型的列表，并将列表内容组织成更具可读性的字符串？</strong></p>
<p>用 Kotlin  的<code>扩展函数</code>+<code>泛型</code>+<code>高阶函数</code>就能优雅地做到：</p>
<pre><code>fun &lt;T&gt; Collection&lt;T&gt;.print(map: (T) -&gt; String) =
    StringBuilder(&quot;\n[&quot;).also { sb -&gt;
        //&#39;遍历集合元素，通过 map 表达式将元素转换成感兴趣的字串，并独占一行&#39;
        this.forEach { e -&gt; sb.append(&quot;\n\t${map(e)},&quot;) }
        sb.append(&quot;\n]&quot;)
    }.toString()
</code></pre><p>为集合的基类<code>Collection</code>新增一个扩展函数，它是一个高阶函数，因为它的参数是另一个函数，该函数用 lambda 表示。再把集合元素抽象成泛型。通过<code>StringBuilder</code>将所有集合内容拼接成一个自动换行的字符串。</p>
<p>写段测试代码看下效果：</p>
<pre><code>data class Person(var name: String, var age: Int)

val persons = listOf(
    Person(&quot;Peter&quot;, 16),
    Person(&quot;Anna&quot;, 28),
    Person(&quot;Anna&quot;, 23),
    Person(&quot;Sonya&quot;, 39)
)

persons.print { &quot;${it.name}_${it.age}&quot; }.let { Log.v(&quot;test&quot;,it) }
</code></pre><p>打印结果如下：</p>
<pre><code>V/test: [
        Peter_16,
        Anna_28,
        Anna_23,
        Sonya_39,
    ]
</code></pre><p>同样地，可以如法炮制一个打印 map 的扩展函数：</p>
<pre><code>fun &lt;K, V&gt; Map&lt;K, V?&gt;.print(map: (V?) -&gt; String): String =
    StringBuilder(&quot;\n{&quot;).also { sb -&gt;
        this.iterator().forEach { entry -&gt;
            sb.append(&quot;\n\t[${entry.key}] = ${map(entry.value)}&quot;)
        }
        sb.append(&quot;\n}&quot;)
    }.toString()
</code></pre>
        <h2 id="将-data-类转换成-map"   >
          <a href="#将-data-类转换成-map" class="heading-link"><i class="fas fa-link"></i></a>将 data 类转换成 map</h2>
      <p>有些数据类字段比较多，调试时，想把它们通通打印出来，在 Java 中，借助于 AndroidStudio 的 <code>toString</code>功能倒是可以方便地生成可读性很高的字串：</p>
<pre><code>public class Person {
    private String name;
    private int age;

    @Override
    public String toString() {
        return ”Person{“ +
                ”name=‘“ + name + ’\” +
                ”, age=“ + age +
                ‘}’;
    }
}
</code></pre><p>但是每新建一个数据类都要手动生成一个<code>toString()</code>方法也挺麻烦。</p>
<p>利用 Kotlin 的 <code>data class</code>可以省去这一步，但打印效果是所有字段都在同一行中：</p>
<pre><code>data class Person(var name: String, var age: Int)

Log.v(“test”, “person=${Person(&quot;Peter&quot;, 16)}”)

//输出如下：
V/test: person=Person(name=Peter, age=16)
</code></pre><p>如果字段很多，把它们都打印在一行中可读性很差。</p>
<p><strong>有没有一种方法，可以读取一个类中所有的字段信息？</strong> 这样我们就可以将他们组织成想要的形状。请看下面这个方法：</p>
<pre><code>fun Any.ofMap() =
    //&#39;过滤掉除data class以外的其他类&#39;
    this::class.takeIf { it.isData }
        //&#39;遍历类的所有成员，过滤掉成员方法，只考虑成员属性&#39;
        ?.members?.filterIsInstance&lt;KProperty&lt;Any&gt;&gt;()
        //&#39;将成员属性名和值存储在Pair中&#39;
        ?.map { it.name to it.call(this) }
        //&#39;将Pair转换成map&#39;
        ?.toMap()
</code></pre><p>为任意 Kotlin 中的类添加一个<code>扩展函数</code>，它的功能是将<code>data class</code>中所有的字段名及其对应值存在一个 map 中。其中用到的 Kotlin 语法糖如下：</p>
<ul>
<li><code>isData</code>是<code>KClass</code>中的一个属性，用于判断该类是不是一个<code>data class</code>。<code>KClass</code>是 Kotlin 中用来描述 <strong>类的类型</strong>，<code>KClass</code>可以通过<code>对象::class</code>语法获得。</li>
<li><code>members</code>也是<code>KClass</code>中的一个属性，它包含了所有类的方法和属性。</li>
<li><code>filterIsInstance()</code>是<code>Iterable</code>接口的扩展函数，用于过滤出集合中指定的类型。</li>
<li><code>to</code>是一个<code>infix</code>扩展函数，它的定义如下：</li>
</ul>
<pre><code>public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that)
</code></pre><ul>
<li>带有<code>infix</code>标识的函数只允许带有一个参数，并且在调用时可以省略包裹参数的括号。这种语法叫<code>中缀表达式</code></li>
</ul>
<p>写段测试代码，结合上一节的打印 map 函数看下效果：</p>
<pre><code>data class Person(var name: String, var age: Int)

Person(&quot;Peter&quot;, 16).ofMap()?.print { it.toString() }.let { Log.v(&quot;test&quot;,&quot;$it&quot;) }
</code></pre><p>测试代码先将<code>Person</code>实例转换成 map，然后打印 map。输出结果如下：</p>
<pre><code>V/test:
    {
        [age] = 16
        [name] = Peter
    }
</code></pre><p>若<code>data class</code>嵌套会发生什么？</p>
<pre><code>//&#39;位置，嵌套在Person类中&#39;
data class Location(var x: Int, var y: Int)
data class Person(var name: String, var age: Int, var locaton: Location? = null)

Person(&quot;Peter&quot;, 16, Location(20, 30)).ofMap()?.print { it.toString() }.let { Log.v(&quot;test&quot;, &quot;$it&quot;) }

//&#39;打印结果如下&#39;
    {
        [age] = 16
        [locaton] = Location(x=20, y=30)
        [name] = Peter
    }
</code></pre><p>期望得到类似 Json 的打印效果，但输出结果还差一点。是因为将<code>Person</code>转化成<code>Map</code>时并没有将嵌套的<code>Location</code>也转化成键值对。</p>
<p>需要将<code>ofMap()</code>方法重构成递归调用：</p>
<pre><code>fun Any.ofMap(): Map&lt;String, Any?&gt;? {
    return this::class.takeIf { it.isData }
        ?.members?.filterIsInstance&lt;KProperty&lt;Any&gt;&gt;()
        ?.map { member -&gt;
            val value = member.call(this)?.let { v-&gt;
                //&#39;若成员变量是data class，则递归调用ofMap()，将其转化成键值对，否则直接返回值&#39;
                if (v::class.isData) v.ofMap()
                else v
            }
            member.name to value
        }
        ?.toMap()
}
</code></pre><p>为了让打印结果也有嵌套缩进效果，打印 Map 的函数也需要相应地重构：</p>
<pre><code>/**
 * 打印 Map，生成结构化键值对子串
 * @param space 行缩进量
 */
fun &lt;K, V&gt; Map&lt;K, V?&gt;.print(space: Int = 0): String {
    //&#39;生成当前层次的行缩进，用space个空格表示，当前层次每一行内容都需要带上缩进&#39;
    val indent = StringBuilder().apply {
        repeat(space) { append(&quot; &quot;) }
    }.toString()
    return StringBuilder(&quot;\n${indent}{&quot;).also { sb -&gt;
        this.iterator().forEach { entry -&gt;
            //&#39;如果值是 Map 类型，则递归调用print()生成其结构化键值对子串，否则返回值本身&#39;
            val value = entry.value.let { v -&gt;
                (v as? Map&lt;*, *&gt;)?.print(&quot;${indent}${entry.key} = &quot;.length) ?: v.toString()
            }
            sb.append(&quot;\n\t${indent}[${entry.key}] = $value,&quot;)
        }
        sb.append(&quot;\n${indent}}&quot;)
    }.toString()
}
</code></pre><p>写段测试代码，看看效果：</p>
<pre><code>//&#39;坐标类，嵌套在Location类中&#39;
data class Coordinate(var x: Int, var y: Int)
//&#39;位置类，嵌套在Person类中&#39;
data class Location(var country: String, var city: String, var coordinate: Coordinate)
data class Person(var name: String, var age: Int, var locaton: Location? = null)

Person(&quot;Peter&quot;, 16, Location(&quot;china&quot;, &quot;shanghai&quot;, Coordinate(10, 20))).ofMap()?.print().let { Log.v(&quot;test&quot;, &quot;$it&quot;) }

//&#39;打印如下&#39;
    {
        [age] = 16,
        [locaton] = 
              {
                  [city] = shanghai,
                  [coordinate] = 
                           {
                               [x] = 10,
                               [y] = 20,
                           },
                  [country] = china,
              },
        [name] = Peter,
    }
</code></pre>
        <h2 id="获取当前周一和周日"   >
          <a href="#获取当前周一和周日" class="heading-link"><i class="fas fa-link"></i></a>获取当前周一和周日</h2>
      <p>Java 系统默认一周的第一天是周日，最后一天是周六。</p>
<p>若需要做类似“一周一次提醒”的功能，就可以本地化提醒时间，然后在每次触发提醒时把它和当前周一作比较，大于则说明本周已提醒。</p>
<pre><code>fun thisMondayInMillis() = Calendar.getInstance().let { c -&gt;
    //&#39;如果当前是周天，则减一天，计算周六所在周的周一&#39;
    if (c.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) c.add(Calendar.DATE, -1)
    c.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
    c.set(Calendar.HOUR_OF_DAY, 0)
    c.set(Calendar.MINUTE, 0)
    c.set(Calendar.SECOND, 0)
    c.set(Calendar.MILLISECOND, 0)
    c.timeInMillis
}

fun thisSundayInMillis() = Calendar.getInstance().let { c -&gt;
    //&#39;如果不是周天，则将日期调整到当前周的周六，然后在加一天&#39;
    if (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {
        c.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY)
        c.add(Calendar.DATE, 1)
    }
    c.set(Calendar.HOUR_OF_DAY, 0)
    c.set(Calendar.MINUTE, 0)
    c.set(Calendar.SECOND, 0)
    c.set(Calendar.MILLISECOND, 0)
    c.timeInMillis
}
</code></pre>
        <h2 id="RecyclerView表项点击监听器"   >
          <a href="#RecyclerView表项点击监听器" class="heading-link"><i class="fas fa-link"></i></a>RecyclerView表项点击监听器</h2>
      <p><code>RecyclerView</code>没有子控件点击事件监听器，那就用<code>Kotlin扩展方法</code>扩展一个：</p>
<pre><code>//&#39;为 RecyclerView 扩展表项点击监听器&#39;
fun RecyclerView.setOnItemClickListener(listener: (View, Int) -&gt; Unit) {
    //&#39;为 RecyclerView 子控件设置触摸监听器&#39;
    addOnItemTouchListener(object : RecyclerView.OnItemTouchListener {
        //&#39;构造手势探测器，用于解析单击事件&#39;
        val gestureDetector = GestureDetector(context, object : GestureDetector.OnGestureListener {
            override fun onShowPress(e: MotionEvent?) {
            }

            override fun onSingleTapUp(e: MotionEvent?): Boolean {
                //&#39;当单击事件发生时，寻找单击坐标下的子控件，并回调监听器&#39;
                e?.let {
                    findChildViewUnder(it.x, it.y)?.let { child -&gt;
                        listener(child, getChildAdapterPosition(child))
                    }
                }
                return false
            }

            override fun onDown(e: MotionEvent?): Boolean {
                return false
            }

            override fun onFling(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean {
                return false
            }

            override fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean {
                return false
            }

            override fun onLongPress(e: MotionEvent?) {
            }
        })

        override fun onTouchEvent(rv: RecyclerView, e: MotionEvent) {

        }

        //&#39;在拦截触摸事件时，解析触摸事件&#39;
        override fun onInterceptTouchEvent(rv: RecyclerView, e: MotionEvent): Boolean {
            gestureDetector.onTouchEvent(e)
            return false
        }

        override fun onRequestDisallowInterceptTouchEvent(disallowIntercept: Boolean) {
        }
    })
}</code></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/Top10/">2020年GitHub 上那些优秀Android开源库</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/Top10/" data-flag-title="2020年GitHub 上那些优秀Android开源库"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>2020年有哪些优秀的开源库呢？本期就为大家带精选的10个，排名不分先后。</p>

        <h3 id="No1-LiquidSwipe"   >
          <a href="#No1-LiquidSwipe" class="heading-link"><i class="fas fa-link"></i></a>No1. LiquidSwipe</h3>
      <p>这是一个很棒的ViewPager库，它在浏览ViewPager的不同页面时，显示波浪的滑动动画，效果非常炫酷。该库的USP是触摸交互的。这意味着在视图中显示类似液体的显示过渡时，应考虑触摸事件。</p>

        <h5 id="1-1如何使用呢？"   >
          <a href="#1-1如何使用呢？" class="heading-link"><i class="fas fa-link"></i></a>1.1如何使用呢？</h5>
      <p>导入以下Gradle依赖项:</p>
<pre><code>implementation &#39;com.github.Chrisvin:LiquidSwipe:1.3&#39;
</code></pre><p>然后将<code>LiquidSwipeLayout</code>添加为保存fragment布局的容器的根布局：</p>
<pre><code>&lt;androidx.constraintlayout.widget.ConstraintLayout 
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;com.jem.liquidswipe.LiquidSwipeViewPager
        android:id=&quot;@+id/viewpager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;/&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
        <h5 id="1-2-效果图"   >
          <a href="#1-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>1.2 效果图</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">效果1</th>
<th align="left">效果2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd596bc8a6?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd611cbcb0?imageslim" style=""  alt="img"></td>
</tr>
</tbody></table></div>
<p>更多详细使用方法请看Github: <span class="exturl"><a class="exturl__link"   href="https://github.com/Chrisvin/LiquidSwipe"  target="_blank" rel="noopener">github.com/Chrisvin/Li…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No2-Flourish"   >
          <a href="#No2-Flourish" class="heading-link"><i class="fas fa-link"></i></a>No2. Flourish</h3>
      <p><code>Flourish</code>提供了一个炫酷的方式来显示或者隐藏一个布局，实现方式也很简单，就是对View或者布局进行了包装，通过构建者模式来提供api给上层调用。就像使用dialog一样，调用<code>show</code>和<code>dissmiss</code>方法来显示和隐藏。此外，通过这些类，我们还可以自定义动画（正常，加速，反弹），或为布局方向设置我们自己的起点（左上，右下等）。</p>

        <h5 id="2-1-如何使用？"   >
          <a href="#2-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>2.1 如何使用？</h5>
      <p>在build.gradle 中添加如下依赖：</p>
<pre><code>dependencies {
    implementation &quot;com.github.skydoves:flourish:1.0.0&quot;
}
</code></pre><p>然后在代码中，构建布局：</p>
<pre><code>Flourish flourish = new Flourish.Builder(parentLayout)
    // sets the flourish layout for showing and dismissing on the parent layout.
    .setFlourishLayout(R.layout.layout_flourish_main)
    // sets the flourishing animation for showing and dismissing.
    .setFlourishAnimation(FlourishAnimation.BOUNCE)
    // sets the orientation of the starting point.
    .setFlourishOrientation(FlourishOrientation.TOP_LEFT)
    // sets a flourishListener for listening changes.
    .setFlourishListener(flourishListener)
    // sets the flourish layout should be showed on start. 
    .setIsShowedOnStart(false)
    // sets the duration of the flourishing.
    .setDuration(800L)
    .build();
</code></pre><p>还提供有更简介的DSL:</p>
<pre><code>val myFlourish = createFlourish(parentLayout) {
  setFlourishLayout(R.layout.layout_flourish_main)
  setFlourishAnimation(FlourishAnimation.ACCELERATE)
  setFlourishOrientation(FlourishOrientation.TOP_RIGHT)
  setIsShowedOnStart(true)
  setFlourishListener {  }
}
</code></pre>
        <h5 id="2-2-效果图"   >
          <a href="#2-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>2.2  效果图</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">效果1</th>
<th align="left">效果2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd598c788c?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd65deef71?imageslim" style=""  alt="img"></td>
</tr>
</tbody></table></div>
<p>更多详细使用请看Github：<span class="exturl"><a class="exturl__link"   href="https://github.com/skydoves/Flourish"  target="_blank" rel="noopener">github.com/skydoves/Fl…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No3-AestheticDialogs"   >
          <a href="#No3-AestheticDialogs" class="heading-link"><i class="fas fa-link"></i></a>No3. AestheticDialogs</h3>
      <p>这是一个美观而时尚的AlterDialog库，目前可支持六种不同的对话框,如：</p>
<ul>
<li>Flash Dialog</li>
<li>Connectify Dialog</li>
<li>Toaster Dialog</li>
<li>Emotion Dialog</li>
<li>Drake Dialog</li>
<li>Emoji Dialog 并且啊，还提供了暗黑模式的适配。</li>
</ul>

        <h5 id="3-1-如何使用？"   >
          <a href="#3-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>3.1 如何使用？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
 ...
 implementation &#39;com.github.gabriel-TheCode:AestheticDialogs:1.1.0&#39;
}
</code></pre><p>代码中，显示不同种类的对话框则调用对应的方法就好</p>
<p>Flash:</p>
<pre><code>AestheticDialog.showFlashDialog(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showFlashDialog(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);
</code></pre><p>Connectify:</p>
<pre><code>AestheticDialog.showConnectify(this,&quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showConnectify(this, &quot;Your message&quot;, AestheticDialog.ERROR);

 /// Dark Theme
 AestheticDialog.showConnectifyDark(this,&quot;Your message&quot;,AestheticDialog.SUCCESS);
 AestheticDialog.showConnectifyDark(this, &quot;Your message&quot;, AestheticDialog.ERROR);
</code></pre><p>Toaster:</p>
<pre><code> AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);
AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING);
 AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO);

 /// Dark Theme
 AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);
AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING);
 AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO);
</code></pre><p>Drake :</p>
<pre><code> AestheticDialog.showDrake(this, AestheticDialog.SUCCESS);
AestheticDialog.showDrake(this, AestheticDialog.ERROR);
</code></pre><p>Emoji :</p>
<pre><code> AestheticDialog.showEmoji(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showEmoji(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);

/// Dark Theme
 AestheticDialog.showEmojiDark(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showEmojiDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);
</code></pre><p>Emotion :</p>
<pre><code> AestheticDialog.showEmotion(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
AestheticDialog.showEmotion(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);
</code></pre><p>Rainbow :</p>
<pre><code> AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);
 AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);
 AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING);
AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO);
</code></pre>
        <h5 id="3-2-效果如下"   >
          <a href="#3-2-效果如下" class="heading-link"><i class="fas fa-link"></i></a>3.2 效果如下</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">Flash Dialog</th>
<th align="left">Connectify Dialog</th>
<th align="left">Toaster Dialog</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd6162084c?imageslim" style=""  alt="d1.gif"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd9aecbe0a?imageslim" style=""  alt="d2.gif"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd65e67426?imageslim" style=""  alt="d3.gif"></td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">Emotion Dialog</th>
<th align="left">Drake Dialog</th>
<th align="left">Emoji Dialog</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fda6337612?imageslim" style=""  alt="d4.gif"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fda6511772?imageslim" style=""  alt="d5.gif"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fda8cf1381?imageslim" style=""  alt="d6.gif"></td>
</tr>
</tbody></table></div>
<p>更多详情使用方法请看Github：<span class="exturl"><a class="exturl__link"   href="https://github.com/gabriel-TheCode/AestheticDialogs"  target="_blank" rel="noopener">github.com/gabriel-The…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="N4-EasyReveal"   >
          <a href="#N4-EasyReveal" class="heading-link"><i class="fas fa-link"></i></a>N4. EasyReveal</h3>
      <p>从名字就知道，这是一个提供<code>reveal</code>动画效果的库，它的厉害之处在于可以提供不同尺寸、不同形状的reveal动画，并且还可以在定义它在屏幕任意位置开始和结束动画。</p>

        <h5 id="4-1-如何使用？"   >
          <a href="#4-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>4.1 如何使用？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
 ...
 implementation &#39;com.github.Chrisvin:EasyReveal:1.2&#39;
}
</code></pre><p>然后，xml中，需要添加显示或者隐藏动画的View应该包裹在<code>EasyRevealLinearLayout</code>中：</p>
<pre><code>&lt;com.jem.easyreveal.layouts.EasyRevealLinearLayout
    ...
    app:clipPathProvider=&quot;star&quot; // possible values: circular, linear, random_line, star, sweep &amp; wave
    app:revealAnimationDuration=&quot;2000&quot;
    app:hideAnimationDuration=&quot;1500&quot; &gt;

    &lt;!-- The views to be revealed/hidden go here --&gt;

&lt;/com.jem.easyreveal.layouts.EasyRevealLinearLayout&gt;
&lt;!-- Similarly for com.jem.easyreveal.layouts.EasyRevealConstraintLayout &amp; com.jem.easyreveal.layouts.EasyRevealFrameLayout --&gt;
</code></pre><p>也可以在代码中添加：</p>
<pre><code>val revealLayout = EasyRevealLinearLayout(this)
// Set the ClipPathProvider that is used to clip the view for reveal animation
revealLayout.clipPathProvider = StarClipPathProvider(numberOfPoints = 6)
// Set the duration taken for reveal animation
revealLayout.revealAnimationDuration = 1500
// Set the duration taken for hide animation
revealLayout.hideAnimationDuration = 2000
// Set listener to get updates during reveal/hide animation
revealLayout.onUpdateListener = object: RevealLayout.OnUpdateListener {
    override fun onUpdate(percent: Float) {
        Toast.makeText(this@MainActivity, &quot;Revealed percent: $percent&quot;, Toast.LENGTH_SHORT).show()
    }
}
// Start reveal animation
revealLayout.reveal()
// Start hide animation
revealLayout.hide()
</code></pre>
        <h5 id="4-2效果图"   >
          <a href="#4-2效果图" class="heading-link"><i class="fas fa-link"></i></a>4.2效果图</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">Emotion Dialog</th>
<th align="left">Drake Dialog</th>
<th align="left">Emoji Dialog</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdaf742389?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdb834525b?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdcdb85e38?imageslim" style=""  alt="img"></td>
</tr>
<tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdd5c42d60?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fde299e5f8?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdecbac3a3?imageslim" style=""  alt="img"></td>
</tr>
</tbody></table></div>
<p>更多详细使用信息请看Github： <span class="exturl"><a class="exturl__link"   href="https://github.com/Chrisvin/EasyReveal"  target="_blank" rel="noopener">github.com/Chrisvin/Ea…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No5-Android-ColorX"   >
          <a href="#No5-Android-ColorX" class="heading-link"><i class="fas fa-link"></i></a>No5. Android ColorX</h3>
      <p><code>Android ColorX</code> 以Kotlin 扩展函数的形式提供了一些重要的获取颜色的方法。 通过提供不同颜色格式（RGB，HSV，CYMK等）的转换功能，它使开发变得更加轻松。该库的USP具有以下功能：</p>
<ul>
<li>颜色的不同阴影和色调。</li>
<li>较深和较浅的阴影。</li>
<li>颜色的补码</li>
</ul>

        <h5 id="5-1-如何使用？"   >
          <a href="#5-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>5.1 如何使用？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
    implementation &#39;me.jorgecastillo:androidcolorx:0.2.0&#39;
}
</code></pre><p>在代码中，一系列的转换方法：</p>
<pre><code>val color = Color.parseColor(&quot;#e91e63&quot;)

val rgb = color.asRgb()
val argb = color.asArgb()
val hex = color.asHex()
val hsl = color.asHsl()
val hsla = color.asHsla()
val hsv = color.asHsv()
val cmyk = color.asCmyk()

val colorHsl = HSLColor(hue = 210f, saturation = 0.5f, lightness = 0.5f)

val colorInt = colorHsl.asColorInt()
val rgb = colorHsl.asRgb()
val argb = colorHsl.asArgb()
val hex = colorHsl.asHex()
val cmyk = colorHsl.asCmyk()
val hsla = colorHsl.asHsla()
val hsv = colorHsl.asHsv()
</code></pre>
        <h5 id="5-2-效果图"   >
          <a href="#5-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>5.2 效果图</h5>
      <p><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdf42d10d3?imageslim" style=""  alt="img"></p>
<p>更多详细使用信息请看Github：<span class="exturl"><a class="exturl__link"   href="https://github.com/JorgeCastilloPrz/AndroidColorX"  target="_blank" rel="noopener">github.com/JorgeCastil…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No6-AnimatedBottomBar"   >
          <a href="#No6-AnimatedBottomBar" class="heading-link"><i class="fas fa-link"></i></a>No6. AnimatedBottomBar</h3>
      <p>这是一个带动画的底部导航栏库。它使你可以以编程方式以及通过XML添加和删除选项卡。此外，我们可以轻松地从BottomBar拦截选项卡。限制访问应用程序导航中的高级区域时，“拦截”标签非常有用。流畅的动画提供了许多自定义选项，从动画插值器到设置波纹效果。</p>

        <h5 id="6-1-如何使用？"   >
          <a href="#6-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>6.1 如何使用？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
  implementation &#39;nl.joery.animatedbottombar:library:1.0.8&#39;
}
</code></pre><p>在xml文件中添加<code>AnimatedBottomBar</code>和自定义属性</p>
<pre><code>&lt;nl.joery.animatedbottombar.AnimatedBottomBar
    android:id=&quot;@+id/bottom_bar&quot;
    android:background=&quot;#FFF&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:abb_selectedTabType=&quot;text&quot;
    app:abb_indicatorAppearance=&quot;round&quot;
    app:abb_indicatorMargin=&quot;16dp&quot;
    app:abb_indicatorHeight=&quot;4dp&quot;
    app:abb_tabs=&quot;@menu/tabs&quot;
    app:abb_selectedIndex=&quot;1&quot; /&gt;
</code></pre><p>在<code>res/menu</code>目录下定义<code>tabs.xml</code>文件：</p>
<pre><code>&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item
        android:id=&quot;@+id/tab_home&quot;
        android:icon=&quot;@drawable/home&quot;
        android:title=&quot;@string/home&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/tab_alarm&quot;
        android:icon=&quot;@drawable/alarm&quot;
        android:title=&quot;@string/alarm&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/tab_bread&quot;
        android:icon=&quot;@drawable/bread&quot;
        android:title=&quot;@string/bread&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/tab_cart&quot;
        android:icon=&quot;@drawable/cart&quot;
        android:title=&quot;@string/cart&quot; /&gt;
&lt;/menu&gt;
</code></pre><p>最后，代码中添加tab</p>
<pre><code>// Creating a tab by passing values
val bottomBarTab1 = AnimatedBottomBar.createTab(drawable, &quot;Tab 1&quot;)

// Creating a tab by passing resources
val bottomBarTab2 = AnimatedBottomBar.createTab(R.drawable.ic_home, R.string.tab_2, R.id.tab_home)
</code></pre>
        <h5 id="6-2-效果图"   >
          <a href="#6-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>6.2 效果图</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">tab1</th>
<th align="left">tab2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe11cdef3a?imageslim" style=""  alt="tab1.gif"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe19a34bf0?imageslim" style=""  alt="tab2.gif"></td>
</tr>
</tbody></table></div>
<p>详情信息请看Github: <span class="exturl"><a class="exturl__link"   href="https://github.com/Droppers/AnimatedBottomBar"  target="_blank" rel="noopener">github.com/Droppers/An…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No7-RateBottomSheet"   >
          <a href="#No7-RateBottomSheet" class="heading-link"><i class="fas fa-link"></i></a>No7. RateBottomSheet</h3>
      <p>有时候，为了推广我们的应用，我们需要让用户跳转到应用商店为我们的APP打分，传统的对话框用户体验很不好，而本库则是用BottomSheet来进行提示，它位于底部缩略区域，用户体验很好。</p>

        <h5 id="7-1-如何使用呢？"   >
          <a href="#7-1-如何使用呢？" class="heading-link"><i class="fas fa-link"></i></a>7.1 如何使用呢？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
implementation &#39;com.mikhaellopez:ratebottomsheet:1.1.0&#39;
}
</code></pre><p>然后修改默认的string资源文件来改变显示文案：</p>
<pre><code>&lt;resources&gt;
    &lt;string name=&quot;rate_popup_ask_title&quot;&gt;Like this App?&lt;/string&gt;
    &lt;string name=&quot;rate_popup_ask_message&quot;&gt;Do you like using this application?&lt;/string&gt;
    &lt;string name=&quot;rate_popup_ask_ok&quot;&gt;Yes I do&lt;/string&gt;
    &lt;string name=&quot;rate_popup_ask_no&quot;&gt;Not really&lt;/string&gt;

    &lt;string name=&quot;rate_popup_title&quot;&gt;Rate this app&lt;/string&gt;
    &lt;string name=&quot;rate_popup_message&quot;&gt;Would you mind taking a moment to rate it? It won\&#39;t take more than a minute. Thanks for your support!&lt;/string&gt;
    &lt;string name=&quot;rate_popup_ok&quot;&gt;Rate it now&lt;/string&gt;
    &lt;string name=&quot;rate_popup_later&quot;&gt;Remind me later&lt;/string&gt;
    &lt;string name=&quot;rate_popup_no&quot;&gt;No, thanks&lt;/string&gt;
&lt;/resources&gt;
</code></pre><p>代码中使用：</p>
<pre><code>RateBottomSheetManager(this)
    .setInstallDays(1) // 3 by default
    .setLaunchTimes(2) // 5 by default
    .setRemindInterval(1) // 2 by default
    .setShowAskBottomSheet(false) // True by default
    .setShowLaterButton(false) // True by default
    .setShowCloseButtonIcon(false) // True by default
    .monitor()

// Show bottom sheet if meets conditions
// With AppCompatActivity or Fragment
RateBottomSheet.showRateBottomSheetIfMeetsConditions(this)
</code></pre>
        <h5 id="7-2-效果图"   >
          <a href="#7-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>7.2 效果图</h5>
      <p><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe29028b1a?imageslim" style=""  alt="img"></p>
<p>更多详情请看Github:<span class="exturl"><a class="exturl__link"   href="https://github.com/lopspower/RateBottomSheet"  target="_blank" rel="noopener">github.com/lopspower/R…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No8-TransformationLayout"   >
          <a href="#No8-TransformationLayout" class="heading-link"><i class="fas fa-link"></i></a>No8. TransformationLayout</h3>
      <p>这是一个用于Activity或者Fragment 以及View切换的过渡动画库，效果非常炫，它使用Material Design的运动系统过渡模式来创建变形动画。该库提供了用于绑定目标视图，设置淡入淡出和路径运动方向以及许多其他自定义选项的属性。</p>

        <h5 id="8-1-如何使用？"   >
          <a href="#8-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>8.1 如何使用？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
    implementation &quot;com.github.skydoves:transformationlayout:1.0.4&quot;
}
</code></pre><p>然后，需要将我们需要添加过渡动画的View包裹到 <code>TransformationLayout</code>:</p>
<pre><code>&lt;com.skydoves.transformationlayout.TransformationLayout
  android:layout_width=&quot;wrap_content&quot;
  android:layout_height=&quot;wrap_content&quot;
  app:transformation_targetView=&quot;@+id/my_cardView&quot; // sets a target view.
  app:transformation_duration=&quot;450&quot; // sets a duration of the transformation.
  app:transformation_direction=&quot;auto&quot; // auto, entering, returning
  app:transformation_fadeMode=&quot;in&quot; // in, out, cross, through
  app:transformation_fitMode=&quot;auto&quot; // auto, height, width
  app:transformation_pathMode=&quot;arc&quot; // arc, linear
&gt;

   &lt;!-- other views --&gt;

&lt;/com.skydoves.transformationlayout.TransformationLayout&gt;
</code></pre><p>比如我们要将一个fab 过渡到一个card卡片，布局如下：</p>
<pre><code>&lt;com.skydoves.transformationlayout.TransformationLayout
    android:id=&quot;@+id/transformationLayout&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:transformation_duration=&quot;550&quot;
    app:transformation_targetView=&quot;@+id/myCardView&quot;&gt;

  &lt;com.google.android.material.floatingactionbutton.FloatingActionButton
      android:id=&quot;@+id/fab&quot;
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:backgroundTint=&quot;@color/colorPrimary&quot;
      android:src=&quot;@drawable/ic_write&quot;/&gt;
&lt;/com.skydoves.transformationlayout.TransformationLayout&gt;

&lt;com.google.android.material.card.MaterialCardView
    android:id=&quot;@+id/myCardView&quot;
    android:layout_width=&quot;240dp&quot;
    android:layout_height=&quot;312dp&quot;
    android:layout_marginLeft=&quot;30dp&quot;
    android:layout_marginTop=&quot;30dp&quot;
    app:cardBackgroundColor=&quot;@color/colorPrimary&quot; /&gt;
</code></pre><p><strong>重点来了，绑定视图</strong>，将一个<code>targetView</code>绑定到<code>TransformationLayout</code>有2种方式：</p>
<ul>
<li>通过在xml中指定属性：</li>
</ul>
<pre><code>app:transformation_targetView=&quot;@+id/myCardView&quot;
</code></pre><ul>
<li>在代码中绑定</li>
</ul>
<pre><code>transformationLayout.bindTargetView(myCardView)
</code></pre><p>当我们点击fab时，在监听器中调用<code>startTransform()</code>开始过渡动画，<code>finishTransform（）</code>开始结束动画。</p>
<pre><code>// start transformation when touching the fab.
fab.setOnClickListener {
  transformationLayout.startTransform()
}

// finish transformation when touching the myCardView.
myCardView.setOnClickListener {
  transformationLayout.finishTransform()
}
</code></pre>
        <h5 id="8-2-效果图"   >
          <a href="#8-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>8.2 效果图</h5>
      <p><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe31ffea34?imageslim" style=""  alt="img"></p>
<p>更多使用方式请看Github: <span class="exturl"><a class="exturl__link"   href="https://github.com/skydoves/TransformationLayout"  target="_blank" rel="noopener">github.com/skydoves/Tr…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No9-Donut"   >
          <a href="#No9-Donut" class="heading-link"><i class="fas fa-link"></i></a>No9. Donut</h3>
      <p>这个一个可以展示多个数据集的圆弧形控件，具有精细的颗粒控制、间隙功能、动画选项以及按比例缩放其值的功能。可以用于项目中的一些数据统计。</p>

        <h5 id="9-1-如何使用？"   >
          <a href="#9-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>9.1 如何使用？</h5>
      <p>在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
    implementation(&quot;app.futured.donut:library:$version&quot;)
}
</code></pre><p>然后在布局文件中添加View:</p>
<pre><code>&lt;app.futured.donut.DonutProgressView
    android:id=&quot;@+id/donut_view&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    app:donut_bgLineColor=&quot;@color/cloud&quot;
    app:donut_gapWidth=&quot;20&quot;
    app:donut_gapAngle=&quot;270&quot;
    app:donut_strokeWidth=&quot;16dp&quot;/&gt;
</code></pre><p>然后在代码中设置数据：</p>
<pre><code>val dataset1 = DonutDataset(
    name = &quot;dataset_1&quot;,
    color = Color.parseColor(&quot;#FB1D32&quot;),
    amount = 1f
)

val dataset2 = DonutDataset(
    name = &quot;dataset_2&quot;,
    color = Color.parseColor(&quot;#FFB98E&quot;),
    amount = 1f
)

donut_view.cap = 5f
donut_view.submitData(listOf(dataset1, dataset2))
</code></pre>
        <h5 id="9-2-效果图"   >
          <a href="#9-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>9.2  效果图</h5>
      <p><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe83c87b9a?imageslim" style=""  alt="img"></p>
<p>更多用法请看Github: <span class="exturl"><a class="exturl__link"   href="https://github.com/futuredapp/donut"  target="_blank" rel="noopener">github.com/futuredapp/…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="No10-CurveGraphView"   >
          <a href="#No10-CurveGraphView" class="heading-link"><i class="fas fa-link"></i></a>No10. CurveGraphView</h3>
      <p><code>CurveGraphView</code> 是一个带有炫酷动画统计图表库，除了性能出色并具有许多样式选项之外，该库还支持单个平面内的多个线图。</p>
<p>多个折线图对于比较不同股票，共同基金，加密货币等的价格非常有用。</p>

        <h5 id="10-1-如何使用？"   >
          <a href="#10-1-如何使用？" class="heading-link"><i class="fas fa-link"></i></a>10.1 如何使用？</h5>
      <p>1、在<code>build.gradle</code> 中添加如下依赖：</p>
<pre><code>dependencies {
    implementation &#39;com.github.swapnil1104:CurveGraphView:{current_lib_ver}&#39;
}
</code></pre><p>2、在xml文件中添加布局：</p>
<pre><code> &lt;com.broooapps.graphview.CurveGraphView
        android:id=&quot;@+id/cgv&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;250dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
</code></pre><p>然后在代码中添加各种配置项</p>
<pre><code>curveGraphView = findViewById(R.id.cgv);

curveGraphView.configure(
        new CurveGraphConfig.Builder(this)
                .setAxisColor(R.color.Blue)                                             // Set X and Y axis line color stroke.
                .setIntervalDisplayCount(7)                                             // Set number of values to be displayed in X ax
                .setGuidelineCount(2)                                                   // Set number of background guidelines to be shown.
                .setGuidelineColor(R.color.GreenYellow)                                 // Set color of the visible guidelines.
                .setNoDataMsg(&quot; No Data &quot;)                                              // Message when no data is provided to the view.
                .setxAxisScaleTextColor(R.color.Black)                                  // Set X axis scale text color.
                .setyAxisScaleTextColor(R.color.Black)                                  // Set Y axis scale text color
                .build()
        ););
</code></pre><p>3、 提供数据集</p>
<pre><code>PointMap pointMap = new PointMap();
        pointMap.addPoint(0, 100);
        pointMap.addPoint(1, 500);
        pointMap.addPoint(5, 800);
        pointMap.addPoint(4, 600);
</code></pre>
        <h5 id="10-2-效果图"   >
          <a href="#10-2-效果图" class="heading-link"><i class="fas fa-link"></i></a>10.2 效果图</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">效果1</th>
<th align="left">效果2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe31f4c9ad?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe61166b90?imageslim" style=""  alt="img"></td>
</tr>
<tr>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe67f21c88?imageslim" style=""  alt="img"></td>
<td align="left"><img   src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe80ec22ee?imageslim" style=""  alt="img"></td>
</tr>
</tbody></table></div>
<p>更多详细使用方式请看Github: <span class="exturl"><a class="exturl__link"   href="https://github.com/swapnil1104/CurveGraphView"  target="_blank" rel="noopener">github.com/swapnil1104…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/FragmentTransaction/">Androidx 下 Fragment 懒加载的新实现</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/FragmentTransaction/" data-flag-title="Androidx 下 Fragment 懒加载的新实现"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数，而在 Androidx 模式下，我们可以使用 <code>FragmentTransaction.setMaxLifecycle()</code> 的方式来处理 Fragment 的懒加载。</p>
<p>在本文章中，我会详细介绍不同使用场景下两种方案的差异。大家快拿好小板凳。一起来学习新知识吧！</p>
<blockquote>
<p>本篇文章涉及到的 Demo，已上传至Github—-&gt;<span class="exturl"><a class="exturl__link"   href="https://github.com/AndyJennifer/AndroidxLazyLoad"  target="_blank" rel="noopener">传送门</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="老的懒加载处理方案"   >
          <a href="#老的懒加载处理方案" class="heading-link"><i class="fas fa-link"></i></a>老的懒加载处理方案</h3>
      <blockquote>
<p>如果你熟悉老一套的 Fragment 懒加载机制，你可以直接查看 Androix 懒加载相关章节</p>
</blockquote>

        <h4 id="add-show-hide-模式下的老方案"   >
          <a href="#add-show-hide-模式下的老方案" class="heading-link"><i class="fas fa-link"></i></a>add+show+hide 模式下的老方案</h4>
      <p>在没有添加懒加载之前，只要使用 <code>add+show+hide</code> 的方式控制并显示 Fragment, 那么不管 Fragment 是否嵌套，在初始化后，如果<code>只调用了add+show</code>，同级下的 Fragment 的相关生命周期函数都会被调用。且调用的生命周期函数如下所示：</p>
<pre><code>onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume</code></pre><blockquote>
<p>Fragment 完整生命周期：onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroyView -&gt; onDestroy -&gt; onDetach</p>
</blockquote>
<p>什么是同级 Frament 呢？看下图</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96781bfcafeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="同级Fragment.jpg"></p>
<blockquote>
<p>上图中，都是使用 <code>add+show+hide</code> 的方式控制 Fragment,</p>
</blockquote>
<p>在上图两种模式中:</p>
<ul>
<li>Fragment_1、Fragment_2、Fragment_3 属于同级 Fragment</li>
<li>Fragment_a、Fragment_b、Fragment_c 属于同级 Fragment</li>
<li>Fragment_d、Fragment_e、Fragment_f 属于同级 Fragment</li>
</ul>
<p>那这种方式会带来什么问题呢？结合下图我们来分别分析。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967909b892db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="show1.png"></p>
<p>观察上图我们可以发现，同级的Fragment_1、Fragment_2、Fragment_3 都调用了 <code>onAttach...onResume</code> 系列方法，也就是说，如果我们没有对 Fragment 进行懒加载处理，那么我们就会无缘无故的加载一些并<code>不可见</code>的 Fragment , 也就会造成用户流量的无故消耗（我们会在 Fragment 相关生命周期函数中，请求网络或其他数据操作）。</p>
<blockquote>
<p>这里<code>&quot;不可见的Fragment&quot;</code>是指，实际不可见但是相关可见生命周期函数(如 <code>onResume</code> 方法）被调用的 Fragment</p>
</blockquote>
<p>如果使用嵌套 Fragment ，这种浪费流量的行为就更明显了。以本节的图一为例，当 Fragment_1 加载时，如果你在 Fragment_1 生命周期函数中使用 <code>show+add+hide</code> 的方式添加 <code>Fragment_a、Fragment_b、Fragment_c</code> , 那么 Fragment_b 又会在其生命周期函数中继续加载 <code>Fragment_d、Fragment_e、Fragment_f</code> 。</p>
<p>那如何解决这种问题呢？我们继续接着上面的例子走，当我们 <code>show Fragment_2</code>，并 hide其他 Fragment 时，对应 Fragment 的生命周期调用如下：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96782a90b81e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="show2.png"></p>
<p>从上图中，我们可以看出 Fragment_2 与 Fragment_3 都调用了 <code>onHiddenChanged</code> 函数，该函数的官方 API 声明如下：</p>
<pre><code>    /**
     * Called when the hidden state (as returned by {@link #isHidden()} of
     * the fragment has changed.  Fragments start out not hidden; this will
     * be called whenever the fragment changes state from that.
     * @param hidden True if the fragment is now hidden, false otherwise.
     */
    public void onHiddenChanged(boolean hidden) {
    }
</code></pre><p>根据官方 API 的注释，我们大概能知道，当 Fragment 隐藏的状态发生改变时，该函数将会被调用，如果当前 Fragment 隐藏， <code>hidden</code> 的值为 true, 反之为 false。最为重要的是<code>hidden</code> 的值，可以通过调用 <code>isHidden()</code> 函数获取。</p>
<p>那么结合上述知识点，我们能推导出：</p>
<ul>
<li>因为 Fragment_1 的 <code>隐藏状态</code> 从<code>可见转为了不可见</code>，所以其 <code>onHiddenChanged</code> 函数被调用，同时 <code>hidden</code> 的值为 true。</li>
<li>同理对于 Fragment_2 ，因为其 <code>隐藏状态</code> 从 <code>不可见转为了可见</code> ，所以其 hidden 值为 false。</li>
<li>对于 Fragment_3 ,因为其隐藏状态从始至终都没有发生变化，所以其 onHiddenChanged 函数并不会调用。</li>
</ul>
<p>嗯，好像有点眉目了。不急，我们继续看下面的例子。</p>
<p>show Fragment_3 并 hide 其他 Fragment ，对应生命周期函数调用如下所示：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967928f23799?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="show3.png"></p>
<p>从图中，我们可以看出，确实只有<code>隐藏状态</code>发生了改变的 Fragment 其 <code>onHiddenChanged</code> 函数才会调用，那么结合以上知识点，我们能得出如下重要结论：</p>
<p><strong>只要通过 <code>show+hide</code> 方式控制 Fragment 的显隐，那么在第一次初始化后，Fragment 任何的生命周期方法都不会调用，只有 <code>onHiddenChanged</code> 方法会被调用。</strong></p>
<p>那么，假如我们要在 <code>add+show+hide</code> 模式下控制 Fragment 的懒加载，我们只需要做这两步：</p>
<ul>
<li>我们需要在 <code>onResume()</code> 函数中调用 <code>isHidden()</code> 函数，来处理默认显示的 Fragment</li>
<li>在 <code>onHiddenChanged</code> 函数中控制其他不可见的Fragment，</li>
</ul>
<p>也就是这样处理：</p>
<pre><code>abstract class LazyFragment:Fragment(){

    private var isLoaded = false //控制是否执行懒加载

    override fun onResume() {
        super.onResume()
        judgeLazyInit()

    }
    override fun onHiddenChanged(hidden: Boolean) {
        super.onHiddenChanged(hidden)
        isVisibleToUser = !hidden
        judgeLazyInit()
    }

    private fun judgeLazyInit() {
        if (!isLoaded &amp;&amp; !isHidden) {
            lazyInit()
            isLoaded = true
        }
    }

     override fun onDestroyView() {
        super.onDestroyView()
        isLoaded = false
    }

    //懒加载方法
    abstract fun lazyInit()
}
</code></pre><blockquote>
<p>该懒加载的实现，是在 <code>onResume</code> 方法中操作，当然你可以在其他生命周期函数中控制。但是建议在该方法中执行懒加载。</p>
</blockquote>

        <h4 id="ViewPager-Fragment-模式下的老方案"   >
          <a href="#ViewPager-Fragment-模式下的老方案" class="heading-link"><i class="fas fa-link"></i></a>ViewPager+Fragment 模式下的老方案</h4>
      <p>使用传统方式处理 ViewPager 中 Fragment 的懒加载，我们需要控制 <code>setUserVisibleHint(boolean isVisibleToUser)</code> 函数，该函数的声明如下所示：</p>
<pre><code>    public void setUserVisibleHint(boolean isVisibleToUser) {}
</code></pre><p>该函数与之前我们介绍的 <code>onHiddenChanged()</code> 作用非常相似，都是通过传入的参数值来判断当前 Fragment 是否对用户可见，只是 <code>onHiddenChanged()</code> 是在 <code>add+show+hide</code> 模式下使用，而 <code>setUserVisibleHint</code> 是在 ViewPager+Fragment 模式下使用。</p>
<p>在本节中，我们用 <code>FragmentPagerAdapter + ViewPager</code> 为例，向大家讲解如何实现 Fragment 的懒加载。</p>
<blockquote>
<p>注意：在本例中没有调用 <code>setOffscreenPageLimit</code> 方法去设置 ViewPager 预缓存的 Fragment 个数。默认情况下 ViewPager 预缓存 Fragment 的个数为 <code>1</code> 。</p>
</blockquote>
<p>初始化 ViewPager 查看内部 Fragment 生命周期函数调用情况：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967817311da1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="viewpager1.png"></p>
<p>观察上图，我们能发现 ViePager 初始化时，默认会调用其内部 Fragment 的 setUserVisibleHint 方法，因为其预缓存 Fragment 个数为 <code>1</code> 的原因，所以只有 Fragment_1 与 Fragment_2 的生命周期函数被调用。</p>
<p>我们继续切换到 Fragment_2，查看各个Fragment的生命周期函数的调用变化。如下图所示：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967825d4acb4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="viewpage2.png"></p>
<p>观察上图，我们同样发现 Fragment 的 setUserVisibleHint 方法被调用了，并且 Fragment_3 的一系列生命周期函数被调用了。继续切换到 Fragment_3:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb9679081837f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="viewpager_3.png"></p>
<p>观察上图可以发现，Fragment_3 调用了 setUserVisibleHint 方法，继续又切换到 Fragment_1，查看调用函数的变化：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96782048236e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="viewpager4.png"></p>
<blockquote>
<p>因为之前在切换到 Fragment_3 时，Frafgment_1 已经走了 onDestoryView(图二，蓝色标记处) 方法，所以 Fragment_1 需要重新走一次生命周期。</p>
</blockquote>
<p>那么结合本节的三幅图，我们能得出以下结论：</p>
<ul>
<li>使用 ViewPager，切换回上一个 Fragment 页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。</li>
<li>setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。</li>
</ul>
<p>所以如果我们想对 ViewPager 中的 Fragment 懒加载，我们需要这样处理：</p>
<pre><code>abstract class LazyFragment : Fragment() {

    /**
     * 是否执行懒加载
     */
    private var isLoaded = false

    /**
     * 当前Fragment是否对用户可见
     */
    private var isVisibleToUser = false

    /**
     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，
     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，
     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量
     */
    private var isCallResume = false

    override fun onResume() {
        super.onResume()
        isCallResume = true
        judgeLazyInit()
    }


    private fun judgeLazyInit() {
        if (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) {
            lazyInit()
            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)
            isLoaded = true
        }
    }

    override fun onHiddenChanged(hidden: Boolean) {
        super.onHiddenChanged(hidden)
        isVisibleToUser = !hidden
        judgeLazyInit()
    }

    //在Fragment销毁View的时候，重置状态
    override fun onDestroyView() {
        super.onDestroyView()
        isLoaded = false
        isVisibleToUser = false
        isCallResume = false
    }

    override fun setUserVisibleHint(isVisibleToUser: Boolean) {
        super.setUserVisibleHint(isVisibleToUser)
        this.isVisibleToUser = isVisibleToUser
        judgeLazyInit()
    }

    abstract fun lazyInit()
}
</code></pre>
        <h4 id="复杂-Fragment-嵌套的情况"   >
          <a href="#复杂-Fragment-嵌套的情况" class="heading-link"><i class="fas fa-link"></i></a>复杂 Fragment 嵌套的情况</h4>
      <p>当然，在实际项目中，我们可能会遇到更为复杂的 Fragment 嵌套组合。比如 Fragment+Fragment、Fragment+ViewPager、ViewPager+ViewPager….等等。 如下图所示：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96784fdd764d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="复杂嵌套Fragment.jpg"></p>
<p>对于以上场景，我们就需要重写我们的懒加载，以支持不同嵌套组合模式下 Fragment 正确懒加载。我们需要将 LazyFragment 修改成如下这样：</p>
<pre><code>abstract class LazyFragment : Fragment() {

    /**
     * 是否执行懒加载
     */
    private var isLoaded = false

    /**
     * 当前Fragment是否对用户可见
     */
    private var isVisibleToUser = false

    /**
     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，
     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，
     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量
     */
    private var isCallResume = false

    /**
     * 是否调用了setUserVisibleHint方法。处理show+add+hide模式下，默认可见 Fragment 不调用
     * onHiddenChanged 方法，进而不执行懒加载方法的问题。
     */
    private var isCallUserVisibleHint = false

    override fun onResume() {
        super.onResume()
        isCallResume = true
        if (!isCallUserVisibleHint) isVisibleToUser = !isHidden
        judgeLazyInit()
    }


    private fun judgeLazyInit() {
        if (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) {
            lazyInit()
            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)
            isLoaded = true
        }
    }

    override fun onHiddenChanged(hidden: Boolean) {
        super.onHiddenChanged(hidden)
        isVisibleToUser = !hidden
        judgeLazyInit()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        isLoaded = false
        isVisibleToUser = false
        isCallUserVisibleHint = false
        isCallResume = false
    }

    override fun setUserVisibleHint(isVisibleToUser: Boolean) {
        super.setUserVisibleHint(isVisibleToUser)
        this.isVisibleToUser = isVisibleToUser
        isCallUserVisibleHint = true
        judgeLazyInit()
    }

    abstract fun lazyInit()
}
</code></pre>
        <h3 id="Androidx-下的懒加载"   >
          <a href="#Androidx-下的懒加载" class="heading-link"><i class="fas fa-link"></i></a>Androidx 下的懒加载</h3>
      <p>虽然之前的方案就能解决轻松的解决 Fragment 的懒加载，但这套方案有一个最大的弊端，<code>就是不可见的 Fragment 执行了 onResume() 方法</code>。onResume 方法设计的初衷，难道不是当前 Fragment 可以和用户进行交互吗？你他妈既不可见，又不能和用户进行交互，你执行 onResume 方法干嘛？</p>
<p>基于此问题，Google 在 Androidx 在 <code>FragmentTransaction</code> 中增加了 <code>setMaxLifecycle</code> 方法来控制 Fragment 所能调用的最大的生命周期函数。如下所示：</p>
<pre><code>   /**
     * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is
     * already above the received state, it will be forced down to the correct state.
     *
     * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#39;s
     * Lifecycle state capped, or previously added as part of this transaction. The
     * {@link Lifecycle.State} passed in must at least be {@link Lifecycle.State#CREATED}, otherwise
     * an {@link IllegalArgumentException} will be thrown.&lt;/p&gt;
     *
     * @param fragment the fragment to have it&#39;s state capped.
     * @param state the ceiling state for the fragment.
     * @return the same FragmentTransaction instance
     */
    @NonNull
    public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment,
            @NonNull Lifecycle.State state) {
        addOp(new Op(OP_SET_MAX_LIFECYCLE, fragment, state));
        return this;
    }
</code></pre><p>根据官方的注释，我们能知道，该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到正确的状态。</p>
<p>那如何使用该方法呢？我们先看该方法在 Androidx 模式下 ViewPager+Fragment 模式下的使用例子。</p>

        <h4 id="ViewPager-Fragment-模式下的方案"   >
          <a href="#ViewPager-Fragment-模式下的方案" class="heading-link"><i class="fas fa-link"></i></a>ViewPager+Fragment 模式下的方案</h4>
      <p>在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有  <code>behavior</code> 字段的构造函数，如下所示：</p>
<pre><code>  public FragmentPagerAdapter(@NonNull FragmentManager fm,
            @Behavior int behavior) {
        mFragmentManager = fm;
        mBehavior = behavior;
    }

  public FragmentStatePagerAdapter(@NonNull FragmentManager fm,
            @Behavior int behavior) {
        mFragmentManager = fm;
        mBehavior = behavior;
    }

</code></pre><p>其中 Behavior 的声明如下：</p>
<pre><code>   @Retention(RetentionPolicy.SOURCE)
    @IntDef({BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT})
    private @interface Behavior { }

     /**
     * Indicates that {@link Fragment#setUserVisibleHint(boolean)} will be called when the current
     * fragment changes.
     *
     * @deprecated This behavior relies on the deprecated
     * {@link Fragment#setUserVisibleHint(boolean)} API. Use
     * {@link #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT} to switch to its replacement,
     * {@link FragmentTransaction#setMaxLifecycle}.
     * @see #FragmentPagerAdapter(FragmentManager, int)
     */
    @Deprecated
    public static final int BEHAVIOR_SET_USER_VISIBLE_HINT = 0;

    /**
     * Indicates that only the current fragment will be in the {@link Lifecycle.State#RESUMED}
     * state. All other Fragments are capped at {@link Lifecycle.State#STARTED}.
     *
     * @see #FragmentPagerAdapter(FragmentManager, int)
     */
    public static final int BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = 1;
</code></pre><p>从官方的注释声明中，我们能得到如下两条结论：</p>
<ul>
<li>如果 behavior 的值为 <code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>，那么当 Fragment 对用户的可见状态发生改变时，<code>setUserVisibleHint</code> 方法会被调用。</li>
<li>如果 behavior 的值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> ，那么当前选中的 Fragment 在 <code>Lifecycle.State#RESUMED</code> 状态 ，其他不可见的 Fragment 会被限制在 <code>Lifecycle.State#STARTED</code> 状态。</li>
</ul>
<p>那 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 这个值到底有什么作用呢？我们看下面的例子：</p>
<blockquote>
<p>在该例子中设置了 ViewPager 的适配器为 FragmentPagerAdapter 且 behavior 值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>。</p>
</blockquote>
<p>默认初始化ViewPager，Fragment 生命周期如下所示：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967895238ac1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="androix1.png"></p>
<p>切换到 Fragment_2 时，日志情况如下所示：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96782b025a2f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="androix2.png"></p>
<p>切换到 Fragment_3 时，日志情况如下所示:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96788af81c73?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="androidx3.png"></p>
<blockquote>
<p>因为篇幅的原因，本文没有在讲解 FragmentStatePagerAdapter 设置 behavior 下的使用情况，但是原理以及生命周期函数调用情况一样，感兴趣的小伙伴，可以根据  <span class="exturl"><a class="exturl__link"   href="https://github.com/AndyJennifer/AndroidxLazyLoad"  target="_blank" rel="noopener">AndroidxLazyLoad</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 项目自行测试。</p>
</blockquote>
<p>观察上述例子，我们可以发现，使用了 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> 后，确实只有当前可见的 Fragment 调用了 onResume 方法。而导致产生这种改变的原因，是因为 FragmentPagerAdapter 在其 <code>setPrimaryItem</code> 方法中调用了 <code>setMaxLifecycle</code> 方法，如下所示：</p>
<pre><code>    public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
        Fragment fragment = (Fragment)object;
        //如果当前的fragment不是当前选中并可见的Fragment,那么就会调用
        // setMaxLifecycle 设置其最大生命周期为 Lifecycle.State.STARTED
        if (fragment != mCurrentPrimaryItem) {
            if (mCurrentPrimaryItem != null) {
                mCurrentPrimaryItem.setMenuVisibility(false);
                if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) {
                    if (mCurTransaction == null) {
                        mCurTransaction = mFragmentManager.beginTransaction();
                    }
                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
                } else {
                    mCurrentPrimaryItem.setUserVisibleHint(false);
                }
            }
        //对于其他非可见的Fragment,则设置其最大生命周期为
        //Lifecycle.State.RESUMED
            fragment.setMenuVisibility(true);
            if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) {
                if (mCurTransaction == null) {
                    mCurTransaction = mFragmentManager.beginTransaction();
                }
                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
            } else {
                fragment.setUserVisibleHint(true);
            }

            mCurrentPrimaryItem = fragment;
        }
    }
</code></pre><p>既然在上述条件下，只有实际可见的 Fragment 会调用 onResume 方法， 那是不是为我们提供了 ViewPager 下实现懒加载的新思路呢？也就是我们可以这样实现 Fragment 的懒加载：</p>
<pre><code>abstract class LazyFragment : Fragment() {

    private var isLoaded = false

    override fun onResume() {
        super.onResume()
        if (!isLoaded) {
            lazyInit()
            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)
            isLoaded = true
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        isLoaded = false
    }

    abstract fun lazyInit()
}
</code></pre>
        <h4 id="add-show-hide-模式下的新方案"   >
          <a href="#add-show-hide-模式下的新方案" class="heading-link"><i class="fas fa-link"></i></a>add+show+hide 模式下的新方案</h4>
      <p>虽然我们实现了Androidx 包下 ViewPager下的懒加载，但是我们仍然要考虑 add+show+hide 模式下的 Fragment 懒加载的情况，基于 ViewPager 在 <code>setPrimaryItem</code> 方法中的思路，我们可以在调用 add+show+hide 时，这样处理：</p>
<blockquote>
<p>完整的代码请点击—&gt;<span class="exturl"><a class="exturl__link"   href="https://github.com/AndyJennifer/AndroidxLazyLoad/blob/master/app/src/main/java/com/jennifer/andy/androidxlazyload/ext/ShowHideExt.kt"  target="_blank" rel="noopener">ShowHideExt</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<pre><code>/**
 * 使用add+show+hide模式加载fragment
 *
 * 默认显示位置[showPosition]的Fragment，最大Lifecycle为Lifecycle.State.RESUMED
 * 其他隐藏的Fragment，最大Lifecycle为Lifecycle.State.STARTED
 *
 *@param containerViewId 容器id
 *@param showPosition  fragments
 *@param fragmentManager FragmentManager
 *@param fragments  控制显示的Fragments
 */
private fun loadFragmentsTransaction(
    @IdRes containerViewId: Int,
    showPosition: Int,
    fragmentManager: FragmentManager,
    vararg fragments: Fragment
) {
    if (fragments.isNotEmpty()) {
        fragmentManager.beginTransaction().apply {
            for (index in fragments.indices) {
                val fragment = fragments[index]
                add(containerViewId, fragment, fragment.javaClass.name)
                if (showPosition == index) {
                    setMaxLifecycle(fragment, Lifecycle.State.RESUMED)
                } else {
                    hide(fragment)
                    setMaxLifecycle(fragment, Lifecycle.State.STARTED)
                }
            }

        }.commit()
    } else {
        throw IllegalStateException(
            &quot;fragments must not empty&quot;
        )
    }
}

/** 显示需要显示的Fragment[showFragment]，并设置其最大Lifecycle为Lifecycle.State.RESUMED。
 *  同时隐藏其他Fragment,并设置最大Lifecycle为Lifecycle.State.STARTED
 * @param fragmentManager
 * @param showFragment
 */
private fun showHideFragmentTransaction(fragmentManager: FragmentManager, showFragment: Fragment) {
    fragmentManager.beginTransaction().apply {
        show(showFragment)
        setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)

        //获取其中所有的fragment,其他的fragment进行隐藏
        val fragments = fragmentManager.fragments
        for (fragment in fragments) {
            if (fragment != showFragment) {
                hide(fragment)
                setMaxLifecycle(fragment, Lifecycle.State.STARTED)
            }
        }
    }.commit()
}
</code></pre><p>上述代码的实现也非常简单：</p>
<ul>
<li>将需要显示的 Fragment ，在调用 add 或 show 方法后，<code>setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)</code></li>
<li>将需要隐藏的 Fragment ，在调用 hide 方法后，<code>setMaxLifecycle(fragment, Lifecycle.State.STARTED)</code></li>
</ul>
<p>结合上述操作模式，查看使用 setMaxLifecycle 后，Fragment 生命周期函数调用的情况。</p>
<p>add Fragment_1、Fragment_2、Fragment_3，并 hide Fragment_2,Fragment_3 :</p>
<p>show Fragment_2，hide 其他 Fragment:</p>
<p>show Fragment_3 hide 其他 Fragment:</p>
<p>不知道是否是谷歌大大没有考虑到 Fragment 嵌套的情况，所以这里我们要对之前的方案就行修改，也就是如下所示：</p>
<pre><code>abstract class LazyFragment : Fragment() {

    private var isLoaded = false

    override fun onResume() {
        super.onResume()
        //增加了Fragment是否可见的判断
        if (!isLoaded &amp;&amp; !isHidden) {
            lazyInit()
            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)
            isLoaded = true
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        isLoaded = false
    }

    abstract fun lazyInit()

}
</code></pre><p>在上述代码中，因为同级的 Fragment 在嵌套模式下，仍然要调用 onResume 方法，所以我们增加了 Fragment 可见性的判断，这样就能保证嵌套模式下，新方案也能完美的支持 Fragment 的懒加载。</p>

        <h5 id="ViewPager2-的处理方案"   >
          <a href="#ViewPager2-的处理方案" class="heading-link"><i class="fas fa-link"></i></a>ViewPager2 的处理方案</h5>
      <p>ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法。关于 ViewPager2 的内部机制。感兴趣的小伙伴可以自行查看源码。</p>
<p>关于 ViewPager2 的懒加载测试，已上传至 <span class="exturl"><a class="exturl__link"   href="https://github.com/AndyJennifer/AndroidxLazyLoad"  target="_blank" rel="noopener">AndroidxLazyLoad</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，大家可以结合项目查看Log日志。</p>

        <h3 id="两种方式的对比与总结"   >
          <a href="#两种方式的对比与总结" class="heading-link"><i class="fas fa-link"></i></a>两种方式的对比与总结</h3>
      
        <h4 id="老一套的懒加载"   >
          <a href="#老一套的懒加载" class="heading-link"><i class="fas fa-link"></i></a>老一套的懒加载</h4>
      <ul>
<li>优点：不用去控制 FragmentManager的 add+show+hide 方法，所有的懒加载都是在Fragment 内部控制，也就是控制 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数。</li>
<li>缺点：实际不可见的 Fragment，其 <code>onResume</code> 方法任然会被调用，这种反常规的逻辑，无法容忍。</li>
</ul>

        <h4 id="新一套的懒加载（Androidx下setMaxLifecycle）"   >
          <a href="#新一套的懒加载（Androidx下setMaxLifecycle）" class="heading-link"><i class="fas fa-link"></i></a>新一套的懒加载（Androidx下setMaxLifecycle）</h4>
      <ul>
<li>优点：<code>在非特殊的情况下(缺点1)</code>，只有实际的可见 Fragment，其 <code>onResume</code> 方法才会被调用，这样才符合方法设计的初衷。</li>
<li>缺点：<ol>
<li>对于 Fragment 的嵌套，及时使用了 <code>setMaxLifecycle</code> 方法。同级不可见的Fragment， 仍然要调用 <code>onResume</code> 方法。</li>
<li>需要在原有的 add+show+hide 方法中，继续调用 setMaxLifecycle 方法来控制Fragment 的最大生命状态。</li>
</ol>
</li>
</ul>

        <h3 id="最后"   >
          <a href="#最后" class="heading-link"><i class="fas fa-link"></i></a>最后</h3>
      <p>这两种方案的优缺点已经非常明显了，到底该选择何种懒加载模式，还是要基于大家的意愿，作者我更倾向于使用新的方案。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/DayNight/">暗黑模式适配</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/DayNight/" data-flag-title="暗黑模式适配"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="暗黑模式"   >
          <a href="#暗黑模式" class="heading-link"><i class="fas fa-link"></i></a>暗黑模式</h1>
      <p>在 Android 10 里，Dark theme 暗黑模式得到了系统级的支持。 暗黑模式不仅酷炫，而且有降低屏幕耗电、在光线较暗的环境中使用更舒适等好处。 今天带大家看一下如何适配暗黑模式，本文会从以下几点进行介绍：</p>
<ul>
<li>动态开启暗黑模式</li>
<li>使用 DayNight 适配暗黑模式</li>
<li>使用 Force Dark 适配暗黑模式</li>
<li>Force Dark 系统源码解析</li>
<li>适配流程建议</li>
</ul>
<p>相信本文会让你对暗黑模式有一个更全面的了解。</p>

        <h1 id="动态开启"   >
          <a href="#动态开启" class="heading-link"><i class="fas fa-link"></i></a>动态开启</h1>
      <p>在 Android 10 系统设置里增加了暗黑模式的开关，但除了系统设置，我们也可以自己动态开启。 假如我们项目里面有一个按钮用来开关暗黑模式，可以这样做：</p>
<pre><code>btn.setOnClickListener {
    if (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_YES) {
        // 关闭暗黑模式
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
    } else {
        // 开启暗黑模式
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)
    }
}
</code></pre><p>如果当前开启了暗黑模式就关掉，反之开启。 你可能还看过另一种 delegate.localNightMode 的写法，同样也是可以生效的，它们的区别在于作用范围不同：</p>
<pre><code>// 作用于当前项目的所有组件
AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES) 
// 只作用于当前组件
delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_YES              
</code></pre><p>另外需要注意的是，在默认情况下，设置暗黑模式会重走 Activity 生命周期，需要重新渲染整个页面，所以不要在 onCreate 里直接设置。 如果不想重走生命周期，可以给 Activity 配置 android:configChanges=”uiMode”，但这样一来就需要在 onConfigurationChanged() 方法里进行手动适配。</p>

        <h2 id="NightMode"   >
          <a href="#NightMode" class="heading-link"><i class="fas fa-link"></i></a>NightMode</h2>
      <p>上面用到了 YES 和 NO 两种暗黑的状态，但其实还不止这两种，暗黑模式一共有这几种状态：</p>
<ul>
<li>MODE_NIGHT_FOLLOW_SYSTEM 跟随系统设置</li>
<li>MODE_NIGHT_NO 关闭暗黑模式</li>
<li>MODE_NIGHT_YES 开启暗黑模式</li>
<li>MODE_NIGHT_AUTO_BATTERY 系统进入省电模式时，开启暗黑模式</li>
<li>MODE_NIGHT_UNSPECIFIED 未指定，默认值</li>
</ul>
<p>由于很多定制系统对省电模式进行了魔改，所以使用 MODE_NIGHT_AUTO_BATTERY 不一定会生效。 另外，当 DefaultNightMode 和 LocalNightMode 都是默认值 MODE_NIGHT_UNSPECIFIED 的时候，会作 MODE_NIGHT_FOLLOW_SYSTEM 跟随系统处理。</p>

        <h1 id="DayNight"   >
          <a href="#DayNight" class="heading-link"><i class="fas fa-link"></i></a>DayNight</h1>
      <p>下面要开始对暗黑模式进行适配啦。我们使用 Android Studio 的 Basic Activity 模板创建一个项目，对它进行暗黑模式适配的改造。</p>

        <h2 id="DayNight-主题适配"   >
          <a href="#DayNight-主题适配" class="heading-link"><i class="fas fa-link"></i></a>DayNight 主题适配</h2>
      <p>第一步，找到当前项目使用的主题，将默认使用的 Theme.AppCompat.Light 主题修改为 Theme.AppCompat.DayNight：</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>第二步，没有第二步了，现在这个项目已经支持暗黑模式了，开启暗黑模式就能看到效果：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd485a20f96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>是不是很简单，但直觉告诉我们肯定没有这么简单。</p>

        <h2 id="硬编码"   >
          <a href="#硬编码" class="heading-link"><i class="fas fa-link"></i></a>硬编码</h2>
      <p>我们进入 MainActivity 的布局文件 activity_main，可以发现这里面是完全没有使用硬编码的。 什么叫硬编码？就是我们平时所说的「写死」。要是我们写死了一个色值，暗黑模式还能生效吗？ 马上试一下，我们给根布局写死一个白色背景 android:background=”#FFFFFF”，切换暗黑模式就变成了这样：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd487a61d7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>可以看到，在写死色值的情况下暗黑模式就失效了。下面看看对于自定义的色值，要如何适配。</p>

        <h2 id="value-night"   >
          <a href="#value-night" class="heading-link"><i class="fas fa-link"></i></a>value-night</h2>
      <p>在 colors.xml 里添加一个配置颜色，比如：</p>
<pre><code>&lt;color name=&quot;color_bg&quot;&gt;#FFFFFF&lt;/color&gt;
</code></pre><p>这个是在普通模式下使用的色值，为了适配暗黑模式，还需要一个在暗黑模式下对应的色值。 新建 values-night 目录，并把对应色值配置到这个目录下的 colors.xml 文件。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd487e14870?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>将根布局的背景颜色修改为 color_bg，这样就能使用我们自己想要的颜色进行适配了：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd48cca9fad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>在暗黑模式下，系统会优先从 night 后缀的目录下找到对应的资源配置。 以上就是使用 DayNight 主题进行暗黑模式适配的全部内容了。</p>

        <h2 id="DayNight-弊端"   >
          <a href="#DayNight-弊端" class="heading-link"><i class="fas fa-link"></i></a>DayNight 弊端</h2>
      <p>一些关于 Android 10 暗黑模式适配的文章到这里就结束了，但其实 DayNight 主题并不是 Android 10 新增的东西，它早在 Android 6.0 就已经出现。虽然它涉及的内容不多，但大家可能也发现了，在实际项目中它的可操作性并不高。 首先，使用这种适配方式，要求我们整个项目所有的色值都不能使用硬编码，要做到这一点已经很不容易了，很多项目连统一的设计规范都很难做到。再退一步讲，就算我们所有色值都是使用 xml 配置的，但 colors.xml 里配置了成百上千个色值，我们需要对所有这些色值配置一个对应的暗黑色值，并且要确保它们在暗黑模式下能比较美观的展示。 所以，除非项目本身已经有一套严格的设计规范并且严格执行了，否则使用 DayNight 主题适配暗黑模式基本是不具有可操作性的。 Android 10 新增的当然不只是一个暗黑模式的开关而已，下面我们看一下 Android 10 有什么新特性供我们适配。</p>

        <h1 id="Force-Dark"   >
          <a href="#Force-Dark" class="heading-link"><i class="fas fa-link"></i></a>Force Dark</h1>
      <p>其实我们的需求很明确，就是使用了硬编码也能被适配成暗黑模式。Android 10 新增的 Force Dark 强制暗黑就实现了这个功能。</p>

        <h2 id="forceDarkAllowed"   >
          <a href="#forceDarkAllowed" class="heading-link"><i class="fas fa-link"></i></a>forceDarkAllowed</h2>
      <p>还是回到刚才的项目，把背景写死白色，再次来到 styles.xml 的主题配置。这次我们不用 DayNight 主题了，把配置改成如下：</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:forceDarkAllowed&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>我们把主题换回 Light 亮色主题，至于为什么要用 Light 后面源码部分还会再讲到 另外，重点来了，这里还增加了一个 forceDarkAllowed 的配置，这是 compileSdkVersion 升级到 29 新增的配置，按字面意思就是「开启强制暗黑」。 这样就已经完成配置了，在 Android 10 的机器上运行一下，切换暗黑模式，记住这次的背景是写死白色的：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd48e65b69c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>背景被强制转换成黑色了，细心的还会发现，右下角按钮的背景颜色也变深了。 Force Dark 这么暴力，连我们写死的色值都改了，虽然方便，但这也给我们一种不安全感。 要是 Force Dark 适配出来的颜色不是我们想要的怎么办？我们还能自定义暗黑色值吗？也是可以的。</p>

        <h2 id="Force-Dark-自定义适配"   >
          <a href="#Force-Dark-自定义适配" class="heading-link"><i class="fas fa-link"></i></a>Force Dark 自定义适配</h2>
      <p>除了主题新增了 forceDarkAllowed 这个配置，View 里面也有。 如果某个 View 的需要使用自定义色值适配暗黑模式，我们需要对这个 View 添加这个配置，让 Force Dark 排除它：</p>
<pre><code>android:forceDarkAllowed=&quot;false&quot;
</code></pre><p>然后在代码里根据当前是否处于暗黑模式，对色值进行动态设置。 对于 View 的 forceDarkAllowed，有几点需要注意：</p>
<ul>
<li>在 View 中使用这个配置的前提是，当前主题开启了 Force Dark</li>
<li>默认值是 true，所以设为 true 和不设是一样的</li>
<li>作用范围是当前 View 以及它所有的子 View</li>
</ul>
<p>综上可以看出，其实目前并没有很好的 Force Dark 自定义方案。好在 Force Dark 的整体效果没什么大问题，就算要自定义，我们也尽量只对子 View 进行自定义。</p>

        <h1 id="Force-Dark-源码解析"   >
          <a href="#Force-Dark-源码解析" class="heading-link"><i class="fas fa-link"></i></a>Force Dark 源码解析</h1>
      <p>下面我们看一下源码，看看系统在暗黑模式下是如何对颜色进行转换的。 这里仅展示几个关键源码片段，它们之间是如何调用的就不赘述啦。</p>

        <h2 id="updateForceDarkMode"   >
          <a href="#updateForceDarkMode" class="heading-link"><i class="fas fa-link"></i></a>updateForceDarkMode</h2>
      <p>看源码首先我们要找到入口，入口就是主题的 forceDarkAllowed 配置，搜索一下可以发现这个配置会在 ViewRootImpl 被用到。 相关的说明已经用注释写在代码里了。</p>
<pre><code>// android.view.ViewRootImpl.java

private void updateForceDarkMode() {
    if (mAttachInfo.mThreadedRenderer == null) return;

    // 判断当前是否处于暗黑模式
    boolean useAutoDark = getNightMode() == Configuration.UI_MODE_NIGHT_YES;

    if (useAutoDark) {
        // 这个是被用来作为默认值用的，这里先不管它，我们后面还会讲到。
        boolean forceDarkAllowedDefault = SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false);
        TypedArray a = mContext.obtainStyledAttributes(R.styleable.Theme);
        // 判断当前是否为 Light 主题，这也是为什么我们前面要使用 Light 主题。这也很好理解，只有当前主题是亮色的时候，才需要进行暗黑的处理。
        // 判断当前是否允许开启强制暗黑，我们就是靠它找到这个地方的。
        useAutoDark = a.getBoolean(R.styleable.Theme_isLightTheme, true)
                &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault);
        a.recycle();
    }

    if (mAttachInfo.mThreadedRenderer.setForceDark(useAutoDark)) {
        // TODO: Don&#39;t require regenerating all display lists to apply this setting
        invalidateWorld(mView);
    }
}
</code></pre><p>总结一下，根据这个方法我们可以知道，Force Dark 生效有三个条件：</p>
<ul>
<li>处于暗黑模式</li>
<li>使用了 Light 亮色主题</li>
<li>允许使用 Force Dark</li>
</ul>
<p>源码再跟下去，发现调用了 Native 代码。</p>

        <h2 id="handleForceDark"   >
          <a href="#handleForceDark" class="heading-link"><i class="fas fa-link"></i></a>handleForceDark</h2>
      <p>下一个关键代码是 RenderNode 的 handleForceDark 函数。RenderNode 是绘制节点，一个 View 可以有多个绘制节点，比如一个 TextView 的文字部分是一个绘制节点，它设置的背景也是一个绘制节点。看一下这个函数做了什么。</p>
<pre><code>// frameworks/base/libs/hwui/RenderNode.cpp

void RenderNode::handleForceDark(android::uirenderer::TreeInfo *info) {
    if (CC_LIKELY(!info || info-&gt;disableForceDark)) {
        return;
    }
    // 这个函数看似有点复杂，但其实我们只需要关注 usage 这个参数。
    // usage 有两个取值，Foreground 前景和 Background 背景。
    auto usage = usageHint();
    const auto&amp; children = mDisplayList-&gt;mChildNodes;
    if (mDisplayList-&gt;hasText()) {
        // 如果当前节点 hasText() 含有文字，那它就是一个 Foreground 前景
        usage = UsageHint::Foreground;
    }
    // 下面的判断都是设为 Background 背景
    if (usage == UsageHint::Unknown) {
        if (children.size() &gt; 1) {
            usage = UsageHint::Background;
        } else if (children.size() == 1 &amp;&amp;
                children.front().getRenderNode()-&gt;usageHint() !=
                        UsageHint::Background) {
            usage = UsageHint::Background;
        }
    }
    if (children.size() &gt; 1) {
        // Crude overlap check
        SkRect drawn = SkRect::MakeEmpty();
        for (auto iter = children.rbegin(); iter != children.rend(); ++iter) {
            const auto&amp; child = iter-&gt;getRenderNode();
            // We use stagingProperties here because we haven&#39;t yet sync&#39;d the children
            SkRect bounds = SkRect::MakeXYWH(child-&gt;stagingProperties().getX(), child-&gt;stagingProperties().getY(),
                    child-&gt;stagingProperties().getWidth(), child-&gt;stagingProperties().getHeight());
            if (bounds.contains(drawn)) {
                // This contains everything drawn after it, so make it a background
                child-&gt;setUsageHint(UsageHint::Background);
            }
            drawn.join(bounds);
        }
    }
    // 根据分类，如果是背景会被设为 Dark 深色，否则是 Light 亮色。
    mDisplayList-&gt;mDisplayList.applyColorTransform(
            usage == UsageHint::Background ? ColorTransform::Dark : ColorTransform::Light);
}
</code></pre><p>这个函数做的就是对当前绘制节点进行 Foreground 还是 Background 的分类。 为了保证文字的可视度，需要保证一定的对比度，在背景切换成深色的情况下，需要把文字部分切换成亮色。</p>

        <h2 id="transformColor"   >
          <a href="#transformColor" class="heading-link"><i class="fas fa-link"></i></a>transformColor</h2>
      <p>根据分好的颜色类型，会进入 CanvasTransform 对颜色进行转换处理。这里也是 Force Dark 最核心的地方了。</p>
<pre><code>// frameworks/base/libs/hwui/CanvasTransform.cpp

static SkColor transformColor(ColorTransform transform, SkColor color) {
    switch (transform) {
        case ColorTransform::Light:
            // 转换为亮色
            return makeLight(color);
        case ColorTransform::Dark:
            // 转换为暗色
            return makeDark(color);
        default:
            return color;
    }
}
</code></pre><p>根据类型调用了对应的函数转换颜色，我们看一下 makeDark 吧。</p>
<pre><code>static SkColor makeDark(SkColor color) {
    Lab lab = sRGBToLab(color);
    float invertedL = std::min(110 - lab.L, 100.0f);
    if (invertedL &lt; lab.L) {
        lab.L = invertedL;
        return LabToSRGB(lab, SkColorGetA(color));
    } else {
        return color;
    }
}
</code></pre><p>这里把 RGB 色值转换成了 Lab 的格式。 Lab 格式含有 L、a、b 三个参数，ab 对应色彩学上的两个维度，不用管它，我们要关注的是里面的 L。 L 就是亮度，它的取值范围是 0 - 100，数值越小颜色就越暗，反之就越亮。这篇文章封面的安卓机器人右边颜色就是降低亮度后的效果。 回到代码来，这里用 110 减去当前亮度，可以说是对亮度做了取反。至于为什么是用 110 而不是用 100，我猜测是为了避免使用纯黑色。 在官方<span class="exturl"><a class="exturl__link"   href="https://material.io/design/color/dark-theme.html#properties"  target="_blank" rel="noopener">暗黑模式设计规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>可以看到，建议使用深灰色作为背景，而不是用纯黑色。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd4abaea406?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>最后比对取反的色值和原色值的亮度，将较暗的那个色值返回。 makeLight 函数也是类似的。</p>
<pre><code>static SkColor makeLight(SkColor color) {
    Lab lab = sRGBToLab(color);
    float invertedL = std::min(110 - lab.L, 100.0f);
    if (invertedL &gt; lab.L) {
        lab.L = invertedL;
        return LabToSRGB(lab, SkColorGetA(color));
    } else {
        return color;
    }
}
</code></pre><p>所以到这里我们发现，其实 Force Dark 强制暗黑转换颜色的规则，或者说是它的本质，就是<strong>亮度取反</strong>。</p>

        <h1 id="适配流程建议"   >
          <a href="#适配流程建议" class="heading-link"><i class="fas fa-link"></i></a>适配流程建议</h1>
      <p>如果你的项目 compileSdkVersion 已经升级到 29，那现在就可以开启 Force Dark 适配暗黑模式了。但很多项目要升级到 29 还有一段路要走，我们有没有办法提前适配呢？</p>

        <h2 id="Debug-Force-Dark"   >
          <a href="#Debug-Force-Dark" class="heading-link"><i class="fas fa-link"></i></a>Debug Force Dark</h2>
      <p>回到我们开始看源码的地方:</p>
<pre><code>boolean forceDarkAllowedDefault = SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false);
TypedArray a = mContext.obtainStyledAttributes(R.styleable.Theme);
useAutoDark = a.getBoolean(R.styleable.Theme_isLightTheme, true)
        &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault);
</code></pre><p>当取不到 Theme_forceDarkAllowed 的时候，会取 DEBUG_FORCE_DARK 作为默认值，在哪里可以开启这个 DEBUG_FORCE_DARK 呢？ 在 Android 10 的开发者选项里面，可以发现多了一个这样的选项：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd4ae8d9bc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>这里的「强制启用 SmartDark 功能」就是 DEBUG_FORCE_DARK 的开关，虽然我们看了源码都知道它也没有多智能。 开启后会对所有项目生效，这样就可以提前用 Force Dark 进行适配了。</p>

        <h2 id="适配流程"   >
          <a href="#适配流程" class="heading-link"><i class="fas fa-link"></i></a>适配流程</h2>
      <p>开启 Force Dark 后大概率会发现一些有问题的图片资源，比如带有固定背景的 icon 等。 如果项目有适配暗黑模式的计划，个人建议可以按以下几步走：</p>
<ol>
<li>开发者选项开启「强制启用 SmartDark」</li>
<li>替换有问题的资源，进行初步适配</li>
<li>compileSdkVersion 升级到 29</li>
<li>开启 Force Dark</li>
<li>和设计师沟通，对部分控件单独适配</li>
</ol>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h1>
      <p>使用 DayNight 主题可以实现暗黑模式的适配，但这种方法在实际项目中可操作性不高。 Android 10 新增的暗黑模式特性叫 Force Dark 强制暗黑，只需给主题添加一个允许开启的配置即可。 Force Dark 的实现方式是降低背景亮度，提高字体亮度，本质是对色值进行亮度取反。 最后，在 Android 10 的设备上，可以开启开发者选项中的「强制启用 SmartDark」，提前用 Force Dark 适配。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/0_kotlin/">使用Kotlin从零开始写一个现代Android</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/0_kotlin/" data-flag-title="使用Kotlin从零开始写一个现代Android"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h3>
      <p>经常在medium.com上看到一些高质量的技术帖子，但是由于国内的上网环境或者有的同学对于看英文比较排斥，错过了不少好文章。因此，西哥决定弄一个《优质译文专栏》，花一些时间翻译一些优质技术文给大家。这篇文章是一个小系列，用Kotlin开发现代Android APP,总共四篇，后面的会陆续翻译！以下是正文。</p>
<p>现在，真的很难找到一个涵盖所有Android新技术的项目，因此我决定自己来写一个，在本文中，我们将用到如下技术：</p>
<ul>
<li>0 、Android Studio</li>
<li>1、Kotlin 语言</li>
<li>2、构建变体</li>
<li>3、ConstraintLayout</li>
<li>4、DataBinding库</li>
<li>5、MVVM+repository+Android Manager架构模式</li>
<li>6、RxJava2及其对架构的帮助</li>
<li>7、Dagger 2.11，什么是依赖注入？为什么要使用它？</li>
<li>8、Retrofit + RxJava2 实现网络请求</li>
<li>9、RooM + RxJava2 实现储存</li>
</ul>

        <h5 id="我们的APP最终是什么样子？"   >
          <a href="#我们的APP最终是什么样子？" class="heading-link"><i class="fas fa-link"></i></a>我们的APP最终是什么样子？</h5>
      <p>我们的APP是一个非常简单的应用程序，它涵盖了上面提到的所有技术。只有一个简单的功能：从Github 获取<code>googlesamples</code>用户下的所有仓库，将数据储存到本地数据库，然后在界面展示它。</p>
<p>我将尝试解释更多的代码，你也可以看看你Github上的代码提交。</p>
<p>Github:<span class="exturl"><a class="exturl__link"   href="https://github.com/mladenrakonjac/ModernAndroidApp/tags"  target="_blank" rel="noopener">github.com/mladenrakon…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>让我们开始吧。</p>

        <h3 id="0、Android-Studio"   >
          <a href="#0、Android-Studio" class="heading-link"><i class="fas fa-link"></i></a>0、Android Studio</h3>
      <p>首先安卓Android Studio 3 beta 1(注：现在最新版为Android Studio 4.0),Android Studio 已经支持Kotlin，去到<code>Create Android Project</code>界面，你将在此处看到新的内容：带有标签的复选框<code>include Kotlin support</code>。默认情况下选中。按两次下一步，然后选择<code>EmptyActivity</code>，然后完成了。 恭喜！你用Kotlin开发了第一个Android app)</p>

        <h3 id="1、Kotlin"   >
          <a href="#1、Kotlin" class="heading-link"><i class="fas fa-link"></i></a>1、Kotlin</h3>
      <p>在刚才新建的项目中，你可以看到一个<code>MainActivity.kt</code>:</p>
<pre><code>package me.mladenrakonjac.modernandroidapp

import android.support.v7.app.AppCompatActivity
import android.os.Bundle

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}
</code></pre><p><code>.kt</code>后缀代表了这是一个Kotlin文件</p>
<p><code>MainActivity : AppCompatActivity()</code>表示我们的<code>MainActivity</code>继承自<code>AppCompatActivity</code> 。</p>
<p>此外，所有的方法都必须有一个关键字<code>fun</code>,在Kotlin 中，你不能使用<code>@override</code>注解，如果你要表明方法是复写父类或者接口的方法的话，直接使用<code>override</code>关键字，注意：它和Java不一样，不是一个注解了。</p>
<p>然后，<code>savedInstanceState: Bundle?</code> 中的<code>?</code>代表什么呢？它代表了<code>savedInstanceState</code>这个参数可以是<code>Bundle</code>或者null。Kotlin是一门null 安全语言，如果你像下面这样写：</p>
<pre><code>var a : String
</code></pre><p>你将会得到一个编译错误。因为<code>a</code>变量必须被初始化，并且不能为null，因此你要像这样写：</p>
<pre><code>var a : String = &quot;Init value&quot;
</code></pre><p>并且，如果你执行以下操作，也会报编译错误：</p>
<pre><code>a = null
</code></pre><p>要想使<code>a</code>变量为null ,你必须这样写：</p>
<pre><code>var a : String?
</code></pre><p>为什么这是Kotlin语言的一个重要功能呢？因为它帮我们避免了NPE,Androd开发者已经对NPE感到厌倦了，甚至是null的发明者-<code>Tony Hoare</code>先生，也为发明它而道歉。假设我们有一个可以为空的<code>nameTextView</code>。如果为null，以下代码将会发生NPE：</p>
<pre><code>nameTextView.setEnabled(true)
</code></pre><p>但实际上，Kotlin做得很好，它甚至不允许我们做这样的事情。它会强制我们使用<code>?</code>或者<code>!!</code>操作符。如果我们使用<code>?</code>操作符：</p>
<pre><code>nameTextView?.setEnabled(true)
</code></pre><p>仅当<code>nameTextView</code>不为null时，这行代码才会继续执行。另一种情况下，如果我们使用<code>!!</code>操作符：</p>
<pre><code>nameTextView!!.setEnabled(true)
</code></pre><p>如果<code>nameTextView</code>为null，它将为我们提供NPE。它只适合喜欢冒险的家伙)</p>
<p>这是对Kotlin的一些介绍。我们继续进行，我将停止描述其他Kotlin特定代码。</p>

        <h3 id="2、构建变体"   >
          <a href="#2、构建变体" class="heading-link"><i class="fas fa-link"></i></a>2、构建变体</h3>
      <p>通常，在开发中，如果你有两套环境，最常见的是测试环境和生产环境。这些环境在服务器<code>URL</code>，<code>图标</code>，<code>名称</code>，<code>目标api</code>等方面可能有所不同。通常，在开始的每个项目中我都有以下内容：</p>
<ul>
<li><code>finalProduction</code>: 上传Google Play 使用</li>
<li><code>demoProduction</code>:该版本使用生产环境服务器Url,并且它有着GP上的版本没有的新功能，用户可以在Google play 旁边安装，然后可以进行新功能测试和提供反馈。</li>
<li><code>demoTesting</code>:和demoProduction一样，只不过它用的是测试地址</li>
<li><code>mock</code>: 对于我来说，作为开发人员和设计师而言都是很有用的。有时我们已经准备好设计，而我们的API仍未准备好。等待API准备就绪后再开始开发可不是好的解决方案。此构建变体为提供有mock数据，因此设计团队可以对其进行测试并提供反馈。对于保证项目进度真的很有帮助,一旦API准备就绪，我们便将开发转移到demoTesting环境。</li>
</ul>
<p>在此应用程序中，我们将拥有所有这些变体。它们的applicationId和名称不同。 gradle 3.0.0 <code>flavourDimension</code>中有一个新的<code>api</code>，可让您混合不同的产品风味，因此您可以混合<code>demo</code>和<code>minApi23</code>风味。在我们的应用程序中，我们将仅使用“默认” 的<code>flavorDimension</code>。早app的<code>build.gradle</code>中，将此代码插入<code>android {}</code>下：</p>
<pre><code>flavorDimensions &quot;default&quot;

productFlavors {

    finalProduction {
        dimension &quot;default&quot;
        applicationId &quot;me.mladenrakonjac.modernandroidapp&quot;
        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App&quot;
    }

    demoProduction {
        dimension &quot;default&quot;
        applicationId &quot;me.mladenrakonjac.modernandroidapp.demoproduction&quot;
        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Demo P&quot;
    }

    demoTesting {
        dimension &quot;default&quot;
        applicationId &quot;me.mladenrakonjac.modernandroidapp.demotesting&quot;
        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Demo T&quot;
    }


    mock {
        dimension &quot;default&quot;
        applicationId &quot;me.mladenrakonjac.modernandroidapp.mock&quot;
        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Mock&quot;
    }
}
</code></pre><p>打开<code>string.xml</code>文件，删掉<code>app_name</code>string资源，因此，我们才不会发生资源冲突，然后点击<code>Sync Now</code>,如果转到屏幕左侧的<code>“构建变体”</code>，则可以看到4个不同的构建变体，其中每个都有两种构建类型：“Debug”和“Release”,切换到<code>demoProduction</code>构建变体并运行它。然后切换到另一个并运行它。您就可以看到两个名称不同的应用程序。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/9/172996a0132edd8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h3 id="3、ConstraintLayout"   >
          <a href="#3、ConstraintLayout" class="heading-link"><i class="fas fa-link"></i></a>3、ConstraintLayout</h3>
      <p>如果你打开<code>activity_main.xml</code>,你可以看到跟布局是<code>ConstraintLayout</code>,如果你开发过iOS应用程序，你可能知道<code>AutoLayout</code>，<code>ConstraintLayout</code>和它非常的相似，他们甚至用了相同的<code>Cassowary</code>算法。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello World!&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
</code></pre><p>Constraints可以帮我们描述View之间的关系。对于每一个View来说，应该有4个约束，每一边一个约束，在这种情况下，我们的View就被约束在了父视图的每一边了。</p>
<p>在Design Tab中，如果你将<code>Hello World</code>文本稍微向上移动，则在<code>Text</code>Tab中将增加下面这行代码：</p>
<pre><code>app:layout_constraintVertical_bias=&quot;0.28&quot;
</code></pre><p><img   src="http://user-gold-cdn.xitu.io/2020/6/9/17299720fee769d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><code>Design</code> tab 和 <code>Text</code> tab是同步的，我们在Design中移动视图，则会影响Text中的<code>xml</code>，反之亦然。垂直偏差描述了视图对其约束的垂直趋势。如果要使视图垂直居中，则应使用：</p>
<pre><code>app:layout_constraintVertical_bias=&quot;0.28&quot;
</code></pre><p>我们让<code>Activity</code>只显示一个仓库，它有仓库的名字，star的数量，作者，并且还会显示是否有issue</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/9/1729977d7debb137?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>要得到上面的布局设计，代码如下所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/repository_name&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginEnd=&quot;16dp&quot;
        android:layout_marginStart=&quot;16dp&quot;
        android:textSize=&quot;20sp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;0.0&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintVertical_bias=&quot;0.083&quot;
        tools:text=&quot;Modern Android app&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/repository_has_issues&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginEnd=&quot;16dp&quot;
        android:layout_marginStart=&quot;16dp&quot;
        android:layout_marginTop=&quot;8dp&quot;
        android:text=&quot;@string/has_issues&quot;
        android:textStyle=&quot;bold&quot;
        app:layout_constraintBottom_toBottomOf=&quot;@+id/repository_name&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;1.0&quot;
        app:layout_constraintStart_toEndOf=&quot;@+id/repository_name&quot;
        app:layout_constraintTop_toTopOf=&quot;@+id/repository_name&quot;
        app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/repository_owner&quot;
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginBottom=&quot;8dp&quot;
        android:layout_marginEnd=&quot;16dp&quot;
        android:layout_marginStart=&quot;16dp&quot;
        android:layout_marginTop=&quot;8dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toBottomOf=&quot;@+id/repository_name&quot;
        app:layout_constraintVertical_bias=&quot;0.0&quot;
        tools:text=&quot;Mladen Rakonjac&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/number_of_starts&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginBottom=&quot;8dp&quot;
        android:layout_marginEnd=&quot;16dp&quot;
        android:layout_marginStart=&quot;16dp&quot;
        android:layout_marginTop=&quot;8dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;1&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toBottomOf=&quot;@+id/repository_owner&quot;
        app:layout_constraintVertical_bias=&quot;0.0&quot;
        tools:text=&quot;0 stars&quot; /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;

</code></pre><p>不要被<code>tools:text</code>搞迷惑了，它的作用仅仅是让我们可以预览我们的布局。</p>
<p>我们可以注意到，我们的布局是扁平的，没有任何嵌套，你应该尽量少的使用布局嵌套，因为它会影响我们的性能。ConstraintLayout也可以在不同的屏幕尺寸下正常工作。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/9/172997c1dd00ddd1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>我有种预感，很快就能达到我们想要的布局效果了。</p>
<p>上面只是一些关于<code>ConstraintLayout</code>的少部分介绍，你也可以看一下关于<code>ConstraintLayout</code>使用的google code lab: <span class="exturl"><a class="exturl__link"   href="https://codelabs.developers.google.com/codelabs/constraint-layout/index.html?index=..%2F..%2Findex#0"  target="_blank" rel="noopener">codelabs.developers.google.com/codelabs/co…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="4-Data-binding-library"   >
          <a href="#4-Data-binding-library" class="heading-link"><i class="fas fa-link"></i></a>4. Data binding library</h3>
      <p>当我听到Data binding 库的时候，我的第一反应是：Butterknife已经很好了，再加上，我现在使用一个插件来从xml中获取View,我为啥要改变，来使用Data binding呢？但当我对Data binding有了更多的了解之后，我的它的感觉就像我第一次见到Butterknife一样，无法自拔。</p>

        <h5 id="Butterknife能帮我们做啥？"   >
          <a href="#Butterknife能帮我们做啥？" class="heading-link"><i class="fas fa-link"></i></a>Butterknife能帮我们做啥？</h5>
      <p>ButterKnife帮助我们摆脱无聊的<code>findViewById</code>。因此，如果您有5个视图，而没有Butterknife，则你有5 + 5行代码来绑定您的视图。使用ButterKnife，您只有我行代码就搞定。就是这样。</p>

        <h5 id="Butterknife的缺点是什么？"   >
          <a href="#Butterknife的缺点是什么？" class="heading-link"><i class="fas fa-link"></i></a>Butterknife的缺点是什么？</h5>
      <p>Butterknife仍然没有解决代码可维护问题，使用ButterKnife时，我经常发现自己遇到运行时异常，这是因为我删除了xml中的视图，而没有删除Activity/Fragment类中的绑定代码。另外，如果要在xml中添加视图，则必须再次进行绑定。真的很不好维护。你将浪费大量时间来维护View绑定。</p>

        <h5 id="那与之相比，Data-Binding-怎么样呢？"   >
          <a href="#那与之相比，Data-Binding-怎么样呢？" class="heading-link"><i class="fas fa-link"></i></a>那与之相比，Data Binding 怎么样呢？</h5>
      <p>有很多好处，使用Data Binding，你可以只用一行代码就搞定View的绑定，让我们看看它是如何工作的，首先，先将Data Binding 添加到项目：</p>
<pre><code>// at the top of file 
apply plugin: &#39;kotlin-kapt&#39;


android {
    //other things that we already used
    dataBinding.enabled = true
}
dependencies {
    //other dependencies that we used
    kapt &quot;com.android.databinding:compiler:3.0.0-beta1&quot;
}
</code></pre><p>请注意，数据绑定编译器的版本与项目<code>build.gradle</code>文件中的gradle版本相同：</p>
<pre><code>classpath &#39;com.android.tools.build:gradle:3.0.0-beta1&#39;
</code></pre><p>然后，点击<code>Sync Now</code>,打开<code>activity_main.xml</code>,将<code>Constraint Layout</code>用layout标签包裹</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;

    &lt;android.support.constraint.ConstraintLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:context=&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/repository_name&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginEnd=&quot;16dp&quot;
            android:layout_marginStart=&quot;16dp&quot;
            android:textSize=&quot;20sp&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintHorizontal_bias=&quot;0.0&quot;
            app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
            app:layout_constraintRight_toRightOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot;
            app:layout_constraintVertical_bias=&quot;0.083&quot;
            tools:text=&quot;Modern Android app&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/repository_has_issues&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginEnd=&quot;16dp&quot;
            android:layout_marginStart=&quot;16dp&quot;
            android:layout_marginTop=&quot;8dp&quot;
            android:text=&quot;@string/has_issues&quot;
            android:textStyle=&quot;bold&quot;
            app:layout_constraintBottom_toBottomOf=&quot;@+id/repository_name&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintHorizontal_bias=&quot;1.0&quot;
            app:layout_constraintStart_toEndOf=&quot;@+id/repository_name&quot;
            app:layout_constraintTop_toTopOf=&quot;@+id/repository_name&quot;
            app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/repository_owner&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginBottom=&quot;8dp&quot;
            android:layout_marginEnd=&quot;16dp&quot;
            android:layout_marginStart=&quot;16dp&quot;
            android:layout_marginTop=&quot;8dp&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toBottomOf=&quot;@+id/repository_name&quot;
            app:layout_constraintVertical_bias=&quot;0.0&quot;
            tools:text=&quot;Mladen Rakonjac&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/number_of_starts&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginBottom=&quot;8dp&quot;
            android:layout_marginEnd=&quot;16dp&quot;
            android:layout_marginStart=&quot;16dp&quot;
            android:layout_marginTop=&quot;8dp&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintHorizontal_bias=&quot;1&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toBottomOf=&quot;@+id/repository_owner&quot;
            app:layout_constraintVertical_bias=&quot;0.0&quot;
            tools:text=&quot;0 stars&quot; /&gt;

    &lt;/android.support.constraint.ConstraintLayout&gt;

&lt;/layout&gt;

</code></pre><p>注意，你需要将所有的xml移动到layout 标签下面，然后点击<code>Build</code>图标或者使用快捷键<code>Cmd + F9</code>,我们需要构建项目来使Data Binding库为我们生成<code>ActivityMainBinding</code>类，后面在MainActivity中将用到它。</p>
<p>如果没有重新编译项目，你是看不到<code>ActivityMainBinding</code>的，因为它在编译时生成。</p>
<p>我们还没有完成绑定，我们只是定义了一个非空的 ActivityMainBinding 类型的变量。你会注意到我没有把<code>?</code> 放在 ActivityMainBinding 的后面，而且也没有初始化它。这怎么可能呢？<code>lateinit</code> 关键字允许我们使用非空的延迟被初始化的变量。和 ButterKnife 类似，在我们的布局准备完成后，初始化绑定需要在 onCreate 方法中进行。此外，你不应该在 onCreate 方法中声明绑定，因为你很有可能在 onCreate 方法外使用它。我们的 binding 不能为空，所以这就是我们使用 lateinit 的原因。使用 lateinit 修饰，我们不需要在每次访问它的时候检查 binding 变量是否为空。</p>
<p>我们初始化binding变量，你需要替换:</p>
<pre><code>setContentView(R.layout.activity_main)
</code></pre><p>为：</p>
<pre><code>binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
</code></pre><p>就是这样，你成功的绑定了所有View,现在你可以访问它并且做一些更改，例如，我们将仓库名字改为<code>Modern Android Medium Article</code>:</p>
<pre><code>binding.repositoryName.text = &quot;Modern Android Medium Article&quot;
</code></pre><p>如你所见，现在我们可以通过<code>bingding</code>变量来访问<code>main_activity.xml</code>的所有View了（前提是它们有id）,这就是Data Binding 比ButterKnife 好用的原因。</p>

        <h5 id="kotlin的-Getters-和-setters"   >
          <a href="#kotlin的-Getters-和-setters" class="heading-link"><i class="fas fa-link"></i></a>kotlin的 Getters 和 setters</h5>
      <p>大概，你已经注意到了，我们没有像Java那样使用<code>.setText()</code>，我想在这里暂停一下，以说明与Java相比，Kotlin中的getter和setter方法如何工作的。</p>
<p>首先，你需要知道，我们为什么要使用getters和setters，我们用它来隐藏类中的变量，仅允许使用方法来访问这些变量，这样我们就可以向用户隐藏类中的细节，并禁止用户直接修改我们的类。假设我们用 Java 写了一个 Square 类：</p>
<pre><code>public class Square {
  private int a;

  Square(){
    a = 1;
  }

  public void setA(int a){
    this.a = Math.abs(a);
  }

  public int getA(){
    return this.a;
  }

}
</code></pre><p>使用<code>setA()</code>方法，我们禁止了用户向<code>Square</code>类的<code>a</code>变量设置一个负数,因为正方形的边长一定是正数，要使用这种方法，我们必须将其设为私有，因此不能直接设置它。这也意味着我们不能直接获得<code>a</code>，需要给它定一个get方法来返回<code>a</code>，如果有10个变量，那么我们就得定义10个相似的get方法，写这样无聊的样板代码，通常会影响我们的心情。</p>
<p>Kotling使我们的开发人员更轻松了。如果你调用下面的代码：</p>
<pre><code>var side: Int = square.a
</code></pre><p>这并不意味着你是在直接访问a变量，它和Java中调用<code>getA()</code>是相同的</p>
<pre><code>int side = square.getA();
</code></pre><p>因为Kotlin自动生成默认的getter和setter。在Kotlin中，只有当您有特殊的setter或getter时，才应指定它。否则，Kotlin会为您自动生成：</p>
<pre><code>var a = 1
   set(value) { field = Math.abs(value) }
</code></pre><p><code>field</code> ? 这又是个什么东西？为了更清楚明白，请看下面代码：</p>
<pre><code>var a = 1
   set(value) { a = Math.abs(value) }
</code></pre><p>这表明你在调用set方法中的<code>set(value){}</code>，因为Kotlin的世界中，没有直接访问属性，这就会造成无限递归，当你调用<code>a = something</code>,会自动调用set方法。使用filed就能避免无限递归，我希望这能让你明白为什么要用filed关键字，并且了解getters和setters是如何工作的。</p>
<p>回到代码中继续，我将向你介绍Kotlin语言的另一个重要功能:apply函数：</p>
<pre><code>class MainActivity : AppCompatActivity() {

    lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        binding.apply {
            repositoryName.text = &quot;Medium Android Repository Article&quot;
            repositoryOwner.text = &quot;Mladen Rakonjac&quot;
            numberOfStarts.text = &quot;1000 stars&quot;

        }
    }
}
</code></pre><p>apply 允许你在一个实例上调用多个方法，我们仍然还没有完成数据绑定，还有更棒的事儿，让我们为仓库定义一个UI模型（这个是github仓库的数据模型Repository,它持有要展示的数据，请不要和Repository模式的中的Repository搞混淆了哈），要创建一个Kotlin class，点击<code>New -&gt; Kotlin File/Class :</code></p>
<pre><code>class Repository(var repositoryName: String?,var repositoryOwner: String?,var numberOfStars: Int? ,var hasIssues: Boolean = false)
</code></pre><p>在Kotlin中，主构造函数是类头的一部分，如果你不想定义次构造函数，那就是这样了，数据类到此就完成了，构造函数没有参数分配给字段，没有setters和getters,整个类就一行代码。</p>
<p>回到<code>MainActivity.kt</code>，为<code>Repository</code>创建一个实例。</p>
<pre><code>var repository = Repository(&quot;Medium Android Repository Article&quot;,
        &quot;Mladen Rakonjac&quot;, 1000, true)
</code></pre><p>你应该注意到了，创建类实例，没有用<code>new</code></p>
<p>现在，我们在<code>activity_main.xml</code>中添加data标签。</p>
<pre><code>&lt;data&gt;
      &lt;variable
        name=&quot;repository&quot;
        type=&quot;me.mladenrakonjac.modernandroidapp.uimodels.Repository&quot;
        /&gt;
&lt;/data&gt;
</code></pre><p>我们可以在布局中访问存储的变量<code>repository</code>,例如，我们可以如下使用id是<code>repository_name</code>的TextView,如下：</p>
<pre><code>android:text=&quot;@{repository.repositoryName}&quot;
</code></pre><p>repository_name文本视图将显示从repository变量的属性<code>repositoryName</code>获取的文本。剩下的唯一事情就是将<code>repository</code>变量从xml绑定到<code>MainActivity.kt</code>中的repository。</p>
<p>点击Build使DataBinding 为我们生成类，然后在MainActivity中添加两行代码：</p>
<pre><code>binding.repository = repository
binding.executePendingBindings()
</code></pre><p>如果你运行APP,你会看到TextView上显示的是：<code>“Medium Android Repository Article”</code>,非常棒的功能，是吧？</p>
<p>但是，如果我们像下面这样改一下呢？</p>
<pre><code>Handler().postDelayed({repository.repositoryName=&quot;New Name&quot;}, 2000)
</code></pre><p>新的文本将会在2000ms后显示吗？不会的，你必须重新设置一次<code>repository</code>,像这样：</p>
<pre><code>Handler().postDelayed({repository.repositoryName=&quot;New Name&quot;
    binding.repository = repository
    binding.executePendingBindings()}, 2000)
</code></pre><p>但是，如果我们每次更改一个属性都要这么写的话，那就非常蛋疼了，这里有一个更好的方案叫做<code>Property Observer</code>。</p>
<p>让我们首先解释一下什么是观察者模式，因为在rxJava部分中我们也将需要它：</p>
<p>可能你已经听说过<code>http://androidweekly.net/</code>,这是一个关于Android开发的周刊。如果您想接收它，则必须订阅它并提供您的电子邮件地址。过了一段时间，如果你不想看了，你可以去网站上取消订阅。</p>
<p>这就是一个<code>观察者/被观察者</code>的模式,在这个例子中， Android 周刊是<code>被观察者</code>,它每周都会发布新闻通讯。读者是<code>观察者</code>，因为他们订阅了它，一旦订阅就会收到数据，如果不想读了，则可以停止订阅。</p>
<p><code>Property Observer</code>在这个例子中就是 xml layout,它将会监听<code>Repository</code>实例的变化。因此，<code>Repository</code>是<code>被观察者</code>,例如，一旦在Repository类的实例中更改了repository nane 属性后，xml不调用下面的代码也会更新：</p>
<pre><code>binding.repository = repository
binding.executePendingBindings()
</code></pre><p>如何让它使用Data Binding 库呢？，Data Binding库提供了一个<code>BaseObservable</code>类，我们的Repostory类必须继承它。</p>
<pre><code>class Repository(repositoryName : String, var repositoryOwner: String?, var numberOfStars: Int?
                 , var hasIssues: Boolean = false) : BaseObservable(){

    @get:Bindable
    var repositoryName : String = &quot;&quot;
    set(value) {
        field = value
        notifyPropertyChanged(BR.repositoryName)
    }

}
</code></pre><p>当我们使用了 Bindable 注解时，就会自动生成 BR 类。你会看到，一旦设置新值，就会通知它更新。现在运行 app 你将看到仓库的名字在 2 秒后改变而不必再次调用 <code>executePendingBindings()</code>。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/android11/">Android 11 Beta 版正式发布！以及众多面向开发者的重磅更新</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/android11/" data-flag-title="Android 11 Beta 版正式发布！以及众多面向开发者的重磅更新"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Android-11-Beta-版现已发布"   >
          <a href="#Android-11-Beta-版现已发布" class="heading-link"><i class="fas fa-link"></i></a>Android 11 Beta 版现已发布</h2>
      <p>自二月以来，大家通过 Android 11 开发者预览版为我们提供了众多反馈。今天发布的 Android 11 第一个 Beta 版聚焦于三个主题: <strong>以人为本</strong>、<strong>灵活控制</strong>以及<strong>隐私安全</strong>。</p>
<p><strong>以人为本</strong></p>
<p>Android 现在更突显人的要素，更善于沟通。我们重塑了您在手机上进行沟通的方式，也让操作系统能识别出那些对您来说更重要的人，让您能更快速地和他们联系。</p>
<ul>
<li><strong>会话通知</strong>会显示在通知栏顶部的专门区域，其设计更凸显联系对象，且提供了会话特定的操作，例如以 Bubbles 的形式打开聊天、在主屏幕中创建会话快捷方式，以及设置提醒。</li>
<li><strong>Bubbles</strong> 可以让用户在手机上多任务切换时依然保持对话可见及可用。消息和聊天应用可以通过基于通知的 Bubbles API，在 Android 11 上提供这种全新体验。</li>
<li><strong>键盘提示整合</strong>功能为用户带来了更便利的输入补全和提示。自动填写应用以及 IME (输入法编辑器) 可以通过这个功能在 IME 提示列表中安全地给出基于上下文的实体和字符串建议。</li>
<li><strong>Voice Access (语音操作)</strong>。对完全使用语音操作设备的用户，Android 现在提供设备集成的屏幕内容感知功能 (visual cortex)，该功能可以理解屏幕中呈现的内容及其上下文，从而为无障碍指令生成标签和操作点。</li>
</ul>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/11/172a20231667797f?imageslim" style=""  alt="img"></p>
<p><strong>灵活控制</strong></p>
<p>最新版的 Android 现在可帮您快速访问所有的智能设备，并集中控制它们:</p>
<ul>
<li><strong>Device Controls (设备控制)</strong> 让用户得以更快、更轻松地访问和控制他们连接的设备。只需长按电源按钮就可以调出设备控制菜单，一站式完成设备控制。应用也可以通过新的 API 出现在这个控制菜单中。阅读<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/features/device-control"  target="_blank" rel="noopener">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>了解更多。</li>
<li><strong>Media Controls (媒体控制)</strong> 让用户得以更快捷地切换音频和视频内容的播放设备——不论是耳机、麦克风还是电视。您现在可以在开发者选项中启用此功能，在后续的 Beta 版本中本功能会默认启用。阅读<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/features/media-controls"  target="_blank" rel="noopener">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>了解更多。</li>
</ul>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/11/172a2035dc3bf460?imageslim" style=""  alt="img"></p>
<p><strong>隐私安全</strong></p>
<p>在 Android 11 中我们为用户带来了更高的掌控能力，让他们能更好地管理敏感权限。我们还会通过更快速的系统更新来持续确保设备安全。</p>
<ul>
<li><strong>单次授权:</strong> 用户现在可以授予应用一次性的权限来访问设备的麦克风、摄像头或者位置信息。应用下次被使用时需要再次请求权限才能进行访问。阅读<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/privacy/permissions"  target="_blank" rel="noopener">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>了解更多。</li>
<li><strong>权限自动重置:</strong> 如果用户在很长一段时间里未使用某应用，Android 11 将自动重置所有与该应用关联的权限并通知用户。在用户下次使用该应用时，应用可以再次请求权限。阅读<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/privacy/permissions#auto-reset"  target="_blank" rel="noopener">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>了解更多。</li>
<li><strong>后台位置:</strong> 我们在今年二月宣布，开发者需要获得批准后才可以让应用在后台访问位置信息，从而避免该信息遭到不当使用。现在我们为开发者提供更长的时间来做出修改，在 2021 年之前我们不会强行要求既有的应用遵守本政策。阅读<span class="exturl"><a class="exturl__link"   href="https://support.google.com/googleplay/android-developer/answer/9799150"  target="_blank" rel="noopener">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>了解更多。</li>
<li><strong>Google Play 系统更新</strong>自去年发布以来，让我们得以更快速地更新操作系统核心组件，并覆盖 Android 生态系统中的众多设备。在 Android 11 中，可更新的模块数量增加了一倍有余，新增的 12 个可更新模块会更有力地确保隐私和安全，以及为用户和开发者带来更好的一致性。</li>
</ul>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/11/172a205b989e4b18?imageslim" style=""  alt="img"></p>
<p><strong>开发者友好</strong></p>
<p>我们希望让开发者能更轻松地用好新版 Android。在兼容性测试方面，有这些举措来减少大家的工作量:</p>
<ul>
<li>有破坏性的行为变更 (breaking changes) 只在您针对 Android 11 发布应用时才生效。所以在您明确修改应用的清单文件之前，这些变更不会对您造成影响。</li>
<li>在开发者选项中加入了全新的界面，来让您逐一开关这些更新选项，以更好地完成测试。</li>
<li>新增了平台稳定性里程碑，在这个版本中所有的 API 和行为变更都已调整完毕并进入稳定状态，这时您可以放心地对应用做出最终更新。</li>
<li>版本发布时间表 <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/overview#timeline"  target="_blank" rel="noopener">developer.android.google.cn/preview/ove…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>Android 11 还带来了其他提升开发效率的改进，比如 ADB 无线调试、能更快安装大型 APK 的 ADB Incremental (ADB 增量安装)，以及在平台 API 上加入更多的可空性注解 (从而在构建时就发现问题，不用等到运行时才出错)，等等。</p>
<p>Android 11 第一个 Beta 版本现已发布，您可以在自己的应用中体验终版 SDK 和 NDK API，以及各种全新功能。如果您使用的是 Pixel 2、3、3a 或 4 系列设备，请<span class="exturl"><a class="exturl__link"   href="https://www.google.com/android/beta"  target="_blank" rel="noopener">参加测试</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>并获取 Android 11 Beta 的 OTA 更新。和以往一样，您可以直接下载系统并安装至 <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/get#on_pixel"  target="_blank" rel="noopener">Pixel 设备</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>以及<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/preview/get#on_emulator"  target="_blank" rel="noopener"> Android 模拟器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。请访问 <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/11"  target="_blank" rel="noopener">Android 11 开发者网站</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>查看完整的 Android 11 开发者功能。</p>

        <h2 id="现代化-Android-开发-Modern-Android-development"   >
          <a href="#现代化-Android-开发-Modern-Android-development" class="heading-link"><i class="fas fa-link"></i></a>现代化 Android 开发 (Modern Android development)</h2>
      <p>在过去数年中，Android 团队通过卓绝的努力持续改善移动开发者的体验，提升大家的开发效率。这些努力包括 Android Studio IDE、一种优秀的开发语言 (没错，就是 Kotlin)、让日常任务更加轻松的 Jetpack 库，以及可以更好地进行应用分发的 Android App Bundle。我们将这些努力统称为<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/modern-android-development"  target="_blank" rel="noopener">现代化 Android 开发</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (Modern Android development)，一切都是为了让您能提升效率，从而尽情释放出 Android 的潜力。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/11/172a2082729f09a2?imageslim" style=""  alt="img"></p>

        <h2 id="Android-Studio"   >
          <a href="#Android-Studio" class="heading-link"><i class="fas fa-link"></i></a>Android Studio</h2>
      <p>今天，我们也通过 Android Studio 4.1 Beta 版和 4.2 Canary 版为大家带来了许多全新功能，主要聚焦于开发者们提出的这些关键诉求:</p>
<ul>
<li><strong>调试更简单</strong>，通过 ADB 无线调试功能更轻松地在 Android 设备上进行调试。我们还新增了 Database Inspector 和依赖注入 (Dagger) 工具。</li>
<li><strong>设备测试体验更佳</strong>。Android 模拟器现在直接集成在 IDE 中，您可以并排显示测试中的应用，同时查看不同设备上的运行结果。我们还改进了设备管理器，让您更轻松地管理多个设备。</li>
<li><strong>更易用的机器学习</strong>: 您现在可以将 ML Kit 和 TensorFlow Lite 模型直接导入 IDE。</li>
<li><strong>更快速的构建与部署</strong>: <span class="exturl"><a class="exturl__link"   href="https://github.com/android/kotlin/tree/ksp/libraries/tools/kotlin-symbol-processing-api"  target="_blank" rel="noopener">Kotlin 符号处理</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>可以将任务图缓存在 Gradle 中，使得应用部署到 Android 11 设备中的速度更快。全新的 Build Analyzer 让您可以很快找到应用构建的性能瓶颈。</li>
<li><strong>更强大的游戏工具</strong>: 改进性能分析界面，并为大家带来了全新的 System Trace 工具，以及原生内存分析功能。</li>
</ul>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/11/172a20a43d3ec10b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/studio/preview"  target="_blank" rel="noopener">即刻体验</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> Android Studio 4.1 Beta 版和 Android Studio 4.2 Canary 版。</p>

        <h2 id="Kotlin-和-Jetpack"   >
          <a href="#Kotlin-和-Jetpack" class="heading-link"><i class="fas fa-link"></i></a>Kotlin 和 Jetpack</h2>
      <p>现代化 Android 开发中的重要环节之一就是编程语言和开发库: <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/kotlin"  target="_blank" rel="noopener">Kotlin</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是一种现代且简洁的编程语言，<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/jetpack"  target="_blank" rel="noopener">Jetpack</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 则提供了颇具特色且功能强大的开发库，二者都专注于提升开发者的工作效率。</p>
<ul>
<li><strong>腾讯视频链接</strong></li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://v.qq.com/x/page/h0980xhkr5t.html"  target="_blank" rel="noopener">v.qq.com/x/page/h098…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><strong>Bilibili 视频链接</strong></li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1Xk4y1B7sT/"  target="_blank" rel="noopener">www.bilibili.com/video/BV1Xk…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Kotlin 的迅速普及 (目前 Google Play 排名前 1,000 的应用中超过 70% 都使用 Kotlin) 和众多开发者的青睐，使得我们可以通过该语言以全新的方式优化开发体验。<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/kotlin/coroutines"  target="_blank" rel="noopener">Kotlin 协程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是 Kotlin 语言的诸多强大功能之一，它可以让您更轻松地编写并发调用，同时获得更高的可读性。现在，我们正式推荐开发者使用协程。我们还在 3 个最常用的 Jetpack 库 (<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle"  target="_blank" rel="noopener">Lifecycle</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/topic/libraries/architecture/workmanager"  target="_blank" rel="noopener">WorkManager</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 和 <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/topic/libraries/architecture/room"  target="_blank" rel="noopener">Room</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>) 中使用了协程，以便您可以利用这些库编写更优质的代码。</p>
<p>Kotlin 自身也随着版本演进而愈发出色，这离不开 Jetbrains 团队的杰出贡献。<span class="exturl"><a class="exturl__link"   href="https://kotlinlang.org/eap/"  target="_blank" rel="noopener">Kotlin 1.4 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>带来了更快的代码补全功能、更强大的类型推断 (默认启用)、各类函数接口，以及各种提升开发者体验的改进，比如可以混合使用命名参数和定位参数。</p>
<p>我们也在持续推动 Jetpack 的演进，这套开发库涵盖了多个 Android 版本，并帮助大家更快速、更轻松地实现常见的移动开发范式。很多用户一直对 Dagger 情有独钟，因此我们联合 Dagger 团队推出了 <span class="exturl"><a class="exturl__link"   href="http://developer.android.google.cn/training/dependency-injection/hilt-android"  target="_blank" rel="noopener">Hilt</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，这是基于 Dagger 的封装方案，且易于开发者使用。我们推荐使用 Hilt 作为 Android 的依赖注入解决方案，并提供了 Alpha 试用版。我们还新增了一个 <span class="exturl"><a class="exturl__link"   href="http://developer.android.google.cn/topic/libraries/app-startup"  target="_blank" rel="noopener">App Startup</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 库，帮助应用和库开发者优化库的初始化，进而缩短应用启动时间。此外，我们还<span class="exturl"><a class="exturl__link"   href="https://medium.com/androiddevelopers/whats-new-in-jetpack-1891d205e136"  target="_blank" rel="noopener">更新了许多现有的开发库</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，包括对<span class="exturl"><a class="exturl__link"   href="http://developer.android.google.cn/paging3"  target="_blank" rel="noopener"> Paging 3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 进行的重大更新——优先使用 Kotlin 进行了重写，并且完全支持协程！</p>

        <h2 id="全新-UI-工具包-Compose-的最新进展"   >
          <a href="#全新-UI-工具包-Compose-的最新进展" class="heading-link"><i class="fas fa-link"></i></a>全新 UI 工具包: Compose 的最新进展</h2>
      <p>想要进一步提升开发效率，您还需要强大的界面工具包，以便快速简便地在 Android 上构建精美的界面，同时还能原生访问系统 API。为此，我们构建了 <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/jetpack/compose"  target="_blank" rel="noopener">Jetpack Compose</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，这是一款全新的现代界面工具包，通过强大的工具和直观的 Kotlin API，帮助您用更少的代码打造心目中的理想应用。</p>
<p>今天，我们为大家带来 <strong>Jetpack Compose 开发者预览版 2</strong>，其中包含开发者们一直要求的诸多功能:</p>
<ul>
<li>与 View 的互操作性 (开始在当前应用中混合使用 Composable 方法) (新！)</li>
<li>动画 (新！)</li>
<li>测试 (新！)</li>
<li>约束布局 (新！)</li>
<li>适配器列表 (新！)</li>
<li>Material UI 组件</li>
<li>文本以及可编辑文本 (新！)</li>
<li>主题和图像</li>
<li>窗口管理</li>
<li>输入和手势</li>
</ul>
<p>通过与 Jetbrains Kotlin 团队的紧密合作，我们在 Android Studio 4.2 中加入了许多新功能，来帮助您通过 Compose 构建应用:</p>
<ul>
<li>用于生成代码的 Kotlin 编译器插件</li>
<li>Compose 预览注解</li>
<li>实时交互式 Compose 预览</li>
<li>将单个的 Composable 部署至设备</li>
<li>Compose 代码补全</li>
<li>适用于 Compose 的示例数据 API</li>
</ul>
<p>Compose 尚未准备好用于生产环境。我们虽然进行了性能优化，但还需要通过大家试用以获得<span class="exturl"><a class="exturl__link"   href="https://issuetracker.google.com/issues/new?component=612128"  target="_blank" rel="noopener">反馈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。我们计划于今年夏天发布 alpha 版，并于明年发布 1.0 版。</p>

        <h2 id="Google-Play-Console-全新改版"   >
          <a href="#Google-Play-Console-全新改版" class="heading-link"><i class="fas fa-link"></i></a>Google Play Console 全新改版</h2>
      <p>Google Play 致力于帮助开发者发展业务。为了更好地达成这一目的，我们重新设计了 Google Play Console，让您可以在我们的平台上获得进一步的成功。除了更简洁、更易用之外，新版 Play Console 还增添了不少功能，让您可以:</p>
<ul>
<li>找到、发现和理解 Play Console 的功能，从而在 Google Play 上收获成功</li>
<li>获取政策变化、发布状态和用户反馈的最新指导信息</li>
<li>通过全新的用户获取报告更好地解读数据表现</li>
<li>通过全新的用户管理选项，让团队中的每个人都能用好 Play Console 提供的功能</li>
</ul>
<p>请阅读文章《Google Play Console beta 版全新发布》进一步了解详情，您也可以访问 play.google.com/console 参与 Beta 版体验。您的反馈能帮助我们为每一个人打造更好的 Google Play Console，我们期待着您的声音。</p>
<ul>
<li><strong>腾讯视频链接</strong></li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://v.qq.com/x/page/x0980f5awj2.html"  target="_blank" rel="noopener">v.qq.com/x/page/x098…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><strong>Bilibili 视频链接</strong></li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1EC4y1a7bU/"  target="_blank" rel="noopener">www.bilibili.com/video/BV1EC…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>我们带来的更新远不止这些！欢迎大家继续关注我们接下来将要发布的内容:</p>
<ul>
<li>我们为大家准备了 <strong>12 场精彩演讲</strong>，会在接下来一段时间陆续发布。</li>
<li>我们会通过 “<strong>11 Weeks of Android</strong>“ 系列内容持续吸引大家对 Android 11 的热情，每周都会带来大家关注的全新开发者内容，比如 UI、Jetpack 和机器学习。请前往<span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/11weeksofandroid"  target="_blank" rel="noopener">官方网站</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>查看发布日程。</li>
<li>我们将在全球举办一系列线上活动，来和大家一起探讨 Android 11 的新内容、应用兼容性，以及现代化 Android 开发的基本知识和最佳实践。请前往 <span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/android11/meetups"  target="_blank" rel="noopener">官方网站</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>了解详情。同时，也可以直接参与到您所在的 GDG 社区的本地活动:</li>
</ul>
<p>7 月 4 日上海 GDG 社区</p>
<p><span class="exturl"><a class="exturl__link"   href="https://www.meetup.com/Shanghai-GDG/events/270723097/"  target="_blank" rel="noopener">www.meetup.com/Shanghai-GD…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>其他的社区活动将在后续发布，敬请关注。</p>
<p><strong><span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/android11"  target="_blank" rel="noopener">点击这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>前往 Android 11 Beta 版官方网站</strong></p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/11/172a21264fe4e17f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/vue_js/">10+个很酷的Vue.js组件，模板和demo示例</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/vue_js/" data-flag-title="10+个很酷的Vue.js组件，模板和demo示例"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>众所周知，<strong>Vue.js</strong> 组件是Vue创建自定义元素的重要功能之一，同时，模板可帮助你避免从头开始创建网页设计。总之，这些工具对于希望其开发过程更快，更高效的任何Web开发人员都是必不可少的。</p>
<p>此外，在过去的几年中，Vue.js 变得非常流行，许多企业将其添加到他们的技术栈中。该框架的优点是它具有内置的数据绑定和MVC模型（模型、视图、控制器），与<strong>Angular.js</strong>和<strong>React.js</strong>相比，它使配置更加容易。另外，Vue.js的学习曲线很小，与 Angular.js 相比，Vue更易于学习，理解和使用。</p>
<p>知道了这一点，我们收集了一份Vue.js组件、模板和实验清单，如果你是一个初学者，可以帮助你对这个框架的意义有一个概念，如果你是一个Vue.js开发者，也可以为你的下一个项目找到一些灵感。</p>
<hr>

        <h2 id="BootstrapVue-Argon-Dashboard-PRO"   >
          <a href="#BootstrapVue-Argon-Dashboard-PRO" class="heading-link"><i class="fas fa-link"></i></a>BootstrapVue Argon Dashboard PRO</h2>
      <p><strong><span class="exturl"><a class="exturl__link"   href="https://demos.creative-tim.com/bootstrap-vue-argon-dashboard-pro"  target="_blank" rel="noopener">BootstrapVue Argon Dashboard PRO</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong> 是BootstrapVue和Vue.js的高级仪表板。这是一种全新产品，它基于我们从头开始重新构建的最新框架结构，这种结构旨在使产品更直观，更具适应性，并且更易于定制。让Argon以其酷炫的功能给你带来惊喜，让你的项目达到一个全新的水平。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e597c2e7a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://demos.creative-tim.com/bootstrap-vue-argon-dashboard-pro"></p>

        <h2 id="Vue-White-Dashboard"   >
          <a href="#Vue-White-Dashboard" class="heading-link"><i class="fas fa-link"></i></a>Vue White Dashboard</h2>
      <p><a href="https://demos.creative-tim.com/vue-white-dashboard" target="_blank" rel="noopener"><strong>Vue White Dashboard</strong> </a>是一个免费的开源Bootstrap 4和Vue.js Admin仪表板，其中包含大量的组件，这些组件可以组合在一起并看起来非常漂亮。Vue White仪表板具有16个以上的独立组件，可让你自由选择和组合。所有组件的颜色都可以不同，你可以使用Sass文件轻松进行修改。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e597b7ccc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://demos.creative-tim.com/vue-white-dashboard"></p>

        <h2 id="Vue-QRcode-Reader"   >
          <a href="#Vue-QRcode-Reader" class="heading-link"><i class="fas fa-link"></i></a>Vue QRcode Reader</h2>
      <p><a href="https://gruhn.github.io/vue-qrcode-reader?rel=nofollow" target="_blank"><strong>Vue QRcode Reader</strong></a>是一组用于检测和解码QR(二维码)码的Vue.js组件。它使你无需离开浏览器即可检测和解码QR码，所有组件都具有响应能力。除此之外，它接近零样式，因此你可以使它们适合你的布局。使用方法简单明了。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59a3db85f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://gruhn.github.io/vue-qrcode-reader"></p>

        <h2 id="VueJS-Expo"   >
          <a href="#VueJS-Expo" class="heading-link"><i class="fas fa-link"></i></a>VueJS Expo</h2>
      <p><a href="https://vuejsexpo.com" target="_blank" rel="noopener"><strong>VueJS Expo</strong></a>是使用Vue.js框架收集的漂亮的网站，应用程序和实验。如果你是Vue.js框架的粉丝，那么这里可能是你获得灵感的地方。展示包括基于VueJS的主题，元素，仪表板等。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59a7bae7d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://vuejsexpo.com"></p>

        <h2 id="Vue-Paper-Dashboard-PRO"   >
          <a href="#Vue-Paper-Dashboard-PRO" class="heading-link"><i class="fas fa-link"></i></a>Vue Paper Dashboard PRO</h2>
      <p><strong><span class="exturl"><a class="exturl__link"   href="https://demos.creative-tim.com/bs3/vue-paper-dashboard-pro/#/admin/overview"  target="_blank" rel="noopener">Vue Paper Dashboard PRO</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong> 是一个基于Bootstrap和Vue构建的漂亮资源，它将帮助你在短时间内开始开发仪表盘。Vue Paper Dashboard Pro是<span class="exturl"><a class="exturl__link"   href="https://www.creative-tim.com/product/paper-dashboard-pro?ref=devto"  target="_blank" rel="noopener">Original Paper Dashboard Pro</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的VueJS移植版本。使用仪表板非常简单，但是需要具备Javascript，Vue和Vue-Router的基础知识。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59c10157c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://demos.creative-tim.com/bs3/vue-paper-dashboard-pro/#/admin/overview"></p>

        <h2 id="Koel"   >
          <a href="#Koel" class="heading-link"><i class="fas fa-link"></i></a>Koel</h2>
      <p><a href="https://koel.dev/?rel=nofollow" target="_blank"><strong>Koel</strong></a>是一种简单的基于Web的个人音频流服务，在客户端用Vue编写，在服务器端用Laravel编写。针对Web开发人员，Koel采用了一些更现代的Web技术——CSS grid，音频和拖放API等来完成其工作。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59da7e067?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://koel.dev/"></p>

        <h2 id="Vue-Argon-Dashboard"   >
          <a href="#Vue-Argon-Dashboard" class="heading-link"><i class="fas fa-link"></i></a>Vue Argon Dashboard</h2>
      <p><a href="https://demos.creative-tim.com/vue-argon-dashboard" target="_blank" rel="noopener"><strong>Vue Argon Dashboard</strong></a>是Bootstrap 4和Vue.js的仪表板。它是开源的，免费的，并且具有许多组件，可以帮助你创建出色的网站。Vue Argon仪表板内置了100多个单独的组件，因此你可以选择和组合，因为实现了所有元素，所以从原型化到全功能代码将节省大量时间。该仪表板附带了预先构建的示例，因此开发过程是无缝的，从我们的页面切换到真实的网站非常容易。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5c28b45c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://demos.creative-tim.com/vue-argon-dashboard"></p>

        <h2 id="Pagekit"   >
          <a href="#Pagekit" class="heading-link"><i class="fas fa-link"></i></a>Pagekit</h2>
      <p><a href="https://pagekit.com/?rel=nofollow" target="_blank"><strong>Pagekit</strong></a>是使用Symfony组件和VueJS构建的模块化，轻量级CMS。无论是个人博客还是你公司的网站，都可以使用Pagekit来为网络创建功能强大的内容，使其在每台设备上都能完美运行。它具有干净直观的界面，它也有一个很棒的内置市场。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5c3ac5bd2?imageslim" style=""  alt="http://pagekit.com/"></p>

        <h2 id="Vue-Material-Dashboard-PRO"   >
          <a href="#Vue-Material-Dashboard-PRO" class="heading-link"><i class="fas fa-link"></i></a>Vue Material Dashboard PRO</h2>
      <p><a href="https://demos.creative-tim.com/vue-material-dashboard-pro" target="_blank" rel="noopener"><strong>Vue Material Dashboard PRO</strong></a>是一个出色的高级管理模板，建立在Vue Material和VueJS之上。它是通过考虑你在仪表板中实际需要的东西而创建的。Vue Material Dashboard PRO包含精选和优化的VueJS插件，一切都旨在相互配合。使用仪表板非常简单，但是需要具备Javascript，VueJS和Vue Router的基础知识。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5c80134f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://demos.creative-tim.com/vue-material-dashboard-pro"></p>

        <h2 id="Vue-Color"   >
          <a href="#Vue-Color" class="heading-link"><i class="fas fa-link"></i></a>Vue-Color</h2>
      <p><a href="http://vue-color.surge.sh/?rel=nofollow" target="_blank"><strong>Vue-Color</strong></a>是一款来自Sketch、Photoshop、Chrome、Github、Twitter、Material Design等的酷炫的采色器。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5e1f3ae5c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://vue-color.surge.sh"></p>

        <h2 id="Vue-Material-Kit"   >
          <a href="#Vue-Material-Kit" class="heading-link"><i class="fas fa-link"></i></a>Vue Material Kit</h2>
      <p><strong><span class="exturl"><a class="exturl__link"   href="https://demos.creative-tim.com/vue-material-kit"  target="_blank" rel="noopener">Vue Material Kit</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong> 是基于Vue Material和VueJS构建的令人惊叹的免费开源资源。它将帮助你立即开始开发UI工具包。Vue Material Kit是原始<span class="exturl"><a class="exturl__link"   href="https://www.creative-tim.com/product/material-kit"  target="_blank" rel="noopener">Material Kit</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的官方VueJS版本。使用UI Kit非常简单，但是需要Javascript，VueJS和Vue Router的基础知识。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5ee23af35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://demos.creative-tim.com/vue-material-kit"></p>

        <h2 id="Retrospectify"   >
          <a href="#Retrospectify" class="heading-link"><i class="fas fa-link"></i></a>Retrospectify</h2>
      <p><strong><span class="exturl"><a class="exturl__link"   href="http://pepf.nl/retrospective/?rel=nofollow"  target="_blank">Retrospectify</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong> 是一个用 Vue 编写的很棒的工具，用于以数字方式进行敏捷团队回顾。当与远程团队进行回顾时，或者当您希望随时间跟踪回顾结果时，这将很有用。它有三种类型的笔记，你可以移动笔记或添加点到个别的笔记。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e60a7f9562?imageslim" style=""  alt="http://pepf.nl/retrospective"></p>

        <h2 id="Code-Notes"   >
          <a href="#Code-Notes" class="heading-link"><i class="fas fa-link"></i></a>Code Notes</h2>
      <p><strong><span class="exturl"><a class="exturl__link"   href="https://lauthieb.github.io/code-notes/?rel=nofollow"  target="_blank">Code Notes</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong> 是使用Electron＆Vue.js构建的开发人员的简单代码段管理器。使用它，你可以将多个片段保存在一个便笺中，按名称/语言/标签进行搜索，还可以管理Github要点。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/8/172944e610d83a53?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="http://lauthieb.github.io/code-notes"></p>
<p><strong>希望这份清单对您的下一个开发项目有帮助 🙂</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/typescript/">TypeScript泛型及应用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/typescript/" data-flag-title="TypeScript泛型及应用"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>觉得 TypeScript 泛型有点难，想系统学习 TypeScript 泛型相关知识的小伙伴们看过来，<strong>本文从八个方面入手，全方位带你一步步学习 TypeScript 中泛型</strong>，详细的内容大纲请看下图：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/10/1729b3d970e872ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="master-ts-generic"></p>
<p><strong>动静（图）结合</strong>，在泛型学习之路助你一臂之力，还在犹豫什么，赶紧开启 TypeScript 泛型的学习之旅吧！</p>

        <h3 id="一、泛型是什么"   >
          <a href="#一、泛型是什么" class="heading-link"><i class="fas fa-link"></i></a>一、泛型是什么</h3>
      <p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p>
<p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>
<p>为了便于大家更好地理解上述的内容，我们来举个例子，在这个例子中，我们将一步步揭示泛型的作用。首先我们来定义一个通用的 <code>identity</code> 函数，该函数接收一个参数并直接返回它：</p>
<pre><code>function identity (value) {
  return value;
}

console.log(identity(1)) // 1
</code></pre><p>现在，我们将 <code>identity</code> 函数做适当的调整，以支持 TypeScript 的 Number 类型的参数：</p>
<pre><code>function identity (value: Number) : Number {
  return value;
}

console.log(identity(1)) // 1
</code></pre><p>这里 <code>identity</code> 的问题是我们将 <code>Number</code> 类型分配给参数和返回类型，使该函数仅可用于该原始类型。但该函数并不是可扩展或通用的，很明显这并不是我们所希望的。</p>
<p>我们确实可以把 <code>Number</code> 换成 <code>any</code>，我们失去了定义应该返回哪种类型的能力，并且在这个过程中使编译器失去了类型保护的作用。我们的目标是让 <code>identity</code> 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用泛型来解决这个问题，具体实现方式如下：</p>
<pre><code>function identity &lt;T&gt;(value: T) : T {
  return value;
}

console.log(identity&lt;Number&gt;(1)) // 1
</code></pre><p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。但这没什么可担心的，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/10/1729b3d9774a21ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="generic-type-filled"></p>
<p>参考上面的图片，当我们调用 <code>identity&lt;Number&gt;(1)</code> ，<code>Number</code> 类型就像参数 <code>1</code> 一样，它将在出现 <code>T</code> 的任何位置填充该类型。图中 <code>&lt;T&gt;</code> 内部的 <code>T</code> 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 <code>value</code> 参数用来代替它的类型：此时 <code>T</code> 充当的是类型，而不是特定的 Number 类型。</p>
<p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p>
<ul>
<li>K（Key）：表示对象中的键类型；</li>
<li>V（Value）：表示对象中的值类型；</li>
<li>E（Element）：表示元素类型。</li>
</ul>
<p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p>
<pre><code>function identity &lt;T, U&gt;(value: T, message: U) : T {
  console.log(message);
  return value;
}

console.log(identity&lt;Number, string&gt;(68, &quot;Semlinker&quot;));
</code></pre><p><img   src="http://user-gold-cdn.xitu.io/2020/6/10/1729b3dbccc38ea7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="generic-multi-type-filled"></p>
<p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p>
<pre><code>function identity &lt;T, U&gt;(value: T, message: U) : T {
  console.log(message);
  return value;
}

console.log(identity(68, &quot;Semlinker&quot;));
</code></pre><p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。下面我们来看张动图，直观地感受一下类型传递的过程：</p>
<p>![generic-type-filled](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="780" height="480"></svg>)</p>
<p>（图片来源：<span class="exturl"><a class="exturl__link"   href="https://medium.com/better-programming/typescript-generics-90be93d8c292）"  target="_blank" rel="noopener">medium.com/better-prog…</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>
<p>感谢 @仑（前端搬砖党）指出，该动图有bug。</p>
<p>动态图最后一句错了吗？console.log(identity([1,2,3]))这里注入类型应该是number[]吧？</p>
</blockquote>
<p>如你所见，该函数接收你传递给它的任何类型，使得我们可以为不同类型创建可重用的组件。现在我们再来看一下 <code>identity</code> 函数：</p>
<pre><code>function identity &lt;T, U&gt;(value: T, message: U) : T {
  console.log(message);
  return value;
}
</code></pre><p>相比之前定义的 <code>identity</code> 函数，新的 <code>identity</code> 函数增加了一个类型变量 <code>U</code>，但该函数的返回类型我们仍然使用 <code>T</code>。如果我们想要返回两种类型的对象该怎么办呢？针对这个问题，我们有多种方案，其中一种就是使用元组，即为元组设置通用的类型：</p>
<pre><code>function identity &lt;T, U&gt;(value: T, message: U) : [T, U] {
  return [value, message];
}
</code></pre><p>虽然使用元组解决了上述的问题，但有没有其它更好的方案呢？答案是有的，你可以使用泛型接口。</p>

        <h3 id="二、泛型接口"   >
          <a href="#二、泛型接口" class="heading-link"><i class="fas fa-link"></i></a>二、泛型接口</h3>
      <p>为了解决上面提到的问题，首先让我们创建一个用于的 <code>identity</code> 函数通用 <code>Identities</code> 接口：</p>
<pre><code>interface Identities&lt;V, M&gt; {
  value: V,
  message: M
}
</code></pre><p>在上述的 <code>Identities</code> 接口中，我们引入了类型变量 <code>V</code> 和 <code>M</code>，来进一步说明有效的字母都可以用于表示类型变量，之后我们就可以将 <code>Identities</code> 接口作为 <code>identity</code> 函数的返回类型：</p>
<pre><code>function identity&lt;T, U&gt; (value: T, message: U): Identities&lt;T, U&gt; {
  console.log(value + &quot;: &quot; + typeof (value));
  console.log(message + &quot;: &quot; + typeof (message));
  let identities: Identities&lt;T, U&gt; = {
    value,
    message
  };
  return identities;
}

console.log(identity(68, &quot;Semlinker&quot;));
</code></pre><p>以上代码成功运行后，在控制台会输出以下结果：</p>
<pre><code>68: number
Semlinker: string
{value: 68, message: &quot;Semlinker&quot;}
</code></pre><p>泛型除了可以应用在函数和接口之外，它也可以应用在类中，下面我们就来看一下在类中如何使用泛型。</p>

        <h3 id="三、泛型类"   >
          <a href="#三、泛型类" class="heading-link"><i class="fas fa-link"></i></a>三、泛型类</h3>
      <p>在类中使用泛型也很简单，我们只需要在类名后面，使用 <code>&lt;T, ...&gt;</code> 的语法定义任意多个类型变量，具体示例如下：</p>
<pre><code>interface GenericInterface&lt;U&gt; {
  value: U
  getIdentity: () =&gt; U
}

class IdentityClass&lt;T&gt; implements GenericInterface&lt;T&gt; {
  value: T

  constructor(value: T) {
    this.value = value
  }

  getIdentity(): T {
    return this.value
  }

}

const myNumberClass = new IdentityClass&lt;Number&gt;(68);
console.log(myNumberClass.getIdentity()); // 68

const myStringClass = new IdentityClass&lt;string&gt;(&quot;Semlinker!&quot;);
console.log(myStringClass.getIdentity()); // Semlinker!
</code></pre><p>接下来我们以实例化 <code>myNumberClass</code> 为例，来分析一下其调用过程：</p>
<ul>
<li>在实例化 <code>IdentityClass</code> 对象时，我们传入 <code>Number</code> 类型和构造函数参数值 <code>68</code>；</li>
<li>之后在 <code>IdentityClass</code> 类中，类型变量 <code>T</code> 的值变成 <code>Number</code> 类型；</li>
<li><code>IdentityClass</code> 类实现了 <code>GenericInterface&lt;T&gt;</code>，而此时 <code>T</code> 表示 <code>Number</code> 类型，因此等价于该类实现了 <code>GenericInterface&lt;Number&gt;</code> 接口；</li>
<li>而对于 <code>GenericInterface&lt;U&gt;</code> 接口来说，类型变量 <code>U</code> 也变成了 <code>Number</code>。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。</li>
</ul>
<p>泛型类可确保在整个类中一致地使用指定的数据类型。比如，你可能已经注意到在使用 Typescript 的 React 项目中使用了以下约定：</p>
<pre><code>type Props = {
  className?: string
   ...
};

type State = {
  submitted?: bool
   ...
};

class MyComponent extends React.Component&lt;Props, State&gt; {
   ...
}
</code></pre><p>在以上代码中，我们将泛型与 React 组件一起使用，以确保组件的 props 和 state 是类型安全的。</p>
<p>相信看到这里一些读者会有疑问，我们在什么时候需要使用泛型呢？通常在决定是否使用泛型时，我们有以下两个参考标准：</p>
<ul>
<li>当你的函数、接口或类将处理多种数据类型时；</li>
<li>当函数、接口或类在多个地方使用该数据类型时。</li>
</ul>
<p>很有可能你没有办法保证在项目早期就使用泛型的组件，但是随着项目的发展，组件的功能通常会被扩展。这种增加的可扩展性最终很可能会满足上述两个条件，在这种情况下，引入泛型将比复制组件来满足一系列数据类型更干净。</p>
<p>我们将在本文的后面探讨更多满足这两个条件的用例。不过在这样做之前，让我们先介绍一下 Typescript 泛型提供的其他功能。</p>

        <h3 id="四、泛型约束"   >
          <a href="#四、泛型约束" class="heading-link"><i class="fas fa-link"></i></a>四、泛型约束</h3>
      <p>有时我们可能希望限制每个类型变量接受的类型数量，这就是泛型约束的作用。下面我们来举几个例子，介绍一下如何使用泛型约束。</p>

        <h4 id="4-1-确保属性存在"   >
          <a href="#4-1-确保属性存在" class="heading-link"><i class="fas fa-link"></i></a>4.1 确保属性存在</h4>
      <p>有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。</p>
<p>一个很好的例子是在处理字符串或数组时，我们会假设 <code>length</code> 属性是可用的。让我们再次使用 <code>identity</code> 函数并尝试输出参数的长度：</p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
  console.log(arg.length); // Error
  return arg;
}
</code></pre><p>在这种情况下，编译器将不会知道 <code>T</code> 确实含有 <code>length</code> 属性，尤其是在可以将任何类型赋给类型变量 <code>T</code> 的情况下。我们需要做的就是让类型变量 <code>extends</code> 一个含有我们所需属性的接口，比如这样：</p>
<pre><code>interface Length {
  length: number;
}

function identity&lt;T extends Length&gt;(arg: T): T {
  console.log(arg.length); // 可以获取length属性
  return arg;
}
</code></pre><p><code>T extends Length</code> 用于告诉编译器，我们支持已经实现 <code>Length</code> 接口的任何类型。之后，当我们使用不含有 <code>length</code> 属性的对象作为参数调用  <code>identity</code> 函数时，TypeScript 会提示相关的错误信息：</p>
<pre><code>identity(68); // Error
// Argument of type &#39;68&#39; is not assignable to parameter of type &#39;Length&#39;.(2345)
</code></pre><p>此外，我们还可以使用 <code>,</code> 号来分隔多种约束类型，比如：<code>&lt;T extends Length, Type2, Type3&gt;</code>。而对于上述的 <code>length</code> 属性问题来说，如果我们显式地将变量设置为数组类型，也可以解决该问题，具体方式如下：</p>
<pre><code>function identity&lt;T&gt;(arg: T[]): T[] {
   console.log(arg.length);  
   return arg; 
}

// or
function identity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {      
  console.log(arg.length);
  return arg; 
}
</code></pre>
        <h4 id="4-2-检查对象上的键是否存在"   >
          <a href="#4-2-检查对象上的键是否存在" class="heading-link"><i class="fas fa-link"></i></a>4.2 检查对象上的键是否存在</h4>
      <p>泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 <code>keyof</code> 操作符，<strong><code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</strong> “耳听为虚，眼见为实”，我们来举个 <code>keyof</code> 的使用示例：</p>
<pre><code>interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;
type K2 = keyof Person[];  // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...
type K3 = keyof { [x: string]: Person };  // string | number
</code></pre><p>通过 <code>keyof</code> 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 <code>extends</code> 约束，即限制输入的属性名包含在 <code>keyof</code> 返回的联合类型中。具体的使用方式如下：</p>
<pre><code>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
  return obj[key];
}
</code></pre><p>在以上的 <code>getProperty</code> 函数中，我们通过 <code>K extends keyof T</code> 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 <code>let value = obj[key];</code> 不同。</p>
<p>下面我们来看一下如何使用 <code>getProperty</code> 函数：</p>
<pre><code>enum Difficulty {
  Easy,
  Intermediate,
  Hard
}

function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
  return obj[key];
}

let tsInfo = {
   name: &quot;Typescript&quot;,
   supersetOf: &quot;Javascript&quot;,
   difficulty: Difficulty.Intermediate
}

let difficulty: Difficulty = 
  getProperty(tsInfo, &#39;difficulty&#39;); // OK

let supersetOf: string = 
  getProperty(tsInfo, &#39;superset_of&#39;); // Error
</code></pre><p>在以上示例中，对于 <code>getProperty(tsInfo, &#39;superset_of&#39;)</code> 这个表达式，TypeScript 编译器会提示以下错误信息：</p>
<pre><code>Argument of type &#39;&quot;superset_of&quot;&#39; is not assignable to parameter of type 
&#39;&quot;difficulty&quot; | &quot;name&quot; | &quot;supersetOf&quot;&#39;.(2345)
</code></pre><p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。接下来，我们来介绍一下泛型参数默认类型。</p>

        <h3 id="五、泛型参数默认类型"   >
          <a href="#五、泛型参数默认类型" class="heading-link"><i class="fas fa-link"></i></a>五、泛型参数默认类型</h3>
      <p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。</p>
<p>泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 <code>&lt;T=Default Type&gt;</code>，对应的使用示例如下：</p>
<pre><code>interface A&lt;T=string&gt; {
  name: T;
}

const strA: A = { name: &quot;Semlinker&quot; };
const numB: A&lt;number&gt; = { name: 101 };
</code></pre><p>泛型参数的默认类型遵循以下规则：</p>
<ul>
<li>有默认类型的类型参数被认为是可选的。</li>
<li>必选的类型参数不能在可选的类型参数后。</li>
<li>如果类型参数有约束，类型参数的默认类型必须满足这个约束。</li>
<li>当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。</li>
<li>如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。</li>
</ul>

        <h3 id="六、泛型条件类型"   >
          <a href="#六、泛型条件类型" class="heading-link"><i class="fas fa-link"></i></a>六、泛型条件类型</h3>
      <p>在 TypeScript 2.8 中引入了条件类型，使得我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 <code>extends</code> 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。</p>
<p>条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p>
<pre><code>T extends U ? X : Y
</code></pre><p>以上表达式的意思是：若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code>。在条件类型表达式中，我们通常还会结合 <code>infer</code> 关键字，实现类型抽取：</p>
<pre><code>interface Dictionary&lt;T = any&gt; {
  [key: string]: T;
}

type StrDict = Dictionary&lt;string&gt;

type DictMember&lt;T&gt; = T extends Dictionary&lt;infer V&gt; ? V : never
type StrDictMember = DictMember&lt;StrDict&gt; // string
</code></pre><p>在上面示例中，当类型 T 满足 <code>T extends Dictionary</code> 约束时，我们会使用 <code>infer</code> 关键字声明了一个类型变量 V，并返回该类型，否则返回 <code>never</code> 类型。</p>
<blockquote>
<p>在 TypeScript 中，<code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>
<p>另外，需要注意的是，没有类型是 <code>never</code> 的子类型或可以赋值给 <code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>
</blockquote>
<p>除了上述的应用外，利用条件类型和 <code>infer</code> 关键字，我们还可以方便地实现获取 Promise 对象的返回值类型，比如：</p>
<pre><code>async function stringPromise() {
  return &quot;Hello, Semlinker!&quot;;
}

interface Person {
  name: string;
  age: number;
}

async function personPromise() {
  return { name: &quot;Semlinker&quot;, age: 30 } as Person;
}

type PromiseType&lt;T&gt; = (args: any[]) =&gt; Promise&lt;T&gt;;
type UnPromisify&lt;T&gt; = T extends PromiseType&lt;infer U&gt; ? U : never;

type extractStringPromise = UnPromisify&lt;typeof stringPromise&gt;; // string
type extractPersonPromise = UnPromisify&lt;typeof personPromise&gt;; // Person
</code></pre>
        <h3 id="七、泛型工具类型"   >
          <a href="#七、泛型工具类型" class="heading-link"><i class="fas fa-link"></i></a>七、泛型工具类型</h3>
      <p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍其中几个常用的工具类型。</p>

        <h4 id="7-1-Partial"   >
          <a href="#7-1-Partial" class="heading-link"><i class="fas fa-link"></i></a>7.1 Partial</h4>
      <p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p>
<p><strong>定义：</strong></p>
<pre><code>/**
 * node_modules/typescript/lib/lib.es5.d.ts
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
};
</code></pre><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p>
<p><strong>示例：</strong></p>
<pre><code>interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: &quot;organize desk&quot;,
  description: &quot;clear clutter&quot;
};

const todo2 = updateTodo(todo1, {
  description: &quot;throw out trash&quot;
});
</code></pre><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p>
<pre><code>{
   title?: string | undefined;
   description?: string | undefined;
}
</code></pre>
        <h4 id="7-2-Record"   >
          <a href="#7-2-Record" class="heading-link"><i class="fas fa-link"></i></a>7.2 Record</h4>
      <p><code>Record&lt;K extends keyof any, T&gt;</code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p>
<p><strong>定义：</strong></p>
<pre><code>/**
 * node_modules/typescript/lib/lib.es5.d.ts
 * Construct a type with a set of properties K of type T
 */
type Record&lt;K extends keyof any, T&gt; = {
    [P in K]: T;
};
</code></pre><p><strong>示例：</strong></p>
<pre><code>interface PageInfo {
  title: string;
}

type Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;

const x: Record&lt;Page, PageInfo&gt; = {
  about: { title: &quot;about&quot; },
  contact: { title: &quot;contact&quot; },
  home: { title: &quot;home&quot; }
};
</code></pre>
        <h4 id="7-3-Pick"   >
          <a href="#7-3-Pick" class="heading-link"><i class="fas fa-link"></i></a>7.3 Pick</h4>
      <p><code>Pick&lt;T, K extends keyof T&gt;</code> 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。</p>
<p><strong>定义：</strong></p>
<pre><code>// node_modules/typescript/lib/lib.es5.d.ts

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
};
</code></pre><p><strong>示例：</strong></p>
<pre><code>interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;

const todo: TodoPreview = {
  title: &quot;Clean room&quot;,
  completed: false
};
</code></pre>
        <h4 id="7-4-Exclude"   >
          <a href="#7-4-Exclude" class="heading-link"><i class="fas fa-link"></i></a>7.4 Exclude</h4>
      <p><code>Exclude&lt;T, U&gt;</code> 的作用是将某个类型中属于另一个的类型移除掉。</p>
<p><strong>定义：</strong></p>
<pre><code>// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Exclude from T those types that are assignable to U
 */
type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre><p>如果 <code>T</code> 能赋值给 <code>U</code> 类型的话，那么就会返回 <code>never</code> 类型，否则返回 <code>T</code> 类型。最终实现的效果就是将 <code>T</code> 中某些属于 <code>U</code> 的类型移除掉。</p>
<p><strong>示例：</strong></p>
<pre><code>type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &quot;b&quot; | &quot;c&quot;
type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &quot;c&quot;
type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number
</code></pre>
        <h4 id="7-5-ReturnType"   >
          <a href="#7-5-ReturnType" class="heading-link"><i class="fas fa-link"></i></a>7.5 ReturnType</h4>
      <p><code>ReturnType&lt;T&gt;</code> 的作用是用于获取函数 <code>T</code> 的返回类型。</p>
<p><strong>定义：</strong></p>
<pre><code>// node_modules/typescript/lib/lib.es5.d.ts

/**
 * Obtain the return type of a function type
 */
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;
</code></pre><p><strong>示例：</strong></p>
<pre><code>type T0 = ReturnType&lt;() =&gt; string&gt;; // string
type T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // void
type T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // {}
type T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // number[]
type T4 = ReturnType&lt;any&gt;; // any
type T5 = ReturnType&lt;never&gt;; // any
type T6 = ReturnType&lt;string&gt;; // Error
type T7 = ReturnType&lt;Function&gt;; // Error
</code></pre><p>简单介绍了泛型工具类型，最后我们来介绍如何使用泛型来创建对象。</p>

        <h3 id="八、使用泛型创建对象"   >
          <a href="#八、使用泛型创建对象" class="heading-link"><i class="fas fa-link"></i></a>八、使用泛型创建对象</h3>
      
        <h4 id="8-1-构造签名"   >
          <a href="#8-1-构造签名" class="heading-link"><i class="fas fa-link"></i></a>8.1 构造签名</h4>
      <p>有时，泛型类可能需要基于传入的泛型 T 来创建其类型相关的对象。比如：</p>
<pre><code>class FirstClass {
  id: number | undefined;
}

class SecondClass {
  name: string | undefined;
}

class GenericCreator&lt;T&gt; {
  create(): T {
    return new T();
  }
}

const creator1 = new GenericCreator&lt;FirstClass&gt;();
const firstClass: FirstClass = creator1.create();

const creator2 = new GenericCreator&lt;SecondClass&gt;();
const secondClass: SecondClass = creator2.create();
</code></pre><p>在以上代码中，我们定义了两个普通类和一个泛型类 <code>GenericCreator&lt;T&gt;</code>。在通用的 <code>GenericCreator</code> 泛型类中，我们定义了一个名为 <code>create</code> 的成员方法，该方法会使用 new 关键字来调用传入的实际类型的构造函数，来创建对应的对象。但可惜的是，以上代码并不能正常运行，对于以上代码，在 <strong>TypeScript v3.9.2</strong> 编译器下会提示以下错误：</p>
<pre><code>&#39;T&#39; only refers to a type, but is being used as a value here.
</code></pre><p>这个错误的意思是：<code>T</code> 类型仅指类型，但此处被用作值。那么如何解决这个问题呢？根据 TypeScript 文档，为了使通用类能够创建 T 类型的对象，我们需要通过其构造函数来引用 T 类型。对于上述问题，在介绍具体的解决方案前，我们先来介绍一下构造签名。</p>
<p>在 TypeScript 接口中，你可以使用 <code>new</code> 关键字来描述一个构造函数：</p>
<pre><code>interface Point {
  new (x: number, y: number): Point;
}
</code></pre><p>以上接口中的 <code>new (x: number, y: number)</code> 我们称之为构造签名，其语法如下：</p>
<blockquote>
<p><em>ConstructSignature:</em> <code>new</code> <em>TypeParametersopt</em> <code>(</code> <em>ParameterListopt</em> <code>)</code> <em>TypeAnnotationopt</em></p>
</blockquote>
<p>在上述的构造签名中，<code>TypeParametersopt</code> 、<code>ParameterListopt</code> 和 <code>TypeAnnotationopt</code> 分别表示：可选的类型参数、可选的参数列表和可选的类型注解。与该语法相对应的几种常见的使用形式如下：</p>
<pre><code>new C  
new C ( ... )  
new C &lt; ... &gt; ( ... )
</code></pre><p>介绍完构造签名，我们再来介绍一个与之相关的概念，即构造函数类型。</p>

        <h4 id="8-2-构造函数类型"   >
          <a href="#8-2-构造函数类型" class="heading-link"><i class="fas fa-link"></i></a>8.2 构造函数类型</h4>
      <p>在 TypeScript 语言规范中这样定义构造函数类型：</p>
<blockquote>
<p>An object type containing one or more construct signatures is said to be a <strong><em>constructor type</em></strong>. Constructor types may be written using constructor type literals or by including construct signatures in object type literals.</p>
</blockquote>
<p>通过规范中的描述信息，我们可以得出以下结论：</p>
<ul>
<li>包含一个或多个构造签名的对象类型被称为构造函数类型；</li>
<li>构造函数类型可以使用构造函数类型字面量或包含构造签名的对象类型字面量来编写。</li>
</ul>
<p>那么什么是构造函数类型字面量呢？构造函数类型字面量是包含单个构造函数签名的对象类型的简写。具体来说，构造函数类型字面量的形式如下：</p>
<pre><code>new &lt; T1, T2, ... &gt; ( p1, p2, ... ) =&gt; R
</code></pre><p>该形式与以下对象类型字面量是等价的：</p>
<pre><code>{ new &lt; T1, T2, ... &gt; ( p1, p2, ... ) : R }
</code></pre><p>下面我们来举个实际的示例：</p>
<pre><code>// 构造函数类型字面量
new (x: number, y: number) =&gt; Point
</code></pre><p>等价于以下对象类型字面量：</p>
<pre><code>{
   new (x: number, y: number): Point;
}
</code></pre>
        <h4 id="8-3-构造函数类型的应用"   >
          <a href="#8-3-构造函数类型的应用" class="heading-link"><i class="fas fa-link"></i></a>8.3 构造函数类型的应用</h4>
      <p>在介绍构造函数类型的应用前，我们先来看个例子：</p>
<pre><code>interface Point {
  new (x: number, y: number): Point;
  x: number;
  y: number;
}

class Point2D implements Point {
  readonly x: number;
  readonly y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const point: Point = new Point2D(1, 2);
</code></pre><p>对于以上的代码，TypeScript 编译器会提示以下错误信息：</p>
<pre><code>Class &#39;Point2D&#39; incorrectly implements interface &#39;Point&#39;.
Type &#39;Point2D&#39; provides no match for the signature &#39;new (x: number, y: number): Point&#39;.
</code></pre><p>相信很多刚接触 TypeScript 不久的小伙伴都会遇到上述的问题。要解决这个问题，我们就需要把对前面定义的 <code>Point</code> 接口进行分离，即把接口的属性和构造函数类型进行分离：</p>
<pre><code>interface Point {
  x: number;
  y: number;
}

interface PointConstructor {
  new (x: number, y: number): Point;
}
</code></pre><p>完成接口拆分之后，除了前面已经定义的 <code>Point2D</code> 类之外，我们又定义了一个 <code>newPoint</code> 工厂函数，该函数用于根据传入的 PointConstructor 类型的构造函数，来创建对应的 Point 对象。</p>
<pre><code>class Point2D implements Point {
  readonly x: number;
  readonly y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

function newPoint(
  pointConstructor: PointConstructor,
  x: number,
  y: number
): Point {
  return new pointConstructor(x, y);
}

const point: Point = newPoint(Point2D, 1, 2);
</code></pre>
        <h4 id="8-4-使用泛型创建对象"   >
          <a href="#8-4-使用泛型创建对象" class="heading-link"><i class="fas fa-link"></i></a>8.4 使用泛型创建对象</h4>
      <p>了解完构造签名和构造函数类型之后，下面我们来开始解决上面遇到的问题，首先我们需要重构一下 <code>create</code> 方法，具体如下所示：</p>
<pre><code>class GenericCreator&lt;T&gt; {
  create&lt;T&gt;(c: { new (): T }): T {
    return new c();
  }
}
</code></pre><p>在以上代码中，我们重新定义了 <code>create</code> 成员方法，根据该方法的签名，我们可以知道该方法接收一个参数，其类型是构造函数类型，且该构造函数不包含任何参数，调用该构造函数后，会返回类型 T 的实例。</p>
<p>如果构造函数含有参数的话，比如包含一个 <code>number</code> 类型的参数时，我们可以这样定义 create 方法：</p>
<pre><code>create&lt;T&gt;(c: { new(a: number): T; }, num: number): T {
  return new c(num);
}
</code></pre><p>更新完 <code>GenericCreator</code> 泛型类，我们就可以使用下面的方式来创建 <code>FirstClass</code> 和 <code>SecondClass</code> 类的实例：</p>
<pre><code>const creator1 = new GenericCreator&lt;FirstClass&gt;();
const firstClass: FirstClass = creator1.create(FirstClass);

const creator2 = new GenericCreator&lt;SecondClass&gt;();
const secondClass: SecondClass = creator2.create(SecondClass);
</code></pre>
        <h3 id="九、参考资源"   >
          <a href="#九、参考资源" class="heading-link"><i class="fas fa-link"></i></a>九、参考资源</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   href="https://medium.com/better-programming/typescript-generics-90be93d8c292"  target="_blank" rel="noopener">typescript-generics</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f"  target="_blank" rel="noopener">typescript-generics-explained</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   href="https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g"  target="_blank" rel="noopener">typescript-tip-of-the-week-generics</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/blog/">如何快速搭建好看的个人博客</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/blog/" data-flag-title="如何快速搭建好看的个人博客"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="如何快速搭建好看的个人博客-完整配置与源码"   >
          <a href="#如何快速搭建好看的个人博客-完整配置与源码" class="heading-link"><i class="fas fa-link"></i></a>如何快速搭建好看的个人博客(完整配置与源码)</h1>
      <blockquote>
<p>博客地址 <span class="exturl"><a class="exturl__link"   href="http://www.inode.club/"  target="_blank" rel="noopener">程序员成长指北</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 就是这样搭建出来的! 可以先体验下。</p>
</blockquote>

        <h2 id="为什么选择vuepress"   >
          <a href="#为什么选择vuepress" class="heading-link"><i class="fas fa-link"></i></a>为什么选择vuepress</h2>
      <p>之前使用docsify部署过个人博客, 在此之前也使用过gitbook, 这次使用vuepress来改版, 根据自己的体验, 将这三者做一个对比</p>
<ul>
<li><p>从阅读体验来说(个人感觉): gitbook &gt; docsify =vuepress</p>
</li>
<li><p>从配置上来说, docsify相比于vuepress和gitbook都要简单一些.</p>
</li>
<li><p>从性能上来说: vuepress &gt; docsify</p>
<p>虽然docsify也是基于vue的, docsify是运行时解析, vuepress是预先渲染HTML</p>
</li>
<li><p>灵活性上, vuepress也是相当占优势的, 对vue熟悉的朋友可以编写vue组件实现你想要的功能样式</p>
</li>
</ul>

        <h3 id="vuepress特性"   >
          <a href="#vuepress特性" class="heading-link"><i class="fas fa-link"></i></a>vuepress特性</h3>
      <ul>
<li>为技术文档而优化的内置Markdown拓展</li>
<li>在Markdown文件中使用Vue组件的能力</li>
<li>Vue驱动的自定义主题系统</li>
<li>自动生成Service Worker(支持PWA)</li>
<li>Google Analytics集成</li>
<li>基于Git的”最后更新时间</li>
<li>多语言支持</li>
<li>响应式布局</li>
<li>支持PWA模式</li>
</ul>
<p>总的来说, 使用vuepress优势有挺多的, 特别是我之前使用docsify搭建的网站, 是一点也没有被浏览器收录啊, 怎么都搜不到,受到一万点打击,所以决心改一改</p>
<p>其实<span class="exturl"><a class="exturl__link"   href="https://v1.vuepress.vuejs.org/zh/guide/"  target="_blank" rel="noopener">vuepress的官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>已经写的挺好的了, 但是我这篇文章也有优势啊,是一步步的教你搭建, 这样就不用来回在文档中去找什么配置.(当然如果你想直接通过官网来学习, 可以直接看官网,点击链接就可以喔)</p>

        <h2 id="项目搭建"   >
          <a href="#项目搭建" class="heading-link"><i class="fas fa-link"></i></a>项目搭建</h2>
      
        <h3 id="安装vuepress"   >
          <a href="#安装vuepress" class="heading-link"><i class="fas fa-link"></i></a>安装vuepress</h3>
      <p>第一步就是进行vuepress进行安装: 如果使用npm来安装, Node.js版本需要 &gt;=8 才可以</p>
<pre><code>yarn global add vuepress # 或者：npm install -g vuepress
</code></pre><blockquote>

        <h4 id="注意"   >
          <a href="#注意" class="heading-link"><i class="fas fa-link"></i></a>注意</h4>
      <p>如果你的现有项目依赖了 webpack 3.x，推荐使用 Yarn而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。</p>
</blockquote>

        <h3 id="初始化项目"   >
          <a href="#初始化项目" class="heading-link"><i class="fas fa-link"></i></a>初始化项目</h3>
      <p>创建项目目录<code>blog</code></p>
<pre><code>mkdir blog
cd blog
</code></pre><p>初始化</p>
<pre><code>yarn init -y # 或者 npm init -y
</code></pre><p>初始化完成后, 会创建一个package.json</p>
<pre><code>{
  &quot;name&quot;:&quot;blog&quot;,  
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;
  &quot;scripts&quot;: {
     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  }
}
</code></pre><p>在package.json中, 配置启动命令</p>
<pre><code>&quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
  }
</code></pre><p>启动项目: <code>npm run docs:dev</code>这条命令就等于<code>vuepress dev docs</code></p>
<p>打包项目: <code>npm run build</code> 这条命令就等于 <code>vuepress build docs</code></p>
<p>创建docs目录, 主要用于放置我们写的<code>.md</code>类型的文章以及<code>.vuepress</code>相关的配置</p>
<pre><code>mkdir docs
</code></pre><p>接着在docs文件夹中创建<code>.vuepress</code>文件夹</p>
<pre><code>cd docs
mkdir .vuepress
</code></pre><p>这个文件主要就是放vuepress相关的<span class="exturl"><a class="exturl__link"   href="https://v1.vuepress.vuejs.org/zh/config/#基本配置"  target="_blank" rel="noopener">配置</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>到这一步, 我们的项目大体架子已经搭建出来了,接下来进行配置.</p>

        <h2 id="页面具体内容配置"   >
          <a href="#页面具体内容配置" class="heading-link"><i class="fas fa-link"></i></a>页面具体内容配置</h2>
      
        <h3 id="基本配置"   >
          <a href="#基本配置" class="heading-link"><i class="fas fa-link"></i></a>基本配置</h3>
      <p>接下来要让页面显示内容, 就需要进行配置, 新建一个总的配置文件<code>config.js</code>, 这个文件的名字是固定的.</p>
<pre><code>cd .vuepress
touch config.js
</code></pre><p><code>config.js</code>最基础的配置文件内容如下:</p>
<pre><code>module.exports = {
    title: &#39;koala的博客&#39;,
    description: &#39;专注 Node.js 技术栈分享，从前端到Node.js再到数据库&#39;,
}
</code></pre><p>如果这时运行<code>npm run docs:dev</code>或者<code>yarn docs:dev</code>, 会出现页面404页面,vuepress默认打开的是docs下的<code>readme.md</code>文件, 由于你没有创建,所以找到的是vuepress默认提供的404页面, 关于这有点,我们借助<span class="exturl"><a class="exturl__link"   href="https://github.com/vuejs/vue-devtools"  target="_blank" rel="noopener">vue-devtools</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>工具来查看一下vue的结构</p>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59c8e15587e40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>在docs目录下创建<code>README.md</code>文件, 再运行,就可以看到运行起来的效果, 如下图所示:</p>
<ul>
<li>blog001.jpg</li>
</ul>

        <h3 id="设置封面页"   >
          <a href="#设置封面页" class="heading-link"><i class="fas fa-link"></i></a>设置封面页</h3>
      <p>此时<code>README</code>文件中没有内容,封面页是空的, 我们可以通过在这个markdown文件中写一些内容, 同时官方也给我们提供了封面页的模板(个人觉得还是比较实用的):</p>
<pre><code>---
home: true
heroImage: /home.png
actionText: Get Started →
actionLink: /node/
features:
- title: day day up
  details: 记录每一天的进步, 一分耕耘，一分收获.
- title: 程序员成长指北
  details: 专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师
- title: koala
  details: 一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。
footer: MIT Licensed | Copyright © 2018-present Evan You

---
</code></pre><p>效果图如下:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cc52c658352?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h3 id="配置导航栏nav"   >
          <a href="#配置导航栏nav" class="heading-link"><i class="fas fa-link"></i></a>配置导航栏nav</h3>
      <p>在<code>config.js</code>中添加:</p>
<pre><code>themeConfig:{
  nav: [{text: &quot;主页&quot;, link: &quot;/&quot;      },
      { text: &quot;node&quot;, link: &quot;/node/&quot; },
      { text: &quot;前端&quot;, link: &quot;/webframe/&quot;},
      { text: &quot;数据库&quot;, link: &quot;/database/&quot;   },
      { text: &quot;android&quot;, link: &quot;/android/&quot;   },
      { text: &quot;面试问题&quot;, link: &quot;/interview/&quot; }
    ],
}

</code></pre><p>效果如下图:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cca4e693662?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>如果想要展示二级导航, 可以这样配置:</p>
<pre><code>themeConfig:{
  nav: [{text: &quot;主页&quot;, link: &quot;/&quot;      },
      { text: &quot;node&quot;, link: &quot;/node/&quot; },
      { text: &quot;前端&quot;, 
        items: [ 
          { text: &quot;html&quot;, link:&quot;/web/html/&quot;},
          { text: &quot;css&quot;, link:&quot;/web/css/&quot;},
          ]
      },
      { text: &quot;数据库&quot;, link: &quot;/database/&quot;   },
      { text: &quot;android&quot;, link: &quot;/android/&quot;   },
      { text: &quot;面试问题&quot;, link: &quot;/interview/&quot; }
    ],
}
</code></pre><p>效果如图所示:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cce0571a8df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<blockquote>
<p>当你使用上面的方式配置nav时, 目录结构最好和我创建的一样 项目目录结构如下:</p>
</blockquote>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cd3042159f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>导航栏创建好了, 接下来就是配置页面内容中的侧边栏slider</p>

        <h3 id="配置侧边栏slider"   >
          <a href="#配置侧边栏slider" class="heading-link"><i class="fas fa-link"></i></a>配置侧边栏slider</h3>
      
        <h4 id="1-自动获取侧边栏内容"   >
          <a href="#1-自动获取侧边栏内容" class="heading-link"><i class="fas fa-link"></i></a>1.自动获取侧边栏内容</h4>
      <p>如果你希望自动生成当前页面标题的侧边栏, 可以在<code>config.js</code>中配置来启用</p>
<pre><code>// .vuepress/config.js
module.exports = {
  themeConfig:{
    sidebar: &#39;auto&#39;,
    // sidebarDepth: 1 
  }
}
</code></pre>
        <h4 id="2-展示每个页面的侧边栏"   >
          <a href="#2-展示每个页面的侧边栏" class="heading-link"><i class="fas fa-link"></i></a>2.展示每个页面的侧边栏</h4>
      <p>如果你希望为不同的页面组显示不同的侧边栏, 就和官网一样, 点击<code>指南</code>显示的是对应的侧边栏,目前目录有<code>node \ database \ web</code>等, 这些目录下都存放着多个md文件:</p>
<pre><code>module.exports = {
  themeConfig:{
    sidebar:{
      &quot;/node/&quot;:[
        [&quot;&quot;, &quot;node目录&quot;],
        [&quot;path&quot;, &quot;作为前端也需要知道的路径知识&quot;],
        [&quot;stream&quot;, &quot;node核心模块-stream&quot;]
      ],
      &quot;/web/&quot;:[
        [&quot;&quot;, &quot;前端&quot;],
        {
          title: &quot;css&quot;,
          name: &quot;css&quot;,
          collabsable: false,
          children: [
            [&quot;css/&quot;, &quot;目录&quot;],
            [&#39;css/1&#39;, &quot;css常考面试题&quot;]
          ]
        }
      ]
    }
  }
}
</code></pre><p>设置的效果图如下: 在<code>node</code>导航下:<img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cd92669ea17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>在<code>前端</code>导航下的效果:<img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cdd5ce60931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>上面采用了两个方式配置侧边栏, 一个侧边栏是<code>node</code>目录下直接是写的markdown文章, 而在<code>web</code>下又有多个分类, 所有有进行了分栏配置, 其实这两种方式在我们博客中都是比较常见的</p>

        <h2 id="自定义布局内容"   >
          <a href="#自定义布局内容" class="heading-link"><i class="fas fa-link"></i></a>自定义布局内容</h2>
      <p>网站的导航和侧边栏都已经配置好之后, 如果你觉得页面不是很符合你的预期, 你也可以自定修改成你想要的效果。比如就像我的博客中左侧固定的内容, 就是自定义的全局组件. 这里使用vuepress提供的插件机制来实现</p>
<p>在.vuepress文件夹下创建components文件夹, 在components下再创建<code>fixed.vue</code>文件</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;fixed_container&quot;&gt;
    &lt;div class=&quot;tencent_code&quot;&gt;
      &lt;h4&gt;关注作者公众&lt;/h4&gt;
      &lt;p&gt;和万千小伙伴一起学习&lt;/p&gt;
      &lt;img src=&quot;/ggh.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;group_code&quot;&gt;
      &lt;h4&gt;加入技术交流群&lt;/h4&gt;
      &lt;p&gt;扫描二维码 备注
        &lt;span&gt; 加群&lt;/span&gt;
      &lt;/p&gt;
      &lt;img src=&quot;/wechat.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &#39;fixed&#39;
}
&lt;/script&gt;
 ....
 // 这里省略了部分样式代码, 想看全部的小伙伴点开github地址就可以了

</code></pre><p>然后在配置文件中以插件的形式配置即可:</p>
<pre><code>  // 插件
  plugins:[
    {
      name:&quot;page-plugin&quot;,
      globalUIComponents:[&quot;fixed&quot;], 
    }
  ]
</code></pre><p><code>globalUIComponents</code>是用于注入全局的UI, 它以数组的形式接收参数名字, 这里的名字必须与components文件夹下的<code>.vue</code>文件同名, <strong>全局UI就是一个Vue组件</strong>; 其实vuepress也提供了一些内置的全局UI组件, 例如:<code>back-to-top</code>, <code>popup</code>, <code>nprogress</code>等.</p>

        <h3 id="配置插件"   >
          <a href="#配置插件" class="heading-link"><i class="fas fa-link"></i></a>配置插件</h3>
      
        <h3 id="UI插件"   >
          <a href="#UI插件" class="heading-link"><i class="fas fa-link"></i></a>UI插件</h3>
      <p>配置内置的全局UI,首先需要插件:</p>
<pre><code>yarn add -D @vuepress/plugin-back-to-top @vuepress/plugin-nprogress
# OR npm install -D @vuepress/plugin-back-to-top  @vuepress/plugin-nprogress
</code></pre><p>在config.js中配置:</p>
<pre><code>  plugins:[
   [&quot;@vuepress/back-to-top&quot;], // 返回顶部
   [&quot;@vuepress/nprogress&quot;],   // 加载进度条
  ]

</code></pre><blockquote>
<p>这里需要注意一点就是看你项目中是否安装了<code>vuepress</code>, 由于我之前是全局安装的, 在项目下还没有安装, 插件是依赖于<code>vuepress</code>的, 所有没有安装的需要安装上, 插件才有效.</p>
</blockquote>

        <h3 id="支持PWA"   >
          <a href="#支持PWA" class="heading-link"><i class="fas fa-link"></i></a>支持PWA</h3>
      <p>vuepress还有一个我比较看重的优势, 就是支持PWA, 当用户没有网的情况下,一样能继续的访问我们的网站</p>
<p>在<code>0.x</code> 版本中我们只要配置<code>serviceWorker: true</code> 即可, 但是我们现在使用的是<code>1.2.0</code>版本, 这个版本中已经将这个功能抽离出来作为插件的方式使用, 下面就看一下具体如何使用的:</p>
<p>首先需要安装插件:</p>
<pre><code>yarn add -D @vuepress/plugin-pwa
# 或者 npm install -D @vuepress/plugin-pwa
</code></pre><p>在<code>config.js</code>中配置:</p>
<pre><code>module.exports = {
  plugins: [&#39;@vuepress/pwa&#39;, {
    serviceWorker: true,
    updatePopup: true
  }]
}
</code></pre><p>注意点:</p>
<blockquote>

        <h4 id="为了让你的网站完全地兼容-PWA，你需要"   >
          <a href="#为了让你的网站完全地兼容-PWA，你需要" class="heading-link"><i class="fas fa-link"></i></a>为了让你的网站完全地兼容 PWA，你需要:</h4>
      <ul>
<li>在 .vuepress/public 提供 Manifest 和 icons</li>
<li>在 <code>.vuepress/config.js</code> 添加正确的 <code>head links</code></li>
</ul>
</blockquote>
<pre><code>// 配置
module.exports = {
  head: [
    [&#39;link&#39;, { rel: &#39;icon&#39;, href: `/favicon.ico` }],
    //增加manifest.json
    [&#39;link&#39;, { rel: &#39;manifest&#39;, href: &#39;/manifest.json&#39; }],
  ],
}
</code></pre><p>manifest.json 文件</p>
<pre><code>{
  &quot;name&quot;: &quot;koala_blog&quot;,
  &quot;short_name&quot;: &quot;blog&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;程序员成长指北博主, koala的博客&quot;,
  &quot;manifest_version&quot;: 2
}
</code></pre>
        <h3 id="配置评论"   >
          <a href="#配置评论" class="heading-link"><i class="fas fa-link"></i></a>配置评论</h3>
      <p>由于之前有小伙伴说过,『程序员成长指北』公众号上不能评论，所有这次我在博客中增加了评论功能，刚开始本来打算使用gitTalk, 但是我的博客采用的是部署到自己的服务器, 并没有部署成 GitHub Pages, 所有我使用的是<code>valine</code>, 它除了评论功能还可以统计阅读量, 请大家看:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59d08fa824ffd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>但是我后面也会将gitTalk配置方式写出来, 方便使用gitTalk的小伙伴</p>

        <h4 id="valine-使用"   >
          <a href="#valine-使用" class="heading-link"><i class="fas fa-link"></i></a>valine 使用</h4>
      <p>点击进入 <span class="exturl"><a class="exturl__link"   href="https://leancloud.cn/dashboard/login.html#/signin"  target="_blank" rel="noopener">Valine官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，需要先注册才能使用.</p>
<p>然后创建应用, 获取APP ID 和APP KEY</p>
<p><img   src="http://user-gold-cdn.xitu.io/2019/12/31/16f59d13ffd4d3b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置 &gt; 应用Key</code>，然后就能看到你的APP ID 和APP Key了</p>
<ul>
<li>安装:</li>
</ul>
<pre><code>yarn add vuepress-plugin-comment -D</code></pre><ul>
<li>快速使用</li>
</ul>
<p>在<code>.vuepress</code>下的config.js插件配置中:</p>
<pre><code>module.exports = {
  plugins: [
    [
      &#39;vuepress-plugin-comment&#39;,
      {
        choosen: &#39;valine&#39;, 
        // options选项中的所有参数，会传给Valine的配置
        options: {
          el: &#39;#valine-vuepress-comment&#39;,
          appId: &#39;Your own appId&#39;,
          appKey: &#39;Your own appKey&#39;
        }
      }
    ]
  ]
}
</code></pre><p>appid和appkey为你创建的应用的APP ID 和APP Key</p>

        <h4 id="gitTalk-使用"   >
          <a href="#gitTalk-使用" class="heading-link"><i class="fas fa-link"></i></a>gitTalk 使用</h4>
      
        <h3 id="主题样式修改"   >
          <a href="#主题样式修改" class="heading-link"><i class="fas fa-link"></i></a>主题样式修改</h3>
      <p>vuepress默认是主题颜色是绿色, 如果你不喜欢可以对其进行更改. 如果要对默认设置的样式进行简单颜色替换, 或者自定义一些颜色变量供以后使用, 可以在<code>.vuepress/styles</code>下创建<code>palette.styl</code>文件.</p>
<p>你可以调整的颜色变量:</p>
<pre><code>// 颜色
$textColor ?= #2c3e50
$accentColor ?= #1e90ff
$grayTextColor ?= #666
$lightTextColor ?= #999
$borderColor ?= #eaecef
$codeBgColor ?= #282c34
$arrowBgColor ?= #ccc
$navbarColor ?= #fff
$headerColor ?= #fff
$headerTitleColor ?= #fff
$nprogressColor ?= $accentColor
// 布局
bannerHeight ?= 12rem // 响应式 breakpoints
MQNarrow ?= 1024px
MQMobileNarrow ?= 480px
</code></pre><blockquote>

        <h4 id="注意点"   >
          <a href="#注意点" class="heading-link"><i class="fas fa-link"></i></a>注意点:</h4>
      <p>你应该只在这个文件中写入颜色变量。因为 <code>palette.styl</code> 将在根的 stylus 配置文件的末尾引入，作为配置，它将被多个文件使用，所以一旦你在这里写了样式，你的样式就会被多次复制</p>
</blockquote>
<p>如果要添加额外的样式, vuepress也是提供了简便方法的, 只要在<code>.vuepress/styles</code>文件下创建一个 <code>index.styl</code>, 在里面写css样式即可, 注意文件命名是固定的.</p>

        <h2 id="部署"   >
          <a href="#部署" class="heading-link"><i class="fas fa-link"></i></a>部署</h2>
      
        <h3 id="nginx部署"   >
          <a href="#nginx部署" class="heading-link"><i class="fas fa-link"></i></a>nginx部署</h3>
      <p>我的博客采用的是静态文件部署, 感觉方便又便捷, 之前部署在Github Pages上, 访问速度不是很理想.</p>
<p><strong>第一步: 确保你满足下面几个条件</strong></p>
<ul>
<li>你有一台服务器</li>
<li>已经安装好nginx, 如果不会的小伙伴请看<span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/320a48fcef57"  target="_blank" rel="noopener">如何安装nginx</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>解析了一个可用的域名</li>
</ul>
<p><strong>第二步: 打包你的项目</strong></p>
<p>运行<code>npm run docs:build</code>将项目打包, 默认打包文件在<code>docs/.vuepress/dist</code>目录下</p>
<p><strong>第三步: 配置nginx</strong></p>
<p>进入到nginx 配置目录, 找到conf.d文件, 添加下面的配置:</p>
<pre><code>server {
    listen       80;
    server_name  www.inode.club;

    root     /usr/web/inode/dist;

    error_log   /var/log/nginx/inode-error.log;
    access_log  /var/log/nginx/inode-access.log;

    #        deny all;
    index  index.php index.html index.htm;
}
</code></pre><ul>
<li>server_name 是你解析的域名地址</li>
<li>root 配置文件将访问的静态资源文件的路径</li>
</ul>
<p>*<em>第四步: 上传静态资源文件 *</em></p>
<p>将静态资源文件放置到服务器上, 路径为配置的<code>/usr/web/inode/dist</code>, 可以借助xftp工具上传也可以通过git克隆, 选择适合自己的方式就可以</p>
<p>*<em>第五步: 重启nginx *</em></p>
<pre><code># 重启之前务必检查配置是否正确
sudo nginx -t  // 检查配置
sudo nginx -s reload  // 重启
</code></pre><p>然后你就可以通过域名来访问你的网站啦!</p>

        <h3 id="github部署"   >
          <a href="#github部署" class="heading-link"><i class="fas fa-link"></i></a>github部署</h3>
      <p>将代码部署到 Github Pages, 你可以看vuepress文档: <span class="exturl"><a class="exturl__link"   href="https://vuepress.vuejs.org/zh/guide/deploy.html#github-pages"  target="_blank" rel="noopener">vuepress部署</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>, 也参照我这里写的的步骤来部署</p>
<p><strong>第一步: 首先确保你的项目满足以下几个条件:</strong></p>
<ul>
<li>文档放置在docs目录中</li>
<li>使用的是默认的构建输出位置</li>
<li>vuepress以本地依赖的形式被安装到你的项目中, 在根目录<code>package.json</code>文件中包含如下代码:</li>
</ul>
<pre><code>// 配置npm scripts
&quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
 }

// VuePress 以本地依赖的形式被安装
&quot;devDependencies&quot;: {
  &quot;vuepress&quot;: &quot;^1.2.0&quot;
}
</code></pre><p><strong>第二步: 创建github仓库</strong></p>
<p>在github上创建一个名为blog的仓库, 并将代码提交到github上</p>
<p><strong>第三步: 配置仓库名称</strong></p>
<p>配置<code>docs/.vuepress/config.js</code>文件中的base, 如果打算发布到<code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code>(也就是说你的仓库在: <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code> ), 此处我的仓库为: blog, 则将base按照如下配置即可:</p>
<pre><code>module.exports = {
  base: &quot;/blog/&quot;
}
</code></pre><p><strong>第四步: 在项目根目录中,创建一个如下的脚本文件<code>deploy.sh</code></strong></p>
<pre><code>#!/usr/bin/env sh

# 确保脚本抛出遇到的错误
set -e

# 生成静态文件
npm run docs:build

# 进入生成的文件夹
cd docs/.vuepress/dist

git init
git add -A
git commit -m &#39;deploy&#39;

# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;
git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages
# 例如 git push -f git@github.com:koala-coding/blog.git master:gh-pages 
cd -
</code></pre><p><strong>第五步: 双击 deploy.sh 运行脚本</strong></p>
<p>会自动在我们的 GitHub 仓库中，创建一个名为 gh-pages 的分支，而我们要部署到 GitHub Pages 的正是这个分支</p>
<p><strong>**第六步: setting Github Pages</strong> 这是最后一步了，在 GitHub 项目点击 Setting 按钮，找到 GitHub Pages - Source，选择 gh-pages 分支，点击 Save 按钮后，静静地等待它部署完成即可。</p>

        <h2 id="项目地址"   >
          <a href="#项目地址" class="heading-link"><i class="fas fa-link"></i></a>项目地址</h2>
      <p>我的网站 <span class="exturl"><a class="exturl__link"   href="http://www.inode.club"  target="_blank" rel="noopener">程序员成长指北</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 就是这样搭建出来的!</p>
<p>本文章实现的内容都已经上传到github, 如果不想一步步进行配置的, 可以直接下载下来使用,就不用重复造轮子啦!</p>
<blockquote>
<p>需要博客源码的小伙伴可以直接<strong>公众后台</strong>回复【<strong>博客</strong>】领取，或者直接联系我。</p>
</blockquote>
<p>参考文章</p>
<ul>
<li><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/5c94ddf35188252d65344cfe"  target="_blank" rel="noopener">https://juejin.im/post/5c94ddf35188252d65344cfe</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="http://q1.qlogo.cn/g?b=qq&amp;nk=2391624941&amp;s=640" alt="avatar"></div><p class="sidebar-ov-author__text">人亦有言，举棋不定</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">25</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Apocalypse</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz',
    appKey: 'FihoucantYlc5U1FQ9BzkO3l',
    notify: true,
    verify: true,
    placeholder: 'Just go go',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>