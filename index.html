<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Apocalypse&#39;s Blog">
<meta property="og:url" content="https://jiyugithub.github.io/index.html">
<meta property="og:site_name" content="Apocalypse&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Apocalypse">
<meta name="twitter:card" content="summary"><meta name="keywords" content="Apocalypse, Apocalypse's Blog"><meta name="description" content=""><title>Apocalypse's Blog</title><link ref="canonical" href="https://jiyugithub.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Apocalypse's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/Kotlinyf/">Kotlin实战 | 语法糖</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/Kotlinyf/" data-flag-title="Kotlin实战 | 语法糖"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>学习了 Kotlin 后，写代码时常有一种“闹革命”的冲动，总是希望运用语法糖推翻“旧世界”（这样不好，项目会 delay 的~）。本文归纳了 Kotlin 语法糖在项目实战中的综合运用，以实际问题为索引，在分析解决方案的同时介绍相关语法知识。</p>
<h2 id="将-px-值转换成-dp-值"><a href="#将-px-值转换成-dp-值" class="headerlink" title="将 px 值转换成 dp 值"></a>将 px 值转换成 dp 值</h2><p>在非 xml 环境下构建布局，需要将 px 转换为 dp 来进行多屏幕适配。Java 的做法是在<code>Util</code>类中新增一个静态函数。利用 Kotlin 的扩展属性可以更简洁地实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val Int.dp: Int</span><br><span class="line">    get() &#123;</span><br><span class="line">        return TypedValue.applyDimension(</span><br><span class="line">            TypedValue.COMPLEX_UNIT_DIP,</span><br><span class="line">            this.toFloat(),</span><br><span class="line">            Resources.getSystem().displayMetrics</span><br><span class="line">        ).toInt()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为 Int 扩展一个属性<code>dp</code>，它的类型是 Int。在<code>get()</code>中定义该属性的取值算法。</p>
<p>然后就可以像这样动态地将 Int 值 dp 化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewGroup.addView( textView, LayoutParam( 40.dp, 50.dp ) )</span><br></pre></td></tr></table></figure>

<h2 id="弃用Builder模式"><a href="#弃用Builder模式" class="headerlink" title="弃用Builder模式"></a>弃用Builder模式</h2><p>当构造复杂对象时，需要很多参数，如果将所有参数都通过一个构造函数来传递，缺乏灵活性，但如果重载若干个带有不同参数的构造函数，代码就变得臃肿。Builder 模式可以简化构建过程。</p>
<p>在 Java 中 Builder模式 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    &#x2F;&#x2F;&#39;必选参数&#39;</span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;&#x2F;&#39;以下都是可选参数&#39;</span><br><span class="line">    private int gender;</span><br><span class="line">    private int age;</span><br><span class="line">    private int height;</span><br><span class="line">    private int weight;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#39;私有构造函数，限制必须通过构造者构建对象&#39;</span><br><span class="line">    private Person(Builder builder) &#123;</span><br><span class="line">        this.name &#x3D; builder.name;</span><br><span class="line">        this.gender &#x3D; builder.gender;</span><br><span class="line">        this.age &#x3D; builder.age;</span><br><span class="line">        this.height &#x3D; builder.height;</span><br><span class="line">        this.weight &#x3D; builder.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#39;构造者&#39;</span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int gender;</span><br><span class="line">        private int age;</span><br><span class="line">        private int height;</span><br><span class="line">        private int weight;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#39;必选参数必须在构造函数中传入&#39;</span><br><span class="line">        public Builder(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#39;以下是每个非必要属性的设值函数，它返回构造者本身用于链式调用&#39;</span><br><span class="line">        public Builder age(int age) &#123;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder gender(int gender) &#123;</span><br><span class="line">            this.gender &#x3D; gender;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder height(int height) &#123;</span><br><span class="line">            this.height &#x3D; height;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder weight(int weight) &#123;</span><br><span class="line">            this.weight &#x3D; weight;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#39;构建对象&#39;</span><br><span class="line">        public Person build() &#123;</span><br><span class="line">            return new Person(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以像这样构建<code>Person</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#39;使用 Builder模式&#39;</span><br><span class="line">Person p &#x3D; new Person.Builder(&quot;taylor&quot;)</span><br><span class="line">            .age(50)</span><br><span class="line">            .gender(1)</span><br><span class="line">            .weight(43)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#39;使用构造函数&#39;</span><br><span class="line">Person p2 &#x3D; new Person(&quot;taylor&quot;, 50, 1, 0, 43);</span><br></pre></td></tr></table></figure>

<p>对比之下，Builder模式 有两个优势：</p>
<ol>
<li>为参数标注语义：在Builder模式中，每个属性的赋值都是一个函数，函数名标注了属性语义。而直接使用构造函数时，很难分辨<code>50</code>，<code>43</code>哪个是年龄，哪个是体重。</li>
<li>可选参数：Builder模式中，除了必选参数，其他参数是可选的。但直接使用构造函数必须为所有参数赋值，比如上例中第四个参数身高被赋值为0。</li>
</ol>
<p>但 Builder模式 也有代价，新增了一个中间类<code>Builder</code>。</p>
<p>使用 Kotlin 的<code>命名参数</code>+<code>参数默认值</code>+<code>数据类</code>语法，在没有任何副作用的情况下就能实现 Builder模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#39;将Person定义为数据类&#39;</span><br><span class="line">data class Person(</span><br><span class="line">    var name: String,</span><br><span class="line">    &#x2F;&#x2F;&#39;为以下可选参数设置默认值&#39;</span><br><span class="line">    var gender: Int &#x3D; 1,</span><br><span class="line">    var age: Int&#x3D; 0,</span><br><span class="line">    var height: Int &#x3D; 0,</span><br><span class="line">    var weight: Int &#x3D; 0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#39;使用命名参数构建Person实例&#39;</span><br><span class="line">val p  &#x3D; Person(name &#x3D; “taylor”,gender &#x3D; 1,weight &#x3D; 43)</span><br></pre></td></tr></table></figure>

<p>关于<code>数据类</code>、<code>参数默认值</code>、<code>命名参数</code>更详细的介绍可以点击<a href="https://juejin.im/post/5cdb9536e51d456e5c5babd4" target="_blank" rel="noopener">这里</a></p>
<p>如果想增加参数约束条件可以调用<code>require()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data class Person(</span><br><span class="line">    var name: String,</span><br><span class="line">    var gender: Int &#x3D; 1,</span><br><span class="line">    var age: Int&#x3D; 0,</span><br><span class="line">    var height: Int &#x3D; 0,</span><br><span class="line">    var weight: Int &#x3D; 0</span><br><span class="line">)&#123;</span><br><span class="line">    &#x2F;&#x2F;&#39;在构造函数被调用的时候执行参数合法检查&#39;</span><br><span class="line">    init &#123;</span><br><span class="line">        require(name.isNotEmpty())&#123;”name cant be empty“&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时如果像下面这样构造 Person，则会抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val p &#x3D; Person(name&#x3D;&quot;&quot;,gender &#x3D; 1)</span><br><span class="line">java.lang.IllegalArgumentException: name cant be empty</span><br></pre></td></tr></table></figure>

<h2 id="打印列表、map"><a href="#打印列表、map" class="headerlink" title="打印列表、map"></a>打印列表、map</h2><p>调试程序时，经常需要打印列表内容，通常会这样打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String str:list) &#123;</span><br><span class="line">    Log.v(&quot;test&quot;, &quot;str&#x3D;&quot;+str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同业务界面的数据类型不同，为了调试，这样的 for 循环就会散落在各处，而且列表内容会分若干条 log 输出，中间极有可能被别的log打断。</p>
<p><strong>有没有一个函数可以打印包含任意数据类型的列表，并将列表内容组织成更具可读性的字符串？</strong></p>
<p>用 Kotlin  的<code>扩展函数</code>+<code>泛型</code>+<code>高阶函数</code>就能优雅地做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; Collection&lt;T&gt;.print(map: (T) -&gt; String) &#x3D;</span><br><span class="line">    StringBuilder(&quot;\n[&quot;).also &#123; sb -&gt;</span><br><span class="line">        &#x2F;&#x2F;&#39;遍历集合元素，通过 map 表达式将元素转换成感兴趣的字串，并独占一行&#39;</span><br><span class="line">        this.forEach &#123; e -&gt; sb.append(&quot;\n\t$&#123;map(e)&#125;,&quot;) &#125;</span><br><span class="line">        sb.append(&quot;\n]&quot;)</span><br><span class="line">    &#125;.toString()</span><br></pre></td></tr></table></figure>

<p>为集合的基类<code>Collection</code>新增一个扩展函数，它是一个高阶函数，因为它的参数是另一个函数，该函数用 lambda 表示。再把集合元素抽象成泛型。通过<code>StringBuilder</code>将所有集合内容拼接成一个自动换行的字符串。</p>
<p>写段测试代码看下效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data class Person(var name: String, var age: Int)</span><br><span class="line"></span><br><span class="line">val persons &#x3D; listOf(</span><br><span class="line">    Person(&quot;Peter&quot;, 16),</span><br><span class="line">    Person(&quot;Anna&quot;, 28),</span><br><span class="line">    Person(&quot;Anna&quot;, 23),</span><br><span class="line">    Person(&quot;Sonya&quot;, 39)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">persons.print &#123; &quot;$&#123;it.name&#125;_$&#123;it.age&#125;&quot; &#125;.let &#123; Log.v(&quot;test&quot;,it) &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V&#x2F;test: [</span><br><span class="line">    	Peter_16,</span><br><span class="line">    	Anna_28,</span><br><span class="line">    	Anna_23,</span><br><span class="line">    	Sonya_39,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>同样地，可以如法炮制一个打印 map 的扩展函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;K, V&gt; Map&lt;K, V?&gt;.print(map: (V?) -&gt; String): String &#x3D;</span><br><span class="line">    StringBuilder(&quot;\n&#123;&quot;).also &#123; sb -&gt;</span><br><span class="line">        this.iterator().forEach &#123; entry -&gt;</span><br><span class="line">            sb.append(&quot;\n\t[$&#123;entry.key&#125;] &#x3D; $&#123;map(entry.value)&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;\n&#125;&quot;)</span><br><span class="line">    &#125;.toString()</span><br></pre></td></tr></table></figure>

<h2 id="将-data-类转换成-map"><a href="#将-data-类转换成-map" class="headerlink" title="将 data 类转换成 map"></a>将 data 类转换成 map</h2><p>有些数据类字段比较多，调试时，想把它们通通打印出来，在 Java 中，借助于 AndroidStudio 的 <code>toString</code>功能倒是可以方便地生成可读性很高的字串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return ”Person&#123;“ +</span><br><span class="line">                ”name&#x3D;‘“ + name + ’\” +</span><br><span class="line">                ”, age&#x3D;“ + age +</span><br><span class="line">                ‘&#125;’;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是每新建一个数据类都要手动生成一个<code>toString()</code>方法也挺麻烦。</p>
<p>利用 Kotlin 的 <code>data class</code>可以省去这一步，但打印效果是所有字段都在同一行中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data class Person(var name: String, var age: Int)</span><br><span class="line"></span><br><span class="line">Log.v(“test”, “person&#x3D;$&#123;Person(&quot;Peter&quot;, 16)&#125;”)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出如下：</span><br><span class="line">V&#x2F;test: person&#x3D;Person(name&#x3D;Peter, age&#x3D;16)</span><br></pre></td></tr></table></figure>

<p>如果字段很多，把它们都打印在一行中可读性很差。</p>
<p><strong>有没有一种方法，可以读取一个类中所有的字段信息？</strong> 这样我们就可以将他们组织成想要的形状。请看下面这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun Any.ofMap() &#x3D;</span><br><span class="line">    &#x2F;&#x2F;&#39;过滤掉除data class以外的其他类&#39;</span><br><span class="line">    this::class.takeIf &#123; it.isData &#125;</span><br><span class="line">        &#x2F;&#x2F;&#39;遍历类的所有成员，过滤掉成员方法，只考虑成员属性&#39;</span><br><span class="line">        ?.members?.filterIsInstance&lt;KProperty&lt;Any&gt;&gt;()</span><br><span class="line">        &#x2F;&#x2F;&#39;将成员属性名和值存储在Pair中&#39;</span><br><span class="line">        ?.map &#123; it.name to it.call(this) &#125;</span><br><span class="line">        &#x2F;&#x2F;&#39;将Pair转换成map&#39;</span><br><span class="line">        ?.toMap()</span><br></pre></td></tr></table></figure>

<p>为任意 Kotlin 中的类添加一个<code>扩展函数</code>，它的功能是将<code>data class</code>中所有的字段名及其对应值存在一个 map 中。其中用到的 Kotlin 语法糖如下：</p>
<ul>
<li><code>isData</code>是<code>KClass</code>中的一个属性，用于判断该类是不是一个<code>data class</code>。<code>KClass</code>是 Kotlin 中用来描述 <strong>类的类型</strong>，<code>KClass</code>可以通过<code>对象::class</code>语法获得。</li>
<li><code>members</code>也是<code>KClass</code>中的一个属性，它包含了所有类的方法和属性。</li>
<li><code>filterIsInstance()</code>是<code>Iterable</code>接口的扩展函数，用于过滤出集合中指定的类型。</li>
<li><code>to</code>是一个<code>infix</code>扩展函数，它的定义如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; &#x3D; Pair(this, that)</span><br></pre></td></tr></table></figure>

<ul>
<li>带有<code>infix</code>标识的函数只允许带有一个参数，并且在调用时可以省略包裹参数的括号。这种语法叫<code>中缀表达式</code></li>
</ul>
<p>写段测试代码，结合上一节的打印 map 函数看下效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data class Person(var name: String, var age: Int)</span><br><span class="line"></span><br><span class="line">Person(&quot;Peter&quot;, 16).ofMap()?.print &#123; it.toString() &#125;.let &#123; Log.v(&quot;test&quot;,&quot;$it&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p>测试代码先将<code>Person</code>实例转换成 map，然后打印 map。输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V&#x2F;test:</span><br><span class="line">    &#123;</span><br><span class="line">    	[age] &#x3D; 16</span><br><span class="line">    	[name] &#x3D; Peter</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>若<code>data class</code>嵌套会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#39;位置，嵌套在Person类中&#39;</span><br><span class="line">data class Location(var x: Int, var y: Int)</span><br><span class="line">data class Person(var name: String, var age: Int, var locaton: Location? &#x3D; null)</span><br><span class="line"></span><br><span class="line">Person(&quot;Peter&quot;, 16, Location(20, 30)).ofMap()?.print &#123; it.toString() &#125;.let &#123; Log.v(&quot;test&quot;, &quot;$it&quot;) &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#39;打印结果如下&#39;</span><br><span class="line">    &#123;</span><br><span class="line">    	[age] &#x3D; 16</span><br><span class="line">    	[locaton] &#x3D; Location(x&#x3D;20, y&#x3D;30)</span><br><span class="line">    	[name] &#x3D; Peter</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>期望得到类似 Json 的打印效果，但输出结果还差一点。是因为将<code>Person</code>转化成<code>Map</code>时并没有将嵌套的<code>Location</code>也转化成键值对。</p>
<p>需要将<code>ofMap()</code>方法重构成递归调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun Any.ofMap(): Map&lt;String, Any?&gt;? &#123;</span><br><span class="line">    return this::class.takeIf &#123; it.isData &#125;</span><br><span class="line">        ?.members?.filterIsInstance&lt;KProperty&lt;Any&gt;&gt;()</span><br><span class="line">        ?.map &#123; member -&gt;</span><br><span class="line">            val value &#x3D; member.call(this)?.let &#123; v-&gt;</span><br><span class="line">                &#x2F;&#x2F;&#39;若成员变量是data class，则递归调用ofMap()，将其转化成键值对，否则直接返回值&#39;</span><br><span class="line">                if (v::class.isData) v.ofMap()</span><br><span class="line">                else v</span><br><span class="line">            &#125;</span><br><span class="line">            member.name to value</span><br><span class="line">        &#125;</span><br><span class="line">        ?.toMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让打印结果也有嵌套缩进效果，打印 Map 的函数也需要相应地重构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 打印 Map，生成结构化键值对子串</span><br><span class="line"> * @param space 行缩进量</span><br><span class="line"> *&#x2F;</span><br><span class="line">fun &lt;K, V&gt; Map&lt;K, V?&gt;.print(space: Int &#x3D; 0): String &#123;</span><br><span class="line">    &#x2F;&#x2F;&#39;生成当前层次的行缩进，用space个空格表示，当前层次每一行内容都需要带上缩进&#39;</span><br><span class="line">    val indent &#x3D; StringBuilder().apply &#123;</span><br><span class="line">        repeat(space) &#123; append(&quot; &quot;) &#125;</span><br><span class="line">    &#125;.toString()</span><br><span class="line">    return StringBuilder(&quot;\n$&#123;indent&#125;&#123;&quot;).also &#123; sb -&gt;</span><br><span class="line">        this.iterator().forEach &#123; entry -&gt;</span><br><span class="line">            &#x2F;&#x2F;&#39;如果值是 Map 类型，则递归调用print()生成其结构化键值对子串，否则返回值本身&#39;</span><br><span class="line">            val value &#x3D; entry.value.let &#123; v -&gt;</span><br><span class="line">                (v as? Map&lt;*, *&gt;)?.print(&quot;$&#123;indent&#125;$&#123;entry.key&#125; &#x3D; &quot;.length) ?: v.toString()</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(&quot;\n\t$&#123;indent&#125;[$&#123;entry.key&#125;] &#x3D; $value,&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;\n$&#123;indent&#125;&#125;&quot;)</span><br><span class="line">    &#125;.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写段测试代码，看看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#39;坐标类，嵌套在Location类中&#39;</span><br><span class="line">data class Coordinate(var x: Int, var y: Int)</span><br><span class="line">&#x2F;&#x2F;&#39;位置类，嵌套在Person类中&#39;</span><br><span class="line">data class Location(var country: String, var city: String, var coordinate: Coordinate)</span><br><span class="line">data class Person(var name: String, var age: Int, var locaton: Location? &#x3D; null)</span><br><span class="line"></span><br><span class="line">Person(&quot;Peter&quot;, 16, Location(&quot;china&quot;, &quot;shanghai&quot;, Coordinate(10, 20))).ofMap()?.print().let &#123; Log.v(&quot;test&quot;, &quot;$it&quot;) &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#39;打印如下&#39;</span><br><span class="line">    &#123;</span><br><span class="line">    	[age] &#x3D; 16,</span><br><span class="line">    	[locaton] &#x3D; </span><br><span class="line">              &#123;</span><br><span class="line">    	          [city] &#x3D; shanghai,</span><br><span class="line">    	          [coordinate] &#x3D; </span><br><span class="line">                           &#123;</span><br><span class="line">    	                       [x] &#x3D; 10,</span><br><span class="line">    	                       [y] &#x3D; 20,</span><br><span class="line">                           &#125;,</span><br><span class="line">    	          [country] &#x3D; china,</span><br><span class="line">              &#125;,</span><br><span class="line">    	[name] &#x3D; Peter,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取当前周一和周日"><a href="#获取当前周一和周日" class="headerlink" title="获取当前周一和周日"></a>获取当前周一和周日</h2><p>Java 系统默认一周的第一天是周日，最后一天是周六。</p>
<p>若需要做类似“一周一次提醒”的功能，就可以本地化提醒时间，然后在每次触发提醒时把它和当前周一作比较，大于则说明本周已提醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun thisMondayInMillis() &#x3D; Calendar.getInstance().let &#123; c -&gt;</span><br><span class="line">    &#x2F;&#x2F;&#39;如果当前是周天，则减一天，计算周六所在周的周一&#39;</span><br><span class="line">    if (c.get(Calendar.DAY_OF_WEEK) &#x3D;&#x3D; Calendar.SUNDAY) c.add(Calendar.DATE, -1)</span><br><span class="line">    c.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)</span><br><span class="line">    c.set(Calendar.HOUR_OF_DAY, 0)</span><br><span class="line">    c.set(Calendar.MINUTE, 0)</span><br><span class="line">    c.set(Calendar.SECOND, 0)</span><br><span class="line">    c.set(Calendar.MILLISECOND, 0)</span><br><span class="line">    c.timeInMillis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun thisSundayInMillis() &#x3D; Calendar.getInstance().let &#123; c -&gt;</span><br><span class="line">    &#x2F;&#x2F;&#39;如果不是周天，则将日期调整到当前周的周六，然后在加一天&#39;</span><br><span class="line">    if (c.get(Calendar.DAY_OF_WEEK) !&#x3D; Calendar.SUNDAY) &#123;</span><br><span class="line">        c.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY)</span><br><span class="line">        c.add(Calendar.DATE, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    c.set(Calendar.HOUR_OF_DAY, 0)</span><br><span class="line">    c.set(Calendar.MINUTE, 0)</span><br><span class="line">    c.set(Calendar.SECOND, 0)</span><br><span class="line">    c.set(Calendar.MILLISECOND, 0)</span><br><span class="line">    c.timeInMillis</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RecyclerView表项点击监听器"><a href="#RecyclerView表项点击监听器" class="headerlink" title="RecyclerView表项点击监听器"></a>RecyclerView表项点击监听器</h2><p><code>RecyclerView</code>没有子控件点击事件监听器，那就用<code>Kotlin扩展方法</code>扩展一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#39;为 RecyclerView 扩展表项点击监听器&#39;</span><br><span class="line">fun RecyclerView.setOnItemClickListener(listener: (View, Int) -&gt; Unit) &#123;</span><br><span class="line">    &#x2F;&#x2F;&#39;为 RecyclerView 子控件设置触摸监听器&#39;</span><br><span class="line">    addOnItemTouchListener(object : RecyclerView.OnItemTouchListener &#123;</span><br><span class="line">        &#x2F;&#x2F;&#39;构造手势探测器，用于解析单击事件&#39;</span><br><span class="line">        val gestureDetector &#x3D; GestureDetector(context, object : GestureDetector.OnGestureListener &#123;</span><br><span class="line">            override fun onShowPress(e: MotionEvent?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onSingleTapUp(e: MotionEvent?): Boolean &#123;</span><br><span class="line">                &#x2F;&#x2F;&#39;当单击事件发生时，寻找单击坐标下的子控件，并回调监听器&#39;</span><br><span class="line">                e?.let &#123;</span><br><span class="line">                    findChildViewUnder(it.x, it.y)?.let &#123; child -&gt;</span><br><span class="line">                        listener(child, getChildAdapterPosition(child))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onDown(e: MotionEvent?): Boolean &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFling(e1: MotionEvent?, e2: MotionEvent?, velocityX: Float, velocityY: Float): Boolean &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onScroll(e1: MotionEvent?, e2: MotionEvent?, distanceX: Float, distanceY: Float): Boolean &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onLongPress(e: MotionEvent?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        override fun onTouchEvent(rv: RecyclerView, e: MotionEvent) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#39;在拦截触摸事件时，解析触摸事件&#39;</span><br><span class="line">        override fun onInterceptTouchEvent(rv: RecyclerView, e: MotionEvent): Boolean &#123;</span><br><span class="line">            gestureDetector.onTouchEvent(e)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onRequestDisallowInterceptTouchEvent(disallowIntercept: Boolean) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/Top10/">2020年GitHub 上那些优秀Android开源库</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/Top10/" data-flag-title="2020年GitHub 上那些优秀Android开源库"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>2020年有哪些优秀的开源库呢？本期就为大家带精选的10个，排名不分先后。</p>
<h3 id="No1-LiquidSwipe"><a href="#No1-LiquidSwipe" class="headerlink" title="No1. LiquidSwipe"></a>No1. LiquidSwipe</h3><p>这是一个很棒的ViewPager库，它在浏览ViewPager的不同页面时，显示波浪的滑动动画，效果非常炫酷。该库的USP是触摸交互的。这意味着在视图中显示类似液体的显示过渡时，应考虑触摸事件。</p>
<h5 id="1-1如何使用呢？"><a href="#1-1如何使用呢？" class="headerlink" title="1.1如何使用呢？"></a>1.1如何使用呢？</h5><p>导入以下Gradle依赖项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.github.Chrisvin:LiquidSwipe:1.3&#39;</span><br></pre></td></tr></table></figure>

<p>然后将<code>LiquidSwipeLayout</code>添加为保存fragment布局的容器的根布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout </span><br><span class="line">    xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.jem.liquidswipe.LiquidSwipeViewPager</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;viewpager&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-效果图"><a href="#1-2-效果图" class="headerlink" title="1.2 效果图"></a>1.2 效果图</h5><table>
<thead>
<tr>
<th align="left">效果1</th>
<th align="left">效果2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd596bc8a6?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd611cbcb0?imageslim" alt="img"></td>
</tr>
</tbody></table>
<p>更多详细使用方法请看Github: <a href="https://github.com/Chrisvin/LiquidSwipe" target="_blank" rel="noopener">github.com/Chrisvin/Li…</a></p>
<h3 id="No2-Flourish"><a href="#No2-Flourish" class="headerlink" title="No2. Flourish"></a>No2. Flourish</h3><p><code>Flourish</code>提供了一个炫酷的方式来显示或者隐藏一个布局，实现方式也很简单，就是对View或者布局进行了包装，通过构建者模式来提供api给上层调用。就像使用dialog一样，调用<code>show</code>和<code>dissmiss</code>方法来显示和隐藏。此外，通过这些类，我们还可以自定义动画（正常，加速，反弹），或为布局方向设置我们自己的起点（左上，右下等）。</p>
<h5 id="2-1-如何使用？"><a href="#2-1-如何使用？" class="headerlink" title="2.1 如何使用？"></a>2.1 如何使用？</h5><p>在build.gradle 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;com.github.skydoves:flourish:1.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在代码中，构建布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Flourish flourish &#x3D; new Flourish.Builder(parentLayout)</span><br><span class="line">    &#x2F;&#x2F; sets the flourish layout for showing and dismissing on the parent layout.</span><br><span class="line">    .setFlourishLayout(R.layout.layout_flourish_main)</span><br><span class="line">    &#x2F;&#x2F; sets the flourishing animation for showing and dismissing.</span><br><span class="line">    .setFlourishAnimation(FlourishAnimation.BOUNCE)</span><br><span class="line">    &#x2F;&#x2F; sets the orientation of the starting point.</span><br><span class="line">    .setFlourishOrientation(FlourishOrientation.TOP_LEFT)</span><br><span class="line">    &#x2F;&#x2F; sets a flourishListener for listening changes.</span><br><span class="line">    .setFlourishListener(flourishListener)</span><br><span class="line">    &#x2F;&#x2F; sets the flourish layout should be showed on start. </span><br><span class="line">    .setIsShowedOnStart(false)</span><br><span class="line">    &#x2F;&#x2F; sets the duration of the flourishing.</span><br><span class="line">    .setDuration(800L)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>还提供有更简介的DSL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val myFlourish &#x3D; createFlourish(parentLayout) &#123;</span><br><span class="line">  setFlourishLayout(R.layout.layout_flourish_main)</span><br><span class="line">  setFlourishAnimation(FlourishAnimation.ACCELERATE)</span><br><span class="line">  setFlourishOrientation(FlourishOrientation.TOP_RIGHT)</span><br><span class="line">  setIsShowedOnStart(true)</span><br><span class="line">  setFlourishListener &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-效果图"><a href="#2-2-效果图" class="headerlink" title="2.2  效果图"></a>2.2  效果图</h5><table>
<thead>
<tr>
<th align="left">效果1</th>
<th align="left">效果2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd598c788c?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd65deef71?imageslim" alt="img"></td>
</tr>
</tbody></table>
<p>更多详细使用请看Github：<a href="https://github.com/skydoves/Flourish" target="_blank" rel="noopener">github.com/skydoves/Fl…</a></p>
<h3 id="No3-AestheticDialogs"><a href="#No3-AestheticDialogs" class="headerlink" title="No3. AestheticDialogs"></a>No3. AestheticDialogs</h3><p>这是一个美观而时尚的AlterDialog库，目前可支持六种不同的对话框,如：</p>
<ul>
<li>Flash Dialog</li>
<li>Connectify Dialog</li>
<li>Toaster Dialog</li>
<li>Emotion Dialog</li>
<li>Drake Dialog</li>
<li>Emoji Dialog 并且啊，还提供了暗黑模式的适配。</li>
</ul>
<h5 id="3-1-如何使用？"><a href="#3-1-如何使用？" class="headerlink" title="3.1 如何使用？"></a>3.1 如何使用？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"> ...</span><br><span class="line"> implementation &#39;com.github.gabriel-TheCode:AestheticDialogs:1.1.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，显示不同种类的对话框则调用对应的方法就好</p>
<p>Flash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AestheticDialog.showFlashDialog(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showFlashDialog(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br></pre></td></tr></table></figure>

<p>Connectify:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AestheticDialog.showConnectify(this,&quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showConnectify(this, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;&#x2F; Dark Theme</span><br><span class="line"> AestheticDialog.showConnectifyDark(this,&quot;Your message&quot;,AestheticDialog.SUCCESS);</span><br><span class="line"> AestheticDialog.showConnectifyDark(this, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br></pre></td></tr></table></figure>

<p>Toaster:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br><span class="line">AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING);</span><br><span class="line"> AestheticDialog.showToaster(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;&#x2F; Dark Theme</span><br><span class="line"> AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br><span class="line">AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING);</span><br><span class="line"> AestheticDialog.showToasterDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO);</span><br></pre></td></tr></table></figure>

<p>Drake :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> AestheticDialog.showDrake(this, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showDrake(this, AestheticDialog.ERROR);</span><br></pre></td></tr></table></figure>

<p>Emoji :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> AestheticDialog.showEmoji(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showEmoji(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Dark Theme</span><br><span class="line"> AestheticDialog.showEmojiDark(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showEmojiDark(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br></pre></td></tr></table></figure>

<p>Emotion :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> AestheticDialog.showEmotion(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line">AestheticDialog.showEmotion(this, &quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br></pre></td></tr></table></figure>

<p>Rainbow :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.SUCCESS);</span><br><span class="line"> AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.ERROR);</span><br><span class="line"> AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.WARNING);</span><br><span class="line">AestheticDialog.showRainbow(this,&quot;Your dialog Title&quot;, &quot;Your message&quot;, AestheticDialog.INFO);</span><br></pre></td></tr></table></figure>

<h5 id="3-2-效果如下"><a href="#3-2-效果如下" class="headerlink" title="3.2 效果如下"></a>3.2 效果如下</h5><table>
<thead>
<tr>
<th align="left">Flash Dialog</th>
<th align="left">Connectify Dialog</th>
<th align="left">Toaster Dialog</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd6162084c?imageslim" alt="d1.gif"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd9aecbe0a?imageslim" alt="d2.gif"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fd65e67426?imageslim" alt="d3.gif"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">Emotion Dialog</th>
<th align="left">Drake Dialog</th>
<th align="left">Emoji Dialog</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fda6337612?imageslim" alt="d4.gif"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fda6511772?imageslim" alt="d5.gif"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fda8cf1381?imageslim" alt="d6.gif"></td>
</tr>
</tbody></table>
<p>更多详情使用方法请看Github：<a href="https://github.com/gabriel-TheCode/AestheticDialogs" target="_blank" rel="noopener">github.com/gabriel-The…</a></p>
<h3 id="N4-EasyReveal"><a href="#N4-EasyReveal" class="headerlink" title="N4. EasyReveal"></a>N4. EasyReveal</h3><p>从名字就知道，这是一个提供<code>reveal</code>动画效果的库，它的厉害之处在于可以提供不同尺寸、不同形状的reveal动画，并且还可以在定义它在屏幕任意位置开始和结束动画。</p>
<h5 id="4-1-如何使用？"><a href="#4-1-如何使用？" class="headerlink" title="4.1 如何使用？"></a>4.1 如何使用？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"> ...</span><br><span class="line"> implementation &#39;com.github.Chrisvin:EasyReveal:1.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，xml中，需要添加显示或者隐藏动画的View应该包裹在<code>EasyRevealLinearLayout</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.jem.easyreveal.layouts.EasyRevealLinearLayout</span><br><span class="line">    ...</span><br><span class="line">    app:clipPathProvider&#x3D;&quot;star&quot; &#x2F;&#x2F; possible values: circular, linear, random_line, star, sweep &amp; wave</span><br><span class="line">    app:revealAnimationDuration&#x3D;&quot;2000&quot;</span><br><span class="line">    app:hideAnimationDuration&#x3D;&quot;1500&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- The views to be revealed&#x2F;hidden go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;com.jem.easyreveal.layouts.EasyRevealLinearLayout&gt;</span><br><span class="line">&lt;!-- Similarly for com.jem.easyreveal.layouts.EasyRevealConstraintLayout &amp; com.jem.easyreveal.layouts.EasyRevealFrameLayout --&gt;</span><br></pre></td></tr></table></figure>

<p>也可以在代码中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">val revealLayout &#x3D; EasyRevealLinearLayout(this)</span><br><span class="line">&#x2F;&#x2F; Set the ClipPathProvider that is used to clip the view for reveal animation</span><br><span class="line">revealLayout.clipPathProvider &#x3D; StarClipPathProvider(numberOfPoints &#x3D; 6)</span><br><span class="line">&#x2F;&#x2F; Set the duration taken for reveal animation</span><br><span class="line">revealLayout.revealAnimationDuration &#x3D; 1500</span><br><span class="line">&#x2F;&#x2F; Set the duration taken for hide animation</span><br><span class="line">revealLayout.hideAnimationDuration &#x3D; 2000</span><br><span class="line">&#x2F;&#x2F; Set listener to get updates during reveal&#x2F;hide animation</span><br><span class="line">revealLayout.onUpdateListener &#x3D; object: RevealLayout.OnUpdateListener &#123;</span><br><span class="line">    override fun onUpdate(percent: Float) &#123;</span><br><span class="line">        Toast.makeText(this@MainActivity, &quot;Revealed percent: $percent&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Start reveal animation</span><br><span class="line">revealLayout.reveal()</span><br><span class="line">&#x2F;&#x2F; Start hide animation</span><br><span class="line">revealLayout.hide()</span><br></pre></td></tr></table></figure>

<h5 id="4-2效果图"><a href="#4-2效果图" class="headerlink" title="4.2效果图"></a>4.2效果图</h5><table>
<thead>
<tr>
<th align="left">Emotion Dialog</th>
<th align="left">Drake Dialog</th>
<th align="left">Emoji Dialog</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdaf742389?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdb834525b?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdcdb85e38?imageslim" alt="img"></td>
</tr>
<tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdd5c42d60?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fde299e5f8?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdecbac3a3?imageslim" alt="img"></td>
</tr>
</tbody></table>
<p>更多详细使用信息请看Github： <a href="https://github.com/Chrisvin/EasyReveal" target="_blank" rel="noopener">github.com/Chrisvin/Ea…</a></p>
<h3 id="No5-Android-ColorX"><a href="#No5-Android-ColorX" class="headerlink" title="No5. Android ColorX"></a>No5. Android ColorX</h3><p><code>Android ColorX</code> 以Kotlin 扩展函数的形式提供了一些重要的获取颜色的方法。 通过提供不同颜色格式（RGB，HSV，CYMK等）的转换功能，它使开发变得更加轻松。该库的USP具有以下功能：</p>
<ul>
<li>颜色的不同阴影和色调。</li>
<li>较深和较浅的阴影。</li>
<li>颜色的补码</li>
</ul>
<h5 id="5-1-如何使用？"><a href="#5-1-如何使用？" class="headerlink" title="5.1 如何使用？"></a>5.1 如何使用？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;me.jorgecastillo:androidcolorx:0.2.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，一系列的转换方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">val color &#x3D; Color.parseColor(&quot;#e91e63&quot;)</span><br><span class="line"></span><br><span class="line">val rgb &#x3D; color.asRgb()</span><br><span class="line">val argb &#x3D; color.asArgb()</span><br><span class="line">val hex &#x3D; color.asHex()</span><br><span class="line">val hsl &#x3D; color.asHsl()</span><br><span class="line">val hsla &#x3D; color.asHsla()</span><br><span class="line">val hsv &#x3D; color.asHsv()</span><br><span class="line">val cmyk &#x3D; color.asCmyk()</span><br><span class="line"></span><br><span class="line">val colorHsl &#x3D; HSLColor(hue &#x3D; 210f, saturation &#x3D; 0.5f, lightness &#x3D; 0.5f)</span><br><span class="line"></span><br><span class="line">val colorInt &#x3D; colorHsl.asColorInt()</span><br><span class="line">val rgb &#x3D; colorHsl.asRgb()</span><br><span class="line">val argb &#x3D; colorHsl.asArgb()</span><br><span class="line">val hex &#x3D; colorHsl.asHex()</span><br><span class="line">val cmyk &#x3D; colorHsl.asCmyk()</span><br><span class="line">val hsla &#x3D; colorHsl.asHsla()</span><br><span class="line">val hsv &#x3D; colorHsl.asHsv()</span><br></pre></td></tr></table></figure>

<h5 id="5-2-效果图"><a href="#5-2-效果图" class="headerlink" title="5.2 效果图"></a>5.2 效果图</h5><p><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fdf42d10d3?imageslim" alt="img"></p>
<p>更多详细使用信息请看Github：<a href="https://github.com/JorgeCastilloPrz/AndroidColorX" target="_blank" rel="noopener">github.com/JorgeCastil…</a></p>
<h3 id="No6-AnimatedBottomBar"><a href="#No6-AnimatedBottomBar" class="headerlink" title="No6. AnimatedBottomBar"></a>No6. AnimatedBottomBar</h3><p>这是一个带动画的底部导航栏库。它使你可以以编程方式以及通过XML添加和删除选项卡。此外，我们可以轻松地从BottomBar拦截选项卡。限制访问应用程序导航中的高级区域时，“拦截”标签非常有用。流畅的动画提供了许多自定义选项，从动画插值器到设置波纹效果。</p>
<h5 id="6-1-如何使用？"><a href="#6-1-如何使用？" class="headerlink" title="6.1 如何使用？"></a>6.1 如何使用？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation &#39;nl.joery.animatedbottombar:library:1.0.8&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在xml文件中添加<code>AnimatedBottomBar</code>和自定义属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;nl.joery.animatedbottombar.AnimatedBottomBar</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;bottom_bar&quot;</span><br><span class="line">    android:background&#x3D;&quot;#FFF&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    app:abb_selectedTabType&#x3D;&quot;text&quot;</span><br><span class="line">    app:abb_indicatorAppearance&#x3D;&quot;round&quot;</span><br><span class="line">    app:abb_indicatorMargin&#x3D;&quot;16dp&quot;</span><br><span class="line">    app:abb_indicatorHeight&#x3D;&quot;4dp&quot;</span><br><span class="line">    app:abb_tabs&#x3D;&quot;@menu&#x2F;tabs&quot;</span><br><span class="line">    app:abb_selectedIndex&#x3D;&quot;1&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>res/menu</code>目录下定义<code>tabs.xml</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tab_home&quot;</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;home&quot;</span><br><span class="line">        android:title&#x3D;&quot;@string&#x2F;home&quot; &#x2F;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tab_alarm&quot;</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;alarm&quot;</span><br><span class="line">        android:title&#x3D;&quot;@string&#x2F;alarm&quot; &#x2F;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tab_bread&quot;</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;bread&quot;</span><br><span class="line">        android:title&#x3D;&quot;@string&#x2F;bread&quot; &#x2F;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tab_cart&quot;</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;cart&quot;</span><br><span class="line">        android:title&#x3D;&quot;@string&#x2F;cart&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;menu&gt;</span><br></pre></td></tr></table></figure>

<p>最后，代码中添加tab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Creating a tab by passing values</span><br><span class="line">val bottomBarTab1 &#x3D; AnimatedBottomBar.createTab(drawable, &quot;Tab 1&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Creating a tab by passing resources</span><br><span class="line">val bottomBarTab2 &#x3D; AnimatedBottomBar.createTab(R.drawable.ic_home, R.string.tab_2, R.id.tab_home)</span><br></pre></td></tr></table></figure>

<h5 id="6-2-效果图"><a href="#6-2-效果图" class="headerlink" title="6.2 效果图"></a>6.2 效果图</h5><table>
<thead>
<tr>
<th align="left">tab1</th>
<th align="left">tab2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe11cdef3a?imageslim" alt="tab1.gif"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe19a34bf0?imageslim" alt="tab2.gif"></td>
</tr>
</tbody></table>
<p>详情信息请看Github: <a href="https://github.com/Droppers/AnimatedBottomBar" target="_blank" rel="noopener">github.com/Droppers/An…</a></p>
<h3 id="No7-RateBottomSheet"><a href="#No7-RateBottomSheet" class="headerlink" title="No7. RateBottomSheet"></a>No7. RateBottomSheet</h3><p>有时候，为了推广我们的应用，我们需要让用户跳转到应用商店为我们的APP打分，传统的对话框用户体验很不好，而本库则是用BottomSheet来进行提示，它位于底部缩略区域，用户体验很好。</p>
<h5 id="7-1-如何使用呢？"><a href="#7-1-如何使用呢？" class="headerlink" title="7.1 如何使用呢？"></a>7.1 如何使用呢？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation &#39;com.mikhaellopez:ratebottomsheet:1.1.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改默认的string资源文件来改变显示文案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_ask_title&quot;&gt;Like this App?&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_ask_message&quot;&gt;Do you like using this application?&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_ask_ok&quot;&gt;Yes I do&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_ask_no&quot;&gt;Not really&lt;&#x2F;string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_title&quot;&gt;Rate this app&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_message&quot;&gt;Would you mind taking a moment to rate it? It won\&#39;t take more than a minute. Thanks for your support!&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_ok&quot;&gt;Rate it now&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_later&quot;&gt;Remind me later&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;string name&#x3D;&quot;rate_popup_no&quot;&gt;No, thanks&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br></pre></td></tr></table></figure>

<p>代码中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RateBottomSheetManager(this)</span><br><span class="line">    .setInstallDays(1) &#x2F;&#x2F; 3 by default</span><br><span class="line">    .setLaunchTimes(2) &#x2F;&#x2F; 5 by default</span><br><span class="line">    .setRemindInterval(1) &#x2F;&#x2F; 2 by default</span><br><span class="line">    .setShowAskBottomSheet(false) &#x2F;&#x2F; True by default</span><br><span class="line">    .setShowLaterButton(false) &#x2F;&#x2F; True by default</span><br><span class="line">    .setShowCloseButtonIcon(false) &#x2F;&#x2F; True by default</span><br><span class="line">    .monitor()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Show bottom sheet if meets conditions</span><br><span class="line">&#x2F;&#x2F; With AppCompatActivity or Fragment</span><br><span class="line">RateBottomSheet.showRateBottomSheetIfMeetsConditions(this)</span><br></pre></td></tr></table></figure>

<h5 id="7-2-效果图"><a href="#7-2-效果图" class="headerlink" title="7.2 效果图"></a>7.2 效果图</h5><p><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe29028b1a?imageslim" alt="img"></p>
<p>更多详情请看Github:<a href="https://github.com/lopspower/RateBottomSheet" target="_blank" rel="noopener">github.com/lopspower/R…</a></p>
<h3 id="No8-TransformationLayout"><a href="#No8-TransformationLayout" class="headerlink" title="No8. TransformationLayout"></a>No8. TransformationLayout</h3><p>这是一个用于Activity或者Fragment 以及View切换的过渡动画库，效果非常炫，它使用Material Design的运动系统过渡模式来创建变形动画。该库提供了用于绑定目标视图，设置淡入淡出和路径运动方向以及许多其他自定义选项的属性。</p>
<h5 id="8-1-如何使用？"><a href="#8-1-如何使用？" class="headerlink" title="8.1 如何使用？"></a>8.1 如何使用？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;com.github.skydoves:transformationlayout:1.0.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，需要将我们需要添加过渡动画的View包裹到 <code>TransformationLayout</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.skydoves.transformationlayout.TransformationLayout</span><br><span class="line">  android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">  android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">  app:transformation_targetView&#x3D;&quot;@+id&#x2F;my_cardView&quot; &#x2F;&#x2F; sets a target view.</span><br><span class="line">  app:transformation_duration&#x3D;&quot;450&quot; &#x2F;&#x2F; sets a duration of the transformation.</span><br><span class="line">  app:transformation_direction&#x3D;&quot;auto&quot; &#x2F;&#x2F; auto, entering, returning</span><br><span class="line">  app:transformation_fadeMode&#x3D;&quot;in&quot; &#x2F;&#x2F; in, out, cross, through</span><br><span class="line">  app:transformation_fitMode&#x3D;&quot;auto&quot; &#x2F;&#x2F; auto, height, width</span><br><span class="line">  app:transformation_pathMode&#x3D;&quot;arc&quot; &#x2F;&#x2F; arc, linear</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- other views --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;com.skydoves.transformationlayout.TransformationLayout&gt;</span><br></pre></td></tr></table></figure>

<p>比如我们要将一个fab 过渡到一个card卡片，布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.skydoves.transformationlayout.TransformationLayout</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;transformationLayout&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    app:transformation_duration&#x3D;&quot;550&quot;</span><br><span class="line">    app:transformation_targetView&#x3D;&quot;@+id&#x2F;myCardView&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;com.google.android.material.floatingactionbutton.FloatingActionButton</span><br><span class="line">      android:id&#x3D;&quot;@+id&#x2F;fab&quot;</span><br><span class="line">      android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">      android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">      android:backgroundTint&#x3D;&quot;@color&#x2F;colorPrimary&quot;</span><br><span class="line">      android:src&#x3D;&quot;@drawable&#x2F;ic_write&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;com.skydoves.transformationlayout.TransformationLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;com.google.android.material.card.MaterialCardView</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;myCardView&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;240dp&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;312dp&quot;</span><br><span class="line">    android:layout_marginLeft&#x3D;&quot;30dp&quot;</span><br><span class="line">    android:layout_marginTop&#x3D;&quot;30dp&quot;</span><br><span class="line">    app:cardBackgroundColor&#x3D;&quot;@color&#x2F;colorPrimary&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重点来了，绑定视图</strong>，将一个<code>targetView</code>绑定到<code>TransformationLayout</code>有2种方式：</p>
<ul>
<li>通过在xml中指定属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:transformation_targetView&#x3D;&quot;@+id&#x2F;myCardView&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>在代码中绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transformationLayout.bindTargetView(myCardView)</span><br></pre></td></tr></table></figure>

<p>当我们点击fab时，在监听器中调用<code>startTransform()</code>开始过渡动画，<code>finishTransform（）</code>开始结束动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; start transformation when touching the fab.</span><br><span class="line">fab.setOnClickListener &#123;</span><br><span class="line">  transformationLayout.startTransform()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; finish transformation when touching the myCardView.</span><br><span class="line">myCardView.setOnClickListener &#123;</span><br><span class="line">  transformationLayout.finishTransform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-效果图"><a href="#8-2-效果图" class="headerlink" title="8.2 效果图"></a>8.2 效果图</h5><p><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe31ffea34?imageslim" alt="img"></p>
<p>更多使用方式请看Github: <a href="https://github.com/skydoves/TransformationLayout" target="_blank" rel="noopener">github.com/skydoves/Tr…</a></p>
<h3 id="No9-Donut"><a href="#No9-Donut" class="headerlink" title="No9. Donut"></a>No9. Donut</h3><p>这个一个可以展示多个数据集的圆弧形控件，具有精细的颗粒控制、间隙功能、动画选项以及按比例缩放其值的功能。可以用于项目中的一些数据统计。</p>
<h5 id="9-1-如何使用？"><a href="#9-1-如何使用？" class="headerlink" title="9.1 如何使用？"></a>9.1 如何使用？</h5><p>在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(&quot;app.futured.donut:library:$version&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在布局文件中添加View:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;app.futured.donut.DonutProgressView</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;donut_view&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    app:donut_bgLineColor&#x3D;&quot;@color&#x2F;cloud&quot;</span><br><span class="line">    app:donut_gapWidth&#x3D;&quot;20&quot;</span><br><span class="line">    app:donut_gapAngle&#x3D;&quot;270&quot;</span><br><span class="line">    app:donut_strokeWidth&#x3D;&quot;16dp&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>然后在代码中设置数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val dataset1 &#x3D; DonutDataset(</span><br><span class="line">    name &#x3D; &quot;dataset_1&quot;,</span><br><span class="line">    color &#x3D; Color.parseColor(&quot;#FB1D32&quot;),</span><br><span class="line">    amount &#x3D; 1f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">val dataset2 &#x3D; DonutDataset(</span><br><span class="line">    name &#x3D; &quot;dataset_2&quot;,</span><br><span class="line">    color &#x3D; Color.parseColor(&quot;#FFB98E&quot;),</span><br><span class="line">    amount &#x3D; 1f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">donut_view.cap &#x3D; 5f</span><br><span class="line">donut_view.submitData(listOf(dataset1, dataset2))</span><br></pre></td></tr></table></figure>

<h5 id="9-2-效果图"><a href="#9-2-效果图" class="headerlink" title="9.2  效果图"></a>9.2  效果图</h5><p><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe83c87b9a?imageslim" alt="img"></p>
<p>更多用法请看Github: <a href="https://github.com/futuredapp/donut" target="_blank" rel="noopener">github.com/futuredapp/…</a></p>
<h3 id="No10-CurveGraphView"><a href="#No10-CurveGraphView" class="headerlink" title="No10. CurveGraphView"></a>No10. CurveGraphView</h3><p><code>CurveGraphView</code> 是一个带有炫酷动画统计图表库，除了性能出色并具有许多样式选项之外，该库还支持单个平面内的多个线图。</p>
<p>多个折线图对于比较不同股票，共同基金，加密货币等的价格非常有用。</p>
<h5 id="10-1-如何使用？"><a href="#10-1-如何使用？" class="headerlink" title="10.1 如何使用？"></a>10.1 如何使用？</h5><p>1、在<code>build.gradle</code> 中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;com.github.swapnil1104:CurveGraphView:&#123;current_lib_ver&#125;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在xml文件中添加布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.broooapps.graphview.CurveGraphView</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;cgv&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;250dp&quot;</span><br><span class="line">       app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">       app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">       app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">       app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>然后在代码中添加各种配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curveGraphView &#x3D; findViewById(R.id.cgv);</span><br><span class="line"></span><br><span class="line">curveGraphView.configure(</span><br><span class="line">        new CurveGraphConfig.Builder(this)</span><br><span class="line">                .setAxisColor(R.color.Blue)                                             &#x2F;&#x2F; Set X and Y axis line color stroke.</span><br><span class="line">                .setIntervalDisplayCount(7)                                             &#x2F;&#x2F; Set number of values to be displayed in X ax</span><br><span class="line">                .setGuidelineCount(2)                                                   &#x2F;&#x2F; Set number of background guidelines to be shown.</span><br><span class="line">                .setGuidelineColor(R.color.GreenYellow)                                 &#x2F;&#x2F; Set color of the visible guidelines.</span><br><span class="line">                .setNoDataMsg(&quot; No Data &quot;)                                              &#x2F;&#x2F; Message when no data is provided to the view.</span><br><span class="line">                .setxAxisScaleTextColor(R.color.Black)                                  &#x2F;&#x2F; Set X axis scale text color.</span><br><span class="line">                .setyAxisScaleTextColor(R.color.Black)                                  &#x2F;&#x2F; Set Y axis scale text color</span><br><span class="line">                .build()</span><br><span class="line">        ););</span><br></pre></td></tr></table></figure>

<p>3、 提供数据集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PointMap pointMap &#x3D; new PointMap();</span><br><span class="line">        pointMap.addPoint(0, 100);</span><br><span class="line">        pointMap.addPoint(1, 500);</span><br><span class="line">        pointMap.addPoint(5, 800);</span><br><span class="line">        pointMap.addPoint(4, 600);</span><br></pre></td></tr></table></figure>

<h5 id="10-2-效果图"><a href="#10-2-效果图" class="headerlink" title="10.2 效果图"></a>10.2 效果图</h5><table>
<thead>
<tr>
<th align="left">效果1</th>
<th align="left">效果2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe31f4c9ad?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe61166b90?imageslim" alt="img"></td>
</tr>
<tr>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe67f21c88?imageslim" alt="img"></td>
<td align="left"><img src="http://user-gold-cdn.xitu.io/2020/4/27/171b92fe80ec22ee?imageslim" alt="img"></td>
</tr>
</tbody></table>
<p>更多详细使用方式请看Github: <a href="https://github.com/swapnil1104/CurveGraphView" target="_blank" rel="noopener">github.com/swapnil1104…</a></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/FragmentTransaction/">Androidx 下 Fragment 懒加载的新实现</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/FragmentTransaction/" data-flag-title="Androidx 下 Fragment 懒加载的新实现"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>以前处理 Fragment 的懒加载，我们通常会在 Fragment 中处理 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数，而在 Androidx 模式下，我们可以使用 <code>FragmentTransaction.setMaxLifecycle()</code> 的方式来处理 Fragment 的懒加载。</p>
<p>在本文章中，我会详细介绍不同使用场景下两种方案的差异。大家快拿好小板凳。一起来学习新知识吧！</p>
<blockquote>
<p>本篇文章涉及到的 Demo，已上传至Github—-&gt;<a href="https://github.com/AndyJennifer/AndroidxLazyLoad" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h3 id="老的懒加载处理方案"><a href="#老的懒加载处理方案" class="headerlink" title="老的懒加载处理方案"></a>老的懒加载处理方案</h3><blockquote>
<p>如果你熟悉老一套的 Fragment 懒加载机制，你可以直接查看 Androix 懒加载相关章节</p>
</blockquote>
<h4 id="add-show-hide-模式下的老方案"><a href="#add-show-hide-模式下的老方案" class="headerlink" title="add+show+hide 模式下的老方案"></a>add+show+hide 模式下的老方案</h4><p>在没有添加懒加载之前，只要使用 <code>add+show+hide</code> 的方式控制并显示 Fragment, 那么不管 Fragment 是否嵌套，在初始化后，如果<code>只调用了add+show</code>，同级下的 Fragment 的相关生命周期函数都会被调用。且调用的生命周期函数如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Fragment 完整生命周期：onAttach -&gt; onCreate -&gt; onCreatedView -&gt; onActivityCreated -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroyView -&gt; onDestroy -&gt; onDetach</p>
</blockquote>
<p>什么是同级 Frament 呢？看下图</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96781bfcafeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="同级Fragment.jpg"></p>
<blockquote>
<p>上图中，都是使用 <code>add+show+hide</code> 的方式控制 Fragment,</p>
</blockquote>
<p>在上图两种模式中:</p>
<ul>
<li>Fragment_1、Fragment_2、Fragment_3 属于同级 Fragment</li>
<li>Fragment_a、Fragment_b、Fragment_c 属于同级 Fragment</li>
<li>Fragment_d、Fragment_e、Fragment_f 属于同级 Fragment</li>
</ul>
<p>那这种方式会带来什么问题呢？结合下图我们来分别分析。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967909b892db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="show1.png"></p>
<p>观察上图我们可以发现，同级的Fragment_1、Fragment_2、Fragment_3 都调用了 <code>onAttach...onResume</code> 系列方法，也就是说，如果我们没有对 Fragment 进行懒加载处理，那么我们就会无缘无故的加载一些并<code>不可见</code>的 Fragment , 也就会造成用户流量的无故消耗（我们会在 Fragment 相关生命周期函数中，请求网络或其他数据操作）。</p>
<blockquote>
<p>这里<code>&quot;不可见的Fragment&quot;</code>是指，实际不可见但是相关可见生命周期函数(如 <code>onResume</code> 方法）被调用的 Fragment</p>
</blockquote>
<p>如果使用嵌套 Fragment ，这种浪费流量的行为就更明显了。以本节的图一为例，当 Fragment_1 加载时，如果你在 Fragment_1 生命周期函数中使用 <code>show+add+hide</code> 的方式添加 <code>Fragment_a、Fragment_b、Fragment_c</code> , 那么 Fragment_b 又会在其生命周期函数中继续加载 <code>Fragment_d、Fragment_e、Fragment_f</code> 。</p>
<p>那如何解决这种问题呢？我们继续接着上面的例子走，当我们 <code>show Fragment_2</code>，并 hide其他 Fragment 时，对应 Fragment 的生命周期调用如下：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96782a90b81e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="show2.png"></p>
<p>从上图中，我们可以看出 Fragment_2 与 Fragment_3 都调用了 <code>onHiddenChanged</code> 函数，该函数的官方 API 声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Called when the hidden state (as returned by &#123;@link #isHidden()&#125; of</span><br><span class="line"> * the fragment has changed.  Fragments start out not hidden; this will</span><br><span class="line"> * be called whenever the fragment changes state from that.</span><br><span class="line"> * @param hidden True if the fragment is now hidden, false otherwise.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void onHiddenChanged(boolean hidden) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方 API 的注释，我们大概能知道，当 Fragment 隐藏的状态发生改变时，该函数将会被调用，如果当前 Fragment 隐藏， <code>hidden</code> 的值为 true, 反之为 false。最为重要的是<code>hidden</code> 的值，可以通过调用 <code>isHidden()</code> 函数获取。</p>
<p>那么结合上述知识点，我们能推导出：</p>
<ul>
<li>因为 Fragment_1 的 <code>隐藏状态</code> 从<code>可见转为了不可见</code>，所以其 <code>onHiddenChanged</code> 函数被调用，同时 <code>hidden</code> 的值为 true。</li>
<li>同理对于 Fragment_2 ，因为其 <code>隐藏状态</code> 从 <code>不可见转为了可见</code> ，所以其 hidden 值为 false。</li>
<li>对于 Fragment_3 ,因为其隐藏状态从始至终都没有发生变化，所以其 onHiddenChanged 函数并不会调用。</li>
</ul>
<p>嗯，好像有点眉目了。不急，我们继续看下面的例子。</p>
<p>show Fragment_3 并 hide 其他 Fragment ，对应生命周期函数调用如下所示：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967928f23799?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="show3.png"></p>
<p>从图中，我们可以看出，确实只有<code>隐藏状态</code>发生了改变的 Fragment 其 <code>onHiddenChanged</code> 函数才会调用，那么结合以上知识点，我们能得出如下重要结论：</p>
<p><strong>只要通过 <code>show+hide</code> 方式控制 Fragment 的显隐，那么在第一次初始化后，Fragment 任何的生命周期方法都不会调用，只有 <code>onHiddenChanged</code> 方法会被调用。</strong></p>
<p>那么，假如我们要在 <code>add+show+hide</code> 模式下控制 Fragment 的懒加载，我们只需要做这两步：</p>
<ul>
<li>我们需要在 <code>onResume()</code> 函数中调用 <code>isHidden()</code> 函数，来处理默认显示的 Fragment</li>
<li>在 <code>onHiddenChanged</code> 函数中控制其他不可见的Fragment，</li>
</ul>
<p>也就是这样处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">abstract class LazyFragment:Fragment()&#123;</span><br><span class="line"></span><br><span class="line">    private var isLoaded &#x3D; false &#x2F;&#x2F;控制是否执行懒加载</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        judgeLazyInit()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    override fun onHiddenChanged(hidden: Boolean) &#123;</span><br><span class="line">        super.onHiddenChanged(hidden)</span><br><span class="line">        isVisibleToUser &#x3D; !hidden</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun judgeLazyInit() &#123;</span><br><span class="line">        if (!isLoaded &amp;&amp; !isHidden) &#123;</span><br><span class="line">            lazyInit()</span><br><span class="line">            isLoaded &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     override fun onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView()</span><br><span class="line">        isLoaded &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;懒加载方法</span><br><span class="line">    abstract fun lazyInit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该懒加载的实现，是在 <code>onResume</code> 方法中操作，当然你可以在其他生命周期函数中控制。但是建议在该方法中执行懒加载。</p>
</blockquote>
<h4 id="ViewPager-Fragment-模式下的老方案"><a href="#ViewPager-Fragment-模式下的老方案" class="headerlink" title="ViewPager+Fragment 模式下的老方案"></a>ViewPager+Fragment 模式下的老方案</h4><p>使用传统方式处理 ViewPager 中 Fragment 的懒加载，我们需要控制 <code>setUserVisibleHint(boolean isVisibleToUser)</code> 函数，该函数的声明如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void setUserVisibleHint(boolean isVisibleToUser) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该函数与之前我们介绍的 <code>onHiddenChanged()</code> 作用非常相似，都是通过传入的参数值来判断当前 Fragment 是否对用户可见，只是 <code>onHiddenChanged()</code> 是在 <code>add+show+hide</code> 模式下使用，而 <code>setUserVisibleHint</code> 是在 ViewPager+Fragment 模式下使用。</p>
<p>在本节中，我们用 <code>FragmentPagerAdapter + ViewPager</code> 为例，向大家讲解如何实现 Fragment 的懒加载。</p>
<blockquote>
<p>注意：在本例中没有调用 <code>setOffscreenPageLimit</code> 方法去设置 ViewPager 预缓存的 Fragment 个数。默认情况下 ViewPager 预缓存 Fragment 的个数为 <code>1</code> 。</p>
</blockquote>
<p>初始化 ViewPager 查看内部 Fragment 生命周期函数调用情况：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967817311da1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="viewpager1.png"></p>
<p>观察上图，我们能发现 ViePager 初始化时，默认会调用其内部 Fragment 的 setUserVisibleHint 方法，因为其预缓存 Fragment 个数为 <code>1</code> 的原因，所以只有 Fragment_1 与 Fragment_2 的生命周期函数被调用。</p>
<p>我们继续切换到 Fragment_2，查看各个Fragment的生命周期函数的调用变化。如下图所示：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967825d4acb4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="viewpage2.png"></p>
<p>观察上图，我们同样发现 Fragment 的 setUserVisibleHint 方法被调用了，并且 Fragment_3 的一系列生命周期函数被调用了。继续切换到 Fragment_3:</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb9679081837f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="viewpager_3.png"></p>
<p>观察上图可以发现，Fragment_3 调用了 setUserVisibleHint 方法，继续又切换到 Fragment_1，查看调用函数的变化：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96782048236e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="viewpager4.png"></p>
<blockquote>
<p>因为之前在切换到 Fragment_3 时，Frafgment_1 已经走了 onDestoryView(图二，蓝色标记处) 方法，所以 Fragment_1 需要重新走一次生命周期。</p>
</blockquote>
<p>那么结合本节的三幅图，我们能得出以下结论：</p>
<ul>
<li>使用 ViewPager，切换回上一个 Fragment 页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。</li>
<li>setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。</li>
</ul>
<p>所以如果我们想对 ViewPager 中的 Fragment 懒加载，我们需要这样处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">abstract class LazyFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否执行懒加载</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isLoaded &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前Fragment是否对用户可见</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isVisibleToUser &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，</span><br><span class="line">     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，</span><br><span class="line">     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isCallResume &#x3D; false</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        isCallResume &#x3D; true</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun judgeLazyInit() &#123;</span><br><span class="line">        if (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) &#123;</span><br><span class="line">            lazyInit()</span><br><span class="line">            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)</span><br><span class="line">            isLoaded &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onHiddenChanged(hidden: Boolean) &#123;</span><br><span class="line">        super.onHiddenChanged(hidden)</span><br><span class="line">        isVisibleToUser &#x3D; !hidden</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在Fragment销毁View的时候，重置状态</span><br><span class="line">    override fun onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView()</span><br><span class="line">        isLoaded &#x3D; false</span><br><span class="line">        isVisibleToUser &#x3D; false</span><br><span class="line">        isCallResume &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun setUserVisibleHint(isVisibleToUser: Boolean) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser)</span><br><span class="line">        this.isVisibleToUser &#x3D; isVisibleToUser</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun lazyInit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂-Fragment-嵌套的情况"><a href="#复杂-Fragment-嵌套的情况" class="headerlink" title="复杂 Fragment 嵌套的情况"></a>复杂 Fragment 嵌套的情况</h4><p>当然，在实际项目中，我们可能会遇到更为复杂的 Fragment 嵌套组合。比如 Fragment+Fragment、Fragment+ViewPager、ViewPager+ViewPager….等等。 如下图所示：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96784fdd764d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="复杂嵌套Fragment.jpg"></p>
<p>对于以上场景，我们就需要重写我们的懒加载，以支持不同嵌套组合模式下 Fragment 正确懒加载。我们需要将 LazyFragment 修改成如下这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">abstract class LazyFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否执行懒加载</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isLoaded &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前Fragment是否对用户可见</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isVisibleToUser &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当使用ViewPager+Fragment形式会调用该方法时，setUserVisibleHint会优先Fragment生命周期函数调用，</span><br><span class="line">     * 所以这个时候就,会导致在setUserVisibleHint方法执行时就执行了懒加载，</span><br><span class="line">     * 而不是在onResume方法实际调用的时候执行懒加载。所以需要这个变量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isCallResume &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否调用了setUserVisibleHint方法。处理show+add+hide模式下，默认可见 Fragment 不调用</span><br><span class="line">     * onHiddenChanged 方法，进而不执行懒加载方法的问题。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private var isCallUserVisibleHint &#x3D; false</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        isCallResume &#x3D; true</span><br><span class="line">        if (!isCallUserVisibleHint) isVisibleToUser &#x3D; !isHidden</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun judgeLazyInit() &#123;</span><br><span class="line">        if (!isLoaded &amp;&amp; isVisibleToUser &amp;&amp; isCallResume) &#123;</span><br><span class="line">            lazyInit()</span><br><span class="line">            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)</span><br><span class="line">            isLoaded &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onHiddenChanged(hidden: Boolean) &#123;</span><br><span class="line">        super.onHiddenChanged(hidden)</span><br><span class="line">        isVisibleToUser &#x3D; !hidden</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView()</span><br><span class="line">        isLoaded &#x3D; false</span><br><span class="line">        isVisibleToUser &#x3D; false</span><br><span class="line">        isCallUserVisibleHint &#x3D; false</span><br><span class="line">        isCallResume &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun setUserVisibleHint(isVisibleToUser: Boolean) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser)</span><br><span class="line">        this.isVisibleToUser &#x3D; isVisibleToUser</span><br><span class="line">        isCallUserVisibleHint &#x3D; true</span><br><span class="line">        judgeLazyInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun lazyInit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Androidx-下的懒加载"><a href="#Androidx-下的懒加载" class="headerlink" title="Androidx 下的懒加载"></a>Androidx 下的懒加载</h3><p>虽然之前的方案就能解决轻松的解决 Fragment 的懒加载，但这套方案有一个最大的弊端，<code>就是不可见的 Fragment 执行了 onResume() 方法</code>。onResume 方法设计的初衷，难道不是当前 Fragment 可以和用户进行交互吗？你他妈既不可见，又不能和用户进行交互，你执行 onResume 方法干嘛？</p>
<p>基于此问题，Google 在 Androidx 在 <code>FragmentTransaction</code> 中增加了 <code>setMaxLifecycle</code> 方法来控制 Fragment 所能调用的最大的生命周期函数。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span><br><span class="line">  * already above the received state, it will be forced down to the correct state.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#39;s</span><br><span class="line">  * Lifecycle state capped, or previously added as part of this transaction. The</span><br><span class="line">  * &#123;@link Lifecycle.State&#125; passed in must at least be &#123;@link Lifecycle.State#CREATED&#125;, otherwise</span><br><span class="line">  * an &#123;@link IllegalArgumentException&#125; will be thrown.&lt;&#x2F;p&gt;</span><br><span class="line">  *</span><br><span class="line">  * @param fragment the fragment to have it&#39;s state capped.</span><br><span class="line">  * @param state the ceiling state for the fragment.</span><br><span class="line">  * @return the same FragmentTransaction instance</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @NonNull</span><br><span class="line"> public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment,</span><br><span class="line">         @NonNull Lifecycle.State state) &#123;</span><br><span class="line">     addOp(new Op(OP_SET_MAX_LIFECYCLE, fragment, state));</span><br><span class="line">     return this;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>根据官方的注释，我们能知道，该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到正确的状态。</p>
<p>那如何使用该方法呢？我们先看该方法在 Androidx 模式下 ViewPager+Fragment 模式下的使用例子。</p>
<h4 id="ViewPager-Fragment-模式下的方案"><a href="#ViewPager-Fragment-模式下的方案" class="headerlink" title="ViewPager+Fragment 模式下的方案"></a>ViewPager+Fragment 模式下的方案</h4><p>在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有  <code>behavior</code> 字段的构造函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public FragmentPagerAdapter(@NonNull FragmentManager fm,</span><br><span class="line">          @Behavior int behavior) &#123;</span><br><span class="line">      mFragmentManager &#x3D; fm;</span><br><span class="line">      mBehavior &#x3D; behavior;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">public FragmentStatePagerAdapter(@NonNull FragmentManager fm,</span><br><span class="line">          @Behavior int behavior) &#123;</span><br><span class="line">      mFragmentManager &#x3D; fm;</span><br><span class="line">      mBehavior &#x3D; behavior;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中 Behavior 的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line"> @IntDef(&#123;BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125;)</span><br><span class="line"> private @interface Behavior &#123; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">  * Indicates that &#123;@link Fragment#setUserVisibleHint(boolean)&#125; will be called when the current</span><br><span class="line">  * fragment changes.</span><br><span class="line">  *</span><br><span class="line">  * @deprecated This behavior relies on the deprecated</span><br><span class="line">  * &#123;@link Fragment#setUserVisibleHint(boolean)&#125; API. Use</span><br><span class="line">  * &#123;@link #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125; to switch to its replacement,</span><br><span class="line">  * &#123;@link FragmentTransaction#setMaxLifecycle&#125;.</span><br><span class="line">  * @see #FragmentPagerAdapter(FragmentManager, int)</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Deprecated</span><br><span class="line"> public static final int BEHAVIOR_SET_USER_VISIBLE_HINT &#x3D; 0;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * Indicates that only the current fragment will be in the &#123;@link Lifecycle.State#RESUMED&#125;</span><br><span class="line">  * state. All other Fragments are capped at &#123;@link Lifecycle.State#STARTED&#125;.</span><br><span class="line">  *</span><br><span class="line">  * @see #FragmentPagerAdapter(FragmentManager, int)</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public static final int BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>从官方的注释声明中，我们能得到如下两条结论：</p>
<ul>
<li>如果 behavior 的值为 <code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>，那么当 Fragment 对用户的可见状态发生改变时，<code>setUserVisibleHint</code> 方法会被调用。</li>
<li>如果 behavior 的值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> ，那么当前选中的 Fragment 在 <code>Lifecycle.State#RESUMED</code> 状态 ，其他不可见的 Fragment 会被限制在 <code>Lifecycle.State#STARTED</code> 状态。</li>
</ul>
<p>那 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT 这个值到底有什么作用呢？我们看下面的例子：</p>
<blockquote>
<p>在该例子中设置了 ViewPager 的适配器为 FragmentPagerAdapter 且 behavior 值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>。</p>
</blockquote>
<p>默认初始化ViewPager，Fragment 生命周期如下所示：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb967895238ac1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="androix1.png"></p>
<p>切换到 Fragment_2 时，日志情况如下所示：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96782b025a2f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="androix2.png"></p>
<p>切换到 Fragment_3 时，日志情况如下所示:</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/1/19/16fb96788af81c73?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="androidx3.png"></p>
<blockquote>
<p>因为篇幅的原因，本文没有在讲解 FragmentStatePagerAdapter 设置 behavior 下的使用情况，但是原理以及生命周期函数调用情况一样，感兴趣的小伙伴，可以根据  <a href="https://github.com/AndyJennifer/AndroidxLazyLoad" target="_blank" rel="noopener">AndroidxLazyLoad</a> 项目自行测试。</p>
</blockquote>
<p>观察上述例子，我们可以发现，使用了 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> 后，确实只有当前可见的 Fragment 调用了 onResume 方法。而导致产生这种改变的原因，是因为 FragmentPagerAdapter 在其 <code>setPrimaryItem</code> 方法中调用了 <code>setMaxLifecycle</code> 方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123;</span><br><span class="line">    Fragment fragment &#x3D; (Fragment)object;</span><br><span class="line">    &#x2F;&#x2F;如果当前的fragment不是当前选中并可见的Fragment,那么就会调用</span><br><span class="line">    &#x2F;&#x2F; setMaxLifecycle 设置其最大生命周期为 Lifecycle.State.STARTED</span><br><span class="line">    if (fragment !&#x3D; mCurrentPrimaryItem) &#123;</span><br><span class="line">        if (mCurrentPrimaryItem !&#x3D; null) &#123;</span><br><span class="line">            mCurrentPrimaryItem.setMenuVisibility(false);</span><br><span class="line">            if (mBehavior &#x3D;&#x3D; BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                if (mCurTransaction &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mCurTransaction &#x3D; mFragmentManager.beginTransaction();</span><br><span class="line">                &#125;</span><br><span class="line">                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mCurrentPrimaryItem.setUserVisibleHint(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#x2F;&#x2F;对于其他非可见的Fragment,则设置其最大生命周期为</span><br><span class="line">    &#x2F;&#x2F;Lifecycle.State.RESUMED</span><br><span class="line">        fragment.setMenuVisibility(true);</span><br><span class="line">        if (mBehavior &#x3D;&#x3D; BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">            if (mCurTransaction &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mCurTransaction &#x3D; mFragmentManager.beginTransaction();</span><br><span class="line">            &#125;</span><br><span class="line">            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fragment.setUserVisibleHint(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCurrentPrimaryItem &#x3D; fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然在上述条件下，只有实际可见的 Fragment 会调用 onResume 方法， 那是不是为我们提供了 ViewPager 下实现懒加载的新思路呢？也就是我们可以这样实现 Fragment 的懒加载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract class LazyFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    private var isLoaded &#x3D; false</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        if (!isLoaded) &#123;</span><br><span class="line">            lazyInit()</span><br><span class="line">            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)</span><br><span class="line">            isLoaded &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView()</span><br><span class="line">        isLoaded &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun lazyInit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-show-hide-模式下的新方案"><a href="#add-show-hide-模式下的新方案" class="headerlink" title="add+show+hide 模式下的新方案"></a>add+show+hide 模式下的新方案</h4><p>虽然我们实现了Androidx 包下 ViewPager下的懒加载，但是我们仍然要考虑 add+show+hide 模式下的 Fragment 懒加载的情况，基于 ViewPager 在 <code>setPrimaryItem</code> 方法中的思路，我们可以在调用 add+show+hide 时，这样处理：</p>
<blockquote>
<p>完整的代码请点击—&gt;<a href="https://github.com/AndyJennifer/AndroidxLazyLoad/blob/master/app/src/main/java/com/jennifer/andy/androidxlazyload/ext/ShowHideExt.kt" target="_blank" rel="noopener">ShowHideExt</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用add+show+hide模式加载fragment</span><br><span class="line"> *</span><br><span class="line"> * 默认显示位置[showPosition]的Fragment，最大Lifecycle为Lifecycle.State.RESUMED</span><br><span class="line"> * 其他隐藏的Fragment，最大Lifecycle为Lifecycle.State.STARTED</span><br><span class="line"> *</span><br><span class="line"> *@param containerViewId 容器id</span><br><span class="line"> *@param showPosition  fragments</span><br><span class="line"> *@param fragmentManager FragmentManager</span><br><span class="line"> *@param fragments  控制显示的Fragments</span><br><span class="line"> *&#x2F;</span><br><span class="line">private fun loadFragmentsTransaction(</span><br><span class="line">    @IdRes containerViewId: Int,</span><br><span class="line">    showPosition: Int,</span><br><span class="line">    fragmentManager: FragmentManager,</span><br><span class="line">    vararg fragments: Fragment</span><br><span class="line">) &#123;</span><br><span class="line">    if (fragments.isNotEmpty()) &#123;</span><br><span class="line">        fragmentManager.beginTransaction().apply &#123;</span><br><span class="line">            for (index in fragments.indices) &#123;</span><br><span class="line">                val fragment &#x3D; fragments[index]</span><br><span class="line">                add(containerViewId, fragment, fragment.javaClass.name)</span><br><span class="line">                if (showPosition &#x3D;&#x3D; index) &#123;</span><br><span class="line">                    setMaxLifecycle(fragment, Lifecycle.State.RESUMED)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    hide(fragment)</span><br><span class="line">                    setMaxLifecycle(fragment, Lifecycle.State.STARTED)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;.commit()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw IllegalStateException(</span><br><span class="line">            &quot;fragments must not empty&quot;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 显示需要显示的Fragment[showFragment]，并设置其最大Lifecycle为Lifecycle.State.RESUMED。</span><br><span class="line"> *  同时隐藏其他Fragment,并设置最大Lifecycle为Lifecycle.State.STARTED</span><br><span class="line"> * @param fragmentManager</span><br><span class="line"> * @param showFragment</span><br><span class="line"> *&#x2F;</span><br><span class="line">private fun showHideFragmentTransaction(fragmentManager: FragmentManager, showFragment: Fragment) &#123;</span><br><span class="line">    fragmentManager.beginTransaction().apply &#123;</span><br><span class="line">        show(showFragment)</span><br><span class="line">        setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取其中所有的fragment,其他的fragment进行隐藏</span><br><span class="line">        val fragments &#x3D; fragmentManager.fragments</span><br><span class="line">        for (fragment in fragments) &#123;</span><br><span class="line">            if (fragment !&#x3D; showFragment) &#123;</span><br><span class="line">                hide(fragment)</span><br><span class="line">                setMaxLifecycle(fragment, Lifecycle.State.STARTED)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的实现也非常简单：</p>
<ul>
<li>将需要显示的 Fragment ，在调用 add 或 show 方法后，<code>setMaxLifecycle(showFragment, Lifecycle.State.RESUMED)</code></li>
<li>将需要隐藏的 Fragment ，在调用 hide 方法后，<code>setMaxLifecycle(fragment, Lifecycle.State.STARTED)</code></li>
</ul>
<p>结合上述操作模式，查看使用 setMaxLifecycle 后，Fragment 生命周期函数调用的情况。</p>
<p>add Fragment_1、Fragment_2、Fragment_3，并 hide Fragment_2,Fragment_3 :</p>
<p>show Fragment_2，hide 其他 Fragment:</p>
<p>show Fragment_3 hide 其他 Fragment:</p>
<p>不知道是否是谷歌大大没有考虑到 Fragment 嵌套的情况，所以这里我们要对之前的方案就行修改，也就是如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class LazyFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    private var isLoaded &#x3D; false</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        &#x2F;&#x2F;增加了Fragment是否可见的判断</span><br><span class="line">        if (!isLoaded &amp;&amp; !isHidden) &#123;</span><br><span class="line">            lazyInit()</span><br><span class="line">            Log.d(TAG, &quot;lazyInit:!!!!!!!&quot;)</span><br><span class="line">            isLoaded &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroyView() &#123;</span><br><span class="line">        super.onDestroyView()</span><br><span class="line">        isLoaded &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun lazyInit()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，因为同级的 Fragment 在嵌套模式下，仍然要调用 onResume 方法，所以我们增加了 Fragment 可见性的判断，这样就能保证嵌套模式下，新方案也能完美的支持 Fragment 的懒加载。</p>
<h5 id="ViewPager2-的处理方案"><a href="#ViewPager2-的处理方案" class="headerlink" title="ViewPager2 的处理方案"></a>ViewPager2 的处理方案</h5><p>ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法。关于 ViewPager2 的内部机制。感兴趣的小伙伴可以自行查看源码。</p>
<p>关于 ViewPager2 的懒加载测试，已上传至 <a href="https://github.com/AndyJennifer/AndroidxLazyLoad" target="_blank" rel="noopener">AndroidxLazyLoad</a>，大家可以结合项目查看Log日志。</p>
<h3 id="两种方式的对比与总结"><a href="#两种方式的对比与总结" class="headerlink" title="两种方式的对比与总结"></a>两种方式的对比与总结</h3><h4 id="老一套的懒加载"><a href="#老一套的懒加载" class="headerlink" title="老一套的懒加载"></a>老一套的懒加载</h4><ul>
<li>优点：不用去控制 FragmentManager的 add+show+hide 方法，所有的懒加载都是在Fragment 内部控制，也就是控制 <code>setUserVisibleHint + onHiddenChanged</code> 这两个函数。</li>
<li>缺点：实际不可见的 Fragment，其 <code>onResume</code> 方法任然会被调用，这种反常规的逻辑，无法容忍。</li>
</ul>
<h4 id="新一套的懒加载（Androidx下setMaxLifecycle）"><a href="#新一套的懒加载（Androidx下setMaxLifecycle）" class="headerlink" title="新一套的懒加载（Androidx下setMaxLifecycle）"></a>新一套的懒加载（Androidx下setMaxLifecycle）</h4><ul>
<li>优点：<code>在非特殊的情况下(缺点1)</code>，只有实际的可见 Fragment，其 <code>onResume</code> 方法才会被调用，这样才符合方法设计的初衷。</li>
<li>缺点：<ol>
<li>对于 Fragment 的嵌套，及时使用了 <code>setMaxLifecycle</code> 方法。同级不可见的Fragment， 仍然要调用 <code>onResume</code> 方法。</li>
<li>需要在原有的 add+show+hide 方法中，继续调用 setMaxLifecycle 方法来控制Fragment 的最大生命状态。</li>
</ol>
</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这两种方案的优缺点已经非常明显了，到底该选择何种懒加载模式，还是要基于大家的意愿，作者我更倾向于使用新的方案。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/14/DayNight/">暗黑模式适配</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-14</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/14/DayNight/" data-flag-title="暗黑模式适配"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h1><p>在 Android 10 里，Dark theme 暗黑模式得到了系统级的支持。 暗黑模式不仅酷炫，而且有降低屏幕耗电、在光线较暗的环境中使用更舒适等好处。 今天带大家看一下如何适配暗黑模式，本文会从以下几点进行介绍：</p>
<ul>
<li>动态开启暗黑模式</li>
<li>使用 DayNight 适配暗黑模式</li>
<li>使用 Force Dark 适配暗黑模式</li>
<li>Force Dark 系统源码解析</li>
<li>适配流程建议</li>
</ul>
<p>相信本文会让你对暗黑模式有一个更全面的了解。</p>
<h1 id="动态开启"><a href="#动态开启" class="headerlink" title="动态开启"></a>动态开启</h1><p>在 Android 10 系统设置里增加了暗黑模式的开关，但除了系统设置，我们也可以自己动态开启。 假如我们项目里面有一个按钮用来开关暗黑模式，可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnClickListener &#123;</span><br><span class="line">    if (AppCompatDelegate.getDefaultNightMode() &#x3D;&#x3D; AppCompatDelegate.MODE_NIGHT_YES) &#123;</span><br><span class="line">        &#x2F;&#x2F; 关闭暗黑模式</span><br><span class="line">        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 开启暗黑模式</span><br><span class="line">        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前开启了暗黑模式就关掉，反之开启。 你可能还看过另一种 delegate.localNightMode 的写法，同样也是可以生效的，它们的区别在于作用范围不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 作用于当前项目的所有组件</span><br><span class="line">AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES) </span><br><span class="line">&#x2F;&#x2F; 只作用于当前组件</span><br><span class="line">delegate.localNightMode &#x3D; AppCompatDelegate.MODE_NIGHT_YES</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，在默认情况下，设置暗黑模式会重走 Activity 生命周期，需要重新渲染整个页面，所以不要在 onCreate 里直接设置。 如果不想重走生命周期，可以给 Activity 配置 android:configChanges=”uiMode”，但这样一来就需要在 onConfigurationChanged() 方法里进行手动适配。</p>
<h2 id="NightMode"><a href="#NightMode" class="headerlink" title="NightMode"></a>NightMode</h2><p>上面用到了 YES 和 NO 两种暗黑的状态，但其实还不止这两种，暗黑模式一共有这几种状态：</p>
<ul>
<li>MODE_NIGHT_FOLLOW_SYSTEM 跟随系统设置</li>
<li>MODE_NIGHT_NO 关闭暗黑模式</li>
<li>MODE_NIGHT_YES 开启暗黑模式</li>
<li>MODE_NIGHT_AUTO_BATTERY 系统进入省电模式时，开启暗黑模式</li>
<li>MODE_NIGHT_UNSPECIFIED 未指定，默认值</li>
</ul>
<p>由于很多定制系统对省电模式进行了魔改，所以使用 MODE_NIGHT_AUTO_BATTERY 不一定会生效。 另外，当 DefaultNightMode 和 LocalNightMode 都是默认值 MODE_NIGHT_UNSPECIFIED 的时候，会作 MODE_NIGHT_FOLLOW_SYSTEM 跟随系统处理。</p>
<h1 id="DayNight"><a href="#DayNight" class="headerlink" title="DayNight"></a>DayNight</h1><p>下面要开始对暗黑模式进行适配啦。我们使用 Android Studio 的 Basic Activity 模板创建一个项目，对它进行暗黑模式适配的改造。</p>
<h2 id="DayNight-主题适配"><a href="#DayNight-主题适配" class="headerlink" title="DayNight 主题适配"></a>DayNight 主题适配</h2><p>第一步，找到当前项目使用的主题，将默认使用的 Theme.AppCompat.Light 主题修改为 Theme.AppCompat.DayNight：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name&#x3D;&quot;AppTheme&quot; parent&#x3D;&quot;Theme.AppCompat.DayNight&quot;&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;colorPrimary&quot;&gt;@color&#x2F;colorPrimary&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;colorPrimaryDark&quot;&gt;@color&#x2F;colorPrimaryDark&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;colorAccent&quot;&gt;@color&#x2F;colorAccent&lt;&#x2F;item&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>第二步，没有第二步了，现在这个项目已经支持暗黑模式了，开启暗黑模式就能看到效果：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd485a20f96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>是不是很简单，但直觉告诉我们肯定没有这么简单。</p>
<h2 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h2><p>我们进入 MainActivity 的布局文件 activity_main，可以发现这里面是完全没有使用硬编码的。 什么叫硬编码？就是我们平时所说的「写死」。要是我们写死了一个色值，暗黑模式还能生效吗？ 马上试一下，我们给根布局写死一个白色背景 android:background=”#FFFFFF”，切换暗黑模式就变成了这样：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd487a61d7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>可以看到，在写死色值的情况下暗黑模式就失效了。下面看看对于自定义的色值，要如何适配。</p>
<h2 id="value-night"><a href="#value-night" class="headerlink" title="value-night"></a>value-night</h2><p>在 colors.xml 里添加一个配置颜色，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;color name&#x3D;&quot;color_bg&quot;&gt;#FFFFFF&lt;&#x2F;color&gt;</span><br></pre></td></tr></table></figure>

<p>这个是在普通模式下使用的色值，为了适配暗黑模式，还需要一个在暗黑模式下对应的色值。 新建 values-night 目录，并把对应色值配置到这个目录下的 colors.xml 文件。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd487e14870?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>将根布局的背景颜色修改为 color_bg，这样就能使用我们自己想要的颜色进行适配了：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd48cca9fad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>在暗黑模式下，系统会优先从 night 后缀的目录下找到对应的资源配置。 以上就是使用 DayNight 主题进行暗黑模式适配的全部内容了。</p>
<h2 id="DayNight-弊端"><a href="#DayNight-弊端" class="headerlink" title="DayNight 弊端"></a>DayNight 弊端</h2><p>一些关于 Android 10 暗黑模式适配的文章到这里就结束了，但其实 DayNight 主题并不是 Android 10 新增的东西，它早在 Android 6.0 就已经出现。虽然它涉及的内容不多，但大家可能也发现了，在实际项目中它的可操作性并不高。 首先，使用这种适配方式，要求我们整个项目所有的色值都不能使用硬编码，要做到这一点已经很不容易了，很多项目连统一的设计规范都很难做到。再退一步讲，就算我们所有色值都是使用 xml 配置的，但 colors.xml 里配置了成百上千个色值，我们需要对所有这些色值配置一个对应的暗黑色值，并且要确保它们在暗黑模式下能比较美观的展示。 所以，除非项目本身已经有一套严格的设计规范并且严格执行了，否则使用 DayNight 主题适配暗黑模式基本是不具有可操作性的。 Android 10 新增的当然不只是一个暗黑模式的开关而已，下面我们看一下 Android 10 有什么新特性供我们适配。</p>
<h1 id="Force-Dark"><a href="#Force-Dark" class="headerlink" title="Force Dark"></a>Force Dark</h1><p>其实我们的需求很明确，就是使用了硬编码也能被适配成暗黑模式。Android 10 新增的 Force Dark 强制暗黑就实现了这个功能。</p>
<h2 id="forceDarkAllowed"><a href="#forceDarkAllowed" class="headerlink" title="forceDarkAllowed"></a>forceDarkAllowed</h2><p>还是回到刚才的项目，把背景写死白色，再次来到 styles.xml 的主题配置。这次我们不用 DayNight 主题了，把配置改成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name&#x3D;&quot;AppTheme&quot; parent&#x3D;&quot;Theme.AppCompat.Light&quot;&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;colorPrimary&quot;&gt;@color&#x2F;colorPrimary&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;colorPrimaryDark&quot;&gt;@color&#x2F;colorPrimaryDark&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;colorAccent&quot;&gt;@color&#x2F;colorAccent&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:forceDarkAllowed&quot;&gt;true&lt;&#x2F;item&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>我们把主题换回 Light 亮色主题，至于为什么要用 Light 后面源码部分还会再讲到 另外，重点来了，这里还增加了一个 forceDarkAllowed 的配置，这是 compileSdkVersion 升级到 29 新增的配置，按字面意思就是「开启强制暗黑」。 这样就已经完成配置了，在 Android 10 的机器上运行一下，切换暗黑模式，记住这次的背景是写死白色的：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd48e65b69c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>背景被强制转换成黑色了，细心的还会发现，右下角按钮的背景颜色也变深了。 Force Dark 这么暴力，连我们写死的色值都改了，虽然方便，但这也给我们一种不安全感。 要是 Force Dark 适配出来的颜色不是我们想要的怎么办？我们还能自定义暗黑色值吗？也是可以的。</p>
<h2 id="Force-Dark-自定义适配"><a href="#Force-Dark-自定义适配" class="headerlink" title="Force Dark 自定义适配"></a>Force Dark 自定义适配</h2><p>除了主题新增了 forceDarkAllowed 这个配置，View 里面也有。 如果某个 View 的需要使用自定义色值适配暗黑模式，我们需要对这个 View 添加这个配置，让 Force Dark 排除它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:forceDarkAllowed&#x3D;&quot;false&quot;</span><br></pre></td></tr></table></figure>

<p>然后在代码里根据当前是否处于暗黑模式，对色值进行动态设置。 对于 View 的 forceDarkAllowed，有几点需要注意：</p>
<ul>
<li>在 View 中使用这个配置的前提是，当前主题开启了 Force Dark</li>
<li>默认值是 true，所以设为 true 和不设是一样的</li>
<li>作用范围是当前 View 以及它所有的子 View</li>
</ul>
<p>综上可以看出，其实目前并没有很好的 Force Dark 自定义方案。好在 Force Dark 的整体效果没什么大问题，就算要自定义，我们也尽量只对子 View 进行自定义。</p>
<h1 id="Force-Dark-源码解析"><a href="#Force-Dark-源码解析" class="headerlink" title="Force Dark 源码解析"></a>Force Dark 源码解析</h1><p>下面我们看一下源码，看看系统在暗黑模式下是如何对颜色进行转换的。 这里仅展示几个关键源码片段，它们之间是如何调用的就不赘述啦。</p>
<h2 id="updateForceDarkMode"><a href="#updateForceDarkMode" class="headerlink" title="updateForceDarkMode"></a>updateForceDarkMode</h2><p>看源码首先我们要找到入口，入口就是主题的 forceDarkAllowed 配置，搜索一下可以发现这个配置会在 ViewRootImpl 被用到。 相关的说明已经用注释写在代码里了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.view.ViewRootImpl.java</span><br><span class="line"></span><br><span class="line">private void updateForceDarkMode() &#123;</span><br><span class="line">    if (mAttachInfo.mThreadedRenderer &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断当前是否处于暗黑模式</span><br><span class="line">    boolean useAutoDark &#x3D; getNightMode() &#x3D;&#x3D; Configuration.UI_MODE_NIGHT_YES;</span><br><span class="line"></span><br><span class="line">    if (useAutoDark) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个是被用来作为默认值用的，这里先不管它，我们后面还会讲到。</span><br><span class="line">        boolean forceDarkAllowedDefault &#x3D; SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false);</span><br><span class="line">        TypedArray a &#x3D; mContext.obtainStyledAttributes(R.styleable.Theme);</span><br><span class="line">        &#x2F;&#x2F; 判断当前是否为 Light 主题，这也是为什么我们前面要使用 Light 主题。这也很好理解，只有当前主题是亮色的时候，才需要进行暗黑的处理。</span><br><span class="line">        &#x2F;&#x2F; 判断当前是否允许开启强制暗黑，我们就是靠它找到这个地方的。</span><br><span class="line">        useAutoDark &#x3D; a.getBoolean(R.styleable.Theme_isLightTheme, true)</span><br><span class="line">                &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault);</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mAttachInfo.mThreadedRenderer.setForceDark(useAutoDark)) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Don&#39;t require regenerating all display lists to apply this setting</span><br><span class="line">        invalidateWorld(mView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，根据这个方法我们可以知道，Force Dark 生效有三个条件：</p>
<ul>
<li>处于暗黑模式</li>
<li>使用了 Light 亮色主题</li>
<li>允许使用 Force Dark</li>
</ul>
<p>源码再跟下去，发现调用了 Native 代码。</p>
<h2 id="handleForceDark"><a href="#handleForceDark" class="headerlink" title="handleForceDark"></a>handleForceDark</h2><p>下一个关键代码是 RenderNode 的 handleForceDark 函数。RenderNode 是绘制节点，一个 View 可以有多个绘制节点，比如一个 TextView 的文字部分是一个绘制节点，它设置的背景也是一个绘制节点。看一下这个函数做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;RenderNode.cpp</span><br><span class="line"></span><br><span class="line">void RenderNode::handleForceDark(android::uirenderer::TreeInfo *info) &#123;</span><br><span class="line">    if (CC_LIKELY(!info || info-&gt;disableForceDark)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 这个函数看似有点复杂，但其实我们只需要关注 usage 这个参数。</span><br><span class="line">    &#x2F;&#x2F; usage 有两个取值，Foreground 前景和 Background 背景。</span><br><span class="line">    auto usage &#x3D; usageHint();</span><br><span class="line">    const auto&amp; children &#x3D; mDisplayList-&gt;mChildNodes;</span><br><span class="line">    if (mDisplayList-&gt;hasText()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前节点 hasText() 含有文字，那它就是一个 Foreground 前景</span><br><span class="line">        usage &#x3D; UsageHint::Foreground;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 下面的判断都是设为 Background 背景</span><br><span class="line">    if (usage &#x3D;&#x3D; UsageHint::Unknown) &#123;</span><br><span class="line">        if (children.size() &gt; 1) &#123;</span><br><span class="line">            usage &#x3D; UsageHint::Background;</span><br><span class="line">        &#125; else if (children.size() &#x3D;&#x3D; 1 &amp;&amp;</span><br><span class="line">                children.front().getRenderNode()-&gt;usageHint() !&#x3D;</span><br><span class="line">                        UsageHint::Background) &#123;</span><br><span class="line">            usage &#x3D; UsageHint::Background;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (children.size() &gt; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Crude overlap check</span><br><span class="line">        SkRect drawn &#x3D; SkRect::MakeEmpty();</span><br><span class="line">        for (auto iter &#x3D; children.rbegin(); iter !&#x3D; children.rend(); ++iter) &#123;</span><br><span class="line">            const auto&amp; child &#x3D; iter-&gt;getRenderNode();</span><br><span class="line">            &#x2F;&#x2F; We use stagingProperties here because we haven&#39;t yet sync&#39;d the children</span><br><span class="line">            SkRect bounds &#x3D; SkRect::MakeXYWH(child-&gt;stagingProperties().getX(), child-&gt;stagingProperties().getY(),</span><br><span class="line">                    child-&gt;stagingProperties().getWidth(), child-&gt;stagingProperties().getHeight());</span><br><span class="line">            if (bounds.contains(drawn)) &#123;</span><br><span class="line">                &#x2F;&#x2F; This contains everything drawn after it, so make it a background</span><br><span class="line">                child-&gt;setUsageHint(UsageHint::Background);</span><br><span class="line">            &#125;</span><br><span class="line">            drawn.join(bounds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 根据分类，如果是背景会被设为 Dark 深色，否则是 Light 亮色。</span><br><span class="line">    mDisplayList-&gt;mDisplayList.applyColorTransform(</span><br><span class="line">            usage &#x3D;&#x3D; UsageHint::Background ? ColorTransform::Dark : ColorTransform::Light);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数做的就是对当前绘制节点进行 Foreground 还是 Background 的分类。 为了保证文字的可视度，需要保证一定的对比度，在背景切换成深色的情况下，需要把文字部分切换成亮色。</p>
<h2 id="transformColor"><a href="#transformColor" class="headerlink" title="transformColor"></a>transformColor</h2><p>根据分好的颜色类型，会进入 CanvasTransform 对颜色进行转换处理。这里也是 Force Dark 最核心的地方了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;CanvasTransform.cpp</span><br><span class="line"></span><br><span class="line">static SkColor transformColor(ColorTransform transform, SkColor color) &#123;</span><br><span class="line">    switch (transform) &#123;</span><br><span class="line">        case ColorTransform::Light:</span><br><span class="line">            &#x2F;&#x2F; 转换为亮色</span><br><span class="line">            return makeLight(color);</span><br><span class="line">        case ColorTransform::Dark:</span><br><span class="line">            &#x2F;&#x2F; 转换为暗色</span><br><span class="line">            return makeDark(color);</span><br><span class="line">        default:</span><br><span class="line">            return color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据类型调用了对应的函数转换颜色，我们看一下 makeDark 吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static SkColor makeDark(SkColor color) &#123;</span><br><span class="line">    Lab lab &#x3D; sRGBToLab(color);</span><br><span class="line">    float invertedL &#x3D; std::min(110 - lab.L, 100.0f);</span><br><span class="line">    if (invertedL &lt; lab.L) &#123;</span><br><span class="line">        lab.L &#x3D; invertedL;</span><br><span class="line">        return LabToSRGB(lab, SkColorGetA(color));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把 RGB 色值转换成了 Lab 的格式。 Lab 格式含有 L、a、b 三个参数，ab 对应色彩学上的两个维度，不用管它，我们要关注的是里面的 L。 L 就是亮度，它的取值范围是 0 - 100，数值越小颜色就越暗，反之就越亮。这篇文章封面的安卓机器人右边颜色就是降低亮度后的效果。 回到代码来，这里用 110 减去当前亮度，可以说是对亮度做了取反。至于为什么是用 110 而不是用 100，我猜测是为了避免使用纯黑色。 在官方<a href="https://material.io/design/color/dark-theme.html#properties" target="_blank" rel="noopener">暗黑模式设计规范</a>可以看到，建议使用深灰色作为背景，而不是用纯黑色。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd4abaea406?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>最后比对取反的色值和原色值的亮度，将较暗的那个色值返回。 makeLight 函数也是类似的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static SkColor makeLight(SkColor color) &#123;</span><br><span class="line">    Lab lab &#x3D; sRGBToLab(color);</span><br><span class="line">    float invertedL &#x3D; std::min(110 - lab.L, 100.0f);</span><br><span class="line">    if (invertedL &gt; lab.L) &#123;</span><br><span class="line">        lab.L &#x3D; invertedL;</span><br><span class="line">        return LabToSRGB(lab, SkColorGetA(color));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以到这里我们发现，其实 Force Dark 强制暗黑转换颜色的规则，或者说是它的本质，就是<strong>亮度取反</strong>。</p>
<h1 id="适配流程建议"><a href="#适配流程建议" class="headerlink" title="适配流程建议"></a>适配流程建议</h1><p>如果你的项目 compileSdkVersion 已经升级到 29，那现在就可以开启 Force Dark 适配暗黑模式了。但很多项目要升级到 29 还有一段路要走，我们有没有办法提前适配呢？</p>
<h2 id="Debug-Force-Dark"><a href="#Debug-Force-Dark" class="headerlink" title="Debug Force Dark"></a>Debug Force Dark</h2><p>回到我们开始看源码的地方:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean forceDarkAllowedDefault &#x3D; SystemProperties.getBoolean(ThreadedRenderer.DEBUG_FORCE_DARK, false);</span><br><span class="line">TypedArray a &#x3D; mContext.obtainStyledAttributes(R.styleable.Theme);</span><br><span class="line">useAutoDark &#x3D; a.getBoolean(R.styleable.Theme_isLightTheme, true)</span><br><span class="line">        &amp;&amp; a.getBoolean(R.styleable.Theme_forceDarkAllowed, forceDarkAllowedDefault);</span><br></pre></td></tr></table></figure>

<p>当取不到 Theme_forceDarkAllowed 的时候，会取 DEBUG_FORCE_DARK 作为默认值，在哪里可以开启这个 DEBUG_FORCE_DARK 呢？ 在 Android 10 的开发者选项里面，可以发现多了一个这样的选项：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/5/28/1725abd4ae8d9bc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>这里的「强制启用 SmartDark 功能」就是 DEBUG_FORCE_DARK 的开关，虽然我们看了源码都知道它也没有多智能。 开启后会对所有项目生效，这样就可以提前用 Force Dark 进行适配了。</p>
<h2 id="适配流程"><a href="#适配流程" class="headerlink" title="适配流程"></a>适配流程</h2><p>开启 Force Dark 后大概率会发现一些有问题的图片资源，比如带有固定背景的 icon 等。 如果项目有适配暗黑模式的计划，个人建议可以按以下几步走：</p>
<ol>
<li>开发者选项开启「强制启用 SmartDark」</li>
<li>替换有问题的资源，进行初步适配</li>
<li>compileSdkVersion 升级到 29</li>
<li>开启 Force Dark</li>
<li>和设计师沟通，对部分控件单独适配</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 DayNight 主题可以实现暗黑模式的适配，但这种方法在实际项目中可操作性不高。 Android 10 新增的暗黑模式特性叫 Force Dark 强制暗黑，只需给主题添加一个允许开启的配置即可。 Force Dark 的实现方式是降低背景亮度，提高字体亮度，本质是对色值进行亮度取反。 最后，在 Android 10 的设备上，可以开启开发者选项中的「强制启用 SmartDark」，提前用 Force Dark 适配。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/0_kotlin/">使用Kotlin从零开始写一个现代Android</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/0_kotlin/" data-flag-title="使用Kotlin从零开始写一个现代Android"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>经常在medium.com上看到一些高质量的技术帖子，但是由于国内的上网环境或者有的同学对于看英文比较排斥，错过了不少好文章。因此，西哥决定弄一个《优质译文专栏》，花一些时间翻译一些优质技术文给大家。这篇文章是一个小系列，用Kotlin开发现代Android APP,总共四篇，后面的会陆续翻译！以下是正文。</p>
<p>现在，真的很难找到一个涵盖所有Android新技术的项目，因此我决定自己来写一个，在本文中，我们将用到如下技术：</p>
<ul>
<li>0 、Android Studio</li>
<li>1、Kotlin 语言</li>
<li>2、构建变体</li>
<li>3、ConstraintLayout</li>
<li>4、DataBinding库</li>
<li>5、MVVM+repository+Android Manager架构模式</li>
<li>6、RxJava2及其对架构的帮助</li>
<li>7、Dagger 2.11，什么是依赖注入？为什么要使用它？</li>
<li>8、Retrofit + RxJava2 实现网络请求</li>
<li>9、RooM + RxJava2 实现储存</li>
</ul>
<h5 id="我们的APP最终是什么样子？"><a href="#我们的APP最终是什么样子？" class="headerlink" title="我们的APP最终是什么样子？"></a>我们的APP最终是什么样子？</h5><p>我们的APP是一个非常简单的应用程序，它涵盖了上面提到的所有技术。只有一个简单的功能：从Github 获取<code>googlesamples</code>用户下的所有仓库，将数据储存到本地数据库，然后在界面展示它。</p>
<p>我将尝试解释更多的代码，你也可以看看你Github上的代码提交。</p>
<p>Github:<a href="https://github.com/mladenrakonjac/ModernAndroidApp/tags" target="_blank" rel="noopener">github.com/mladenrakon…</a></p>
<p>让我们开始吧。</p>
<h3 id="0、Android-Studio"><a href="#0、Android-Studio" class="headerlink" title="0、Android Studio"></a>0、Android Studio</h3><p>首先安卓Android Studio 3 beta 1(注：现在最新版为Android Studio 4.0),Android Studio 已经支持Kotlin，去到<code>Create Android Project</code>界面，你将在此处看到新的内容：带有标签的复选框<code>include Kotlin support</code>。默认情况下选中。按两次下一步，然后选择<code>EmptyActivity</code>，然后完成了。 恭喜！你用Kotlin开发了第一个Android app)</p>
<h3 id="1、Kotlin"><a href="#1、Kotlin" class="headerlink" title="1、Kotlin"></a>1、Kotlin</h3><p>在刚才新建的项目中，你可以看到一个<code>MainActivity.kt</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package me.mladenrakonjac.modernandroidapp</span><br><span class="line"></span><br><span class="line">import android.support.v7.app.AppCompatActivity</span><br><span class="line">import android.os.Bundle</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.kt</code>后缀代表了这是一个Kotlin文件</p>
<p><code>MainActivity : AppCompatActivity()</code>表示我们的<code>MainActivity</code>继承自<code>AppCompatActivity</code> 。</p>
<p>此外，所有的方法都必须有一个关键字<code>fun</code>,在Kotlin 中，你不能使用<code>@override</code>注解，如果你要表明方法是复写父类或者接口的方法的话，直接使用<code>override</code>关键字，注意：它和Java不一样，不是一个注解了。</p>
<p>然后，<code>savedInstanceState: Bundle?</code> 中的<code>?</code>代表什么呢？它代表了<code>savedInstanceState</code>这个参数可以是<code>Bundle</code>或者null。Kotlin是一门null 安全语言，如果你像下面这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a : String</span><br></pre></td></tr></table></figure>

<p>你将会得到一个编译错误。因为<code>a</code>变量必须被初始化，并且不能为null，因此你要像这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a : String &#x3D; &quot;Init value&quot;</span><br></pre></td></tr></table></figure>

<p>并且，如果你执行以下操作，也会报编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; null</span><br></pre></td></tr></table></figure>

<p>要想使<code>a</code>变量为null ,你必须这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a : String?</span><br></pre></td></tr></table></figure>

<p>为什么这是Kotlin语言的一个重要功能呢？因为它帮我们避免了NPE,Androd开发者已经对NPE感到厌倦了，甚至是null的发明者-<code>Tony Hoare</code>先生，也为发明它而道歉。假设我们有一个可以为空的<code>nameTextView</code>。如果为null，以下代码将会发生NPE：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameTextView.setEnabled(true)</span><br></pre></td></tr></table></figure>

<p>但实际上，Kotlin做得很好，它甚至不允许我们做这样的事情。它会强制我们使用<code>?</code>或者<code>!!</code>操作符。如果我们使用<code>?</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameTextView?.setEnabled(true)</span><br></pre></td></tr></table></figure>

<p>仅当<code>nameTextView</code>不为null时，这行代码才会继续执行。另一种情况下，如果我们使用<code>!!</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameTextView!!.setEnabled(true)</span><br></pre></td></tr></table></figure>

<p>如果<code>nameTextView</code>为null，它将为我们提供NPE。它只适合喜欢冒险的家伙)</p>
<p>这是对Kotlin的一些介绍。我们继续进行，我将停止描述其他Kotlin特定代码。</p>
<h3 id="2、构建变体"><a href="#2、构建变体" class="headerlink" title="2、构建变体"></a>2、构建变体</h3><p>通常，在开发中，如果你有两套环境，最常见的是测试环境和生产环境。这些环境在服务器<code>URL</code>，<code>图标</code>，<code>名称</code>，<code>目标api</code>等方面可能有所不同。通常，在开始的每个项目中我都有以下内容：</p>
<ul>
<li><code>finalProduction</code>: 上传Google Play 使用</li>
<li><code>demoProduction</code>:该版本使用生产环境服务器Url,并且它有着GP上的版本没有的新功能，用户可以在Google play 旁边安装，然后可以进行新功能测试和提供反馈。</li>
<li><code>demoTesting</code>:和demoProduction一样，只不过它用的是测试地址</li>
<li><code>mock</code>: 对于我来说，作为开发人员和设计师而言都是很有用的。有时我们已经准备好设计，而我们的API仍未准备好。等待API准备就绪后再开始开发可不是好的解决方案。此构建变体为提供有mock数据，因此设计团队可以对其进行测试并提供反馈。对于保证项目进度真的很有帮助,一旦API准备就绪，我们便将开发转移到demoTesting环境。</li>
</ul>
<p>在此应用程序中，我们将拥有所有这些变体。它们的applicationId和名称不同。 gradle 3.0.0 <code>flavourDimension</code>中有一个新的<code>api</code>，可让您混合不同的产品风味，因此您可以混合<code>demo</code>和<code>minApi23</code>风味。在我们的应用程序中，我们将仅使用“默认” 的<code>flavorDimension</code>。早app的<code>build.gradle</code>中，将此代码插入<code>android {}</code>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions &quot;default&quot;</span><br><span class="line">    </span><br><span class="line">productFlavors &#123;</span><br><span class="line"></span><br><span class="line">    finalProduction &#123;</span><br><span class="line">        dimension &quot;default&quot;</span><br><span class="line">        applicationId &quot;me.mladenrakonjac.modernandroidapp&quot;</span><br><span class="line">        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    demoProduction &#123;</span><br><span class="line">        dimension &quot;default&quot;</span><br><span class="line">        applicationId &quot;me.mladenrakonjac.modernandroidapp.demoproduction&quot;</span><br><span class="line">        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Demo P&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    demoTesting &#123;</span><br><span class="line">        dimension &quot;default&quot;</span><br><span class="line">        applicationId &quot;me.mladenrakonjac.modernandroidapp.demotesting&quot;</span><br><span class="line">        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Demo T&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mock &#123;</span><br><span class="line">        dimension &quot;default&quot;</span><br><span class="line">        applicationId &quot;me.mladenrakonjac.modernandroidapp.mock&quot;</span><br><span class="line">        resValue &quot;string&quot;, &quot;app_name&quot;, &quot;Modern App Mock&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开<code>string.xml</code>文件，删掉<code>app_name</code>string资源，因此，我们才不会发生资源冲突，然后点击<code>Sync Now</code>,如果转到屏幕左侧的<code>“构建变体”</code>，则可以看到4个不同的构建变体，其中每个都有两种构建类型：“Debug”和“Release”,切换到<code>demoProduction</code>构建变体并运行它。然后切换到另一个并运行它。您就可以看到两个名称不同的应用程序。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/9/172996a0132edd8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="3、ConstraintLayout"><a href="#3、ConstraintLayout" class="headerlink" title="3、ConstraintLayout"></a>3、ConstraintLayout</h3><p>如果你打开<code>activity_main.xml</code>,你可以看到跟布局是<code>ConstraintLayout</code>,如果你开发过iOS应用程序，你可能知道<code>AutoLayout</code>，<code>ConstraintLayout</code>和它非常的相似，他们甚至用了相同的<code>Cassowary</code>算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>Constraints可以帮我们描述View之间的关系。对于每一个View来说，应该有4个约束，每一边一个约束，在这种情况下，我们的View就被约束在了父视图的每一边了。</p>
<p>在Design Tab中，如果你将<code>Hello World</code>文本稍微向上移动，则在<code>Text</code>Tab中将增加下面这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintVertical_bias&#x3D;&quot;0.28&quot;</span><br></pre></td></tr></table></figure>



<p><img src="http://user-gold-cdn.xitu.io/2020/6/9/17299720fee769d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><code>Design</code> tab 和 <code>Text</code> tab是同步的，我们在Design中移动视图，则会影响Text中的<code>xml</code>，反之亦然。垂直偏差描述了视图对其约束的垂直趋势。如果要使视图垂直居中，则应使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintVertical_bias&#x3D;&quot;0.28&quot;</span><br></pre></td></tr></table></figure>

<p>我们让<code>Activity</code>只显示一个仓库，它有仓库的名字，star的数量，作者，并且还会显示是否有issue</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/9/1729977d7debb137?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>要得到上面的布局设计，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:textSize&#x3D;&quot;20sp&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintHorizontal_bias&#x3D;&quot;0.0&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.083&quot;</span><br><span class="line">        tools:text&#x3D;&quot;Modern Android app&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;repository_has_issues&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginTop&#x3D;&quot;8dp&quot;</span><br><span class="line">        android:text&#x3D;&quot;@string&#x2F;has_issues&quot;</span><br><span class="line">        android:textStyle&#x3D;&quot;bold&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintHorizontal_bias&#x3D;&quot;1.0&quot;</span><br><span class="line">        app:layout_constraintStart_toEndOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;1.0&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;repository_owner&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginBottom&#x3D;&quot;8dp&quot;</span><br><span class="line">        android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginTop&#x3D;&quot;8dp&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.0&quot;</span><br><span class="line">        tools:text&#x3D;&quot;Mladen Rakonjac&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;number_of_starts&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginBottom&#x3D;&quot;8dp&quot;</span><br><span class="line">        android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">        android:layout_marginTop&#x3D;&quot;8dp&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintHorizontal_bias&#x3D;&quot;1&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;repository_owner&quot;</span><br><span class="line">        app:layout_constraintVertical_bias&#x3D;&quot;0.0&quot;</span><br><span class="line">        tools:text&#x3D;&quot;0 stars&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<p>不要被<code>tools:text</code>搞迷惑了，它的作用仅仅是让我们可以预览我们的布局。</p>
<p>我们可以注意到，我们的布局是扁平的，没有任何嵌套，你应该尽量少的使用布局嵌套，因为它会影响我们的性能。ConstraintLayout也可以在不同的屏幕尺寸下正常工作。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/9/172997c1dd00ddd1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>我有种预感，很快就能达到我们想要的布局效果了。</p>
<p>上面只是一些关于<code>ConstraintLayout</code>的少部分介绍，你也可以看一下关于<code>ConstraintLayout</code>使用的google code lab: <a href="https://codelabs.developers.google.com/codelabs/constraint-layout/index.html?index=..%2F..%2Findex#0" target="_blank" rel="noopener">codelabs.developers.google.com/codelabs/co…</a></p>
<h3 id="4-Data-binding-library"><a href="#4-Data-binding-library" class="headerlink" title="4. Data binding library"></a>4. Data binding library</h3><p>当我听到Data binding 库的时候，我的第一反应是：Butterknife已经很好了，再加上，我现在使用一个插件来从xml中获取View,我为啥要改变，来使用Data binding呢？但当我对Data binding有了更多的了解之后，我的它的感觉就像我第一次见到Butterknife一样，无法自拔。</p>
<h5 id="Butterknife能帮我们做啥？"><a href="#Butterknife能帮我们做啥？" class="headerlink" title="Butterknife能帮我们做啥？"></a>Butterknife能帮我们做啥？</h5><p>ButterKnife帮助我们摆脱无聊的<code>findViewById</code>。因此，如果您有5个视图，而没有Butterknife，则你有5 + 5行代码来绑定您的视图。使用ButterKnife，您只有我行代码就搞定。就是这样。</p>
<h5 id="Butterknife的缺点是什么？"><a href="#Butterknife的缺点是什么？" class="headerlink" title="Butterknife的缺点是什么？"></a>Butterknife的缺点是什么？</h5><p>Butterknife仍然没有解决代码可维护问题，使用ButterKnife时，我经常发现自己遇到运行时异常，这是因为我删除了xml中的视图，而没有删除Activity/Fragment类中的绑定代码。另外，如果要在xml中添加视图，则必须再次进行绑定。真的很不好维护。你将浪费大量时间来维护View绑定。</p>
<h5 id="那与之相比，Data-Binding-怎么样呢？"><a href="#那与之相比，Data-Binding-怎么样呢？" class="headerlink" title="那与之相比，Data Binding 怎么样呢？"></a>那与之相比，Data Binding 怎么样呢？</h5><p>有很多好处，使用Data Binding，你可以只用一行代码就搞定View的绑定，让我们看看它是如何工作的，首先，先将Data Binding 添加到项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; at the top of file </span><br><span class="line">apply plugin: &#39;kotlin-kapt&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    &#x2F;&#x2F;other things that we already used</span><br><span class="line">    dataBinding.enabled &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    &#x2F;&#x2F;other dependencies that we used</span><br><span class="line">    kapt &quot;com.android.databinding:compiler:3.0.0-beta1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，数据绑定编译器的版本与项目<code>build.gradle</code>文件中的gradle版本相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath &#39;com.android.tools.build:gradle:3.0.0-beta1&#39;</span><br></pre></td></tr></table></figure>

<p>然后，点击<code>Sync Now</code>,打开<code>activity_main.xml</code>,将<code>Constraint Layout</code>用layout标签包裹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.constraint.ConstraintLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">        tools:context&#x3D;&quot;me.mladenrakonjac.modernandroidapp.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:textSize&#x3D;&quot;20sp&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintHorizontal_bias&#x3D;&quot;0.0&quot;</span><br><span class="line">            app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintVertical_bias&#x3D;&quot;0.083&quot;</span><br><span class="line">            tools:text&#x3D;&quot;Modern Android app&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;repository_has_issues&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;8dp&quot;</span><br><span class="line">            android:text&#x3D;&quot;@string&#x2F;has_issues&quot;</span><br><span class="line">            android:textStyle&#x3D;&quot;bold&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintHorizontal_bias&#x3D;&quot;1.0&quot;</span><br><span class="line">            app:layout_constraintStart_toEndOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">            app:layout_constraintVertical_bias&#x3D;&quot;1.0&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;repository_owner&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;8dp&quot;</span><br><span class="line">            android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;8dp&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;repository_name&quot;</span><br><span class="line">            app:layout_constraintVertical_bias&#x3D;&quot;0.0&quot;</span><br><span class="line">            tools:text&#x3D;&quot;Mladen Rakonjac&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;number_of_starts&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;8dp&quot;</span><br><span class="line">            android:layout_marginEnd&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginStart&#x3D;&quot;16dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;8dp&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintHorizontal_bias&#x3D;&quot;1&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf&#x3D;&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf&#x3D;&quot;@+id&#x2F;repository_owner&quot;</span><br><span class="line">            app:layout_constraintVertical_bias&#x3D;&quot;0.0&quot;</span><br><span class="line">            tools:text&#x3D;&quot;0 stars&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;android.support.constraint.ConstraintLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;layout&gt;</span><br></pre></td></tr></table></figure>

<p>注意，你需要将所有的xml移动到layout 标签下面，然后点击<code>Build</code>图标或者使用快捷键<code>Cmd + F9</code>,我们需要构建项目来使Data Binding库为我们生成<code>ActivityMainBinding</code>类，后面在MainActivity中将用到它。</p>
<p>如果没有重新编译项目，你是看不到<code>ActivityMainBinding</code>的，因为它在编译时生成。</p>
<p>我们还没有完成绑定，我们只是定义了一个非空的 ActivityMainBinding 类型的变量。你会注意到我没有把<code>?</code> 放在 ActivityMainBinding 的后面，而且也没有初始化它。这怎么可能呢？<code>lateinit</code> 关键字允许我们使用非空的延迟被初始化的变量。和 ButterKnife 类似，在我们的布局准备完成后，初始化绑定需要在 onCreate 方法中进行。此外，你不应该在 onCreate 方法中声明绑定，因为你很有可能在 onCreate 方法外使用它。我们的 binding 不能为空，所以这就是我们使用 lateinit 的原因。使用 lateinit 修饰，我们不需要在每次访问它的时候检查 binding 变量是否为空。</p>
<p>我们初始化binding变量，你需要替换:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(R.layout.activity_main)</span><br></pre></td></tr></table></figure>

<p>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding &#x3D; DataBindingUtil.setContentView(this, R.layout.activity_main)</span><br></pre></td></tr></table></figure>

<p>就是这样，你成功的绑定了所有View,现在你可以访问它并且做一些更改，例如，我们将仓库名字改为<code>Modern Android Medium Article</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding.repositoryName.text &#x3D; &quot;Modern Android Medium Article&quot;</span><br></pre></td></tr></table></figure>

<p>如你所见，现在我们可以通过<code>bingding</code>变量来访问<code>main_activity.xml</code>的所有View了（前提是它们有id）,这就是Data Binding 比ButterKnife 好用的原因。</p>
<h5 id="kotlin的-Getters-和-setters"><a href="#kotlin的-Getters-和-setters" class="headerlink" title="kotlin的 Getters 和 setters"></a>kotlin的 Getters 和 setters</h5><p>大概，你已经注意到了，我们没有像Java那样使用<code>.setText()</code>，我想在这里暂停一下，以说明与Java相比，Kotlin中的getter和setter方法如何工作的。</p>
<p>首先，你需要知道，我们为什么要使用getters和setters，我们用它来隐藏类中的变量，仅允许使用方法来访问这些变量，这样我们就可以向用户隐藏类中的细节，并禁止用户直接修改我们的类。假设我们用 Java 写了一个 Square 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Square &#123;</span><br><span class="line">  private int a;</span><br><span class="line">  </span><br><span class="line">  Square()&#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setA(int a)&#123;</span><br><span class="line">    this.a &#x3D; Math.abs(a);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int getA()&#123;</span><br><span class="line">    return this.a;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>setA()</code>方法，我们禁止了用户向<code>Square</code>类的<code>a</code>变量设置一个负数,因为正方形的边长一定是正数，要使用这种方法，我们必须将其设为私有，因此不能直接设置它。这也意味着我们不能直接获得<code>a</code>，需要给它定一个get方法来返回<code>a</code>，如果有10个变量，那么我们就得定义10个相似的get方法，写这样无聊的样板代码，通常会影响我们的心情。</p>
<p>Kotling使我们的开发人员更轻松了。如果你调用下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var side: Int &#x3D; square.a</span><br></pre></td></tr></table></figure>

<p>这并不意味着你是在直接访问a变量，它和Java中调用<code>getA()</code>是相同的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int side &#x3D; square.getA();</span><br></pre></td></tr></table></figure>

<p>因为Kotlin自动生成默认的getter和setter。在Kotlin中，只有当您有特殊的setter或getter时，才应指定它。否则，Kotlin会为您自动生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1</span><br><span class="line">   set(value) &#123; field &#x3D; Math.abs(value) &#125;</span><br></pre></td></tr></table></figure>

<p><code>field</code> ? 这又是个什么东西？为了更清楚明白，请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1</span><br><span class="line">   set(value) &#123; a &#x3D; Math.abs(value) &#125;</span><br></pre></td></tr></table></figure>

<p>这表明你在调用set方法中的<code>set(value){}</code>，因为Kotlin的世界中，没有直接访问属性，这就会造成无限递归，当你调用<code>a = something</code>,会自动调用set方法。使用filed就能避免无限递归，我希望这能让你明白为什么要用filed关键字，并且了解getters和setters是如何工作的。</p>
<p>回到代码中继续，我将向你介绍Kotlin语言的另一个重要功能:apply函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    lateinit var binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        binding &#x3D; DataBindingUtil.setContentView(this, R.layout.activity_main)</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            repositoryName.text &#x3D; &quot;Medium Android Repository Article&quot;</span><br><span class="line">            repositoryOwner.text &#x3D; &quot;Mladen Rakonjac&quot;</span><br><span class="line">            numberOfStarts.text &#x3D; &quot;1000 stars&quot;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>apply 允许你在一个实例上调用多个方法，我们仍然还没有完成数据绑定，还有更棒的事儿，让我们为仓库定义一个UI模型（这个是github仓库的数据模型Repository,它持有要展示的数据，请不要和Repository模式的中的Repository搞混淆了哈），要创建一个Kotlin class，点击<code>New -&gt; Kotlin File/Class :</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Repository(var repositoryName: String?,var repositoryOwner: String?,var numberOfStars: Int? ,var hasIssues: Boolean &#x3D; false)</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，主构造函数是类头的一部分，如果你不想定义次构造函数，那就是这样了，数据类到此就完成了，构造函数没有参数分配给字段，没有setters和getters,整个类就一行代码。</p>
<p>回到<code>MainActivity.kt</code>，为<code>Repository</code>创建一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var repository &#x3D; Repository(&quot;Medium Android Repository Article&quot;,</span><br><span class="line">        &quot;Mladen Rakonjac&quot;, 1000, true)</span><br></pre></td></tr></table></figure>

<p>你应该注意到了，创建类实例，没有用<code>new</code></p>
<p>现在，我们在<code>activity_main.xml</code>中添加data标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">      &lt;variable</span><br><span class="line">        name&#x3D;&quot;repository&quot;</span><br><span class="line">        type&#x3D;&quot;me.mladenrakonjac.modernandroidapp.uimodels.Repository&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以在布局中访问存储的变量<code>repository</code>,例如，我们可以如下使用id是<code>repository_name</code>的TextView,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text&#x3D;&quot;@&#123;repository.repositoryName&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>repository_name文本视图将显示从repository变量的属性<code>repositoryName</code>获取的文本。剩下的唯一事情就是将<code>repository</code>变量从xml绑定到<code>MainActivity.kt</code>中的repository。</p>
<p>点击Build使DataBinding 为我们生成类，然后在MainActivity中添加两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.repository &#x3D; repository</span><br><span class="line">binding.executePendingBindings()</span><br></pre></td></tr></table></figure>

<p>如果你运行APP,你会看到TextView上显示的是：<code>“Medium Android Repository Article”</code>,非常棒的功能，是吧？</p>
<p>但是，如果我们像下面这样改一下呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler().postDelayed(&#123;repository.repositoryName&#x3D;&quot;New Name&quot;&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>新的文本将会在2000ms后显示吗？不会的，你必须重新设置一次<code>repository</code>,像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Handler().postDelayed(&#123;repository.repositoryName&#x3D;&quot;New Name&quot;</span><br><span class="line">    binding.repository &#x3D; repository</span><br><span class="line">    binding.executePendingBindings()&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>但是，如果我们每次更改一个属性都要这么写的话，那就非常蛋疼了，这里有一个更好的方案叫做<code>Property Observer</code>。</p>
<p>让我们首先解释一下什么是观察者模式，因为在rxJava部分中我们也将需要它：</p>
<p>可能你已经听说过<code>http://androidweekly.net/</code>,这是一个关于Android开发的周刊。如果您想接收它，则必须订阅它并提供您的电子邮件地址。过了一段时间，如果你不想看了，你可以去网站上取消订阅。</p>
<p>这就是一个<code>观察者/被观察者</code>的模式,在这个例子中， Android 周刊是<code>被观察者</code>,它每周都会发布新闻通讯。读者是<code>观察者</code>，因为他们订阅了它，一旦订阅就会收到数据，如果不想读了，则可以停止订阅。</p>
<p><code>Property Observer</code>在这个例子中就是 xml layout,它将会监听<code>Repository</code>实例的变化。因此，<code>Repository</code>是<code>被观察者</code>,例如，一旦在Repository类的实例中更改了repository nane 属性后，xml不调用下面的代码也会更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.repository &#x3D; repository</span><br><span class="line">binding.executePendingBindings()</span><br></pre></td></tr></table></figure>

<p>如何让它使用Data Binding 库呢？，Data Binding库提供了一个<code>BaseObservable</code>类，我们的Repostory类必须继承它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Repository(repositoryName : String, var repositoryOwner: String?, var numberOfStars: Int?</span><br><span class="line">                 , var hasIssues: Boolean &#x3D; false) : BaseObservable()&#123;</span><br><span class="line"></span><br><span class="line">    @get:Bindable</span><br><span class="line">    var repositoryName : String &#x3D; &quot;&quot;</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        field &#x3D; value</span><br><span class="line">        notifyPropertyChanged(BR.repositoryName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用了 Bindable 注解时，就会自动生成 BR 类。你会看到，一旦设置新值，就会通知它更新。现在运行 app 你将看到仓库的名字在 2 秒后改变而不必再次调用 <code>executePendingBindings()</code>。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/android11/">Android 11 Beta 版正式发布！以及众多面向开发者的重磅更新</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/android11/" data-flag-title="Android 11 Beta 版正式发布！以及众多面向开发者的重磅更新"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h2 id="Android-11-Beta-版现已发布"><a href="#Android-11-Beta-版现已发布" class="headerlink" title="Android 11 Beta 版现已发布"></a>Android 11 Beta 版现已发布</h2><p>自二月以来，大家通过 Android 11 开发者预览版为我们提供了众多反馈。今天发布的 Android 11 第一个 Beta 版聚焦于三个主题: <strong>以人为本</strong>、<strong>灵活控制</strong>以及<strong>隐私安全</strong>。</p>
<p><strong>以人为本</strong></p>
<p>Android 现在更突显人的要素，更善于沟通。我们重塑了您在手机上进行沟通的方式，也让操作系统能识别出那些对您来说更重要的人，让您能更快速地和他们联系。</p>
<ul>
<li><strong>会话通知</strong>会显示在通知栏顶部的专门区域，其设计更凸显联系对象，且提供了会话特定的操作，例如以 Bubbles 的形式打开聊天、在主屏幕中创建会话快捷方式，以及设置提醒。</li>
<li><strong>Bubbles</strong> 可以让用户在手机上多任务切换时依然保持对话可见及可用。消息和聊天应用可以通过基于通知的 Bubbles API，在 Android 11 上提供这种全新体验。</li>
<li><strong>键盘提示整合</strong>功能为用户带来了更便利的输入补全和提示。自动填写应用以及 IME (输入法编辑器) 可以通过这个功能在 IME 提示列表中安全地给出基于上下文的实体和字符串建议。</li>
<li><strong>Voice Access (语音操作)</strong>。对完全使用语音操作设备的用户，Android 现在提供设备集成的屏幕内容感知功能 (visual cortex)，该功能可以理解屏幕中呈现的内容及其上下文，从而为无障碍指令生成标签和操作点。</li>
</ul>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/11/172a20231667797f?imageslim" alt="img"></p>
<p><strong>灵活控制</strong></p>
<p>最新版的 Android 现在可帮您快速访问所有的智能设备，并集中控制它们:</p>
<ul>
<li><strong>Device Controls (设备控制)</strong> 让用户得以更快、更轻松地访问和控制他们连接的设备。只需长按电源按钮就可以调出设备控制菜单，一站式完成设备控制。应用也可以通过新的 API 出现在这个控制菜单中。阅读<a href="https://developer.android.google.cn/preview/features/device-control" target="_blank" rel="noopener">官方文档</a>了解更多。</li>
<li><strong>Media Controls (媒体控制)</strong> 让用户得以更快捷地切换音频和视频内容的播放设备——不论是耳机、麦克风还是电视。您现在可以在开发者选项中启用此功能，在后续的 Beta 版本中本功能会默认启用。阅读<a href="https://developer.android.google.cn/preview/features/media-controls" target="_blank" rel="noopener">官方文档</a>了解更多。</li>
</ul>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/11/172a2035dc3bf460?imageslim" alt="img"></p>
<p><strong>隐私安全</strong></p>
<p>在 Android 11 中我们为用户带来了更高的掌控能力，让他们能更好地管理敏感权限。我们还会通过更快速的系统更新来持续确保设备安全。</p>
<ul>
<li><strong>单次授权:</strong> 用户现在可以授予应用一次性的权限来访问设备的麦克风、摄像头或者位置信息。应用下次被使用时需要再次请求权限才能进行访问。阅读<a href="https://developer.android.google.cn/preview/privacy/permissions" target="_blank" rel="noopener">官方文档</a>了解更多。</li>
<li><strong>权限自动重置:</strong> 如果用户在很长一段时间里未使用某应用，Android 11 将自动重置所有与该应用关联的权限并通知用户。在用户下次使用该应用时，应用可以再次请求权限。阅读<a href="https://developer.android.google.cn/preview/privacy/permissions#auto-reset" target="_blank" rel="noopener">官方文档</a>了解更多。</li>
<li><strong>后台位置:</strong> 我们在今年二月宣布，开发者需要获得批准后才可以让应用在后台访问位置信息，从而避免该信息遭到不当使用。现在我们为开发者提供更长的时间来做出修改，在 2021 年之前我们不会强行要求既有的应用遵守本政策。阅读<a href="https://support.google.com/googleplay/android-developer/answer/9799150" target="_blank" rel="noopener">官方文档</a>了解更多。</li>
<li><strong>Google Play 系统更新</strong>自去年发布以来，让我们得以更快速地更新操作系统核心组件，并覆盖 Android 生态系统中的众多设备。在 Android 11 中，可更新的模块数量增加了一倍有余，新增的 12 个可更新模块会更有力地确保隐私和安全，以及为用户和开发者带来更好的一致性。</li>
</ul>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/11/172a205b989e4b18?imageslim" alt="img"></p>
<p><strong>开发者友好</strong></p>
<p>我们希望让开发者能更轻松地用好新版 Android。在兼容性测试方面，有这些举措来减少大家的工作量:</p>
<ul>
<li>有破坏性的行为变更 (breaking changes) 只在您针对 Android 11 发布应用时才生效。所以在您明确修改应用的清单文件之前，这些变更不会对您造成影响。</li>
<li>在开发者选项中加入了全新的界面，来让您逐一开关这些更新选项，以更好地完成测试。</li>
<li>新增了平台稳定性里程碑，在这个版本中所有的 API 和行为变更都已调整完毕并进入稳定状态，这时您可以放心地对应用做出最终更新。</li>
<li>版本发布时间表 <a href="https://developer.android.google.cn/preview/overview#timeline" target="_blank" rel="noopener">developer.android.google.cn/preview/ove…</a></li>
</ul>
<p>Android 11 还带来了其他提升开发效率的改进，比如 ADB 无线调试、能更快安装大型 APK 的 ADB Incremental (ADB 增量安装)，以及在平台 API 上加入更多的可空性注解 (从而在构建时就发现问题，不用等到运行时才出错)，等等。</p>
<p>Android 11 第一个 Beta 版本现已发布，您可以在自己的应用中体验终版 SDK 和 NDK API，以及各种全新功能。如果您使用的是 Pixel 2、3、3a 或 4 系列设备，请<a href="https://www.google.com/android/beta" target="_blank" rel="noopener">参加测试</a>并获取 Android 11 Beta 的 OTA 更新。和以往一样，您可以直接下载系统并安装至 <a href="https://developer.android.google.cn/preview/get#on_pixel" target="_blank" rel="noopener">Pixel 设备</a>以及<a href="https://developer.android.google.cn/preview/get#on_emulator" target="_blank" rel="noopener"> Android 模拟器</a>。请访问 <a href="https://developer.android.google.cn/11" target="_blank" rel="noopener">Android 11 开发者网站</a>查看完整的 Android 11 开发者功能。</p>
<h2 id="现代化-Android-开发-Modern-Android-development"><a href="#现代化-Android-开发-Modern-Android-development" class="headerlink" title="现代化 Android 开发 (Modern Android development)"></a>现代化 Android 开发 (Modern Android development)</h2><p>在过去数年中，Android 团队通过卓绝的努力持续改善移动开发者的体验，提升大家的开发效率。这些努力包括 Android Studio IDE、一种优秀的开发语言 (没错，就是 Kotlin)、让日常任务更加轻松的 Jetpack 库，以及可以更好地进行应用分发的 Android App Bundle。我们将这些努力统称为<a href="https://developer.android.google.cn/modern-android-development" target="_blank" rel="noopener">现代化 Android 开发</a> (Modern Android development)，一切都是为了让您能提升效率，从而尽情释放出 Android 的潜力。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/11/172a2082729f09a2?imageslim" alt="img"></p>
<h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p>今天，我们也通过 Android Studio 4.1 Beta 版和 4.2 Canary 版为大家带来了许多全新功能，主要聚焦于开发者们提出的这些关键诉求:</p>
<ul>
<li><strong>调试更简单</strong>，通过 ADB 无线调试功能更轻松地在 Android 设备上进行调试。我们还新增了 Database Inspector 和依赖注入 (Dagger) 工具。</li>
<li><strong>设备测试体验更佳</strong>。Android 模拟器现在直接集成在 IDE 中，您可以并排显示测试中的应用，同时查看不同设备上的运行结果。我们还改进了设备管理器，让您更轻松地管理多个设备。</li>
<li><strong>更易用的机器学习</strong>: 您现在可以将 ML Kit 和 TensorFlow Lite 模型直接导入 IDE。</li>
<li><strong>更快速的构建与部署</strong>: <a href="https://github.com/android/kotlin/tree/ksp/libraries/tools/kotlin-symbol-processing-api" target="_blank" rel="noopener">Kotlin 符号处理</a>可以将任务图缓存在 Gradle 中，使得应用部署到 Android 11 设备中的速度更快。全新的 Build Analyzer 让您可以很快找到应用构建的性能瓶颈。</li>
<li><strong>更强大的游戏工具</strong>: 改进性能分析界面，并为大家带来了全新的 System Trace 工具，以及原生内存分析功能。</li>
</ul>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/11/172a20a43d3ec10b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><a href="https://developer.android.google.cn/studio/preview" target="_blank" rel="noopener">即刻体验</a> Android Studio 4.1 Beta 版和 Android Studio 4.2 Canary 版。</p>
<h2 id="Kotlin-和-Jetpack"><a href="#Kotlin-和-Jetpack" class="headerlink" title="Kotlin 和 Jetpack"></a>Kotlin 和 Jetpack</h2><p>现代化 Android 开发中的重要环节之一就是编程语言和开发库: <a href="https://developer.android.google.cn/kotlin" target="_blank" rel="noopener">Kotlin</a> 是一种现代且简洁的编程语言，<a href="https://developer.android.google.cn/jetpack" target="_blank" rel="noopener">Jetpack</a> 则提供了颇具特色且功能强大的开发库，二者都专注于提升开发者的工作效率。</p>
<ul>
<li><strong>腾讯视频链接</strong></li>
</ul>
<p><a href="https://v.qq.com/x/page/h0980xhkr5t.html" target="_blank" rel="noopener">v.qq.com/x/page/h098…</a></p>
<ul>
<li><strong>Bilibili 视频链接</strong></li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1Xk4y1B7sT/" target="_blank" rel="noopener">www.bilibili.com/video/BV1Xk…</a></p>
<p>Kotlin 的迅速普及 (目前 Google Play 排名前 1,000 的应用中超过 70% 都使用 Kotlin) 和众多开发者的青睐，使得我们可以通过该语言以全新的方式优化开发体验。<a href="https://developer.android.google.cn/kotlin/coroutines" target="_blank" rel="noopener">Kotlin 协程</a>是 Kotlin 语言的诸多强大功能之一，它可以让您更轻松地编写并发调用，同时获得更高的可读性。现在，我们正式推荐开发者使用协程。我们还在 3 个最常用的 Jetpack 库 (<a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle</a>、<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager" target="_blank" rel="noopener">WorkManager</a> 和 <a href="https://developer.android.google.cn/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a>) 中使用了协程，以便您可以利用这些库编写更优质的代码。</p>
<p>Kotlin 自身也随着版本演进而愈发出色，这离不开 Jetbrains 团队的杰出贡献。<a href="https://kotlinlang.org/eap/" target="_blank" rel="noopener">Kotlin 1.4 </a>带来了更快的代码补全功能、更强大的类型推断 (默认启用)、各类函数接口，以及各种提升开发者体验的改进，比如可以混合使用命名参数和定位参数。</p>
<p>我们也在持续推动 Jetpack 的演进，这套开发库涵盖了多个 Android 版本，并帮助大家更快速、更轻松地实现常见的移动开发范式。很多用户一直对 Dagger 情有独钟，因此我们联合 Dagger 团队推出了 <a href="http://developer.android.google.cn/training/dependency-injection/hilt-android" target="_blank" rel="noopener">Hilt</a>，这是基于 Dagger 的封装方案，且易于开发者使用。我们推荐使用 Hilt 作为 Android 的依赖注入解决方案，并提供了 Alpha 试用版。我们还新增了一个 <a href="http://developer.android.google.cn/topic/libraries/app-startup" target="_blank" rel="noopener">App Startup</a> 库，帮助应用和库开发者优化库的初始化，进而缩短应用启动时间。此外，我们还<a href="https://medium.com/androiddevelopers/whats-new-in-jetpack-1891d205e136" target="_blank" rel="noopener">更新了许多现有的开发库</a>，包括对<a href="http://developer.android.google.cn/paging3" target="_blank" rel="noopener"> Paging 3</a> 进行的重大更新——优先使用 Kotlin 进行了重写，并且完全支持协程！</p>
<h2 id="全新-UI-工具包-Compose-的最新进展"><a href="#全新-UI-工具包-Compose-的最新进展" class="headerlink" title="全新 UI 工具包: Compose 的最新进展"></a>全新 UI 工具包: Compose 的最新进展</h2><p>想要进一步提升开发效率，您还需要强大的界面工具包，以便快速简便地在 Android 上构建精美的界面，同时还能原生访问系统 API。为此，我们构建了 <a href="https://developer.android.google.cn/jetpack/compose" target="_blank" rel="noopener">Jetpack Compose</a>，这是一款全新的现代界面工具包，通过强大的工具和直观的 Kotlin API，帮助您用更少的代码打造心目中的理想应用。</p>
<p>今天，我们为大家带来 <strong>Jetpack Compose 开发者预览版 2</strong>，其中包含开发者们一直要求的诸多功能:</p>
<ul>
<li>与 View 的互操作性 (开始在当前应用中混合使用 Composable 方法) (新！)</li>
<li>动画 (新！)</li>
<li>测试 (新！)</li>
<li>约束布局 (新！)</li>
<li>适配器列表 (新！)</li>
<li>Material UI 组件</li>
<li>文本以及可编辑文本 (新！)</li>
<li>主题和图像</li>
<li>窗口管理</li>
<li>输入和手势</li>
</ul>
<p>通过与 Jetbrains Kotlin 团队的紧密合作，我们在 Android Studio 4.2 中加入了许多新功能，来帮助您通过 Compose 构建应用:</p>
<ul>
<li>用于生成代码的 Kotlin 编译器插件</li>
<li>Compose 预览注解</li>
<li>实时交互式 Compose 预览</li>
<li>将单个的 Composable 部署至设备</li>
<li>Compose 代码补全</li>
<li>适用于 Compose 的示例数据 API</li>
</ul>
<p>Compose 尚未准备好用于生产环境。我们虽然进行了性能优化，但还需要通过大家试用以获得<a href="https://issuetracker.google.com/issues/new?component=612128" target="_blank" rel="noopener">反馈</a>。我们计划于今年夏天发布 alpha 版，并于明年发布 1.0 版。</p>
<h2 id="Google-Play-Console-全新改版"><a href="#Google-Play-Console-全新改版" class="headerlink" title="Google Play Console 全新改版"></a>Google Play Console 全新改版</h2><p>Google Play 致力于帮助开发者发展业务。为了更好地达成这一目的，我们重新设计了 Google Play Console，让您可以在我们的平台上获得进一步的成功。除了更简洁、更易用之外，新版 Play Console 还增添了不少功能，让您可以:</p>
<ul>
<li>找到、发现和理解 Play Console 的功能，从而在 Google Play 上收获成功</li>
<li>获取政策变化、发布状态和用户反馈的最新指导信息</li>
<li>通过全新的用户获取报告更好地解读数据表现</li>
<li>通过全新的用户管理选项，让团队中的每个人都能用好 Play Console 提供的功能</li>
</ul>
<p>请阅读文章《Google Play Console beta 版全新发布》进一步了解详情，您也可以访问 play.google.com/console 参与 Beta 版体验。您的反馈能帮助我们为每一个人打造更好的 Google Play Console，我们期待着您的声音。</p>
<ul>
<li><strong>腾讯视频链接</strong></li>
</ul>
<p><a href="https://v.qq.com/x/page/x0980f5awj2.html" target="_blank" rel="noopener">v.qq.com/x/page/x098…</a></p>
<ul>
<li><strong>Bilibili 视频链接</strong></li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1EC4y1a7bU/" target="_blank" rel="noopener">www.bilibili.com/video/BV1EC…</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们带来的更新远不止这些！欢迎大家继续关注我们接下来将要发布的内容:</p>
<ul>
<li>我们为大家准备了 <strong>12 场精彩演讲</strong>，会在接下来一段时间陆续发布。</li>
<li>我们会通过 “<strong>11 Weeks of Android</strong>“ 系列内容持续吸引大家对 Android 11 的热情，每周都会带来大家关注的全新开发者内容，比如 UI、Jetpack 和机器学习。请前往<a href="https://developer.android.google.cn/11weeksofandroid" target="_blank" rel="noopener">官方网站</a>查看发布日程。</li>
<li>我们将在全球举办一系列线上活动，来和大家一起探讨 Android 11 的新内容、应用兼容性，以及现代化 Android 开发的基本知识和最佳实践。请前往 <a href="https://developer.android.google.cn/android11/meetups" target="_blank" rel="noopener">官方网站</a>了解详情。同时，也可以直接参与到您所在的 GDG 社区的本地活动:</li>
</ul>
<p>7 月 4 日上海 GDG 社区</p>
<p><a href="https://www.meetup.com/Shanghai-GDG/events/270723097/" target="_blank" rel="noopener">www.meetup.com/Shanghai-GD…</a></p>
<p>其他的社区活动将在后续发布，敬请关注。</p>
<p><strong><a href="https://developer.android.google.cn/android11" target="_blank" rel="noopener">点击这里</a>前往 Android 11 Beta 版官方网站</strong></p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/11/172a21264fe4e17f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/vue_js/">10+个很酷的Vue.js组件，模板和demo示例</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/vue_js/" data-flag-title="10+个很酷的Vue.js组件，模板和demo示例"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>众所周知，<strong>Vue.js</strong> 组件是Vue创建自定义元素的重要功能之一，同时，模板可帮助你避免从头开始创建网页设计。总之，这些工具对于希望其开发过程更快，更高效的任何Web开发人员都是必不可少的。</p>
<p>此外，在过去的几年中，Vue.js 变得非常流行，许多企业将其添加到他们的技术栈中。该框架的优点是它具有内置的数据绑定和MVC模型（模型、视图、控制器），与<strong>Angular.js</strong>和<strong>React.js</strong>相比，它使配置更加容易。另外，Vue.js的学习曲线很小，与 Angular.js 相比，Vue更易于学习，理解和使用。</p>
<p>知道了这一点，我们收集了一份Vue.js组件、模板和实验清单，如果你是一个初学者，可以帮助你对这个框架的意义有一个概念，如果你是一个Vue.js开发者，也可以为你的下一个项目找到一些灵感。</p>
<hr>
<h2 id="BootstrapVue-Argon-Dashboard-PRO"><a href="#BootstrapVue-Argon-Dashboard-PRO" class="headerlink" title="BootstrapVue Argon Dashboard PRO"></a>BootstrapVue Argon Dashboard PRO</h2><p><strong><a href="https://demos.creative-tim.com/bootstrap-vue-argon-dashboard-pro" target="_blank" rel="noopener">BootstrapVue Argon Dashboard PRO</a></strong> 是BootstrapVue和Vue.js的高级仪表板。这是一种全新产品，它基于我们从头开始重新构建的最新框架结构，这种结构旨在使产品更直观，更具适应性，并且更易于定制。让Argon以其酷炫的功能给你带来惊喜，让你的项目达到一个全新的水平。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e597c2e7a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://demos.creative-tim.com/bootstrap-vue-argon-dashboard-pro"></p>
<h2 id="Vue-White-Dashboard"><a href="#Vue-White-Dashboard" class="headerlink" title="Vue White Dashboard"></a>Vue White Dashboard</h2><p><a href="https://demos.creative-tim.com/vue-white-dashboard" target="_blank" rel="noopener"><strong>Vue White Dashboard</strong> </a>是一个免费的开源Bootstrap 4和Vue.js Admin仪表板，其中包含大量的组件，这些组件可以组合在一起并看起来非常漂亮。Vue White仪表板具有16个以上的独立组件，可让你自由选择和组合。所有组件的颜色都可以不同，你可以使用Sass文件轻松进行修改。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e597b7ccc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://demos.creative-tim.com/vue-white-dashboard"></p>
<h2 id="Vue-QRcode-Reader"><a href="#Vue-QRcode-Reader" class="headerlink" title="Vue QRcode Reader"></a>Vue QRcode Reader</h2><p><a href="https://gruhn.github.io/vue-qrcode-reader?rel=nofollow" target="_blank"><strong>Vue QRcode Reader</strong></a>是一组用于检测和解码QR(二维码)码的Vue.js组件。它使你无需离开浏览器即可检测和解码QR码，所有组件都具有响应能力。除此之外，它接近零样式，因此你可以使它们适合你的布局。使用方法简单明了。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59a3db85f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://gruhn.github.io/vue-qrcode-reader"></p>
<h2 id="VueJS-Expo"><a href="#VueJS-Expo" class="headerlink" title="VueJS Expo"></a>VueJS Expo</h2><p><a href="https://vuejsexpo.com" target="_blank" rel="noopener"><strong>VueJS Expo</strong></a>是使用Vue.js框架收集的漂亮的网站，应用程序和实验。如果你是Vue.js框架的粉丝，那么这里可能是你获得灵感的地方。展示包括基于VueJS的主题，元素，仪表板等。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59a7bae7d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://vuejsexpo.com"></p>
<h2 id="Vue-Paper-Dashboard-PRO"><a href="#Vue-Paper-Dashboard-PRO" class="headerlink" title="Vue Paper Dashboard PRO"></a>Vue Paper Dashboard PRO</h2><p><strong><a href="https://demos.creative-tim.com/bs3/vue-paper-dashboard-pro/#/admin/overview" target="_blank" rel="noopener">Vue Paper Dashboard PRO</a></strong> 是一个基于Bootstrap和Vue构建的漂亮资源，它将帮助你在短时间内开始开发仪表盘。Vue Paper Dashboard Pro是<a href="https://www.creative-tim.com/product/paper-dashboard-pro?ref=devto" target="_blank" rel="noopener">Original Paper Dashboard Pro</a>的VueJS移植版本。使用仪表板非常简单，但是需要具备Javascript，Vue和Vue-Router的基础知识。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59c10157c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://demos.creative-tim.com/bs3/vue-paper-dashboard-pro/#/admin/overview"></p>
<h2 id="Koel"><a href="#Koel" class="headerlink" title="Koel"></a>Koel</h2><p><a href="https://koel.dev/?rel=nofollow" target="_blank"><strong>Koel</strong></a>是一种简单的基于Web的个人音频流服务，在客户端用Vue编写，在服务器端用Laravel编写。针对Web开发人员，Koel采用了一些更现代的Web技术——CSS grid，音频和拖放API等来完成其工作。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e59da7e067?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://koel.dev/"></p>
<h2 id="Vue-Argon-Dashboard"><a href="#Vue-Argon-Dashboard" class="headerlink" title="Vue Argon Dashboard"></a>Vue Argon Dashboard</h2><p><a href="https://demos.creative-tim.com/vue-argon-dashboard" target="_blank" rel="noopener"><strong>Vue Argon Dashboard</strong></a>是Bootstrap 4和Vue.js的仪表板。它是开源的，免费的，并且具有许多组件，可以帮助你创建出色的网站。Vue Argon仪表板内置了100多个单独的组件，因此你可以选择和组合，因为实现了所有元素，所以从原型化到全功能代码将节省大量时间。该仪表板附带了预先构建的示例，因此开发过程是无缝的，从我们的页面切换到真实的网站非常容易。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5c28b45c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://demos.creative-tim.com/vue-argon-dashboard"></p>
<h2 id="Pagekit"><a href="#Pagekit" class="headerlink" title="Pagekit"></a>Pagekit</h2><p><a href="https://pagekit.com/?rel=nofollow" target="_blank"><strong>Pagekit</strong></a>是使用Symfony组件和VueJS构建的模块化，轻量级CMS。无论是个人博客还是你公司的网站，都可以使用Pagekit来为网络创建功能强大的内容，使其在每台设备上都能完美运行。它具有干净直观的界面，它也有一个很棒的内置市场。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5c3ac5bd2?imageslim" alt="http://pagekit.com/"></p>
<h2 id="Vue-Material-Dashboard-PRO"><a href="#Vue-Material-Dashboard-PRO" class="headerlink" title="Vue Material Dashboard PRO"></a>Vue Material Dashboard PRO</h2><p><a href="https://demos.creative-tim.com/vue-material-dashboard-pro" target="_blank" rel="noopener"><strong>Vue Material Dashboard PRO</strong></a>是一个出色的高级管理模板，建立在Vue Material和VueJS之上。它是通过考虑你在仪表板中实际需要的东西而创建的。Vue Material Dashboard PRO包含精选和优化的VueJS插件，一切都旨在相互配合。使用仪表板非常简单，但是需要具备Javascript，VueJS和Vue Router的基础知识。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5c80134f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://demos.creative-tim.com/vue-material-dashboard-pro"></p>
<h2 id="Vue-Color"><a href="#Vue-Color" class="headerlink" title="Vue-Color"></a>Vue-Color</h2><p><a href="http://vue-color.surge.sh/?rel=nofollow" target="_blank"><strong>Vue-Color</strong></a>是一款来自Sketch、Photoshop、Chrome、Github、Twitter、Material Design等的酷炫的采色器。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5e1f3ae5c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://vue-color.surge.sh"></p>
<h2 id="Vue-Material-Kit"><a href="#Vue-Material-Kit" class="headerlink" title="Vue Material Kit"></a>Vue Material Kit</h2><p><strong><a href="https://demos.creative-tim.com/vue-material-kit" target="_blank" rel="noopener">Vue Material Kit</a></strong> 是基于Vue Material和VueJS构建的令人惊叹的免费开源资源。它将帮助你立即开始开发UI工具包。Vue Material Kit是原始<a href="https://www.creative-tim.com/product/material-kit" target="_blank" rel="noopener">Material Kit</a>的官方VueJS版本。使用UI Kit非常简单，但是需要Javascript，VueJS和Vue Router的基础知识。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e5ee23af35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://demos.creative-tim.com/vue-material-kit"></p>
<h2 id="Retrospectify"><a href="#Retrospectify" class="headerlink" title="Retrospectify"></a>Retrospectify</h2><p><strong><a href="http://pepf.nl/retrospective/?rel=nofollow" target="_blank">Retrospectify</a></strong> 是一个用 Vue 编写的很棒的工具，用于以数字方式进行敏捷团队回顾。当与远程团队进行回顾时，或者当您希望随时间跟踪回顾结果时，这将很有用。它有三种类型的笔记，你可以移动笔记或添加点到个别的笔记。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e60a7f9562?imageslim" alt="http://pepf.nl/retrospective"></p>
<h2 id="Code-Notes"><a href="#Code-Notes" class="headerlink" title="Code Notes"></a>Code Notes</h2><p><strong><a href="https://lauthieb.github.io/code-notes/?rel=nofollow" target="_blank">Code Notes</a></strong> 是使用Electron＆Vue.js构建的开发人员的简单代码段管理器。使用它，你可以将多个片段保存在一个便笺中，按名称/语言/标签进行搜索，还可以管理Github要点。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/8/172944e610d83a53?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http://lauthieb.github.io/code-notes"></p>
<p><strong>希望这份清单对您的下一个开发项目有帮助 🙂</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/typescript/">TypeScript泛型及应用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/typescript/" data-flag-title="TypeScript泛型及应用"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>觉得 TypeScript 泛型有点难，想系统学习 TypeScript 泛型相关知识的小伙伴们看过来，<strong>本文从八个方面入手，全方位带你一步步学习 TypeScript 中泛型</strong>，详细的内容大纲请看下图：</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/10/1729b3d970e872ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="master-ts-generic"></p>
<p><strong>动静（图）结合</strong>，在泛型学习之路助你一臂之力，还在犹豫什么，赶紧开启 TypeScript 泛型的学习之旅吧！</p>
<h3 id="一、泛型是什么"><a href="#一、泛型是什么" class="headerlink" title="一、泛型是什么"></a>一、泛型是什么</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p>
<p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>
<p>为了便于大家更好地理解上述的内容，我们来举个例子，在这个例子中，我们将一步步揭示泛型的作用。首先我们来定义一个通用的 <code>identity</code> 函数，该函数接收一个参数并直接返回它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity (value) &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(identity(1)) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>现在，我们将 <code>identity</code> 函数做适当的调整，以支持 TypeScript 的 Number 类型的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity (value: Number) : Number &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(identity(1)) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>这里 <code>identity</code> 的问题是我们将 <code>Number</code> 类型分配给参数和返回类型，使该函数仅可用于该原始类型。但该函数并不是可扩展或通用的，很明显这并不是我们所希望的。</p>
<p>我们确实可以把 <code>Number</code> 换成 <code>any</code>，我们失去了定义应该返回哪种类型的能力，并且在这个过程中使编译器失去了类型保护的作用。我们的目标是让 <code>identity</code> 函数可以适用于任何特定的类型，为了实现这个目标，我们可以使用泛型来解决这个问题，具体实现方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity &lt;T&gt;(value: T) : T &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(identity&lt;Number&gt;(1)) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。但这没什么可担心的，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p>
<p><img src="http://user-gold-cdn.xitu.io/2020/6/10/1729b3d9774a21ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="generic-type-filled"></p>
<p>参考上面的图片，当我们调用 <code>identity&lt;Number&gt;(1)</code> ，<code>Number</code> 类型就像参数 <code>1</code> 一样，它将在出现 <code>T</code> 的任何位置填充该类型。图中 <code>&lt;T&gt;</code> 内部的 <code>T</code> 被称为类型变量，它是我们希望传递给 identity 函数的类型占位符，同时它被分配给 <code>value</code> 参数用来代替它的类型：此时 <code>T</code> 充当的是类型，而不是特定的 Number 类型。</p>
<p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p>
<ul>
<li>K（Key）：表示对象中的键类型；</li>
<li>V（Value）：表示对象中的值类型；</li>
<li>E（Element）：表示元素类型。</li>
</ul>
<p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function identity &lt;T, U&gt;(value: T, message: U) : T &#123;</span><br><span class="line">  console.log(message);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(identity&lt;Number, string&gt;(68, &quot;Semlinker&quot;));</span><br></pre></td></tr></table></figure>



<p><img src="http://user-gold-cdn.xitu.io/2020/6/10/1729b3dbccc38ea7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="generic-multi-type-filled"></p>
<p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function identity &lt;T, U&gt;(value: T, message: U) : T &#123;</span><br><span class="line">  console.log(message);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(identity(68, &quot;Semlinker&quot;));</span><br></pre></td></tr></table></figure>

<p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。下面我们来看张动图，直观地感受一下类型传递的过程：</p>
<p>![generic-type-filled](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="780" height="480"></svg>)</p>
<p>（图片来源：<a href="https://medium.com/better-programming/typescript-generics-90be93d8c292）" target="_blank" rel="noopener">medium.com/better-prog…</a></p>
<blockquote>
<p>感谢 @仑（前端搬砖党）指出，该动图有bug。</p>
<p>动态图最后一句错了吗？console.log(identity([1,2,3]))这里注入类型应该是number[]吧？</p>
</blockquote>
<p>如你所见，该函数接收你传递给它的任何类型，使得我们可以为不同类型创建可重用的组件。现在我们再来看一下 <code>identity</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function identity &lt;T, U&gt;(value: T, message: U) : T &#123;</span><br><span class="line">  console.log(message);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之前定义的 <code>identity</code> 函数，新的 <code>identity</code> 函数增加了一个类型变量 <code>U</code>，但该函数的返回类型我们仍然使用 <code>T</code>。如果我们想要返回两种类型的对象该怎么办呢？针对这个问题，我们有多种方案，其中一种就是使用元组，即为元组设置通用的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity &lt;T, U&gt;(value: T, message: U) : [T, U] &#123;</span><br><span class="line">  return [value, message];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然使用元组解决了上述的问题，但有没有其它更好的方案呢？答案是有的，你可以使用泛型接口。</p>
<h3 id="二、泛型接口"><a href="#二、泛型接口" class="headerlink" title="二、泛型接口"></a>二、泛型接口</h3><p>为了解决上面提到的问题，首先让我们创建一个用于的 <code>identity</code> 函数通用 <code>Identities</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Identities&lt;V, M&gt; &#123;</span><br><span class="line">  value: V,</span><br><span class="line">  message: M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的 <code>Identities</code> 接口中，我们引入了类型变量 <code>V</code> 和 <code>M</code>，来进一步说明有效的字母都可以用于表示类型变量，之后我们就可以将 <code>Identities</code> 接口作为 <code>identity</code> 函数的返回类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T, U&gt; (value: T, message: U): Identities&lt;T, U&gt; &#123;</span><br><span class="line">  console.log(value + &quot;: &quot; + typeof (value));</span><br><span class="line">  console.log(message + &quot;: &quot; + typeof (message));</span><br><span class="line">  let identities: Identities&lt;T, U&gt; &#x3D; &#123;</span><br><span class="line">    value,</span><br><span class="line">    message</span><br><span class="line">  &#125;;</span><br><span class="line">  return identities;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(identity(68, &quot;Semlinker&quot;));</span><br></pre></td></tr></table></figure>

<p>以上代码成功运行后，在控制台会输出以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">68: number</span><br><span class="line">Semlinker: string</span><br><span class="line">&#123;value: 68, message: &quot;Semlinker&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>泛型除了可以应用在函数和接口之外，它也可以应用在类中，下面我们就来看一下在类中如何使用泛型。</p>
<h3 id="三、泛型类"><a href="#三、泛型类" class="headerlink" title="三、泛型类"></a>三、泛型类</h3><p>在类中使用泛型也很简单，我们只需要在类名后面，使用 <code>&lt;T, ...&gt;</code> 的语法定义任意多个类型变量，具体示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface GenericInterface&lt;U&gt; &#123;</span><br><span class="line">  value: U</span><br><span class="line">  getIdentity: () &#x3D;&gt; U</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IdentityClass&lt;T&gt; implements GenericInterface&lt;T&gt; &#123;</span><br><span class="line">  value: T</span><br><span class="line"></span><br><span class="line">  constructor(value: T) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getIdentity(): T &#123;</span><br><span class="line">    return this.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myNumberClass &#x3D; new IdentityClass&lt;Number&gt;(68);</span><br><span class="line">console.log(myNumberClass.getIdentity()); &#x2F;&#x2F; 68</span><br><span class="line"></span><br><span class="line">const myStringClass &#x3D; new IdentityClass&lt;string&gt;(&quot;Semlinker!&quot;);</span><br><span class="line">console.log(myStringClass.getIdentity()); &#x2F;&#x2F; Semlinker!</span><br></pre></td></tr></table></figure>

<p>接下来我们以实例化 <code>myNumberClass</code> 为例，来分析一下其调用过程：</p>
<ul>
<li>在实例化 <code>IdentityClass</code> 对象时，我们传入 <code>Number</code> 类型和构造函数参数值 <code>68</code>；</li>
<li>之后在 <code>IdentityClass</code> 类中，类型变量 <code>T</code> 的值变成 <code>Number</code> 类型；</li>
<li><code>IdentityClass</code> 类实现了 <code>GenericInterface&lt;T&gt;</code>，而此时 <code>T</code> 表示 <code>Number</code> 类型，因此等价于该类实现了 <code>GenericInterface&lt;Number&gt;</code> 接口；</li>
<li>而对于 <code>GenericInterface&lt;U&gt;</code> 接口来说，类型变量 <code>U</code> 也变成了 <code>Number</code>。这里我有意使用不同的变量名，以表明类型值沿链向上传播，且与变量名无关。</li>
</ul>
<p>泛型类可确保在整个类中一致地使用指定的数据类型。比如，你可能已经注意到在使用 Typescript 的 React 项目中使用了以下约定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Props &#x3D; &#123;</span><br><span class="line">  className?: string</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type State &#x3D; &#123;</span><br><span class="line">  submitted?: bool</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyComponent extends React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们将泛型与 React 组件一起使用，以确保组件的 props 和 state 是类型安全的。</p>
<p>相信看到这里一些读者会有疑问，我们在什么时候需要使用泛型呢？通常在决定是否使用泛型时，我们有以下两个参考标准：</p>
<ul>
<li>当你的函数、接口或类将处理多种数据类型时；</li>
<li>当函数、接口或类在多个地方使用该数据类型时。</li>
</ul>
<p>很有可能你没有办法保证在项目早期就使用泛型的组件，但是随着项目的发展，组件的功能通常会被扩展。这种增加的可扩展性最终很可能会满足上述两个条件，在这种情况下，引入泛型将比复制组件来满足一系列数据类型更干净。</p>
<p>我们将在本文的后面探讨更多满足这两个条件的用例。不过在这样做之前，让我们先介绍一下 Typescript 泛型提供的其他功能。</p>
<h3 id="四、泛型约束"><a href="#四、泛型约束" class="headerlink" title="四、泛型约束"></a>四、泛型约束</h3><p>有时我们可能希望限制每个类型变量接受的类型数量，这就是泛型约束的作用。下面我们来举几个例子，介绍一下如何使用泛型约束。</p>
<h4 id="4-1-确保属性存在"><a href="#4-1-确保属性存在" class="headerlink" title="4.1 确保属性存在"></a>4.1 确保属性存在</h4><p>有时候，我们希望类型变量对应的类型上存在某些属性。这时，除非我们显式地将特定属性定义为类型变量，否则编译器不会知道它们的存在。</p>
<p>一个很好的例子是在处理字符串或数组时，我们会假设 <code>length</code> 属性是可用的。让我们再次使用 <code>identity</code> 函数并尝试输出参数的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length); &#x2F;&#x2F; Error</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，编译器将不会知道 <code>T</code> 确实含有 <code>length</code> 属性，尤其是在可以将任何类型赋给类型变量 <code>T</code> 的情况下。我们需要做的就是让类型变量 <code>extends</code> 一个含有我们所需属性的接口，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Length &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function identity&lt;T extends Length&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length); &#x2F;&#x2F; 可以获取length属性</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>T extends Length</code> 用于告诉编译器，我们支持已经实现 <code>Length</code> 接口的任何类型。之后，当我们使用不含有 <code>length</code> 属性的对象作为参数调用  <code>identity</code> 函数时，TypeScript 会提示相关的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identity(68); &#x2F;&#x2F; Error</span><br><span class="line">&#x2F;&#x2F; Argument of type &#39;68&#39; is not assignable to parameter of type &#39;Length&#39;.(2345)</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以使用 <code>,</code> 号来分隔多种约束类型，比如：<code>&lt;T extends Length, Type2, Type3&gt;</code>。而对于上述的 <code>length</code> 属性问题来说，如果我们显式地将变量设置为数组类型，也可以解决该问题，具体方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T[]): T[] &#123;</span><br><span class="line">   console.log(arg.length);  </span><br><span class="line">   return arg; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">function identity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;      </span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-检查对象上的键是否存在"><a href="#4-2-检查对象上的键是否存在" class="headerlink" title="4.2 检查对象上的键是否存在"></a>4.2 检查对象上的键是否存在</h4><p>泛型约束的另一个常见的使用场景就是检查对象上的键是否存在。不过在看具体示例之前，我们得来了解一下 <code>keyof</code> 操作符，<strong><code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</strong> “耳听为虚，眼见为实”，我们来举个 <code>keyof</code> 的使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  location: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 &#x3D; keyof Person; &#x2F;&#x2F; &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span><br><span class="line">type K2 &#x3D; keyof Person[];  &#x2F;&#x2F; number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span><br><span class="line">type K3 &#x3D; keyof &#123; [x: string]: Person &#125;;  &#x2F;&#x2F; string | number</span><br></pre></td></tr></table></figure>

<p>通过 <code>keyof</code> 操作符，我们就可以获取指定类型的所有键，之后我们就可以结合前面介绍的 <code>extends</code> 约束，即限制输入的属性名包含在 <code>keyof</code> 返回的联合类型中。具体的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上的 <code>getProperty</code> 函数中，我们通过 <code>K extends keyof T</code> 确保参数 key 一定是对象中含有的键，这样就不会发生运行时错误。这是一个类型安全的解决方案，与简单调用 <code>let value = obj[key];</code> 不同。</p>
<p>下面我们来看一下如何使用 <code>getProperty</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">enum Difficulty &#123;</span><br><span class="line">  Easy,</span><br><span class="line">  Intermediate,</span><br><span class="line">  Hard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123;</span><br><span class="line">  return obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tsInfo &#x3D; &#123;</span><br><span class="line">   name: &quot;Typescript&quot;,</span><br><span class="line">   supersetOf: &quot;Javascript&quot;,</span><br><span class="line">   difficulty: Difficulty.Intermediate</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let difficulty: Difficulty &#x3D; </span><br><span class="line">  getProperty(tsInfo, &#39;difficulty&#39;); &#x2F;&#x2F; OK</span><br><span class="line"></span><br><span class="line">let supersetOf: string &#x3D; </span><br><span class="line">  getProperty(tsInfo, &#39;superset_of&#39;); &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>在以上示例中，对于 <code>getProperty(tsInfo, &#39;superset_of&#39;)</code> 这个表达式，TypeScript 编译器会提示以下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Argument of type &#39;&quot;superset_of&quot;&#39; is not assignable to parameter of type </span><br><span class="line">&#39;&quot;difficulty&quot; | &quot;name&quot; | &quot;supersetOf&quot;&#39;.(2345)</span><br></pre></td></tr></table></figure>

<p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。接下来，我们来介绍一下泛型参数默认类型。</p>
<h3 id="五、泛型参数默认类型"><a href="#五、泛型参数默认类型" class="headerlink" title="五、泛型参数默认类型"></a>五、泛型参数默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推断出类型时，这个默认类型就会起作用。</p>
<p>泛型参数默认类型与普通函数默认值类似，对应的语法很简单，即 <code>&lt;T=Default Type&gt;</code>，对应的使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface A&lt;T&#x3D;string&gt; &#123;</span><br><span class="line">  name: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const strA: A &#x3D; &#123; name: &quot;Semlinker&quot; &#125;;</span><br><span class="line">const numB: A&lt;number&gt; &#x3D; &#123; name: 101 &#125;;</span><br></pre></td></tr></table></figure>

<p>泛型参数的默认类型遵循以下规则：</p>
<ul>
<li>有默认类型的类型参数被认为是可选的。</li>
<li>必选的类型参数不能在可选的类型参数后。</li>
<li>如果类型参数有约束，类型参数的默认类型必须满足这个约束。</li>
<li>当指定类型实参时，你只需要指定必选类型参数的类型实参。 未指定的类型参数会被解析为它们的默认类型。</li>
<li>如果指定了默认类型，且类型推断无法选择一个候选类型，那么将使用默认类型作为推断结果。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以为现有类型参数引入默认类型。</li>
<li>一个被现有类或接口合并的类或者接口的声明可以引入新的类型参数，只要它指定了默认类型。</li>
</ul>
<h3 id="六、泛型条件类型"><a href="#六、泛型条件类型" class="headerlink" title="六、泛型条件类型"></a>六、泛型条件类型</h3><p>在 TypeScript 2.8 中引入了条件类型，使得我们可以根据某些条件得到不同的类型，这里所说的条件是类型兼容性约束。尽管以上代码中使用了 <code>extends</code> 关键字，也不一定要强制满足继承关系，而是检查是否满足结构兼容性。</p>
<p>条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends U ? X : Y</span><br></pre></td></tr></table></figure>

<p>以上表达式的意思是：若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code>。在条件类型表达式中，我们通常还会结合 <code>infer</code> 关键字，实现类型抽取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Dictionary&lt;T &#x3D; any&gt; &#123;</span><br><span class="line">  [key: string]: T;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type StrDict &#x3D; Dictionary&lt;string&gt;</span><br><span class="line"></span><br><span class="line">type DictMember&lt;T&gt; &#x3D; T extends Dictionary&lt;infer V&gt; ? V : never</span><br><span class="line">type StrDictMember &#x3D; DictMember&lt;StrDict&gt; &#x2F;&#x2F; string</span><br></pre></td></tr></table></figure>

<p>在上面示例中，当类型 T 满足 <code>T extends Dictionary</code> 约束时，我们会使用 <code>infer</code> 关键字声明了一个类型变量 V，并返回该类型，否则返回 <code>never</code> 类型。</p>
<blockquote>
<p>在 TypeScript 中，<code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>
<p>另外，需要注意的是，没有类型是 <code>never</code> 的子类型或可以赋值给 <code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>
</blockquote>
<p>除了上述的应用外，利用条件类型和 <code>infer</code> 关键字，我们还可以方便地实现获取 Promise 对象的返回值类型，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">async function stringPromise() &#123;</span><br><span class="line">  return &quot;Hello, Semlinker!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function personPromise() &#123;</span><br><span class="line">  return &#123; name: &quot;Semlinker&quot;, age: 30 &#125; as Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PromiseType&lt;T&gt; &#x3D; (args: any[]) &#x3D;&gt; Promise&lt;T&gt;;</span><br><span class="line">type UnPromisify&lt;T&gt; &#x3D; T extends PromiseType&lt;infer U&gt; ? U : never;</span><br><span class="line"></span><br><span class="line">type extractStringPromise &#x3D; UnPromisify&lt;typeof stringPromise&gt;; &#x2F;&#x2F; string</span><br><span class="line">type extractPersonPromise &#x3D; UnPromisify&lt;typeof personPromise&gt;; &#x2F;&#x2F; Person</span><br></pre></td></tr></table></figure>

<h3 id="七、泛型工具类型"><a href="#七、泛型工具类型" class="headerlink" title="七、泛型工具类型"></a>七、泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍其中几个常用的工具类型。</p>
<h4 id="7-1-Partial"><a href="#7-1-Partial" class="headerlink" title="7.1 Partial"></a>7.1 Partial</h4><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p>
<p><strong>定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"> * Make all properties in T optional</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Partial&lt;T&gt; &#x3D; &#123;</span><br><span class="line">    [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;</span><br><span class="line">  return &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const todo1 &#x3D; &#123;</span><br><span class="line">  title: &quot;organize desk&quot;,</span><br><span class="line">  description: &quot;clear clutter&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const todo2 &#x3D; updateTodo(todo1, &#123;</span><br><span class="line">  description: &quot;throw out trash&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: string | undefined;</span><br><span class="line">   description?: string | undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-Record"><a href="#7-2-Record" class="headerlink" title="7.2 Record"></a>7.2 Record</h4><p><code>Record&lt;K extends keyof any, T&gt;</code> 的作用是将 <code>K</code> 中所有的属性的值转化为 <code>T</code> 类型。</p>
<p><strong>定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"> * Construct a type with a set of properties K of type T</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Record&lt;K extends keyof any, T&gt; &#x3D; &#123;</span><br><span class="line">    [P in K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface PageInfo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Page &#x3D; &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;</span><br><span class="line"></span><br><span class="line">const x: Record&lt;Page, PageInfo&gt; &#x3D; &#123;</span><br><span class="line">  about: &#123; title: &quot;about&quot; &#125;,</span><br><span class="line">  contact: &#123; title: &quot;contact&quot; &#125;,</span><br><span class="line">  home: &#123; title: &quot;home&quot; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-Pick"><a href="#7-3-Pick" class="headerlink" title="7.3 Pick"></a>7.3 Pick</h4><p><code>Pick&lt;T, K extends keyof T&gt;</code> 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。</p>
<p><strong>定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * From T, pick a set of properties whose keys are in the union K</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;</span><br><span class="line">    [P in K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">  completed: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TodoPreview &#x3D; Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;</span><br><span class="line"></span><br><span class="line">const todo: TodoPreview &#x3D; &#123;</span><br><span class="line">  title: &quot;Clean room&quot;,</span><br><span class="line">  completed: false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-Exclude"><a href="#7-4-Exclude" class="headerlink" title="7.4 Exclude"></a>7.4 Exclude</h4><p><code>Exclude&lt;T, U&gt;</code> 的作用是将某个类型中属于另一个的类型移除掉。</p>
<p><strong>定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Exclude from T those types that are assignable to U</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</span><br></pre></td></tr></table></figure>

<p>如果 <code>T</code> 能赋值给 <code>U</code> 类型的话，那么就会返回 <code>never</code> 类型，否则返回 <code>T</code> 类型。最终实现的效果就是将 <code>T</code> 中某些属于 <code>U</code> 的类型移除掉。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type T0 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; &#x2F;&#x2F; &quot;b&quot; | &quot;c&quot;</span><br><span class="line">type T1 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; &#x2F;&#x2F; &quot;c&quot;</span><br><span class="line">type T2 &#x3D; Exclude&lt;string | number | (() &#x3D;&gt; void), Function&gt;; &#x2F;&#x2F; string | number</span><br></pre></td></tr></table></figure>

<h4 id="7-5-ReturnType"><a href="#7-5-ReturnType" class="headerlink" title="7.5 ReturnType"></a>7.5 ReturnType</h4><p><code>ReturnType&lt;T&gt;</code> 的作用是用于获取函数 <code>T</code> 的返回类型。</p>
<p><strong>定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Obtain the return type of a function type</span><br><span class="line"> *&#x2F;</span><br><span class="line">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type T0 &#x3D; ReturnType&lt;() &#x3D;&gt; string&gt;; &#x2F;&#x2F; string</span><br><span class="line">type T1 &#x3D; ReturnType&lt;(s: string) &#x3D;&gt; void&gt;; &#x2F;&#x2F; void</span><br><span class="line">type T2 &#x3D; ReturnType&lt;&lt;T&gt;() &#x3D;&gt; T&gt;; &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">type T3 &#x3D; ReturnType&lt;&lt;T extends U, U extends number[]&gt;() &#x3D;&gt; T&gt;; &#x2F;&#x2F; number[]</span><br><span class="line">type T4 &#x3D; ReturnType&lt;any&gt;; &#x2F;&#x2F; any</span><br><span class="line">type T5 &#x3D; ReturnType&lt;never&gt;; &#x2F;&#x2F; any</span><br><span class="line">type T6 &#x3D; ReturnType&lt;string&gt;; &#x2F;&#x2F; Error</span><br><span class="line">type T7 &#x3D; ReturnType&lt;Function&gt;; &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>简单介绍了泛型工具类型，最后我们来介绍如何使用泛型来创建对象。</p>
<h3 id="八、使用泛型创建对象"><a href="#八、使用泛型创建对象" class="headerlink" title="八、使用泛型创建对象"></a>八、使用泛型创建对象</h3><h4 id="8-1-构造签名"><a href="#8-1-构造签名" class="headerlink" title="8.1 构造签名"></a>8.1 构造签名</h4><p>有时，泛型类可能需要基于传入的泛型 T 来创建其类型相关的对象。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class FirstClass &#123;</span><br><span class="line">  id: number | undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SecondClass &#123;</span><br><span class="line">  name: string | undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GenericCreator&lt;T&gt; &#123;</span><br><span class="line">  create(): T &#123;</span><br><span class="line">    return new T();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const creator1 &#x3D; new GenericCreator&lt;FirstClass&gt;();</span><br><span class="line">const firstClass: FirstClass &#x3D; creator1.create();</span><br><span class="line"></span><br><span class="line">const creator2 &#x3D; new GenericCreator&lt;SecondClass&gt;();</span><br><span class="line">const secondClass: SecondClass &#x3D; creator2.create();</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们定义了两个普通类和一个泛型类 <code>GenericCreator&lt;T&gt;</code>。在通用的 <code>GenericCreator</code> 泛型类中，我们定义了一个名为 <code>create</code> 的成员方法，该方法会使用 new 关键字来调用传入的实际类型的构造函数，来创建对应的对象。但可惜的是，以上代码并不能正常运行，对于以上代码，在 <strong>TypeScript v3.9.2</strong> 编译器下会提示以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;T&#39; only refers to a type, but is being used as a value here.</span><br></pre></td></tr></table></figure>

<p>这个错误的意思是：<code>T</code> 类型仅指类型，但此处被用作值。那么如何解决这个问题呢？根据 TypeScript 文档，为了使通用类能够创建 T 类型的对象，我们需要通过其构造函数来引用 T 类型。对于上述问题，在介绍具体的解决方案前，我们先来介绍一下构造签名。</p>
<p>在 TypeScript 接口中，你可以使用 <code>new</code> 关键字来描述一个构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  new (x: number, y: number): Point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上接口中的 <code>new (x: number, y: number)</code> 我们称之为构造签名，其语法如下：</p>
<blockquote>
<p><em>ConstructSignature:</em> <code>new</code> <em>TypeParametersopt</em> <code>(</code> <em>ParameterListopt</em> <code>)</code> <em>TypeAnnotationopt</em></p>
</blockquote>
<p>在上述的构造签名中，<code>TypeParametersopt</code> 、<code>ParameterListopt</code> 和 <code>TypeAnnotationopt</code> 分别表示：可选的类型参数、可选的参数列表和可选的类型注解。与该语法相对应的几种常见的使用形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new C  </span><br><span class="line">new C ( ... )  </span><br><span class="line">new C &lt; ... &gt; ( ... )</span><br></pre></td></tr></table></figure>

<p>介绍完构造签名，我们再来介绍一个与之相关的概念，即构造函数类型。</p>
<h4 id="8-2-构造函数类型"><a href="#8-2-构造函数类型" class="headerlink" title="8.2 构造函数类型"></a>8.2 构造函数类型</h4><p>在 TypeScript 语言规范中这样定义构造函数类型：</p>
<blockquote>
<p>An object type containing one or more construct signatures is said to be a <strong><em>constructor type</em></strong>. Constructor types may be written using constructor type literals or by including construct signatures in object type literals.</p>
</blockquote>
<p>通过规范中的描述信息，我们可以得出以下结论：</p>
<ul>
<li>包含一个或多个构造签名的对象类型被称为构造函数类型；</li>
<li>构造函数类型可以使用构造函数类型字面量或包含构造签名的对象类型字面量来编写。</li>
</ul>
<p>那么什么是构造函数类型字面量呢？构造函数类型字面量是包含单个构造函数签名的对象类型的简写。具体来说，构造函数类型字面量的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new &lt; T1, T2, ... &gt; ( p1, p2, ... ) &#x3D;&gt; R</span><br></pre></td></tr></table></figure>

<p>该形式与以下对象类型字面量是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; new &lt; T1, T2, ... &gt; ( p1, p2, ... ) : R &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来举个实际的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数类型字面量</span><br><span class="line">new (x: number, y: number) &#x3D;&gt; Point</span><br></pre></td></tr></table></figure>

<p>等价于以下对象类型字面量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   new (x: number, y: number): Point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-构造函数类型的应用"><a href="#8-3-构造函数类型的应用" class="headerlink" title="8.3 构造函数类型的应用"></a>8.3 构造函数类型的应用</h4><p>在介绍构造函数类型的应用前，我们先来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  new (x: number, y: number): Point;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point2D implements Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line"></span><br><span class="line">  constructor(x: number, y: number) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const point: Point &#x3D; new Point2D(1, 2);</span><br></pre></td></tr></table></figure>

<p>对于以上的代码，TypeScript 编译器会提示以下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#39;Point2D&#39; incorrectly implements interface &#39;Point&#39;.</span><br><span class="line">Type &#39;Point2D&#39; provides no match for the signature &#39;new (x: number, y: number): Point&#39;.</span><br></pre></td></tr></table></figure>

<p>相信很多刚接触 TypeScript 不久的小伙伴都会遇到上述的问题。要解决这个问题，我们就需要把对前面定义的 <code>Point</code> 接口进行分离，即把接口的属性和构造函数类型进行分离：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PointConstructor &#123;</span><br><span class="line">  new (x: number, y: number): Point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成接口拆分之后，除了前面已经定义的 <code>Point2D</code> 类之外，我们又定义了一个 <code>newPoint</code> 工厂函数，该函数用于根据传入的 PointConstructor 类型的构造函数，来创建对应的 Point 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Point2D implements Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line"></span><br><span class="line">  constructor(x: number, y: number) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function newPoint(</span><br><span class="line">  pointConstructor: PointConstructor,</span><br><span class="line">  x: number,</span><br><span class="line">  y: number</span><br><span class="line">): Point &#123;</span><br><span class="line">  return new pointConstructor(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const point: Point &#x3D; newPoint(Point2D, 1, 2);</span><br></pre></td></tr></table></figure>

<h4 id="8-4-使用泛型创建对象"><a href="#8-4-使用泛型创建对象" class="headerlink" title="8.4 使用泛型创建对象"></a>8.4 使用泛型创建对象</h4><p>了解完构造签名和构造函数类型之后，下面我们来开始解决上面遇到的问题，首先我们需要重构一下 <code>create</code> 方法，具体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GenericCreator&lt;T&gt; &#123;</span><br><span class="line">  create&lt;T&gt;(c: &#123; new (): T &#125;): T &#123;</span><br><span class="line">    return new c();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们重新定义了 <code>create</code> 成员方法，根据该方法的签名，我们可以知道该方法接收一个参数，其类型是构造函数类型，且该构造函数不包含任何参数，调用该构造函数后，会返回类型 T 的实例。</p>
<p>如果构造函数含有参数的话，比如包含一个 <code>number</code> 类型的参数时，我们可以这样定义 create 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create&lt;T&gt;(c: &#123; new(a: number): T; &#125;, num: number): T &#123;</span><br><span class="line">  return new c(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新完 <code>GenericCreator</code> 泛型类，我们就可以使用下面的方式来创建 <code>FirstClass</code> 和 <code>SecondClass</code> 类的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const creator1 &#x3D; new GenericCreator&lt;FirstClass&gt;();</span><br><span class="line">const firstClass: FirstClass &#x3D; creator1.create(FirstClass);</span><br><span class="line"></span><br><span class="line">const creator2 &#x3D; new GenericCreator&lt;SecondClass&gt;();</span><br><span class="line">const secondClass: SecondClass &#x3D; creator2.create(SecondClass);</span><br></pre></td></tr></table></figure>

<h3 id="九、参考资源"><a href="#九、参考资源" class="headerlink" title="九、参考资源"></a>九、参考资源</h3><ul>
<li><a href="https://medium.com/better-programming/typescript-generics-90be93d8c292" target="_blank" rel="noopener">typescript-generics</a></li>
<li><a href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f" target="_blank" rel="noopener">typescript-generics-explained</a></li>
<li><a href="https://dev.to/shadow1349/typescript-tip-of-the-week-generics-170g" target="_blank" rel="noopener">typescript-tip-of-the-week-generics</a></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/blog/">如何快速搭建好看的个人博客</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/blog/" data-flag-title="如何快速搭建好看的个人博客"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="如何快速搭建好看的个人博客-完整配置与源码"><a href="#如何快速搭建好看的个人博客-完整配置与源码" class="headerlink" title="如何快速搭建好看的个人博客(完整配置与源码)"></a>如何快速搭建好看的个人博客(完整配置与源码)</h1><blockquote>
<p>博客地址 <a href="http://www.inode.club/" target="_blank" rel="noopener">程序员成长指北</a> 就是这样搭建出来的! 可以先体验下。</p>
</blockquote>
<h2 id="为什么选择vuepress"><a href="#为什么选择vuepress" class="headerlink" title="为什么选择vuepress"></a>为什么选择vuepress</h2><p>之前使用docsify部署过个人博客, 在此之前也使用过gitbook, 这次使用vuepress来改版, 根据自己的体验, 将这三者做一个对比</p>
<ul>
<li><p>从阅读体验来说(个人感觉): gitbook &gt; docsify =vuepress</p>
</li>
<li><p>从配置上来说, docsify相比于vuepress和gitbook都要简单一些.</p>
</li>
<li><p>从性能上来说: vuepress &gt; docsify</p>
<p>虽然docsify也是基于vue的, docsify是运行时解析, vuepress是预先渲染HTML</p>
</li>
<li><p>灵活性上, vuepress也是相当占优势的, 对vue熟悉的朋友可以编写vue组件实现你想要的功能样式</p>
</li>
</ul>
<h3 id="vuepress特性"><a href="#vuepress特性" class="headerlink" title="vuepress特性"></a><strong>vuepress特性</strong></h3><ul>
<li>为技术文档而优化的内置Markdown拓展</li>
<li>在Markdown文件中使用Vue组件的能力</li>
<li>Vue驱动的自定义主题系统</li>
<li>自动生成Service Worker(支持PWA)</li>
<li>Google Analytics集成</li>
<li>基于Git的”最后更新时间</li>
<li>多语言支持</li>
<li>响应式布局</li>
<li>支持PWA模式</li>
</ul>
<p>总的来说, 使用vuepress优势有挺多的, 特别是我之前使用docsify搭建的网站, 是一点也没有被浏览器收录啊, 怎么都搜不到,受到一万点打击,所以决心改一改</p>
<p>其实<a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener">vuepress的官网</a>已经写的挺好的了, 但是我这篇文章也有优势啊,是一步步的教你搭建, 这样就不用来回在文档中去找什么配置.(当然如果你想直接通过官网来学习, 可以直接看官网,点击链接就可以喔)</p>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="安装vuepress"><a href="#安装vuepress" class="headerlink" title="安装vuepress"></a><strong>安装vuepress</strong></h3><p>第一步就是进行vuepress进行安装: 如果使用npm来安装, Node.js版本需要 &gt;=8 才可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add vuepress # 或者：npm install -g vuepress</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果你的现有项目依赖了 webpack 3.x，推荐使用 Yarn而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。</p>
</blockquote>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><strong>初始化项目</strong></h3><p>创建项目目录<code>blog</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init -y # 或者 npm init -y</span><br></pre></td></tr></table></figure>

<p>初始化完成后, 会创建一个package.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;blog&quot;,  </span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在package.json中, 配置启动命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,</span><br><span class="line">    &quot;docs:build&quot;: &quot;vuepress build docs&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>启动项目: <code>npm run docs:dev</code>这条命令就等于<code>vuepress dev docs</code></p>
<p>打包项目: <code>npm run build</code> 这条命令就等于 <code>vuepress build docs</code></p>
<p>创建docs目录, 主要用于放置我们写的<code>.md</code>类型的文章以及<code>.vuepress</code>相关的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir docs</span><br></pre></td></tr></table></figure>

<p>接着在docs文件夹中创建<code>.vuepress</code>文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd docs</span><br><span class="line">mkdir .vuepress</span><br></pre></td></tr></table></figure>

<p>这个文件主要就是放vuepress相关的<a href="https://v1.vuepress.vuejs.org/zh/config/#基本配置" target="_blank" rel="noopener">配置</a></p>
<p>到这一步, 我们的项目大体架子已经搭建出来了,接下来进行配置.</p>
<h2 id="页面具体内容配置"><a href="#页面具体内容配置" class="headerlink" title="页面具体内容配置"></a>页面具体内容配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a><strong>基本配置</strong></h3><p>接下来要让页面显示内容, 就需要进行配置, 新建一个总的配置文件<code>config.js</code>, 这个文件的名字是固定的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .vuepress</span><br><span class="line">touch config.js</span><br></pre></td></tr></table></figure>

<p><code>config.js</code>最基础的配置文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    title: &#39;koala的博客&#39;,</span><br><span class="line">    description: &#39;专注 Node.js 技术栈分享，从前端到Node.js再到数据库&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这时运行<code>npm run docs:dev</code>或者<code>yarn docs:dev</code>, 会出现页面404页面,vuepress默认打开的是docs下的<code>readme.md</code>文件, 由于你没有创建,所以找到的是vuepress默认提供的404页面, 关于这有点,我们借助<a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a>工具来查看一下vue的结构</p>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59c8e15587e40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>在docs目录下创建<code>README.md</code>文件, 再运行,就可以看到运行起来的效果, 如下图所示:</p>
<ul>
<li>blog001.jpg</li>
</ul>
<h3 id="设置封面页"><a href="#设置封面页" class="headerlink" title="设置封面页"></a><strong>设置封面页</strong></h3><p>此时<code>README</code>文件中没有内容,封面页是空的, 我们可以通过在这个markdown文件中写一些内容, 同时官方也给我们提供了封面页的模板(个人觉得还是比较实用的):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">home: true</span><br><span class="line">heroImage: &#x2F;home.png</span><br><span class="line">actionText: Get Started →</span><br><span class="line">actionLink: &#x2F;node&#x2F;</span><br><span class="line">features:</span><br><span class="line">- title: day day up</span><br><span class="line">  details: 记录每一天的进步, 一分耕耘，一分收获.</span><br><span class="line">- title: 程序员成长指北</span><br><span class="line">  details: 专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师</span><br><span class="line">- title: koala</span><br><span class="line">  details: 一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。</span><br><span class="line">footer: MIT Licensed | Copyright © 2018-present Evan You</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>效果图如下:</p>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cc52c658352?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="配置导航栏nav"><a href="#配置导航栏nav" class="headerlink" title="配置导航栏nav"></a><strong>配置导航栏nav</strong></h3><p>在<code>config.js</code>中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">themeConfig:&#123;</span><br><span class="line">  nav: [&#123;text: &quot;主页&quot;, link: &quot;&#x2F;&quot;      &#125;,</span><br><span class="line">      &#123; text: &quot;node&quot;, link: &quot;&#x2F;node&#x2F;&quot; &#125;,</span><br><span class="line">      &#123; text: &quot;前端&quot;, link: &quot;&#x2F;webframe&#x2F;&quot;&#125;,</span><br><span class="line">      &#123; text: &quot;数据库&quot;, link: &quot;&#x2F;database&#x2F;&quot;   &#125;,</span><br><span class="line">      &#123; text: &quot;android&quot;, link: &quot;&#x2F;android&#x2F;&quot;   &#125;,</span><br><span class="line">      &#123; text: &quot;面试问题&quot;, link: &quot;&#x2F;interview&#x2F;&quot; &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下图:</p>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cca4e693662?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>如果想要展示二级导航, 可以这样配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">themeConfig:&#123;</span><br><span class="line">  nav: [&#123;text: &quot;主页&quot;, link: &quot;&#x2F;&quot;      &#125;,</span><br><span class="line">      &#123; text: &quot;node&quot;, link: &quot;&#x2F;node&#x2F;&quot; &#125;,</span><br><span class="line">      &#123; text: &quot;前端&quot;, </span><br><span class="line">        items: [ </span><br><span class="line">          &#123; text: &quot;html&quot;, link:&quot;&#x2F;web&#x2F;html&#x2F;&quot;&#125;,</span><br><span class="line">          &#123; text: &quot;css&quot;, link:&quot;&#x2F;web&#x2F;css&#x2F;&quot;&#125;,</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; text: &quot;数据库&quot;, link: &quot;&#x2F;database&#x2F;&quot;   &#125;,</span><br><span class="line">      &#123; text: &quot;android&quot;, link: &quot;&#x2F;android&#x2F;&quot;   &#125;,</span><br><span class="line">      &#123; text: &quot;面试问题&quot;, link: &quot;&#x2F;interview&#x2F;&quot; &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如图所示:</p>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cce0571a8df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>当你使用上面的方式配置nav时, 目录结构最好和我创建的一样 项目目录结构如下:</p>
</blockquote>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cd3042159f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>导航栏创建好了, 接下来就是配置页面内容中的侧边栏slider</p>
<h3 id="配置侧边栏slider"><a href="#配置侧边栏slider" class="headerlink" title="配置侧边栏slider"></a><strong>配置侧边栏slider</strong></h3><h4 id="1-自动获取侧边栏内容"><a href="#1-自动获取侧边栏内容" class="headerlink" title="1.自动获取侧边栏内容"></a>1.自动获取侧边栏内容</h4><p>如果你希望自动生成当前页面标题的侧边栏, 可以在<code>config.js</code>中配置来启用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .vuepress&#x2F;config.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  themeConfig:&#123;</span><br><span class="line">    sidebar: &#39;auto&#39;,</span><br><span class="line">    &#x2F;&#x2F; sidebarDepth: 1 </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-展示每个页面的侧边栏"><a href="#2-展示每个页面的侧边栏" class="headerlink" title="2.展示每个页面的侧边栏"></a>2.展示每个页面的侧边栏</h4><p>如果你希望为不同的页面组显示不同的侧边栏, 就和官网一样, 点击<code>指南</code>显示的是对应的侧边栏,目前目录有<code>node \ database \ web</code>等, 这些目录下都存放着多个md文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  themeConfig:&#123;</span><br><span class="line">    sidebar:&#123;</span><br><span class="line">      &quot;&#x2F;node&#x2F;&quot;:[</span><br><span class="line">        [&quot;&quot;, &quot;node目录&quot;],</span><br><span class="line">        [&quot;path&quot;, &quot;作为前端也需要知道的路径知识&quot;],</span><br><span class="line">        [&quot;stream&quot;, &quot;node核心模块-stream&quot;]</span><br><span class="line">      ],</span><br><span class="line">      &quot;&#x2F;web&#x2F;&quot;:[</span><br><span class="line">        [&quot;&quot;, &quot;前端&quot;],</span><br><span class="line">        &#123;</span><br><span class="line">          title: &quot;css&quot;,</span><br><span class="line">          name: &quot;css&quot;,</span><br><span class="line">          collabsable: false,</span><br><span class="line">          children: [</span><br><span class="line">            [&quot;css&#x2F;&quot;, &quot;目录&quot;],</span><br><span class="line">            [&#39;css&#x2F;1&#39;, &quot;css常考面试题&quot;]</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置的效果图如下: 在<code>node</code>导航下:<img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cd92669ea17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>在<code>前端</code>导航下的效果:<img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59cdd5ce60931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>上面采用了两个方式配置侧边栏, 一个侧边栏是<code>node</code>目录下直接是写的markdown文章, 而在<code>web</code>下又有多个分类, 所有有进行了分栏配置, 其实这两种方式在我们博客中都是比较常见的</p>
<h2 id="自定义布局内容"><a href="#自定义布局内容" class="headerlink" title="自定义布局内容"></a>自定义布局内容</h2><p>网站的导航和侧边栏都已经配置好之后, 如果你觉得页面不是很符合你的预期, 你也可以自定修改成你想要的效果。比如就像我的博客中左侧固定的内容, 就是自定义的全局组件. 这里使用vuepress提供的插件机制来实现</p>
<p>在.vuepress文件夹下创建components文件夹, 在components下再创建<code>fixed.vue</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;fixed_container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;tencent_code&quot;&gt;</span><br><span class="line">      &lt;h4&gt;关注作者公众&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;和万千小伙伴一起学习&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;img src&#x3D;&quot;&#x2F;ggh.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;group_code&quot;&gt;</span><br><span class="line">      &lt;h4&gt;加入技术交流群&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;p&gt;扫描二维码 备注</span><br><span class="line">        &lt;span&gt; 加群&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;img src&#x3D;&quot;&#x2F;wechat.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;fixed&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"> ....</span><br><span class="line"> &#x2F;&#x2F; 这里省略了部分样式代码, 想看全部的小伙伴点开github地址就可以了</span><br></pre></td></tr></table></figure>

<p>然后在配置文件中以插件的形式配置即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 插件</span><br><span class="line">plugins:[</span><br><span class="line">  &#123;</span><br><span class="line">    name:&quot;page-plugin&quot;,</span><br><span class="line">    globalUIComponents:[&quot;fixed&quot;], </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>globalUIComponents</code>是用于注入全局的UI, 它以数组的形式接收参数名字, 这里的名字必须与components文件夹下的<code>.vue</code>文件同名, <strong>全局UI就是一个Vue组件</strong>; 其实vuepress也提供了一些内置的全局UI组件, 例如:<code>back-to-top</code>, <code>popup</code>, <code>nprogress</code>等.</p>
<h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a><strong>配置插件</strong></h3><h3 id="UI插件"><a href="#UI插件" class="headerlink" title="UI插件"></a><strong>UI插件</strong></h3><p>配置内置的全局UI,首先需要插件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @vuepress&#x2F;plugin-back-to-top @vuepress&#x2F;plugin-nprogress</span><br><span class="line"># OR npm install -D @vuepress&#x2F;plugin-back-to-top  @vuepress&#x2F;plugin-nprogress</span><br></pre></td></tr></table></figure>

<p>在config.js中配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line"> [&quot;@vuepress&#x2F;back-to-top&quot;], &#x2F;&#x2F; 返回顶部</span><br><span class="line"> [&quot;@vuepress&#x2F;nprogress&quot;],   &#x2F;&#x2F; 加载进度条</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意一点就是看你项目中是否安装了<code>vuepress</code>, 由于我之前是全局安装的, 在项目下还没有安装, 插件是依赖于<code>vuepress</code>的, 所有没有安装的需要安装上, 插件才有效.</p>
</blockquote>
<h3 id="支持PWA"><a href="#支持PWA" class="headerlink" title="支持PWA"></a><strong>支持PWA</strong></h3><p>vuepress还有一个我比较看重的优势, 就是支持PWA, 当用户没有网的情况下,一样能继续的访问我们的网站</p>
<p>在<code>0.x</code> 版本中我们只要配置<code>serviceWorker: true</code> 即可, 但是我们现在使用的是<code>1.2.0</code>版本, 这个版本中已经将这个功能抽离出来作为插件的方式使用, 下面就看一下具体如何使用的:</p>
<p>首先需要安装插件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @vuepress&#x2F;plugin-pwa</span><br><span class="line"># 或者 npm install -D @vuepress&#x2F;plugin-pwa</span><br></pre></td></tr></table></figure>

<p>在<code>config.js</code>中配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [&#39;@vuepress&#x2F;pwa&#39;, &#123;</span><br><span class="line">    serviceWorker: true,</span><br><span class="line">    updatePopup: true</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点:</p>
<blockquote>
<h4 id="为了让你的网站完全地兼容-PWA，你需要"><a href="#为了让你的网站完全地兼容-PWA，你需要" class="headerlink" title="为了让你的网站完全地兼容 PWA，你需要:"></a>为了让你的网站完全地兼容 PWA，你需要:</h4><ul>
<li>在 .vuepress/public 提供 Manifest 和 icons</li>
<li>在 <code>.vuepress/config.js</code> 添加正确的 <code>head links</code></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 配置</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  head: [</span><br><span class="line">    [&#39;link&#39;, &#123; rel: &#39;icon&#39;, href: &#96;&#x2F;favicon.ico&#96; &#125;],</span><br><span class="line">    &#x2F;&#x2F;增加manifest.json</span><br><span class="line">    [&#39;link&#39;, &#123; rel: &#39;manifest&#39;, href: &#39;&#x2F;manifest.json&#39; &#125;],</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>manifest.json 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koala_blog&quot;,</span><br><span class="line">  &quot;short_name&quot;: &quot;blog&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;程序员成长指北博主, koala的博客&quot;,</span><br><span class="line">  &quot;manifest_version&quot;: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置评论"><a href="#配置评论" class="headerlink" title="配置评论"></a><strong>配置评论</strong></h3><p>由于之前有小伙伴说过,『程序员成长指北』公众号上不能评论，所有这次我在博客中增加了评论功能，刚开始本来打算使用gitTalk, 但是我的博客采用的是部署到自己的服务器, 并没有部署成 GitHub Pages, 所有我使用的是<code>valine</code>, 它除了评论功能还可以统计阅读量, 请大家看:</p>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59d08fa824ffd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>但是我后面也会将gitTalk配置方式写出来, 方便使用gitTalk的小伙伴</p>
<h4 id="valine-使用"><a href="#valine-使用" class="headerlink" title="valine 使用"></a>valine 使用</h4><p>点击进入 <a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">Valine官网</a> ，需要先注册才能使用.</p>
<p>然后创建应用, 获取APP ID 和APP KEY</p>
<p><img src="http://user-gold-cdn.xitu.io/2019/12/31/16f59d13ffd4d3b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置 &gt; 应用Key</code>，然后就能看到你的APP ID 和APP Key了</p>
<ul>
<li>安装:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuepress-plugin-comment -D</span><br></pre></td></tr></table></figure>

<ul>
<li>快速使用</li>
</ul>
<p>在<code>.vuepress</code>下的config.js插件配置中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &#39;vuepress-plugin-comment&#39;,</span><br><span class="line">      &#123;</span><br><span class="line">        choosen: &#39;valine&#39;, </span><br><span class="line">        &#x2F;&#x2F; options选项中的所有参数，会传给Valine的配置</span><br><span class="line">        options: &#123;</span><br><span class="line">          el: &#39;#valine-vuepress-comment&#39;,</span><br><span class="line">          appId: &#39;Your own appId&#39;,</span><br><span class="line">          appKey: &#39;Your own appKey&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>appid和appkey为你创建的应用的APP ID 和APP Key</p>
<h4 id="gitTalk-使用"><a href="#gitTalk-使用" class="headerlink" title="gitTalk 使用"></a>gitTalk 使用</h4><h3 id="主题样式修改"><a href="#主题样式修改" class="headerlink" title="主题样式修改"></a><strong>主题样式修改</strong></h3><p>vuepress默认是主题颜色是绿色, 如果你不喜欢可以对其进行更改. 如果要对默认设置的样式进行简单颜色替换, 或者自定义一些颜色变量供以后使用, 可以在<code>.vuepress/styles</code>下创建<code>palette.styl</code>文件.</p>
<p>你可以调整的颜色变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 颜色</span><br><span class="line">$textColor ?&#x3D; #2c3e50</span><br><span class="line">$accentColor ?&#x3D; #1e90ff</span><br><span class="line">$grayTextColor ?&#x3D; #666</span><br><span class="line">$lightTextColor ?&#x3D; #999</span><br><span class="line">$borderColor ?&#x3D; #eaecef</span><br><span class="line">$codeBgColor ?&#x3D; #282c34</span><br><span class="line">$arrowBgColor ?&#x3D; #ccc</span><br><span class="line">$navbarColor ?&#x3D; #fff</span><br><span class="line">$headerColor ?&#x3D; #fff</span><br><span class="line">$headerTitleColor ?&#x3D; #fff</span><br><span class="line">$nprogressColor ?&#x3D; $accentColor</span><br><span class="line">&#x2F;&#x2F; 布局</span><br><span class="line">bannerHeight ?&#x3D; 12rem &#x2F;&#x2F; 响应式 breakpoints</span><br><span class="line">MQNarrow ?&#x3D; 1024px</span><br><span class="line">MQMobileNarrow ?&#x3D; 480px</span><br></pre></td></tr></table></figure>



<blockquote>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h4><p>你应该只在这个文件中写入颜色变量。因为 <code>palette.styl</code> 将在根的 stylus 配置文件的末尾引入，作为配置，它将被多个文件使用，所以一旦你在这里写了样式，你的样式就会被多次复制</p>
</blockquote>
<p>如果要添加额外的样式, vuepress也是提供了简便方法的, 只要在<code>.vuepress/styles</code>文件下创建一个 <code>index.styl</code>, 在里面写css样式即可, 注意文件命名是固定的.</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="nginx部署"><a href="#nginx部署" class="headerlink" title="nginx部署"></a><strong>nginx部署</strong></h3><p>我的博客采用的是静态文件部署, 感觉方便又便捷, 之前部署在Github Pages上, 访问速度不是很理想.</p>
<p><strong>第一步: 确保你满足下面几个条件</strong></p>
<ul>
<li>你有一台服务器</li>
<li>已经安装好nginx, 如果不会的小伙伴请看<a href="https://www.jianshu.com/p/320a48fcef57" target="_blank" rel="noopener">如何安装nginx</a></li>
<li>解析了一个可用的域名</li>
</ul>
<p><strong>第二步: 打包你的项目</strong></p>
<p>运行<code>npm run docs:build</code>将项目打包, 默认打包文件在<code>docs/.vuepress/dist</code>目录下</p>
<p><strong>第三步: 配置nginx</strong></p>
<p>进入到nginx 配置目录, 找到conf.d文件, 添加下面的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.inode.club;</span><br><span class="line"></span><br><span class="line">    root     &#x2F;usr&#x2F;web&#x2F;inode&#x2F;dist;</span><br><span class="line"></span><br><span class="line">    error_log   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;inode-error.log;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;inode-access.log;</span><br><span class="line"></span><br><span class="line">    #        deny all;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>server_name 是你解析的域名地址</li>
<li>root 配置文件将访问的静态资源文件的路径</li>
</ul>
<p>*<em>第四步: 上传静态资源文件 *</em></p>
<p>将静态资源文件放置到服务器上, 路径为配置的<code>/usr/web/inode/dist</code>, 可以借助xftp工具上传也可以通过git克隆, 选择适合自己的方式就可以</p>
<p>*<em>第五步: 重启nginx *</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 重启之前务必检查配置是否正确</span><br><span class="line">sudo nginx -t  &#x2F;&#x2F; 检查配置</span><br><span class="line">sudo nginx -s reload  &#x2F;&#x2F; 重启</span><br></pre></td></tr></table></figure>

<p>然后你就可以通过域名来访问你的网站啦!</p>
<h3 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a><strong>github部署</strong></h3><p>将代码部署到 Github Pages, 你可以看vuepress文档: <a href="https://vuepress.vuejs.org/zh/guide/deploy.html#github-pages" target="_blank" rel="noopener">vuepress部署</a>, 也参照我这里写的的步骤来部署</p>
<p><strong>第一步: 首先确保你的项目满足以下几个条件:</strong></p>
<ul>
<li>文档放置在docs目录中</li>
<li>使用的是默认的构建输出位置</li>
<li>vuepress以本地依赖的形式被安装到你的项目中, 在根目录<code>package.json</code>文件中包含如下代码:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 配置npm scripts</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,</span><br><span class="line">    &quot;docs:build&quot;: &quot;vuepress build docs&quot;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; VuePress 以本地依赖的形式被安装</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;vuepress&quot;: &quot;^1.2.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步: 创建github仓库</strong></p>
<p>在github上创建一个名为blog的仓库, 并将代码提交到github上</p>
<p><strong>第三步: 配置仓库名称</strong></p>
<p>配置<code>docs/.vuepress/config.js</code>文件中的base, 如果打算发布到<code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code>(也就是说你的仓库在: <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code> ), 此处我的仓库为: blog, 则将base按照如下配置即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  base: &quot;&#x2F;blog&#x2F;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步: 在项目根目录中,创建一个如下的脚本文件<code>deploy.sh</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env sh</span><br><span class="line"></span><br><span class="line"># 确保脚本抛出遇到的错误</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># 生成静态文件</span><br><span class="line">npm run docs:build</span><br><span class="line"></span><br><span class="line"># 进入生成的文件夹</span><br><span class="line">cd docs&#x2F;.vuepress&#x2F;dist</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &#39;deploy&#39;</span><br><span class="line"></span><br><span class="line"># 如果发布到 https:&#x2F;&#x2F;&lt;USERNAME&gt;.github.io&#x2F;&lt;REPO&gt;</span><br><span class="line">git push -f git@github.com:&lt;USERNAME&gt;&#x2F;&lt;REPO&gt;.git master:gh-pages</span><br><span class="line"># 例如 git push -f git@github.com:koala-coding&#x2F;blog.git master:gh-pages </span><br><span class="line">cd -</span><br></pre></td></tr></table></figure>

<p><strong>第五步: 双击 deploy.sh 运行脚本</strong></p>
<p>会自动在我们的 GitHub 仓库中，创建一个名为 gh-pages 的分支，而我们要部署到 GitHub Pages 的正是这个分支</p>
<p><strong>**第六步: setting Github Pages</strong> 这是最后一步了，在 GitHub 项目点击 Setting 按钮，找到 GitHub Pages - Source，选择 gh-pages 分支，点击 Save 按钮后，静静地等待它部署完成即可。</p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>我的网站 <a href="http://www.inode.club" target="_blank" rel="noopener">程序员成长指北</a> 就是这样搭建出来的!</p>
<p>本文章实现的内容都已经上传到github, 如果不想一步步进行配置的, 可以直接下载下来使用,就不用重复造轮子啦!</p>
<blockquote>
<p>需要博客源码的小伙伴可以直接<strong>公众后台</strong>回复【<strong>博客</strong>】领取，或者直接联系我。</p>
</blockquote>
<p>参考文章</p>
<ul>
<li><a href="https://juejin.im/post/5c94ddf35188252d65344cfe" target="_blank" rel="noopener">https://juejin.im/post/5c94ddf35188252d65344cfe</a></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/agent/">动态代理设计模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/agent/" data-flag-title="动态代理设计模式"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="10分钟看懂动态代理设计模式"><a href="#10分钟看懂动态代理设计模式" class="headerlink" title="10分钟看懂动态代理设计模式"></a>10分钟看懂动态代理设计模式</h1><blockquote>
<p>动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。</p>
</blockquote>
<h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。</p>
<p>是的，你没有看错，代理就是这么简单！</p>
<p>理解了代理的意思，你脑海中恐怕还有两个巨大的疑问：</p>
<ul>
<li>怎么实现代理模式</li>
<li>代理模式有什么实际用途</li>
</ul>
<p>要理解这两个问题，看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface Flyable &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Bird implements Flyable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;Bird is flying...&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？</p>
<p>有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void fly() &#123;</span><br><span class="line">     long start &#x3D; System.currentTimeMillis();</span><br><span class="line">     System.out.println(&quot;Bird is flying...&quot;);</span><br><span class="line">     try &#123;</span><br><span class="line">         Thread.sleep(new Random().nextInt(1000));</span><br><span class="line">     &#125; catch (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     long end &#x3D; System.currentTimeMillis();</span><br><span class="line">     System.out.println(&quot;Fly time &#x3D; &quot; + (end - start));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？</p>
<p>一定会有人说，我可以在调用的地方这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Bird bird &#x3D; new Bird();</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        bird.fly();</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Fly time &#x3D; &quot; + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？</p>
<h5 id="a）使用继承"><a href="#a）使用继承" class="headerlink" title="a）使用继承"></a>a）使用继承</h5><p>继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。 为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Bird2 extends Bird &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        super.fly();</span><br><span class="line">        </span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Fly time &#x3D; &quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种解决方案，还有一种解决方案叫做：<strong>聚合</strong>，其实也是比较容易想到的。 我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Bird3 implements Flyable &#123;</span><br><span class="line">    private Bird bird;</span><br><span class="line"></span><br><span class="line">    public Bird3(Bird bird) &#123;</span><br><span class="line">        this.bird &#x3D; bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        bird.fly();</span><br><span class="line"></span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Fly time &#x3D; &quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！</p>
<p>继续深入思考，用问题推导来解答这个问题：</p>
<p><strong>问题一</strong>：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？ 有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。</p>
<p><strong>问题二</strong>：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？ 有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。</p>
<p>问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 <a href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" target="_blank" rel="noopener">聚合</a> 是否可以避免这个问题呢？ 答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Bird3 implements Flyable &#123;</span><br><span class="line">    private Flyable flyable;</span><br><span class="line"></span><br><span class="line">    public Bird3(Flyable flyable) &#123;</span><br><span class="line">        this.flyable &#x3D; flyable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        flyable.fly();</span><br><span class="line"></span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Fly time &#x3D; &quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BirdLogProxy implements Flyable &#123;</span><br><span class="line">    private Flyable flyable;</span><br><span class="line"></span><br><span class="line">    public BirdLogProxy(Flyable flyable) &#123;</span><br><span class="line">        this.flyable &#x3D; flyable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;Bird fly start...&quot;);</span><br><span class="line"></span><br><span class="line">        flyable.fly();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Bird fly end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Bird bird &#x3D; new Bird();</span><br><span class="line">    BirdLogProxy p1 &#x3D; new BirdLogProxy(bird);</span><br><span class="line">    BirdTimeProxy p2 &#x3D; new BirdTimeProxy(p1);</span><br><span class="line"></span><br><span class="line">    p2.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反过来，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Bird bird &#x3D; new Bird();</span><br><span class="line">       BirdTimeProxy p2 &#x3D; new BirdTimeProxy(bird);</span><br><span class="line">       BirdLogProxy p1 &#x3D; new BirdLogProxy(p2);</span><br><span class="line"></span><br><span class="line">       p1.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 <a href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" target="_blank" rel="noopener">聚合</a> 可以做到，而继承不行呢。我们用一张图来解释一下：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba292275e28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。</p>
<p>从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题：</p>
<ul>
<li>如果同时代理多个类，依然会导致类无限制扩展</li>
<li>如果类中有多个方法，同样的逻辑需要反复实现</li>
</ul>
<p>那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：<strong>动态代理</strong>。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。</p>
<p>这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923a81ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 这个第三方库帮我们生成TimeProxy的源码。希望 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 不要成为你的负担，不理解 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 没有关系，你只要把它当成一个Java源码生成工具使用即可。</p>
<p>PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。</p>
<h5 id="第一步：生成TimeProxy源码"><a href="#第一步：生成TimeProxy源码" class="headerlink" title="第一步：生成TimeProxy源码"></a>第一步：生成TimeProxy源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy &#123;</span><br><span class="line"></span><br><span class="line">    public static Object newProxyInstance() throws IOException &#123;</span><br><span class="line">        TypeSpec.Builder typeSpecBuilder &#x3D; TypeSpec.classBuilder(&quot;TimeProxy&quot;)</span><br><span class="line">                .addSuperinterface(Flyable.class);</span><br><span class="line"></span><br><span class="line">        FieldSpec fieldSpec &#x3D; FieldSpec.builder(Flyable.class, &quot;flyable&quot;, Modifier.PRIVATE).build();</span><br><span class="line">        typeSpecBuilder.addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">        MethodSpec constructorMethodSpec &#x3D; MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addParameter(Flyable.class, &quot;flyable&quot;)</span><br><span class="line">                .addStatement(&quot;this.flyable &#x3D; flyable&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        typeSpecBuilder.addMethod(constructorMethodSpec);</span><br><span class="line"></span><br><span class="line">        Method[] methods &#x3D; Flyable.class.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            MethodSpec methodSpec &#x3D; MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .addAnnotation(Override.class)</span><br><span class="line">                    .returns(method.getReturnType())</span><br><span class="line">                    .addStatement(&quot;long start &#x3D; $T.currentTimeMillis()&quot;, System.class)</span><br><span class="line">                    .addCode(&quot;\n&quot;)</span><br><span class="line">                    .addStatement(&quot;this.flyable.&quot; + method.getName() + &quot;()&quot;)</span><br><span class="line">                    .addCode(&quot;\n&quot;)</span><br><span class="line">                    .addStatement(&quot;long end &#x3D; $T.currentTimeMillis()&quot;, System.class)</span><br><span class="line">                    .addStatement(&quot;$T.out.println(\&quot;Fly Time &#x3D;\&quot; + (end - start))&quot;, System.class)</span><br><span class="line">                    .build();</span><br><span class="line">            typeSpecBuilder.addMethod(methodSpec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile &#x3D; JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build();</span><br><span class="line">        &#x2F;&#x2F; 为了看的更清楚，我将源码文件生成到桌面</span><br><span class="line">        javaFile.writeTo(new File(&quot;&#x2F;Users&#x2F;ouyangfeng&#x2F;Desktop&#x2F;&quot;));</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.youngfeng.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.Override;</span><br><span class="line">import java.lang.System;</span><br><span class="line"></span><br><span class="line">class TimeProxy implements Flyable &#123;</span><br><span class="line">  private Flyable flyable;</span><br><span class="line"></span><br><span class="line">  public TimeProxy(Flyable flyable) &#123;</span><br><span class="line">    this.flyable &#x3D; flyable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void fly() &#123;</span><br><span class="line">    long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    this.flyable.fly();</span><br><span class="line"></span><br><span class="line">    long end &#x3D; System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;Fly Time &#x3D;&quot; + (end - start));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二步：编译TimeProxy源码"><a href="#第二步：编译TimeProxy源码" class="headerlink" title="第二步：编译TimeProxy源码"></a>第二步：编译TimeProxy源码</h5><p>编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class JavaCompiler &#123;</span><br><span class="line"></span><br><span class="line">    public static void compile(File javaFile) throws IOException &#123;</span><br><span class="line">        javax.tools.JavaCompiler javaCompiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager &#x3D; javaCompiler.getStandardFileManager(null, null, null);</span><br><span class="line">        Iterable iterable &#x3D; fileManager.getJavaFileObjects(javaFile);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask task &#x3D; javaCompiler.getTask(null, fileManager, null, null, null, iterable);</span><br><span class="line">        task.call();</span><br><span class="line">        fileManager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 为了看的更清楚，我将源码文件生成到桌面</span><br><span class="line">String sourcePath &#x3D; &quot;&#x2F;Users&#x2F;ouyangfeng&#x2F;Desktop&#x2F;&quot;;</span><br><span class="line">javaFile.writeTo(new File(sourcePath));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 编译</span><br><span class="line">JavaCompiler.compile(new File(sourcePath + &quot;&#x2F;com&#x2F;youngfeng&#x2F;proxy&#x2F;TimeProxy.java&quot;));</span><br></pre></td></tr></table></figure>



<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923ae39e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h5 id="第三步：加载到内存中并创建对象"><a href="#第三步：加载到内存中并创建对象" class="headerlink" title="第三步：加载到内存中并创建对象"></a>第三步：加载到内存中并创建对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls &#x3D; new URL[] &#123;new URL(&quot;file:&#x2F;&quot; + sourcePath)&#125;;</span><br><span class="line">URLClassLoader classLoader &#x3D; new URLClassLoader(urls);</span><br><span class="line">Class clazz &#x3D; classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);</span><br><span class="line">Constructor constructor &#x3D; clazz.getConstructor(Flyable.class);</span><br><span class="line">Flyable flyable &#x3D; (Flyable) constructor.newInstance(new Bird());</span><br><span class="line">flyable.fly();</span><br></pre></td></tr></table></figure>

<p>通过以上三个步骤，我们至少解决了下面两个问题：</p>
<ul>
<li>不再需要手动创建TimeProxy</li>
<li>可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间</li>
</ul>
<p>可是，说好的任意对象呢？</p>
<h5 id="第四步：增加InvocationHandler接口"><a href="#第四步：增加InvocationHandler接口" class="headerlink" title="第四步：增加InvocationHandler接口"></a>第四步：增加InvocationHandler接口</h5><p>查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba293f2e59e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！</p>
<p>为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增<code>InvocationHandler</code>接口，用于处理自定义逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler &#123;</span><br><span class="line">    void invoke(Object proxy, Method method, Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）：</p>
<ul>
<li>proxy =&gt; 这个参数指定动态生成的代理类，这里是<code>TimeProxy</code></li>
<li>method =&gt; 这个参数表示传入接口中的所有Method对象</li>
<li>args =&gt; 这个参数对应当前method方法中的参数</li>
</ul>
<p>引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyInvocationHandler handler &#x3D; new MyInvocationHandler();</span><br><span class="line">Flyable proxy &#x3D; Proxy.newProxyInstance(Flyable.class, handler);</span><br><span class="line">proxy.fly();</span><br><span class="line"></span><br><span class="line">方法执行流：proxy.fly() &#x3D;&gt; handler.invoke()</span><br></pre></td></tr></table></figure>

<p>为此，我们需要在Proxy.newProxyInstance()方法中做如下改动：</p>
<ul>
<li>在newProxyInstance方法中传入InvocationHandler</li>
<li>在生成的代理类中增加成员变量handler</li>
<li>在生成的代理类方法中，调用invoke方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception &#123;</span><br><span class="line">       TypeSpec.Builder typeSpecBuilder &#x3D; TypeSpec.classBuilder(&quot;TimeProxy&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC)</span><br><span class="line">               .addSuperinterface(inf);</span><br><span class="line"></span><br><span class="line">       FieldSpec fieldSpec &#x3D; FieldSpec.builder(InvocationHandler.class, &quot;handler&quot;, Modifier.PRIVATE).build();</span><br><span class="line">       typeSpecBuilder.addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">       MethodSpec constructorMethodSpec &#x3D; MethodSpec.constructorBuilder()</span><br><span class="line">               .addModifiers(Modifier.PUBLIC)</span><br><span class="line">               .addParameter(InvocationHandler.class, &quot;handler&quot;)</span><br><span class="line">               .addStatement(&quot;this.handler &#x3D; handler&quot;)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       typeSpecBuilder.addMethod(constructorMethodSpec);</span><br><span class="line"></span><br><span class="line">       Method[] methods &#x3D; inf.getDeclaredMethods();</span><br><span class="line">       for (Method method : methods) &#123;</span><br><span class="line">           MethodSpec methodSpec &#x3D; MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                   .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                   .addAnnotation(Override.class)</span><br><span class="line">                   .returns(method.getReturnType())</span><br><span class="line">                   .addCode(&quot;try &#123;\n&quot;)</span><br><span class="line">                   .addStatement(&quot;\t$T method &#x3D; &quot; + inf.getName() + &quot;.class.getMethod(\&quot;&quot; + method.getName() + &quot;\&quot;)&quot;, Method.class)</span><br><span class="line">                   &#x2F;&#x2F; 为了简单起见，这里参数直接写死为空</span><br><span class="line">                   .addStatement(&quot;\tthis.handler.invoke(this, method, null)&quot;)</span><br><span class="line">                   .addCode(&quot;&#125; catch(Exception e) &#123;\n&quot;)</span><br><span class="line">                   .addCode(&quot;\te.printStackTrace();\n&quot;)</span><br><span class="line">                   .addCode(&quot;&#125;\n&quot;)</span><br><span class="line">                   .build();</span><br><span class="line">           typeSpecBuilder.addMethod(methodSpec);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       JavaFile javaFile &#x3D; JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build();</span><br><span class="line">       &#x2F;&#x2F; 为了看的更清楚，我将源码文件生成到桌面</span><br><span class="line">       String sourcePath &#x3D; &quot;&#x2F;Users&#x2F;ouyangfeng&#x2F;Desktop&#x2F;&quot;;</span><br><span class="line">       javaFile.writeTo(new File(sourcePath));</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 编译</span><br><span class="line">       JavaCompiler.compile(new File(sourcePath + &quot;&#x2F;com&#x2F;youngfeng&#x2F;proxy&#x2F;TimeProxy.java&quot;));</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 使用反射load到内存</span><br><span class="line">       URL[] urls &#x3D; new URL[] &#123;new URL(&quot;file:&quot; + sourcePath)&#125;;</span><br><span class="line">       URLClassLoader classLoader &#x3D; new URLClassLoader(urls);</span><br><span class="line">       Class clazz &#x3D; classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);</span><br><span class="line">       Constructor constructor &#x3D; clazz.getConstructor(InvocationHandler.class);</span><br><span class="line">       Object obj &#x3D; constructor.newInstance(handler);</span><br><span class="line"></span><br><span class="line">       return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码：</p>
<p><strong>测试代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird()));</span><br></pre></td></tr></table></figure>

<p><strong>生成的TimeProxy.java源码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.youngfeng.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.Override;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class TimeProxy implements Flyable &#123;</span><br><span class="line">  private InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">  public TimeProxy(InvocationHandler handler) &#123;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void fly() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    	Method method &#x3D; com.youngfeng.proxy.Flyable.class.getMethod(&quot;fly&quot;);</span><br><span class="line">    	this.handler.invoke(this, method, null);</span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyInvocationHandler.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Bird bird;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Bird bird) &#123;</span><br><span class="line">        this.bird &#x3D; bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void invoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            method.invoke(bird, new Object[] &#123;&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Fly time &#x3D; &quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，整个方法栈的调用栈变成了这样：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294367cdd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。</p>
<p>其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳：</p>
<ul>
<li>Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象</li>
<li>InvocationHandler：这个接口主要用于自定义代理逻辑处理</li>
<li>为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。</li>
</ul>
<p>查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。</p>
<p>这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？</p>
<p>想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！</p>
<p>只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。</p>
<p>事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。</p>
<h3 id="JDK实现揭秘"><a href="#JDK实现揭秘" class="headerlink" title="JDK实现揭秘"></a>JDK实现揭秘</h3><p>通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。</p>
<p><strong>Proxy.java</strong></p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294623577?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>InvocationHandler</strong></p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d87bf2f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义：</p>
<ul>
<li>Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。</li>
<li>Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。</li>
</ul>
<p>最后一个参数就不用说了，和我们实现的版本完全是一样的。</p>
<p>仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档：</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d92efdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><em>核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。</em></p>
<p>遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。</p>
<h3 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h3><h5 id="invoke方法的第一个参数proxy到底有什么作用？"><a href="#invoke方法的第一个参数proxy到底有什么作用？" class="headerlink" title="invoke方法的第一个参数proxy到底有什么作用？"></a>invoke方法的第一个参数proxy到底有什么作用？</h5><p>这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。</p>
<h5 id="动态代理到底有什么用？"><a href="#动态代理到底有什么用？" class="headerlink" title="动态代理到底有什么用？"></a>动态代理到底有什么用？</h5><p>学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 <a href="https://baike.baidu.com/item/AOP/1332219" target="_blank" rel="noopener">AOP</a>。所谓的AOP，就像刀一样，抓住时机，趁机插入。</p>
<p><img src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2dfeb24bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>基于这样一种动态特性，我们可以用它做很多事情，例如：</p>
<ul>
<li>事务提交或回退（Web开发中很常见）</li>
<li>权限管理</li>
<li>自定义缓存逻辑处理</li>
<li>SDK Bug修复 …</li>
</ul>
<p>如果你阅读过 <a href="https://github.com/yuanhoujun/Android_Slide_To_Close" target="_blank" rel="noopener">Android_Slide_To_Close</a> 的源码会发现，它也在某个地方使用了动态代理设计模式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。</p>
<p>为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点：</p>
<ul>
<li>至少已经理解了面向对象语言的多态特性</li>
<li>了解简单的反射用法</li>
<li>会简单使用 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 生成Java源码</li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="http://q1.qlogo.cn/g?b=qq&amp;nk=2391624941&amp;s=640" alt="avatar"></div><p class="sidebar-ov-author__text">人亦有言，举棋不定</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">24</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Apocalypse</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz',
    appKey: 'FihoucantYlc5U1FQ9BzkO3l',
    notify: true,
    verify: true,
    placeholder: 'Just go go',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>