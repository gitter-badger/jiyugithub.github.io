<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Apocalypse&#39;s Blog">
<meta property="og:url" content="https://jiyugithub.github.io/page/2/index.html">
<meta property="og:site_name" content="Apocalypse&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Apocalypse">
<meta name="twitter:card" content="summary"><meta name="keywords" content="Apocalypse, Apocalypse's Blog"><meta name="description" content=""><title>Apocalypse's Blog</title><link ref="canonical" href="https://jiyugithub.github.io/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Apocalypse's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/agent/">动态代理设计模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/agent/" data-flag-title="动态代理设计模式"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="10分钟看懂动态代理设计模式"   >
          <a href="#10分钟看懂动态代理设计模式" class="heading-link"><i class="fas fa-link"></i></a>10分钟看懂动态代理设计模式</h1>
      <blockquote>
<p>动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。</p>
</blockquote>

        <h3 id="什么是代理"   >
          <a href="#什么是代理" class="heading-link"><i class="fas fa-link"></i></a>什么是代理</h3>
      <p>从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。</p>
<p>是的，你没有看错，代理就是这么简单！</p>
<p>理解了代理的意思，你脑海中恐怕还有两个巨大的疑问：</p>
<ul>
<li>怎么实现代理模式</li>
<li>代理模式有什么实际用途</li>
</ul>
<p>要理解这两个问题，看一个简单的例子：</p>
<pre><code>public interface Flyable {
    void fly();
}

public class Bird implements Flyable {

    @Override
    public void fly() {
        System.out.println(&quot;Bird is flying...&quot;);
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？</p>
<p>有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。</p>
<pre><code>   @Override
    public void fly() {
        long start = System.currentTimeMillis();
        System.out.println(&quot;Bird is flying...&quot;);
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
</code></pre><p>的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？</p>
<p>一定会有人说，我可以在调用的地方这样写：</p>
<pre><code>public static void main(String[] args) {
        Bird bird = new Bird();
        long start = System.currentTimeMillis();
        bird.fly();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
}
</code></pre><p>这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？</p>

        <h5 id="a）使用继承"   >
          <a href="#a）使用继承" class="heading-link"><i class="fas fa-link"></i></a>a）使用继承</h5>
      <p>继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。 为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：</p>
<pre><code>public class Bird2 extends Bird {

    @Override
    public void fly() {
        long start = System.currentTimeMillis();

        super.fly();

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>这是一种解决方案，还有一种解决方案叫做：<strong>聚合</strong>，其实也是比较容易想到的。 我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：</p>
<pre><code>public class Bird3 implements Flyable {
    private Bird bird;

    public Bird3(Bird bird) {
        this.bird = bird;
    }

    @Override
    public void fly() {
        long start = System.currentTimeMillis();

        bird.fly();

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！</p>
<p>继续深入思考，用问题推导来解答这个问题：</p>
<p><strong>问题一</strong>：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？ 有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。</p>
<p><strong>问题二</strong>：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？ 有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。</p>
<p>问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 <span class="exturl"><a class="exturl__link"   href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition"  target="_blank" rel="noopener">聚合</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 是否可以避免这个问题呢？ 答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable</p>
<pre><code>public class Bird3 implements Flyable {
    private Flyable flyable;

    public Bird3(Flyable flyable) {
        this.flyable = flyable;
    }

    @Override
    public void fly() {
        long start = System.currentTimeMillis();

        flyable.fly();

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志：</p>
<pre><code>public class BirdLogProxy implements Flyable {
    private Flyable flyable;

    public BirdLogProxy(Flyable flyable) {
        this.flyable = flyable;
    }

    @Override
    public void fly() {
        System.out.println(&quot;Bird fly start...&quot;);

        flyable.fly();

        System.out.println(&quot;Bird fly end...&quot;);
    }
}
</code></pre><p>接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做：</p>
<pre><code>    public static void main(String[] args) {
        Bird bird = new Bird();
        BirdLogProxy p1 = new BirdLogProxy(bird);
        BirdTimeProxy p2 = new BirdTimeProxy(p1);

        p2.fly();
    }
</code></pre><p>反过来，可以这么做：</p>
<pre><code> public static void main(String[] args) {
        Bird bird = new Bird();
        BirdTimeProxy p2 = new BirdTimeProxy(bird);
        BirdLogProxy p1 = new BirdLogProxy(p2);

        p1.fly();
 }
</code></pre><p>看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 <span class="exturl"><a class="exturl__link"   href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition"  target="_blank" rel="noopener">聚合</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 可以做到，而继承不行呢。我们用一张图来解释一下：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba292275e28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h3 id="静态代理"   >
          <a href="#静态代理" class="heading-link"><i class="fas fa-link"></i></a>静态代理</h3>
      <p>接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。</p>
<p>从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题：</p>
<ul>
<li>如果同时代理多个类，依然会导致类无限制扩展</li>
<li>如果类中有多个方法，同样的逻辑需要反复实现</li>
</ul>
<p>那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：<strong>动态代理</strong>。</p>

        <h3 id="动态代理"   >
          <a href="#动态代理" class="heading-link"><i class="fas fa-link"></i></a>动态代理</h3>
      <p>继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。</p>
<p>这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923a81ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 <span class="exturl"><a class="exturl__link"   href="https://github.com/square/javapoet"  target="_blank" rel="noopener">JavaPoet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 这个第三方库帮我们生成TimeProxy的源码。希望 <span class="exturl"><a class="exturl__link"   href="https://github.com/square/javapoet"  target="_blank" rel="noopener">JavaPoet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 不要成为你的负担，不理解 <span class="exturl"><a class="exturl__link"   href="https://github.com/square/javapoet"  target="_blank" rel="noopener">JavaPoet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 没有关系，你只要把它当成一个Java源码生成工具使用即可。</p>
<p>PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。</p>

        <h5 id="第一步：生成TimeProxy源码"   >
          <a href="#第一步：生成TimeProxy源码" class="heading-link"><i class="fas fa-link"></i></a>第一步：生成TimeProxy源码</h5>
      <pre><code>public class Proxy {

    public static Object newProxyInstance() throws IOException {
        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;)
                .addSuperinterface(Flyable.class);

        FieldSpec fieldSpec = FieldSpec.builder(Flyable.class, &quot;flyable&quot;, Modifier.PRIVATE).build();
        typeSpecBuilder.addField(fieldSpec);

        MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(Flyable.class, &quot;flyable&quot;)
                .addStatement(&quot;this.flyable = flyable&quot;)
                .build();
        typeSpecBuilder.addMethod(constructorMethodSpec);

        Method[] methods = Flyable.class.getDeclaredMethods();
        for (Method method : methods) {
            MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName())
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class)
                    .returns(method.getReturnType())
                    .addStatement(&quot;long start = $T.currentTimeMillis()&quot;, System.class)
                    .addCode(&quot;\n&quot;)
                    .addStatement(&quot;this.flyable.&quot; + method.getName() + &quot;()&quot;)
                    .addCode(&quot;\n&quot;)
                    .addStatement(&quot;long end = $T.currentTimeMillis()&quot;, System.class)
                    .addStatement(&quot;$T.out.println(\&quot;Fly Time =\&quot; + (end - start))&quot;, System.class)
                    .build();
            typeSpecBuilder.addMethod(methodSpec);
        }

        JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build();
        // 为了看的更清楚，我将源码文件生成到桌面
        javaFile.writeTo(new File(&quot;/Users/ouyangfeng/Desktop/&quot;));

        return null;
    }

}
</code></pre><p>在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下：</p>
<pre><code>package com.youngfeng.proxy;

import java.lang.Override;
import java.lang.System;

class TimeProxy implements Flyable {
  private Flyable flyable;

  public TimeProxy(Flyable flyable) {
    this.flyable = flyable;
  }

  @Override
  public void fly() {
    long start = System.currentTimeMillis();

    this.flyable.fly();

    long end = System.currentTimeMillis();
    System.out.println(&quot;Fly Time =&quot; + (end - start));
  }
}
</code></pre>
        <h5 id="第二步：编译TimeProxy源码"   >
          <a href="#第二步：编译TimeProxy源码" class="heading-link"><i class="fas fa-link"></i></a>第二步：编译TimeProxy源码</h5>
      <p>编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作：</p>
<pre><code>public class JavaCompiler {

    public static void compile(File javaFile) throws IOException {
        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);
        Iterable iterable = fileManager.getJavaFileObjects(javaFile);
        javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);
        task.call();
        fileManager.close();
    }
}
</code></pre><p>在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成：</p>
<pre><code>// 为了看的更清楚，我将源码文件生成到桌面
String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;;
javaFile.writeTo(new File(sourcePath));

// 编译
JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;));
</code></pre><p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2923ae39e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h5 id="第三步：加载到内存中并创建对象"   >
          <a href="#第三步：加载到内存中并创建对象" class="heading-link"><i class="fas fa-link"></i></a>第三步：加载到内存中并创建对象</h5>
      <pre><code>  URL[] urls = new URL[] {new URL(&quot;file:/&quot; + sourcePath)};
  URLClassLoader classLoader = new URLClassLoader(urls);
  Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);
  Constructor constructor = clazz.getConstructor(Flyable.class);
  Flyable flyable = (Flyable) constructor.newInstance(new Bird());
  flyable.fly();
</code></pre><p>通过以上三个步骤，我们至少解决了下面两个问题：</p>
<ul>
<li>不再需要手动创建TimeProxy</li>
<li>可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间</li>
</ul>
<p>可是，说好的任意对象呢？</p>

        <h5 id="第四步：增加InvocationHandler接口"   >
          <a href="#第四步：增加InvocationHandler接口" class="heading-link"><i class="fas fa-link"></i></a>第四步：增加InvocationHandler接口</h5>
      <p>查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba293f2e59e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！</p>
<p>为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增<code>InvocationHandler</code>接口，用于处理自定义逻辑：</p>
<pre><code>public interface InvocationHandler {
    void invoke(Object proxy, Method method, Object[] args);
}
</code></pre><p>想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）：</p>
<ul>
<li>proxy =&gt; 这个参数指定动态生成的代理类，这里是<code>TimeProxy</code></li>
<li>method =&gt; 这个参数表示传入接口中的所有Method对象</li>
<li>args =&gt; 这个参数对应当前method方法中的参数</li>
</ul>
<p>引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样：</p>
<pre><code>MyInvocationHandler handler = new MyInvocationHandler();
Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler);
proxy.fly();

方法执行流：proxy.fly() =&gt; handler.invoke()
</code></pre><p>为此，我们需要在Proxy.newProxyInstance()方法中做如下改动：</p>
<ul>
<li>在newProxyInstance方法中传入InvocationHandler</li>
<li>在生成的代理类中增加成员变量handler</li>
<li>在生成的代理类方法中，调用invoke方法</li>
</ul>
<pre><code>  public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception {
        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(inf);

        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, &quot;handler&quot;, Modifier.PRIVATE).build();
        typeSpecBuilder.addField(fieldSpec);

        MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(InvocationHandler.class, &quot;handler&quot;)
                .addStatement(&quot;this.handler = handler&quot;)
                .build();

        typeSpecBuilder.addMethod(constructorMethodSpec);

        Method[] methods = inf.getDeclaredMethods();
        for (Method method : methods) {
            MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName())
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class)
                    .returns(method.getReturnType())
                    .addCode(&quot;try {\n&quot;)
                    .addStatement(&quot;\t$T method = &quot; + inf.getName() + &quot;.class.getMethod(\&quot;&quot; + method.getName() + &quot;\&quot;)&quot;, Method.class)
                    // 为了简单起见，这里参数直接写死为空
                    .addStatement(&quot;\tthis.handler.invoke(this, method, null)&quot;)
                    .addCode(&quot;} catch(Exception e) {\n&quot;)
                    .addCode(&quot;\te.printStackTrace();\n&quot;)
                    .addCode(&quot;}\n&quot;)
                    .build();
            typeSpecBuilder.addMethod(methodSpec);
        }

        JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build();
        // 为了看的更清楚，我将源码文件生成到桌面
        String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;;
        javaFile.writeTo(new File(sourcePath));

        // 编译
        JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;));

        // 使用反射load到内存
        URL[] urls = new URL[] {new URL(&quot;file:&quot; + sourcePath)};
        URLClassLoader classLoader = new URLClassLoader(urls);
        Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);
        Constructor constructor = clazz.getConstructor(InvocationHandler.class);
        Object obj = constructor.newInstance(handler);

        return obj;
 }
</code></pre><p>上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码：</p>
<p><strong>测试代码</strong></p>
<pre><code>Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird()));
</code></pre><p><strong>生成的TimeProxy.java源码</strong></p>
<pre><code>package com.youngfeng.proxy;

import java.lang.Override;
import java.lang.reflect.Method;

public class TimeProxy implements Flyable {
  private InvocationHandler handler;

  public TimeProxy(InvocationHandler handler) {
    this.handler = handler;
  }

  @Override
  public void fly() {
    try {
        Method method = com.youngfeng.proxy.Flyable.class.getMethod(&quot;fly&quot;);
        this.handler.invoke(this, method, null);
    } catch(Exception e) {
        e.printStackTrace();
    }
  }
}
</code></pre><p><strong>MyInvocationHandler.java</strong></p>
<pre><code>public class MyInvocationHandler implements InvocationHandler {
    private Bird bird;

    public MyInvocationHandler(Bird bird) {
        this.bird = bird;
    }

    @Override
    public void invoke(Object proxy, Method method, Object[] args) {
        long start = System.currentTimeMillis();

        try {
            method.invoke(bird, new Object[] {});
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;Fly time = &quot; + (end - start));
    }
}
</code></pre><p>至此，整个方法栈的调用栈变成了这样：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294367cdd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。</p>
<p>其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。</p>

        <h3 id="如何使用"   >
          <a href="#如何使用" class="heading-link"><i class="fas fa-link"></i></a>如何使用</h3>
      <p>上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳：</p>
<ul>
<li>Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象</li>
<li>InvocationHandler：这个接口主要用于自定义代理逻辑处理</li>
<li>为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。</li>
</ul>
<p>查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。</p>
<p>这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？</p>
<p>想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！</p>
<p>只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。</p>
<p>事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。</p>

        <h3 id="JDK实现揭秘"   >
          <a href="#JDK实现揭秘" class="heading-link"><i class="fas fa-link"></i></a>JDK实现揭秘</h3>
      <p>通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。</p>
<p><strong>Proxy.java</strong></p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba294623577?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><strong>InvocationHandler</strong></p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d87bf2f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义：</p>
<ul>
<li>Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。</li>
<li>Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。</li>
</ul>
<p>最后一个参数就不用说了，和我们实现的版本完全是一样的。</p>
<p>仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2d92efdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><em>核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。</em></p>
<p>遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。</p>

        <h3 id="答疑解惑"   >
          <a href="#答疑解惑" class="heading-link"><i class="fas fa-link"></i></a>答疑解惑</h3>
      
        <h5 id="invoke方法的第一个参数proxy到底有什么作用？"   >
          <a href="#invoke方法的第一个参数proxy到底有什么作用？" class="heading-link"><i class="fas fa-link"></i></a>invoke方法的第一个参数proxy到底有什么作用？</h5>
      <p>这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。</p>

        <h5 id="动态代理到底有什么用？"   >
          <a href="#动态代理到底有什么用？" class="heading-link"><i class="fas fa-link"></i></a>动态代理到底有什么用？</h5>
      <p>学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 <span class="exturl"><a class="exturl__link"   href="https://baike.baidu.com/item/AOP/1332219"  target="_blank" rel="noopener">AOP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。所谓的AOP，就像刀一样，抓住时机，趁机插入。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/3/2/161e5ba2dfeb24bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>基于这样一种动态特性，我们可以用它做很多事情，例如：</p>
<ul>
<li>事务提交或回退（Web开发中很常见）</li>
<li>权限管理</li>
<li>自定义缓存逻辑处理</li>
<li>SDK Bug修复 …</li>
</ul>
<p>如果你阅读过 <span class="exturl"><a class="exturl__link"   href="https://github.com/yuanhoujun/Android_Slide_To_Close"  target="_blank" rel="noopener">Android_Slide_To_Close</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 的源码会发现，它也在某个地方使用了动态代理设计模式。</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。</p>
<p>为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点：</p>
<ul>
<li>至少已经理解了面向对象语言的多态特性</li>
<li>了解简单的反射用法</li>
<li>会简单使用 <span class="exturl"><a class="exturl__link"   href="https://github.com/square/javapoet"  target="_blank" rel="noopener">JavaPoet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 生成Java源码</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/socket/">手把手教你写Socket长连接</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/socket/" data-flag-title="手把手教你写Socket长连接"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>本篇我们先简单了解一下 TCP/IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。</p>

        <h2 id="TCP-IP-协议简介"   >
          <a href="#TCP-IP-协议简介" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP 协议简介</h2>
      
        <h4 id="IP"   >
          <a href="#IP" class="heading-link"><i class="fas fa-link"></i></a>IP</h4>
      <p>首先我们看 IP（Internet Protocol）协议。IP 协议提供了<strong>主机和主机</strong>间的通信。</p>
<p>为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的<strong>IP地址</strong>。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。</p>

        <h4 id="TCP"   >
          <a href="#TCP" class="heading-link"><i class="fas fa-link"></i></a>TCP</h4>
      <p>前面我们说过，IP 协议提供了主机和主机间的通信。TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上<strong>进程对进程</strong>的通信。</p>
<p>有了 IP，不同主机就能够交换数据。但是，计算机收到数据后，并不知道这个数据属于哪个进程（简单讲，进程就是一个正在运行的应用程序）。TCP 的作用就在于，让我们能够知道这个数据属于哪个进程，从而完成进程间的通信。</p>
<p>为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的<strong>端口号</strong>。</p>
<p>TCP 的全称是 Transmission Control Protocol，大家对它说得最多的，大概就是<strong>面向连接</strong>的特性了。之所以说它是有连接的，是说在进行通信前，通信双方需要先经过一个<em>三次握手</em>的过程。三次握手完成后，连接便建立了。这时候我们才可以开始发送/接收数据。（与之相对的是 UDP，不需要经过握手，就可以直接发送数据）。</p>
<p>下面我们简单了解一下三次握手的过程。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/29/1644c0f951971fd5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="tcp-three-way-handshake"></p>
<ol>
<li>首先，客户向服务端发送一个 <code>SYN</code>，假设此时 sequence number 为 <code>x</code>。这个 <code>x</code> 是由操作系统根据一定的规则生成的，不妨认为它是一个随机数。</li>
<li>服务端收到 <code>SYN</code> 后，会向客户端再发送一个 <code>SYN</code>，此时服务器的 <code>seq number = y</code>。与此同时，会 <code>ACK x+1</code>，告诉客户端“已经收到了 <code>SYN</code>，可以发送数据了”。</li>
<li>客户端收到服务器的 <code>SYN</code> 后，回复一个 <code>ACK y+1</code>，这个 <code>ACK</code> 则是告诉服务器，<code>SYN</code> 已经收到，服务器可以发送数据了。</li>
</ol>
<p>经过这 3 步，TCP 连接就建立了。这里需要注意的有三点：</p>
<ol>
<li>连接是由客户端主动发起的</li>
<li>在第 3 步客户端向服务器回复 <code>ACK</code> 的时候，TCP 协议是允许我们携带数据的。之所以做不到，是 API 的限制导致的。</li>
<li>TCP 协议还允许 “四次握手” 的发生，同样的，由于 API 的限制，这个极端的情况并不会发生。</li>
</ol>
<p>TCP/IP 相关的理论知识我们就先了解到这里。关于 TCP，还有诸如可靠性、流量控制、拥塞控制等非常有趣的特性，<strong>强烈推荐</strong>读者看一看 Richard 的名著《TCP/IP 详解 - 卷1》（注意，是<strong>第1版</strong>，不是第2版）。</p>
<p>下面我们看一些偏实战的东西。</p>

        <h2 id="Socket-基本用法"   >
          <a href="#Socket-基本用法" class="heading-link"><i class="fas fa-link"></i></a>Socket 基本用法</h2>
      <p>Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。</p>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p>
<ol>
<li>创建 <code>ServerSocket</code> 并监听客户连接</li>
<li>使用 <code>Socket</code> 连接服务端</li>
<li>通过 <code>Socket</code> 获取输入输出流进行通信</li>
</ol>
<p>下面，我们通过实现一个简单的 echo 服务来学习 socket 的使用。所谓的 echo 服务，就是客户端向服务端写入任意数据，服务器都将数据原封不动地写回给客户端。</p>
<p><strong>1. 创建 ServerSocket 并监听客户连接</strong></p>
<pre><code>public class EchoServer {

    private final ServerSocket mServerSocket;

    public EchoServer(int port) throws IOException {
        // 1. 创建一个 ServerSocket 并监听端口 port
        mServerSocket = new ServerSocket(port);
    }

    public void run() throws IOException {
        // 2. 开始接受客户连接
        Socket client = mServerSocket.accept();
        handleClient(client);
    }

    private void handleClient(Socket socket) {
        // 3. 使用 socket 进行通信 ...
    }


    public static void main(String[] argv) {
        try {
            EchoServer server = new EchoServer(9877);
            server.run();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p><strong>2. 使用 Socket 连接服务端</strong></p>
<pre><code>public class EchoClient {

    private final Socket mSocket;

    public EchoClient(String host, int port) throws IOException {
        // 创建 socket 并连接服务器
        mSocket = new Socket(host, port);
    }

    public void run() {
        // 和服务端进行通信
    }


    public static void main(String[] argv) {
        try {
            // 由于服务端运行在同一主机，这里我们使用 localhost
            EchoClient client = new EchoClient(&quot;localhost&quot;, 9877);
            client.run();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p><strong>3. 通过 socket.getInputStream()/getOutputStream() 获取输入/输出流进行通信</strong></p>
<p>首先，我们来实现服务端：</p>
<pre><code>public class EchoServer {
    // ...

    private void handleClient(Socket socket) throws IOException {
        InputStream in = socket.getInputStream();
        OutputStream out = socket.getOutputStream();
        byte[] buffer = new byte[1024];
        int n;
        while ((n = in.read(buffer)) &gt; 0) {
            out.write(buffer, 0, n);
        }
    }
}
</code></pre><p>可以看到，服务端的实现其实很简单，我们不停地读取输入数据，然后写回给客户端。</p>
<p>下面我们看看客户端。</p>
<pre><code>public class EchoClient {
    // ...

    public void run() throws IOException {
        Thread readerThread = new Thread(this::readResponse);
        readerThread.start();

        OutputStream out = mSocket.getOutputStream();
        byte[] buffer = new byte[1024];
        int n;
        while ((n = System.in.read(buffer)) &gt; 0) {
            out.write(buffer, 0, n);
        }
    }

    private void readResponse() {
        try {
            InputStream in = mSocket.getInputStream();
            byte[] buffer = new byte[1024];
            int n;
            while ((n = in.read(buffer)) &gt; 0) {
                System.out.write(buffer, 0, n);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>客户端会稍微复杂一点点，在读取用户输入的同时，我们又想读取服务器的响应。所以，这里创建了一个线程来读服务器的响应。</p>
<p>不熟悉 lambda 的读者，可以把 <code>Thread readerThread = new Thread(this::readResponse)</code> 换成下面这个代码：</p>
<pre><code>Thread readerThread = new Thread(new Runnable() {
    @Override
    public void run() {
        readResponse();
    }
});
</code></pre><p>打开两个 terminal 分别执行如下命令：</p>
<pre><code>$ javac EchoServer.java
$ java EchoServer

$ javac EchoClient.java
$ java EchoClient
hello Server
hello Server
foo
foo
</code></pre><p>在客户端，我们会看到，输入的所有字符都打印了出来。</p>
<p>最后需要注意的有几点：</p>
<ol>
<li>在上面的代码中，我们所有的异常都没有处理。实际应用中，在发生异常时，需要关闭 socket，并根据实际业务做一些错误处理工作</li>
<li>在客户端，我们没有停止 <code>readThread</code>。实际应用中，我们可以通过关闭 socket 来让线程从阻塞读中返回。推荐读者阅读《Java并发编程实战》</li>
<li>我们的服务端只处理了一个客户连接。如果需要同时处理多个客户端，可以创建线程来处理请求。这个作为练习留给读者来完全。</li>
</ol>

        <h2 id="Socket、ServerSocket-傻傻分不清楚"   >
          <a href="#Socket、ServerSocket-傻傻分不清楚" class="heading-link"><i class="fas fa-link"></i></a>Socket、ServerSocket 傻傻分不清楚</h2>
      <p>在进入这一节的主题前，读者不妨先考虑一个问题：在上一节的实例中，我们运行 echo 服务后，在客户端连接成功时，一个有多少个 socket 存在？</p>
<p>答案是 3 个 socket。客户端一个，服务端有两个。跟这个问题的答案直接关联的是本节的主题——<code>Socket</code> 和 <code>ServerSocket</code> 的区别是什么。</p>
<p>眼尖的读者，可能会注意到在上一节我是这样描述他们的：</p>
<blockquote>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。</p>
</blockquote>
<p>注意，我只说 <code>ServerSocket</code> 是用于监听客户连接，而没有说它也可以用来通信。下面我们来详细了解一下他们的区别。</p>
<blockquote>
<p>注：以下描述使用的是 UNIX/Linux 系统的 API</p>
</blockquote>
<p>首先，我们创建 <code>ServerSocket</code> 后，内核会创建一个 socket。这个 socket 既可以拿来监听客户连接，也可以连接远端的服务。由于 <code>ServerSocket</code> 是用来监听客户连接的，紧接着它就会对内核创建的这个 socket 调用 <code>listen</code> 函数。这样一来，这个 socket 就成了所谓的 listening socket，它开始监听客户的连接。</p>
<p>接下来，我们的客户端创建一个 <code>Socket</code>，同样的，内核也创建一个 socket 实例。内核创建的这个 socket 跟 <code>ServerSocket</code> 一开始创建的那个没有什么区别。不同的是，接下来 <code>Socket</code> 会对它执行 <code>connect</code>，发起对服务端的连接。前面我们说过，socket API 其实是 TCP 层的封装，所以 <code>connect</code> 后，内核会发送一个 <code>SYN</code> 给服务端。</p>
<p>现在，我们切换角色到服务端。<strong>服务端的主机在收到这个 <code>SYN</code> 后，会创建一个新的 socket</strong>，这个新创建的 socket 跟客户端继续执行三次握手过程。</p>
<p>三次握手完成后，我们执行的 <code>serverSocket.accept()</code> 会返回一个 <code>Socket</code> 实例，这个 socket 就是上一步内核自动帮我们创建的。</p>
<p>所以说，在一个客户端连接的情况下，其实有 3 个 socket。</p>
<p>关于内核自动创建的这个 socket，还有一个很有意思的地方。它的端口号跟 <code>ServerSocket</code> 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。</p>
<p>前面我说的TCP 通过端口号来区分数据属于哪个进程的说法，在 socket 的实现里需要改一改。Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 <code>&lt;peer addr:peer port, local addr:local port&gt;</code> 这个四元组。</p>
<p>在上面的例子中，我们的 <code>ServerSocket</code> 长这样：<code>&lt;*:*, *:9877&gt;</code>。意思是，可以接受任何的客户端，和本地任何 IP。</p>
<p><code>accept</code> 返回的 <code>Socket</code> 则是这样： <code>&lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;</code>，其中<code>xxxx</code> 是客户端的端口号。</p>
<p>如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。</p>
<p>如果是客户端要发起连接，这时候只有 <code>&lt;*:*, *:9877&gt;</code> 会匹配成功，所以 <code>SYN</code> 也准确发送给了监听套接字。</p>
<p><code>Socket/ServerSocket</code> 的区别我们就讲到这里。如果读者觉得不过瘾，可以参考《TCP/IP 详解》卷1、卷2。</p>

        <h2 id="Socket-长连接的实现"   >
          <a href="#Socket-长连接的实现" class="heading-link"><i class="fas fa-link"></i></a>Socket 长连接的实现</h2>
      <p><strong>背景知识</strong></p>
<p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p>
<p>比较熟悉 <code>Socket</code> 的读者，可能知道有这样一个 API：</p>
<pre><code>socket.setKeepAlive(true);
</code></pre><p>嗯……keep alive，“保持活着”，这个应该就是让 TCP 不断开的意思。那么，我们要实现一个 socket 的长连接，只需要这一个调用即可。</p>
<p>遗憾的是，生活并不总是那么美好。对于 4.4BSD 的实现来说，Socket 的这个 keep alive 选项如果打开并且<strong>两个小时</strong>内没有通信，那么底层会发一个心跳，看看对方是不是还活着。</p>
<p>注意，两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。</p>
<p>在说明如果实现长连接前，我们先来理一理我们面临的问题。假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用：</p>
<ol>
<li>某一端关闭是 socket（这不是废话吗）。主动关闭的一方会发送 <code>FIN</code>，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 <code>EoF</code>（End of File）。于是我们知道对方关闭了 socket。</li>
<li>应用程序奔溃。此时 socket 会由内核关闭，结果跟情况1一样。</li>
<li>系统奔溃。这时候系统是来不及发送 <code>FIN</code> 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。</li>
<li>电缆被挖断、网线被拔。跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用。</li>
</ol>
<p>在上面的几种情形中，有一个共同点就是，只要去读、写 socket，只要 socket 连接不正常，我们就能够知道。基于这一点，要实现一个 socket 长连接，我们需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的<strong>心跳</strong>。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。</p>
<p>心跳包不是实际的业务数据，根据通信协议的不同，需要做不同的处理。</p>
<p>比方说，我们使用 JSON 进行通信，那么，我们可以加一个 <code>type</code> 字段，表面这个 JSON 是心跳还是业务数据。</p>
<pre><code>{
    &quot;type&quot;: 0,  // 0 表示心跳

    // ...
}
</code></pre><p>使用二进制协议的情况类似。要求就是，我们能够区别一个数据包是心跳还是真实数据。这样，我们便实现了一个 socket 长连接。</p>
<p><strong>实现示例</strong></p>
<p>这一小节我们一起来实现一个带长连接的 Android echo 客户端。</p>
<p>首先了接口部分：</p>
<pre><code>public final class LongLiveSocket {

    /**
     * 错误回调
     */
    public interface ErrorCallback {
        /**
         * 如果需要重连，返回 true
         */
        boolean onError();
    }

    /**
     * 读数据回调
     */
    public interface DataCallback {
        void onData(byte[] data, int offset, int len);
    }

    /**
     * 写数据回调
     */
    public interface WritingCallback {
        void onSuccess();
        void onFail(byte[] data, int offset, int len);
    }


    public LongLiveSocket(String host, int port,
                          DataCallback dataCallback, ErrorCallback errorCallback) {
    }

    public void write(byte[] data, WritingCallback callback) {
    }

    public void write(byte[] data, int offset, int len, WritingCallback callback) {
    }

    public void close() {
    }
}
</code></pre><p>我们这个支持长连接的类就叫 <code>LongLiveSocket</code> 好了。如果在 socket 断开后需要重连，只需要在对应的接口里面返回 true 即可（在真实场景里，我们还需要让客户设置重连的等待时间，还有读写、连接的 timeout等。为了简单，这里就直接不支持了。</p>
<p>另外需要注意的一点是，如果要做一个完整的库，需要同时提供阻塞式和回调式API。同样由于篇幅原因，这里直接省掉了。</p>
<p>首先我们看看 <code>write()</code> 方法：</p>
<pre><code>public void write(byte[] data, int offset, int len, WritingCallback callback) {
    mWriterHandler.post(() -&gt; {
        Socket socket = getSocket();
        if (socket == null) {
            // initSocket 失败而客户说不需要重连，但客户又叫我们给他发送数据
            throw new IllegalStateException(&quot;Socket not initialized&quot;);
        }
        try {
            OutputStream outputStream = socket.getOutputStream();
            DataOutputStream out = new DataOutputStream(outputStream);
            out.writeInt(len);
            out.write(data, offset, len);
            callback.onSuccess();
        } catch (IOException e) {
            Log.e(TAG, &quot;write: &quot;, e);
            // 关闭 socket，避免资源泄露
            closeSocket();
            // 这里我们把发生失败的数据返回给客户端，这样客户可以更方便地重新发送数据
            callback.onFail(data, offset, len);
            if (!closed() &amp;&amp; mErrorCallback.onError()) {
                // 重连
                initSocket();
            }
        }
    });
}
</code></pre><p>由于我们需要定时写心跳，这里使用一个 <code>HandlerThread</code> 来处理写请求。通信使用的协议，只是简单地在用户数据前加一个 len 字段，用于确定消息的长度。</p>
<p>下面我们看心跳的发送：</p>
<pre><code>private final Runnable mHeartBeatTask = new Runnable() {
    private byte[] mHeartBeat = new byte[0];

    @Override
    public void run() {
        // 我们使用长度为 0 的数据作为 heart beat
        write(mHeartBeat, new WritingCallback() {
            @Override
            public void onSuccess() {
                // 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次
                mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS);
                mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS);
            }

            @Override
            public void onFail(byte[] data, int offset, int len) {
                // nop
                // write() 方法会处理失败
            }
        });
    }
};

private final Runnable mHeartBeatTimeoutTask = () -&gt; {
    Log.e(TAG, &quot;mHeartBeatTimeoutTask#run: heart beat timeout&quot;);
    closeSocket();
};
</code></pre><p>发送心跳使用我们上面实现的 <code>write()</code> 方法。在发送成功后，post delay 一个 timeout task，如果到期后还没收到服务器的响应，我们将认为 socket 出现异常，这里直接关闭 socket。最后是对心跳的处理：</p>
<pre><code>int nbyte = in.readInt();
if (nbyte == 0) {
    Log.i(TAG, &quot;readResponse: heart beat received&quot;);
    mUIHandler.removeCallbacks(mHeartBeatTimeoutTask);
}
</code></pre><p>由于用户数据的长度总是会大于 1，这里我们就使用 <code>len == 0</code> 的数据作为心跳。收到心跳后，移除 <code>mHeartBeatTimeoutTask</code>。</p>
<p>剩余代码跟我们的主题没有太大关系，读者在<span class="exturl"><a class="exturl__link"   href="https://github.com/Jekton/Echo"  target="_blank" rel="noopener">这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>[3]可以找到完整的代码或者自己完成这个例子。</p>
<p>最后需要说明的是，如果想节省资源，在有客户发送数据的时候可以省略 heart beat。</p>
<p>我们对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。heart beat timeout 的情况类似。</p>

        <h2 id="跟-TCP-IP-学协议设计"   >
          <a href="#跟-TCP-IP-学协议设计" class="heading-link"><i class="fas fa-link"></i></a>跟 TCP/IP 学协议设计</h2>
      <p>如果仅仅是为了使用是 socket，我们大可以不去理会协议的细节。之所以推荐大家去看一看《TCP/IP 详解》，是因为它们有太多值得学习的地方。很多我们工作中遇到的问题，都可以在这里找到答案。</p>
<p>以下每一个小节的标题都是一个小问题，建议读者独立思考一下，再继续往下看。如果你发现你的答案比我的更好，请一定发送邮件到 ljtong64 AT gmail DOT com 告诉我。</p>

        <h4 id="协议版本如何升级？"   >
          <a href="#协议版本如何升级？" class="heading-link"><i class="fas fa-link"></i></a>协议版本如何升级？</h4>
      <p>有这么一句流行的话：这个世界唯一不变的，就是变化。当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？</p>
<p>答案可以在 IP 协议找到。</p>
<p>IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。</p>
<p>再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。</p>

        <h4 id="如何发送不定长数据的数据包"   >
          <a href="#如何发送不定长数据的数据包" class="heading-link"><i class="fas fa-link"></i></a>如何发送不定长数据的数据包</h4>
      <p>举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？</p>
<p>还是一样，看看 IP。IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。</p>
<p>跟这个相对的，还有另一个方案，那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 <code>\0</code> 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 <code>\0</code>。此时，我们就需要对用户的数据进行<strong>转义</strong>。比方说，把用户数据的所有 <code>\0</code> 都变成 <code>\0\0</code>。读消息的过程总，如果遇到 <code>\0\0</code>，那它就代表 <code>\0</code>，如果只有一个 <code>\0</code>，那就是消息尾部。</p>
<p>使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。</p>
<p>终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。</p>
<p>当然，这两个方法不是互斥的，可以一起使用。</p>

        <h4 id="上传多个文件，只有所有文件都上传成功时才算成功"   >
          <a href="#上传多个文件，只有所有文件都上传成功时才算成功" class="heading-link"><i class="fas fa-link"></i></a>上传多个文件，只有所有文件都上传成功时才算成功</h4>
      <p>现在我们有一个需求，需要一次上传多个文件到服务器，只有在所有文件都上传成功的情况下，才算成功。我们该如何来实现呢？</p>
<p>IP 在数据报过大的时候，会把一个数据报拆分成多个，并设置一个 MF （more fragments）位，表示这个包只是被拆分后的数据的一部分。</p>
<p>好，我们也学一学 IP。这里，我们可以给每个文件从 0 开始编号。上传文件的同时，也携带这个编号，并额外附带一个 MF 标志。除了编号最大的文件，所有文件的 MF 标志都置位。因为 MF 没有置位的是最后一个文件，服务器就可以根据这个得出总共有多少个文件。</p>
<p>另一种不使用 MF 标志的方法是，我们在上传文件前，就告诉服务器总共有多少个文件。</p>
<p>如果读者对数据库比较熟悉，学数据库用事务来处理，也是可以的。这里就不展开讨论了。</p>

        <h4 id="如何保证数据的有序性"   >
          <a href="#如何保证数据的有序性" class="heading-link"><i class="fas fa-link"></i></a>如何保证数据的有序性</h4>
      <p>这里讲一个我曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。</p>
<p>我们看看 TCP/IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。</p>
<p>一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。</p>
<p>更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。工作线程要将结果放入，有两种可能：</p>
<ol>
<li>刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去。</li>
<li>所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。</li>
</ol>
<p>如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。</p>

        <h4 id="如何保证对方收到了消息"   >
          <a href="#如何保证对方收到了消息" class="heading-link"><i class="fas fa-link"></i></a>如何保证对方收到了消息</h4>
      <p>我们说，TCP 提供了可靠的传输。这样不就能够保证对方收到消息了吗？</p>
<p>很遗憾，其实不能。在我们往 socket 写入的数据，只要对端的内核收到后，就会返回 <code>ACK</code>，此时，socket 就认为数据已经写入成功。然而要注意的是，这里只是对方所运行的系统的内核成功收到了数据，并不表示应用程序已经成功处理了数据。</p>
<p>解决办法还是一样，我们学 <code>TCP</code>，添加一个应用层的 <code>APP ACK</code>。应用接收到消息并处理成功后，发送一个 <code>APP ACK</code> 给对方。</p>
<p>有了 <code>APP ACK</code>，我们需要处理的另一个问题是，如果对方真的没有收到，需要怎么做？</p>
<p>TCP 发送数据的时候，消息一样可能丢失。TCP 发送数据后，如果长时间没有收到对方的 <code>ACK</code>，就假设数据已经丢失，并重新发送。</p>
<p>我们也一样，如果长时间没有收到 <code>APP ACK</code>，就假设数据丢失，重新发送一个。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/undefined/">Android目前最稳定和高效的UI适配方案</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/undefined/" data-flag-title="Android目前最稳定和高效的UI适配方案"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Android-目前最稳定和高效的UI适配方案"   >
          <a href="#Android-目前最稳定和高效的UI适配方案" class="heading-link"><i class="fas fa-link"></i></a>Android 目前最稳定和高效的UI适配方案</h1>
      <p>Android系统发布十多年以来，关于Android的UI的适配一直是开发环节中最重要的问题，但是我看到还是有很多小伙伴对Android适配方案不了解。刚好，近期准备对糗事百科Android客户端设计一套UI尺寸适配方案，可以和小伙伴们详细的聊一聊这个问题。</p>
<p>Android适配最核心的问题有两个，其一，就是适配的效率，即把设计图转化为App界面的过程是否高效，其二如何保证实现UI界面在不同尺寸和分辨率的手机中UI的一致性。这两个问题都很重要，一个是保证我们开发的高效，一个是保证我们适配的成效；今天我们就这两个核心的问题来聊一聊Android的适配方案。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/13/163f4be45ba74a31?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>首先，大家都知道，在标识尺寸的时候，Android并不推荐我们使用px这个真实像素单位，因为不同的手机之间，分辨率是不同的，比如一个96*96像素的控件在分辨率越来越高的手机上会在整体UI中看起来越来越小。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/13/163f4bf39182027e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>出现类似于上图这样这样，整体的布局效果可能会变形，所以px这个单位在布局文件中是不推荐的。</p>

        <h2 id="dp直接适配"   >
          <a href="#dp直接适配" class="heading-link"><i class="fas fa-link"></i></a>dp直接适配</h2>
      <p>针对这种情况，Android推荐使用dp作为尺寸单位来适配UI.</p>
<p>那么什么是dp？dp指的是设备独立像素，以dp为尺寸单位的控件，在不同分辨率和尺寸的手机上代表了不同的真实像素，比如在分辨率较低的手机中，可能1dp=1px,而在分辨率较高的手机中，可能1dp=2px，这样的话，一个96*96dp的控件，在不同的手机中就能表现出差不多的大小了。那么这个dp是如何计算的呢？ 我们都知道一个公式： px = dp(dpi/160) 系统都是通过这个来判断px和dp的数学关系，</p>
<p>那么这里又出现了一个问题，dpi是什么呢？</p>
<p>dpi是像素密度，指的是在<strong>系统软件上指定</strong>的单位尺寸的像素数量，它往往是写在系统出厂配置文件的一个固定值。</p>
<p>我为什么要强调它是软件系统上的概念？因为大家买手机的时候，往往会听到另一个叫ppi的参数，这个在手机屏幕中指的也是像素密度，但是这个是物理上的概念，它是客观存在的不会改变。dpi是软件参考了物理像素密度后，人为指定的一个值，这样保证了某一个区间内的物理像素密度在软件上都使用同一个值。这样会有利于我们的UI适配。</p>
<p>比如，几部相同分辨率不同尺寸的手机的ppi可能分别是是430,440,450,那么在Android系统中，可能dpi会全部指定为480.这样的话，dpi/160就会是一个相对固定的数值，这样就能保证相同分辨率下不同尺寸的手机表现一致。</p>
<p>而在不同分辨率下，dpi将会不同，比如：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>…</th>
<th align="center">1080*720</th>
<th align="right">1920*1080</th>
</tr>
</thead>
<tbody><tr>
<td>dpi</td>
<td align="center">320</td>
<td align="right">480</td>
</tr>
<tr>
<td>dpi/160</td>
<td align="center">2</td>
<td align="right">3</td>
</tr>
</tbody></table></div>
<p>根据上面的表格，我们可以发现，720P,和1080P的手机，dpi是不同的，这也就意味着，不同的分辨率中，1dp对应不同数量的px(720P中，1dp=2px，1080P中1dp=3px)，这就实现了，当我们使用dp来定义一个控件大小的时候，他在不同的手机里表现出相应大小的像素值。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/13/163f4d6fe59be47d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>我们可以说，通过dp加上自适应布局和weight比例布局可以基本解决不同手机上适配的问题，这基本是最原始的Android适配方案。</p>
<p>这种方式存在两个小问题，第一，这只能保证我们写出来的界面适配绝大部分手机，部分手机仍然需要单独适配，为什么dp只解决了90%的适配问题，因为并不是所有的1080P的手机dpi都是480，比如Google 的Pixel2（1920<em>1080）的dpi是420，也就是说，在Pixel2中，1dp=2.625px,这样会导致相同分辨率的手机中，这样，一个100dp</em>100dp的控件，在一般的1080P手机上，可能都是300px,而Pixel 2 中 ，就只有262.5px,这样控件的实际大小会有所不同。</p>
<p>为了更形象的展示，假设我们在布局文件中把一个ImageView的宽度设置为360dp,那么在下面两张图中表现是不一样的：</p>
<p>图一是1080P,480dpi的手机，图二是1080P,420dpi的手机</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/10/163ea44745e200a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="1080P,480dpi的手机"></p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/10/163ea461ceb490a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="1080P,420dpi的手机"></p>
<p>从上面的布局中可以看到，同样是1080P的手机，差异是比较明显的。在这种情况下，我们的UI可能需要做一些微调甚至单独适配。</p>
<p>第二个问题，这种方式无法快速高效的把设计师的设计稿实现到布局代码中，通过dp直接适配，我们只能让UI基本适配不同的手机,但是在设计图和UI代码之间的鸿沟，dp是无法解决的，因为dp不是真实像素。而且，设计稿的宽高往往和Android的手机真实宽高差别极大，以我们的设计稿为例，设计稿的宽高是375px<em>750px，而真实手机可能普遍是1080</em>1920,</p>
<p>那么在日常开发中我们是怎么跨过这个鸿沟的呢？基本都是通过百分比啊，或者通过估算，或者设定一个规范值等等。总之，当我们拿到设计稿的时候，设计稿的ImageView是128px<em>128px，当我们在编写layout文件的时候，却不能直接写成128dp</em>128dp。在把设计稿向UI代码转换的过程中，我们需要耗费相当的精力去转换尺寸，这会极大的降低我们的生产力，拉低开发效率。</p>

        <h2 id="宽高限定符适配"   >
          <a href="#宽高限定符适配" class="heading-link"><i class="fas fa-link"></i></a>宽高限定符适配</h2>
      <p>为了高效的实现UI开发，出现了新的适配方案，我把它称作<strong>宽高限定符适配</strong>。简单说，就是穷举市面上所有的Android手机的宽高像素值：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/12/163f4802fbef23d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>设定一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件。</p>
<p>比如以480x320为基准分辨率</p>
<ul>
<li>宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320</li>
<li>高度为480，将任何分辨率的高度整分为480份，取值为y1-y480</li>
</ul>
<p>那么对于800*480的分辨率的dimens文件来说，</p>
<p>x1=(480/320)*1=1.5px</p>
<p>x2=(480/320)*2=3px</p>
<p>…</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/13/163f4f9e227a1bb4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>这个时候，如果我们的UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens引用了,而当APP运行在不同分辨率的手机中时，这些系统会根据这些dimens引用去该分辨率的文件夹下面寻找对应的值。这样基本解决了我们的适配问题，而且极大的提升了我们UI开发的效率，</p>
<p>但是这个方案有一个致命的缺陷，那就是需要精准命中才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。</p>
<p>不过这个方案有一些团队用过，我们可以认为它是一个比较成熟有效的方案了。</p>

        <h2 id="UI适配框架（已经停止维护）"   >
          <a href="#UI适配框架（已经停止维护）" class="heading-link"><i class="fas fa-link"></i></a>UI适配框架（已经停止维护）</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://github.com/hongyangAndroid/AndroidAutoLayout"  target="_blank" rel="noopener">鸿洋大佬的适配方案</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的项目也来自于宽高限定符方案的启发。</p>
<p>使用方法也很简单：</p>
<p>第一步： 在你的项目的AndroidManifest中注明你的设计稿的尺寸。</p>
<pre><code>&lt;meta-data android:name=&quot;design_width&quot; android:value=&quot;768&quot;&gt;
&lt;/meta-data&gt;
&lt;meta-data android:name=&quot;design_height&quot; android:value=&quot;1280&quot;&gt;
&lt;/meta-data&gt;</code></pre><p>第二步： 让你的Activity继承自AutoLayoutActivity.</p>
<p>然后我们就可以直接在布局文件里面使用具体的像素值了，比如，设计稿上是96*96,那么我们可以直接写96px，APP运行时，框架会帮助我们根据不同手机的具体尺寸按比例伸缩。</p>
<p>这可以说是一个极好的方案，因为它在宽高限定符适配的基础上更进一步，并且解决了容错机制的问题，可以说完美的达成了开发高效和适配精准的两个要求。</p>
<p>但是我们能够想到，因为框架要在运行时会在onMeasure里面做变换，我们自定义的控件可能会被影响或限制，可能有些特定的控件，需要单独适配，这里面可能存在的暗坑是不可预见的，还有一个比较重要的问题，那就是整个适配工作是有框架完成的，而不是系统完成的，一旦使用这个框架，未来一旦遇到很难解决的问题，替换起来是非常麻烦的，而且项目一旦停止维护，后续的升级就只能靠你自己了，这种代价团队能否承受？当然，它已经停止维护了。</p>
<p>不过仅仅就技术方案而言，不可否认，这是一个很好的开源项目。</p>

        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <p>讨论的上述几种适配方案都是可以实际用于开发中的比较成熟的方案，而且确实有很多开发者正在使用。不过由于他们各自都存在一些缺陷，所以我们使用了上述方案后还需要花费额外的精力着手解决这些可能存在的缺陷。</p>
<p>那么，是否存在一种相对比较完美，没有明显的缺陷的方案呢？</p>

        <h2 id="smallestWidth适配"   >
          <a href="#smallestWidth适配" class="heading-link"><i class="fas fa-link"></i></a>smallestWidth适配</h2>
      <p>smallestWidth适配，或者叫sw限定符适配。指的是Android会识别<strong>屏幕可用高度和宽度的最小尺寸</strong>的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。</p>
<p>这种机制和上文提到的宽高限定符适配原理上是一样的，都是系统通过特定的规则来选择对应的文件。</p>
<p>举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/11/163ea6e3fcb3a835?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。这个特性就完美的解决了上文提到的宽高限定符的容错问题。</p>
<p>这套方案是上述几种方案中最接近完美的方案。 首先，<strong>从开发效率上，它不逊色于上述任意一种方案</strong>。根据固定的放缩比例，我们基本可以按照UI设计的尺寸不假思索的填写对应的dimens引用。 我们还有以375个像素宽度的设计稿为例，在values-sw360dp文件夹下的diemns文件应该怎么编写呢？这个文件夹下，意味着手机的最小宽度的dp值是360，我们把360dp等分成375等份，每一个设计稿中的像素，大概代表smallestWidth值为360dp的手机中的0.96dp，那么接下来的事情就很简单了，假如设计稿上出现了一个10px*10px的ImageView,那么，我们就可以不假思索的在layout文件中写下对应的尺寸。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/13/163f9dfd9ba47a62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>而这种diemns引用，在不同的values-sw<N>dp文件夹下的数值是不同的，比如values-sw360dp和values-sw400dp,</p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/12/163f45e3e95e2650?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><img   src="http://user-gold-cdn.xitu.io/2018/6/14/163f9e36163d741c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>当系统识别到手机的smallestWidth值时，就会自动去寻找和目标数据最近的资源文件的尺寸。</p>
<p>其次，从稳定性上，它也优于上述方案。原生的dp适配可能会碰到Pixel 2这种有些特别的手机需要单独适配，但是在smallestWidth适配中，通过计算Pixel 2手机的的smallestWidth的值是411，我们只需要生成一个values-sw411dp(或者取整生成values-sw410dp也没问题)就能解决问题。</p>
<p>smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，不会出现什么难以解决的问题，也根本不会影响我们的业务逻辑代码，而且只要我们生成的资源文件分布合理，，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。</p>
<p>当然，smallestWidth适配方案有一个小问题，那就是它是在Android 3.2 以后引入的，Google的本意是用它来适配平板的布局文件（但是实际上显然用于diemns适配的效果更好），不过目前所有的项目应该最低支持版本应该都是4.0了（糗事百科这么老的项目最低都是4.0哦），所以，这问题其实也不重要了。</p>
<p>评论中还说到了一个缺陷我忘了提，那就是多个dimens文件可能导致apk变大，这是事实，根据生成的dimens文件的覆盖范围和尺寸范围，apk可能会增大300kb-800kb左右，目前糗百的dimens文件大小是406kb，我认为这是可以接受的。</p>

        <h2 id="今日头条适配方案（更新）"   >
          <a href="#今日头条适配方案（更新）" class="heading-link"><i class="fas fa-link"></i></a>今日头条适配方案（更新）</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA"  target="_blank" rel="noopener">文章链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，之前确实没有接触过，我简单看了一遍，可以说，这也是相对比较完美的方案，我先简单说一下这个方案的思路，它是通过修改density值，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就解决了所有的适配问题。</p>
<p>比如，设计稿宽度是360px，那么开发这边就会把目标dp值设为360dp，在不同的设备中，动态修改density值，从而保证(手机像素宽度)px/density这个值始终是360dp,这样的话，就能保证UI在不同的设备上表现一致了。</p>
<p>这个方案侵入性很低，而且也没有涉及私有API，应该也是极不错的方案，我暂时也想不到强行修改density是否会有其他影响，既然有今日头条的大厂在用，稳定性应当是有保证的。</p>
<p>但是根据我的观察，这套方案<strong>对老项目是不太友好的</strong>，因为修改了系统的density值之后，整个布局的实际尺寸都会发生改变，如果想要在老项目文件中使用，恐怕整个布局文件中的尺寸都可能要重新按照设计稿修改一遍才行。因此，如果你是在维护或者改造老项目，使用这套方案就要三思了。</p>

        <h2 id="福利赠送"   >
          <a href="#福利赠送" class="heading-link"><i class="fas fa-link"></i></a>福利赠送</h2>
      <p>生成diemns文件的过程以及数据计算方法上面已经讲清楚了，大家完全可以自己去生成这些文件，我在这里附赠生成values-sw的项目代码，大家直接拿去用，是Java工程。<span class="exturl"><a class="exturl__link"   href="https://github.com/ladingwu/dimens_sw"  target="_blank" rel="noopener">点击这里获取项目地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="关于一些问题"   >
          <a href="#关于一些问题" class="heading-link"><i class="fas fa-link"></i></a>关于一些问题</h2>
      <p>Q: 该适配方案怎么用？</p>
<p>A:点击进入上文的github项目，下载到本地，然后运行该Java工程，会在本地根目录下生成相应的文件，如果需要生成更多尺寸，在DimenTypes 文件中填写你需要的尺寸即可。</p>
<p>Q： 是否有推荐的尺寸？</p>
<p>A 300,320,360,390,411，450，这几个尺寸是比较必要的，然后在其中插入一些其他的尺寸即可，如果不放心，可以在300-450之间，以10为步长生成十几个文件就OK了。</p>
<p>Q:平板适配的问题？</p>
<p>A: 这个可以分成两个问题，第一，团队有没有专门针对平板设计UI?第二，才是如何对平板适配。如果团队内部没有针对平板设计UI,那么大家对于App在平板上运行的要求大抵也就是不要太难看即可。针对这种情况的适配方法是被动适配，即不要生成480以上的适配文件，这样在平板上，系统就会使用480这个尺寸的dimens文件，这样效果比主动适配更好；而如果团队主动设计了平板的UI，那么我们就需要主动生成平板的适配文件，大概在600-800之间，关键尺寸是640,768。然后按照UI设计的图来写即可。</p>
<p>Q：用了这套方案是否就不需要使用wrap_content等来布局了？</p>
<p>A:这是绝对错误的做法！如果UI设计上明显更适合使用wrap_content,match_parent,layout_weight等,我们就要毫不犹豫的使用，而且在高这个维度上，我们要依照情况设计为可滑动的方式，或者match_parent,尽量不要写死。总之，<strong>所有的适配方案都不是用来取代match_parent,wrap_content的，而是用来完善他们的</strong>。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/javafs/">Java反射真的很慢吗</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/javafs/" data-flag-title="Java反射真的很慢吗"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="反射到底是好是坏"   >
          <a href="#反射到底是好是坏" class="heading-link"><i class="fas fa-link"></i></a>反射到底是好是坏</h2>
      <p>说到Java 中的反射，初学者在刚刚接触到反射的各种高级特性时，往往表示十分兴奋，甚至会在一些不需要使用反射的场景中强行使用反射来「炫技」。而经验较为丰富的长者，看到反射时往往会发出灵魂三问：为什么要用反射？反射不会降低性能么？不用还有什么办法可以解决这个问题？</p>
<p>那么今天我们就来深入探讨下，反射到底对性能有多大影响？顺便探讨下，反射为什么对性能有影响？</p>

        <h2 id="编码试验"   >
          <a href="#编码试验" class="heading-link"><i class="fas fa-link"></i></a>编码试验</h2>
      <p>在我们分析具体原理之前，我们可以通过编写代码做实验得出结论。</p>
<p>反射可能会涉及多种类型的操作，比如生成实例，获取/设置变量属性，调用方法等。经过简单的思考，我们认为生成实例对性能的影响相对其他操作要大一些，所以我们采用生成实例来做试验。</p>
<p>在如下代码中，我们定义了一个类 <code>InnerClass</code>，我们测试分别使用<code>new</code>和<code>反射</code>来生成 <code>MAX_TIMES</code>个实例，并打印出耗时时间。</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    private static final String TAG = &quot;MainAc&quot;;
    private final int MAX_TIMES = 100 * 1000;
    private InnerClass innerList[];

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        innerList = new InnerClass[MAX_TIMES];

        long startTime = SystemClock.elapsedRealtime();
        for (int i=0; i &lt; MAX_TIMES; i++) {
            innerList[i] = new InnerClass();
        }
        Log.e(TAG, &quot;totalTime: &quot; + (SystemClock.elapsedRealtime() - startTime));

        long startTime2 = SystemClock.elapsedRealtime();
        for (int i=0; i &lt; MAX_TIMES; i++) {
            innerList[i] = newInstanceByReflection();
        }
        Log.e(TAG, &quot;totalTime2: &quot; + (SystemClock.elapsedRealtime() - startTime2));
    }

    public InnerClass newInstanceByReflection() {
        Class clazz = InnerClass.class;
        try {
            return (InnerClass) clazz.getDeclaredConstructor().newInstance();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }

    static class InnerClass {
    }
}
</code></pre><p>输出日志：</p>
<pre><code>2020-03-19 22:34:49.738 2151-2151/? E/MainAc: totalTime: 15
2020-03-19 22:34:50.409 2151-2151/? E/MainAc: totalTime2: 670
</code></pre><p>使用反射生成 10万 个实例，耗时 670ms，明显高于直接使用 <code>new</code>关键字的 15ms，所以反射性能低。别急，这个结论总结的还有点早，我们将要生成的实例总数改为 1000个试试，输出日志：</p>
<pre><code>2020-03-19 22:39:21.287 3641-3641/com.example.myapplication E/MainAc: totalTime: 2
2020-03-19 22:39:21.296 3641-3641/com.example.myapplication E/MainAc: totalTime2: 9
</code></pre><p>使用反射生成 1000 个实例，虽然需要9ms，高于<code>new</code>的 2ms，但是 9ms 和 2ms 的差距本身肉眼不可见，而且通常我们在业务中写的反射一般来说执行频率也未必会超过 1000 次，这种场景下，我们还能理直气壮地说反射性能很低么？</p>
<p>很显然，不能。</p>
<p>除了代码执行耗时，我们再看看反射对内存的影响。我们仍然以生成 10万 个实例为目标，对上述代码做略微改动，依次只保留 <code>new</code> 方式和反射方式，然后运行程序，观察内存占用情况。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df2febd3611?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>使用 <code>new</code> 方式</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df300d4decd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>使用反射</p>
<p>对比两图，我们可以看到第二张图中多了很多 <code>Constructor</code>和<code>Class</code>对象实例，这两部分占用的内存2.7M。因此，我们可以得出结论，反射会产生大量的临时对象，并且会占用额外内存空间。</p>

        <h2 id="刨根问底：反射原理是什么"   >
          <a href="#刨根问底：反射原理是什么" class="heading-link"><i class="fas fa-link"></i></a>刨根问底：反射原理是什么</h2>
      <p>我们以前面试验中反射生成实例的代码为入口。</p>
<p>首先回顾下虚拟机中类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载。在加载的过程 中，虚拟机会把类的字节码转换成运行时数据结构，并保存在方法区，在内存中会生成一个代表这个类数据结构的 java.lang.Class 对象，后续访问这个类的数据结构就可以通过这个 Class 对象来访问。</p>
<pre><code>public InnerClass newInstanceByReflection() {
    // 获取虚拟机中 InnerClass 类的 Class 对象
    Class clazz = InnerClass.class;
    try {
        return (InnerClass) clazz.getDeclaredConstructor().newInstance();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre><p>代码中 <code>clazz.getDeclaredConstructor()</code> 用于获取类中定义的构造方法，由于我们没有显式定义构造方法，所以会返回编译器为我们自己生成的默认无参构造方法。</p>
<p>下面我们看下 <code>getDeclaredConstructor</code>是如何返回构造方法的。以下均以 jdk 1.8代码为源码。</p>
<pre><code>@CallerSensitive
public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
    throws NoSuchMethodException, SecurityException {
    // 权限检查
    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);
    return getConstructor0(parameterTypes, Member.DECLARED);
}
</code></pre><p><code>getDeclaredConstructor</code> 方法首先做了权限检查，然后直接调用 <code>getConstructor0</code> 方法。</p>
<pre><code>private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
                                    int which) throws NoSuchMethodException
{
    // privateGetDeclaredConstructors 方法是获取所有的构造方法数组
    Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
    // 遍历所有的构造方法数组，根据传入的参数类型依次匹配，找到合适的构造方法后就会拷贝一份作为返回值
    for (Constructor&lt;T&gt; constructor : constructors) {
        if (arrayContentsEq(parameterTypes,
                            constructor.getParameterTypes())) {
            // 拷贝构造方法
            return getReflectionFactory().copyConstructor(constructor);
        }
    }
    // 没有找到的话，就抛出异常 
    throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));
}
</code></pre><p><code>getConstructor0</code> 方法主要做了两件事：</p>
<ul>
<li>获取所有构造方法组成的数组</li>
<li>遍历构造方法数组，找到匹配的</li>
</ul>
<p>遍历匹配没啥好说的，我们重点看下第一件事，怎么获取的所有构造方法数组，也就是这个方法 <code>privateGetDeclaredConstructors</code>。</p>
<pre><code>private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
    checkInitted();
    Constructor&lt;T&gt;[] res;
    // 获取缓存的 ReflectionData 数据
    ReflectionData&lt;T&gt; rd = reflectionData();
    // 如果缓存中有 ReflectionData，就先看看 ReflectionData 中的 publicConstructors 或 declaredConstructors是否为空
    if (rd != null) {
        res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
        if (res != null) return res;
    }
    // 如果没有缓存，或者缓存中构造方法数组为空
    // No cached value available; request value from VM
    // 对接口类型的字节码特殊处理
    if (isInterface()) {
        @SuppressWarnings(&quot;unchecked&quot;)
        // 如果是接口类型，那么生成一个长度为0的构造方法数组
        Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
        res = temporaryRes;
    } else {
        // 如果不是接口类型，就调用 getDeclaredConstructors0 获取构造方法数组
        res = getDeclaredConstructors0(publicOnly);
    }
    // 获取到构造方法数组后，再赋值给缓存 ReflectionData 中的对应属性
    if (rd != null) {
        if (publicOnly) {
            rd.publicConstructors = res;
        } else {
            rd.declaredConstructors = res;
        }
    }
    return res;
}
</code></pre><p>上述代码中我已经对关键代码进行了注释，在讲解整个流程之前，我们看到了一个陌生的类型 <code>ReflectionData</code>。它对应的数据结构是：</p>
<pre><code>private static class ReflectionData&lt;T&gt; {
    volatile Field[] declaredFields;
    volatile Field[] publicFields;
    volatile Method[] declaredMethods;
    volatile Method[] publicMethods;
    volatile Constructor&lt;T&gt;[] declaredConstructors;
    volatile Constructor&lt;T&gt;[] publicConstructors;
    // Intermediate results for getFields and getMethods
    volatile Field[] declaredPublicFields;
    volatile Method[] declaredPublicMethods;
    volatile Class&lt;?&gt;[] interfaces;

    // Value of classRedefinedCount when we created this ReflectionData instance
    final int redefinedCount;

    ReflectionData(int redefinedCount) {
        this.redefinedCount = redefinedCount;
    }
}
</code></pre><p><code>ReflectionData</code> 这个类就是用来保存从虚拟机中获取到的一些数据。同时我们可以看到所有反射属性都使用了 <code>volatile</code>关键字修饰。</p>
<p>获取缓存的 <code>ReflectionData</code> 数据是通过调用<code>reflectionData()</code>方法获取的。</p>
<pre><code>// 定义在 Class 类中的反射缓存对象
private volatile transient SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;

private ReflectionData&lt;T&gt; reflectionData() {
    SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
    int classRedefinedCount = this.classRedefinedCount;
    ReflectionData&lt;T&gt; rd;
    if (useCaches &amp;&amp;
        reflectionData != null &amp;&amp;
        (rd = reflectionData.get()) != null &amp;&amp;
        rd.redefinedCount == classRedefinedCount) {
        return rd;
    }
    // else no SoftReference or cleared SoftReference or stale ReflectionData
    // -&gt; create and replace new instance
    return newReflectionData(reflectionData, classRedefinedCount);
}
</code></pre><p>我们可以看到 <code>reflectionData</code>实际上是一个软引用，软引用会在内存不足的情况下被虚拟机回收，所以<code>reflectionData()</code>方法在开始的地方，先判断了是否可以使用缓存以及缓存是否失效，如果失效了，就会调用 <code>newReflectionData</code>方法生成一个新的 <code>ReflectionData</code> 实例。</p>
<p>接下来看看 <code>newReflectionData</code> 方法。</p>
<pre><code>private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
                                                int classRedefinedCount) {
    // 如果不允许使用缓存，直接返回 null
    if (!useCaches) return null;

    while (true) {
        ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
        // try to CAS it...
        if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
            return rd;
        }
        // else retry
        oldReflectionData = this.reflectionData;
        classRedefinedCount = this.classRedefinedCount;
        if (oldReflectionData != null &amp;&amp;
            (rd = oldReflectionData.get()) != null &amp;&amp;
            rd.redefinedCount == classRedefinedCount) {
            return rd;
        }
    }
}
</code></pre><p><code>newReflectionData</code>中使用 <strong>volatile + 死循环 + CAS 机制</strong> 保证线程安全。注意到这里的死循环每执行一次都会构造一个新的 <code>ReflectionData</code> 实例。</p>
<p>你可能会有疑问，<code>Class</code> 中 <code>reflectionData</code>属性什么时候被赋值的，其实是封装在<code>Atomic.casReflectionData</code>这个方法里了，他会检测当前<code>Class</code>对象中的<code>reflectionData</code>是否与<code>oldReflectionData</code>相等，如果相等，就会把<code>new SoftReference&lt;&gt;(rd)</code>赋值给 <code>reflectionData</code>。</p>
<p>到现在为止，关于 <code>ReflectionData</code>的背景知识都介绍完了。我们再回到 <code>privateGetDeclaredConstructors</code>中看看获取构造方法的流程。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/3/20/170f7df304157365?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><code>privateGetDeclaredConstructors</code>流程图</p>
<p>可以看到对于普通类，最终通过调用 <code>getDeclaredConstructors0</code>方法获取的构造方法列表。</p>
<pre><code>private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
</code></pre><p>这个方法是 native 的，具体逻辑在 jdk 源码中。</p>
<p>在 <code>native/java/lang/Class_getDeclaredConstructors0.c</code> 文件中，</p>
<pre><code>void getDeclaredConstructors0(Frame * frame)
{
    // Frame 可以理解为调用native方法时，java层传递过来的数据的一种封装
    LocalVars * vars = frame-&gt;localVars;
    Object * classObj = getLocalVarsThis(vars);
    // 取得java方法的入参
    bool publicOnly = getLocalVarsBoolean(vars, 1);

    uint16_t constructorsCount = 0;
    // 获取要查询的类的 Class 对象
    Class * c = classObj-&gt;extra;
    // 获取这个类的所有构造方法，且数量保存在 constructorsCount 中
    Method* * constructors = getClassConstructors(c, publicOnly, &amp;constructorsCount);
    // 获取 java 方法调用所属的 classLoader
    ClassLoader *  classLoader = frame-&gt;method-&gt;classMember.attachClass-&gt;classLoader;
    // 拿到 Constructor 对应的 class 对象
    Class * constructorClass = loadClass(classLoader, &quot;java/lang/reflect/Constructor&quot;);
    //创建一个长度为 constructorsCount 的数组保存构造方法
    Object * constructorArr = newArray(arrayClass(constructorClass), constructorsCount);

    pushOperandRef(frame-&gt;operandStack, constructorArr);
    // 后面是具体的赋值逻辑。将native中的Method对象转化为java层的Constructor对象
    if (constructorsCount &gt; 0)
    {
        Thread * thread = frame-&gt;thread;
        Object* * constructorObjs = getObjectRefs(constructorArr);

        Method * constructorInitMethod = getClassConstructor(constructorClass, _constructorConstructorDescriptor);
        for (uint16_t i = 0; i &lt; constructorsCount; i++)
        {
            Method * constructor = constructors[i];

            Object * constructorObj = newObject(constructorClass);
            constructorObj-&gt;extra = constructor;
            constructorObjs[i] = constructorObj;

            OperandStack * ops = newOperandStack(9);
            pushOperandRef(ops, constructorObj);
            pushOperandRef(ops, classObj);
            pushOperandRef(ops, toClassArr(classLoader, methodParameterTypes(constructor), constructor-&gt;parsedDescriptor-&gt;parameterTypesCount));
            if (constructor-&gt;exceptions != NULL)
                pushOperandRef(ops, toClassArr(classLoader, methodExceptionTypes(constructor), constructor-&gt;exceptions-&gt;number_of_exceptions));
            else
                pushOperandRef(ops, toClassArr(classLoader, methodExceptionTypes(constructor), 0));
            pushOperandInt(ops, constructor-&gt;classMember.accessFlags);
            pushOperandInt(ops, 0);
            pushOperandRef(ops, getSignatureStr(classLoader, constructor-&gt;classMember.signature));         // signature
            pushOperandRef(ops, toByteArr(classLoader, constructor-&gt;classMember.annotationData, constructor-&gt;classMember.annotationDataLen));
            pushOperandRef(ops, toByteArr(classLoader, constructor-&gt;parameterAnnotationData, constructor-&gt;parameterAnnotationDataLen));


            Frame * shimFrame = newShimFrame(thread, ops);
            pushThreadFrame(thread, shimFrame);

            // init constructorObj
            InvokeMethod(shimFrame, constructorInitMethod);
        }


    }
}
</code></pre><p>从上面的逻辑，可以知道获取构造方法的核心方法是 <code>getClassConstructors</code> ，所在文件为 <code>rtda/heap/class.c</code>。</p>
<pre><code>Method* * getClassConstructors(Class * self, bool publicOnly, uint16_t * constructorsCount)
{
    // 分配大小为 sizeof(Method) 的长度为 methodsCount 的连续内存地址，即数组
    Method* * constructors = calloc(self-&gt;methodsCount, sizeof(Method));
    *constructorsCount = 0;
    // 在native 层，构造方法和普通方法都存在 methods 中，逐一遍历
    for (uint16_t i = 0; i &lt; self-&gt;methodsCount; i++)
    {
        Method * method = self-&gt;methods + i;
        // 判断是否是构造方法
        if (isMethodConstructor(method))
        {
            // 检查权限
            if (!publicOnly || isMethodPublic(method))
            {
                // 符合条件的构造方法依次存到数组中
                constructors[*constructorsCount] = method;
                (*constructorsCount)++;
            }
        }
    }
    return constructors;
}
</code></pre><p>可以看到<code>getClassConstructors</code>实际上就是对 <code>methods</code> 进行了一次过滤，过滤的条件为：1.是构造方法；2.权限一致。</p>
<p><code>isMethodConstructor</code> 方法的判断逻辑也是十分简单，不是静态方法，而且方法名是<code>&lt;init&gt;</code>即可。</p>
<pre><code>bool isMethodConstructor(Method * self)
{
    return !isMethodStatic(self) &amp;&amp; strcmp(self-&gt;classMember.name, &quot;&lt;init&gt;&quot;) == 0;    
}
</code></pre><p>所以核心的逻辑变成了<code>Class</code>中的 <code>methods</code>数组何时被初始化赋值的？我们刨根问底的追踪下。</p>
<p>我们先找到类加载到虚拟机中的入口方法 <code>loadNonArrayClass</code>：</p>
<pre><code>Class * loadNonArrayClass(ClassLoader * classLoader, const char * className)
{
    int32_t classSize = 0;
    char * classContent = NULL;
    Class * loadClass = NULL;
    classSize = readClass(className, &amp;classContent);
    if (classSize &gt; 0 &amp;&amp; classContent != NULL){
#if 0
        printf(&quot;class size:%d,class data:[&quot;, classSize);
        for (int32_t i = 0; i &lt; classSize; i++)
        {
            printf(&quot;0x%02x &quot;, classContent[i]);
        }
        printf(&quot;]\n&quot;);
#endif
    }
    if (classSize &lt;= 0)
    {
        printf(&quot;Could not found target class\n&quot;);
        exit(127);
    }
    // 解析字节码文件
    loadClass = parseClassFile(classContent, classSize);
    loadClass-&gt;classLoader = classLoader;
    // 加载
    defineClass(classLoader, loadClass);
    // 链接
    linkClass(classLoader, loadClass);

    //printf(&quot;[Loaded %s\n&quot;, loadClass-&gt;name);
    return loadClass;
}

</code></pre><p>在 <code>parseClassFile</code>方法中，调用了<code>newClass</code>方法。</p>
<pre><code>Class * parseClassFile(char * classContent, int32_t classSize)
{
    ClassFile * classFile = NULL;

    classFile = parseClassData(classContent, classSize);

    return newClass(classFile);
}
</code></pre><p><code>newClass</code>方法在<code>rtda/heap/class.c</code>文件中。</p>
<pre><code>Class * newClass(ClassFile * classFile)
{
    Class * c = calloc(1, sizeof(Class));
    c-&gt;accessFlags = classFile-&gt;accessFlags;
    c-&gt;sourceFile = getClassSourceFileName(classFile);
    newClassName(c, classFile);
    newSuperClassName(c, classFile);
    newInterfacesName(c, classFile);
    newConstantPool(c, classFile);
    newFields(c, classFile);
    newMethods(c, classFile);
    return c;

}
</code></pre><p>可以看到，在native层创建了一个<code>Class</code>对象，我们重点看<code>newMethods(c, classFile)</code>方法啊，这个方法定义在<code>rtda/heap/method.c</code>中。</p>
<pre><code>Method * newMethods(struct Class * c, ClassFile * classFile)
{
    c-&gt;methodsCount = classFile-&gt;methodsCount;
    c-&gt;methods = NULL;
    if (c-&gt;methodsCount == 0)
        return NULL;

    c-&gt;methods = calloc(classFile-&gt;methodsCount, sizeof(Method));
    for (uint16_t i = 0; i &lt; c-&gt;methodsCount; i++)
    {        
        c-&gt;methods[i].classMember.attachClass = c;
        copyMethodInfo(&amp;c-&gt;methods[i], &amp;classFile-&gt;methods[i], classFile);
        copyAttributes(&amp;c-&gt;methods[i], &amp;classFile-&gt;methods[i], classFile);
        MethodDescriptor * md = parseMethodDescriptor(c-&gt;methods[i].classMember.descriptor);
        c-&gt;methods[i].parsedDescriptor = md;
        calcArgSlotCount(&amp;c-&gt;methods[i]);
        if (isMethodNative(&amp;c-&gt;methods[i]))
        {
            injectCodeAttribute(&amp;c-&gt;methods[i], md-&gt;returnType);
        }
    }

    return NULL;
}
</code></pre><p>上述代码可以看出，实际上就是把<code>ClassFile</code>中解析到的方法逐一赋值给了 <code>Class</code> 对象的 <code>methods</code> 数组。</p>
<p>总算梳理清楚了，反射创建对象的调用链为：</p>
<pre><code>loadClass -&gt; loadNonArrayClass -&gt; parseClassFile -&gt; newMethods -&gt; Class 的 methods数组

privateGetDeclaredConstructors -&gt; getDeclaredConstructors0 -&gt; getClassConstructors (过滤Class 的 methods数组)
</code></pre><p>到目前为止，我们搞明白反射时如何找到对应的构造方法的。下面我们来看 <code>newInstance</code> 方法。</p>
<pre><code>(InnerClass) clazz.getDeclaredConstructor().newInstance();

public T newInstance(Object ... initargs)
        throws InstantiationException, IllegalAccessException,
               IllegalArgumentException, InvocationTargetException
    {
        // 构造方法是否被重载了
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class&lt;?&gt; caller = Reflection.getCallerClass();
                // 检查权限
                checkAccess(caller, clazz, null, modifiers);
            }
        }
        // 枚举类型报错
        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)
            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);
        // ConstructorAccessor 是缓存的，如果为空，就去创建一个
        ConstructorAccessor ca = constructorAccessor;   // read volatile
        if (ca == null) {
            // 创建 ConstructorAccessor
            ca = acquireConstructorAccessor();
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        // 使用 ConstructorAccessor 的 newInstance 构造实例
        T inst = (T) ca.newInstance(initargs);
        return inst;
    }
</code></pre><p>接着看下 <code>acquireConstructorAccessor</code> 方法。</p>
<pre><code>private ConstructorAccessor acquireConstructorAccessor() {
    // First check to see if one has been created yet, and take it
    // if so.
    ConstructorAccessor tmp = null;
    // 可以理解为缓存的对象
    if (root != null) tmp = root.getConstructorAccessor();
    if (tmp != null) {
        constructorAccessor = tmp;
    } else {
        // Otherwise fabricate one and propagate it up to the root
        // 生成一个 ConstructorAccessor，并缓存起来
        tmp = reflectionFactory.newConstructorAccessor(this);
        setConstructorAccessor(tmp);
    }

    return tmp;
}
</code></pre><p>继续走到<code>newConstructorAccessor</code>方法。</p>
<pre><code>public ConstructorAccessor newConstructorAccessor(Constructor&lt;?&gt; var1) {
        checkInitted();
        Class var2 = var1.getDeclaringClass();
    // 如果是抽象类，报错
    if (Modifier.isAbstract(var2.getModifiers())) {
        return new InstantiationExceptionConstructorAccessorImpl((String)null);
    } 
    // 如果 Class 类报错
    else if (var2 == Class.class) {
        return new InstantiationExceptionConstructorAccessorImpl(&quot;Can not instantiate java.lang.Class&quot;);
    } 
    // 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl 
    else if (Reflection.isSubclassOf(var2, ConstructorAccessorImpl.class)) {
        return new BootstrapConstructorAccessorImpl(var1);
    } 
    // 判断 noInflation , 后面是判断不是匿名类
    else if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) {
        return (new MethodAccessorGenerator()).generateConstructor(var1.getDeclaringClass(), var1.getParameterTypes(), var1.getExceptionTypes(), var1.getModifiers());
    } 
    // 使用 NativeConstructorAccessorImpl 来生成实例
    else {
        NativeConstructorAccessorImpl var3 = new NativeConstructorAccessorImpl(var1);
        DelegatingConstructorAccessorImpl var4 = new DelegatingConstructorAccessorImpl(var3);
        var3.setParent(var4);
        return var4;
    }
}
</code></pre><p>具体逻辑，在上述代码中已经注释了。这里提一下 <code>noInflation</code>。</p>
<p><code>ReflectionFactory</code>在执行所有方法前会检查下是否执行过了<code>checkInitted</code>方法，这个方法会把<code>noInflation</code>的值和<code>inflationThreshold</code>从虚拟机的环境变量中读取出来并赋值。</p>
<p>当<code>noInflation</code> 为 <code>false</code>而且不是匿名类时，就会使用<code>MethodAccessorGenerator</code>方式。否则就是用 <code>NativeConstructorAccessorImpl</code>的方式来生成。</p>
<p>默认<code>noInflation</code> 为<code>false</code>，所以我们先看native调用的方式。关注 <code>NativeConstructorAccessorImpl</code>类。</p>
<pre><code>class NativeConstructorAccessorImpl extends ConstructorAccessorImpl {
    private final Constructor&lt;?&gt; c;
    private DelegatingConstructorAccessorImpl parent;
    private int numInvocations;

    NativeConstructorAccessorImpl(Constructor&lt;?&gt; var1) {
        this.c = var1;
    }

    public Object newInstance(Object[] var1) throws InstantiationException, IllegalArgumentException, InvocationTargetException {
        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.c.getDeclaringClass())) {
            ConstructorAccessorImpl var2 = (ConstructorAccessorImpl)(new MethodAccessorGenerator()).generateConstructor(this.c.getDeclaringClass(), this.c.getParameterTypes(), this.c.getExceptionTypes(), this.c.getModifiers());
            this.parent.setDelegate(var2);
        }

        return newInstance0(this.c, var1);
    }

    void setParent(DelegatingConstructorAccessorImpl var1) {
        this.parent = var1;
    }

    private static native Object newInstance0(Constructor&lt;?&gt; var0, Object[] var1) throws InstantiationException, IllegalArgumentException, InvocationTargetException;
}

</code></pre><p>我们可以看到 <code>NativeConstructorAccessorImpl</code> 中维护了一个计数器<code>numInvocations</code>,在每次调用<code>newInstance</code>方法生成实例时，就会对计数器自增，当计数器超过<code>ReflectionFactory.inflationThreshold()</code>的阈值，默认为15，就会使用 <code>ConstructorAccessorImpl</code>替换 <code>NativeConstructorAccessorImpl</code>,后面就会直接调用<code>MethodAccessorGenerator</code>中的方法了。</p>
<p>我们先看看没到达阈值前，会调用native方法 <code>newInstance0</code>,这个方法定义在<code>native/sun/reflect/NativeConstructorAccessorImpl.c</code>中，具体<code>newInstance0</code>的流程我就不分析了，大致逻辑是操作堆栈执行方法。</p>
<p>然后我们再看看超过阈值后，执行的是 <code>MethodAccessorGenerator</code>生成构造器的方式。这种方式与<code>newConstructorAccessor</code>方法中<code>noInflation</code> 为 <code>false</code>的处理方式一样。所以可以解释为：java虚拟机在执行反射操作时，如果同一操作执行次数超过阈值，会从native生成实例的方式转变为java生成实例的方式。</p>
<p><code>MethodAccessorGenerator</code>的<code>MethodAccessorGenerator</code>方法如下。</p>
<pre><code>public ConstructorAccessor generateConstructor(Class&lt;?&gt; var1, Class&lt;?&gt;[] var2, Class&lt;?&gt;[] var3, int var4) {
    return (ConstructorAccessor)this.generate(var1, &quot;&lt;init&gt;&quot;, var2, Void.TYPE, var3, var4, true, false, (Class)null);
}
</code></pre><p>继续跟踪下去可以发现，反射调用构造方法实际上是动态编写字节码，并且在虚拟机中把编好的字节码加载成一个Class，这个Class实际上是 <code>ConstructorAccessorImpl</code> 类型的，然后调用这个动态类的<code>newInstance</code>方法。回看刚刚我们梳理的<code>newConstructorAccessor</code>代码，可以看到第三个逻辑：</p>
<pre><code>// 如果是 ConstructorAccessorImpl 的子类的话，返回 BootstrapConstructorAccessorImpl 
else if (Reflection.isSubclassOf(var2, ConstructorAccessorImpl.class)) {
    return new BootstrapConstructorAccessorImpl(var1);
} 
</code></pre><p>最终执行的是 <code>BootstrapConstructorAccessorImpl</code>的<code>newInstance</code>方法。</p>
<pre><code>class BootstrapConstructorAccessorImpl extends ConstructorAccessorImpl {
    private final Constructor&lt;?&gt; constructor;

    BootstrapConstructorAccessorImpl(Constructor&lt;?&gt; var1) {
        this.constructor = var1;
    }

    public Object newInstance(Object[] var1) throws IllegalArgumentException, InvocationTargetException {
        try {
            return UnsafeFieldAccessorImpl.unsafe.allocateInstance(this.constructor.getDeclaringClass());
        } catch (InstantiationException var3) {
            throw new InvocationTargetException(var3);
        }
    }
}
</code></pre><p>最后是通过使用<code>Unsafe</code>类分配了一个实例。</p>

        <h2 id="反射带来的问题"   >
          <a href="#反射带来的问题" class="heading-link"><i class="fas fa-link"></i></a>反射带来的问题</h2>
      <p>到现在为止，我们已经把反射生成实例的所有流程都搞清楚了。回到文章开头的问题，我们现在反思下，反射性能低么？为什么？</p>
<ol>
<li>反射调用过程中会产生大量的临时对象，这些对象会占用内存，可能会导致频繁 gc，从而影响性能。</li>
<li>反射调用方法时会从方法数组中遍历查找，并且会检查可见性等操作会耗时。</li>
<li>反射在达到一定次数时，会动态编写字节码并加载到内存中，这个字节码没有经过编译器优化，也不能享受JIT优化。</li>
<li>反射一般会涉及自动装箱/拆箱和类型转换，都会带来一定的资源开销。</li>
</ol>
<p>在Android中，我们可以在某些情况下对反射进行优化。举个例子，EventBus 2.x 会在 register 方法运行时，遍历所有方法找到回调方法；而EventBus 3.x 则在编译期间，将所有回调方法的信息保存的自己定义的 <code>SubscriberMethodInfo</code> 中，这样可以减少对运行时的性能影响。</p>
<p><strong>本文的结论如下：</strong></p>
<ol>
<li>不要在性能敏感的应用中，频繁调用反射。</li>
<li>如果反射执行的次数小于1000这个数量级，反射的耗时实际上与正常调用无太大差异。</li>
<li>反射对内存占用还有一定影响的，在内存敏感的场景下，谨慎使用反射。</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/hashmap/">HashMap原理技术知识整理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/hashmap/" data-flag-title="HashMap原理技术知识整理"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p><img   src="http://user-gold-cdn.xitu.io/2020/1/8/16f81686afbf1d6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>HashMap涉及的技术点非常多，典型的数据结构和算法有机结合，JDK对HashMap优化变化中不断权衡时间复杂和空间复杂度。</p>

        <h3 id="一-存储结构"   >
          <a href="#一-存储结构" class="heading-link"><i class="fas fa-link"></i></a>一. 存储结构</h3>
      <p>1.JDK1.8之前 HashMap = 数组(O(1)）+ 单向链表（O(n)）</p>
<p>2.JDK1.8之后 HashMap = 数组(O(1)）+ 单向链表（O(n)）+ 红黑树(O(log n)</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/8/16f815af3de6cbaf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="HashMap结构图.png"></p>
<p>关于结构的几个关键数字：</p>
<p>1.默认初始化数组容量大小是16。</p>
<p>2.数组扩容刚好是2的次幂。</p>
<p>3.默认的加载因子是0.75。</p>
<p>4.链表长度超过8时将链表转化成红黑树结构。 5.红黑树节点数减少到6的时候退化成链表。</p>
<p>以上几个数字关系，又为什么是上边的几个数字接下来一个个分析。</p>

        <h3 id="二-操作原理"   >
          <a href="#二-操作原理" class="heading-link"><i class="fas fa-link"></i></a>二. 操作原理</h3>
      
        <h5 id="1-put储存流程"   >
          <a href="#1-put储存流程" class="heading-link"><i class="fas fa-link"></i></a>1. put储存流程</h5>
      <p>①计算桶的位置，根据key的hashcode求出hash值，位置index = hash%length。</p>
<p>②判断是否达到扩容条件，threshold=DEFAULT_INITIAL_CAPACITY * loadFactor（16*0.75=12）大于这个阀门值就需要扩容，否则下一步。</p>
<p>③判断桶位置是否为空，如果为空直接在数据插入数据。如果不为空，下一步。</p>
<p>④判断是链表还是红黑树，链表是否到达转化红黑树，当前链表节点数&lt;=8，插入节点；如果是红黑树插入节点，否则下一步。</p>
<p>⑤链表转化成红黑树，插入节点。</p>
<p>⑥插入节点后计算当前size是否需要扩容，如果大于阀门值需要扩容resize。</p>
<pre><code>/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don&#39;t change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre><p>以上是JDK1.8的HashMap的get调用关键方法源码。</p>

        <h5 id="2-get获取过程"   >
          <a href="#2-get获取过程" class="heading-link"><i class="fas fa-link"></i></a>2. get获取过程</h5>
      <p>①计算桶的位置，根据key的hashcode求出hash值，位置index = hash%length。</p>
<p>②无论是数值，链表还是红黑树，for循环判断hash值冲突就比对key是否相等，相等就返回对应的value。</p>
<pre><code>/**
 * Implements Map.get and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @return the node, or null if none
 */
final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre><p>以上是JDK1.8的HashMap的put调用关键方法源码。</p>

        <h3 id="三-数据结构和算法思考"   >
          <a href="#三-数据结构和算法思考" class="heading-link"><i class="fas fa-link"></i></a>三. 数据结构和算法思考</h3>
      
        <h5 id="1-为什么选择数组和链表结构？"   >
          <a href="#1-为什么选择数组和链表结构？" class="heading-link"><i class="fas fa-link"></i></a>1.为什么选择数组和链表结构？</h5>
      <p>①数组内存连续块分配，效率体现查询更快。HashMap中用作查找数组桶的位置，利用元素的key的hash值对数组长度取模得到。</p>
<p>②链表效率体现增加和删除。HashMap中链表是用来解决hash冲突，增删空间消耗平衡。</p>
<p><strong>扩展：</strong> 为什么不是ArrayList而是使用Node&lt;K,V&gt;[] tab？因为ArrayList的扩容机制是1.5倍扩容，而HashMap扩容是2的次幂。</p>

        <h5 id="2-为什么扩容是2次幂，根据key的hashcode再求hash值？"   >
          <a href="#2-为什么扩容是2次幂，根据key的hashcode再求hash值？" class="heading-link"><i class="fas fa-link"></i></a>2.为什么扩容是2次幂，根据key的hashcode再求hash值？</h5>
      
        <h5 id="①key的hash值计算"   >
          <a href="#①key的hash值计算" class="heading-link"><i class="fas fa-link"></i></a>①key的hash值计算</h5>
      <pre><code>static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>代码意思是hash = hashcode的高16位异化低16位，而不是直接hashcode。</p>

        <h5 id="②计算桶的位置代码"   >
          <a href="#②计算桶的位置代码" class="heading-link"><i class="fas fa-link"></i></a>②计算桶的位置代码</h5>
      <pre><code>index = (n - 1) &amp; hash
</code></pre><p><strong>思想：</strong></p>
<p>一是，为了减少hash冲突使用hash%length计算，求模计算保证了得到的结果一定在0-length范围之内。</p>
<p>二是，为了提高运算速度，模运算比不上位运算，当n是2的次幂才满足hash%length == （n-1）&amp;hash。</p>
<p>确定公式中（n-1）符合最优等式，剩下考虑hash值的最优，hash值这个因子考虑影响结果尽可能不冲突。</p>
<p>因为计算速度体现在位运算上，条件n是2的次幂，那么n-1的换算成二进制前边都是连续的0，后边都是连续的1,。比如n=16，则n-1=15，15的二进制1111。hash &amp; 1111 = 只要关注的hash的二进制的最后四位数进行&amp;运算。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/1/8/16f815af3f39c141?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="（n-1）&amp; length.png"></p>
<p>如上图，最终会与15的二进制进行1111四位运算，如果与key.hashcode进行与运算的话，只要key的hashcode最后四位为0000前边无论是什么都没关系，这样出现相同值的概率高很多。所以，引入hashcode先高低16位进行异或运算，减少hash冲突。</p>
<p><strong>扩展：</strong> hashcode与equals相等判断对比： 两个key的hashcode相等，key不一定equals。 两个key的equals，hashcode一定相等。</p>

        <h5 id="3-为什么加载因子为0-75，链表长度大于8转成红黑树？"   >
          <a href="#3-为什么加载因子为0-75，链表长度大于8转成红黑树？" class="heading-link"><i class="fas fa-link"></i></a>3.为什么加载因子为0.75，链表长度大于8转成红黑树？</h5>
      <p><strong>思想：</strong></p>
<p>上边问题不是两个独立问题而是相互相关，<strong>目的尽量减少冲突前提提高空间利用率和减少查询成本的折中。</strong></p>
<p>加载因子决定了HashMap的扩容的阀门值，如果桶是16，那么扩容值16* 0.75=12，也就是12的时候就要考虑扩容，还有4个没有被利用到，牺牲的空间。如果加载因子是1，空间利用率高，但是查询速度变慢。</p>
<p><strong>原理：</strong></p>
<p>权衡依据是以上情况符合泊松分布（一种统计与概率学里常见到的离散概率分布，适合于描述单位时间（或空间）内随机事件发生的次数），<strong>用0.75作为加载因子，每个碰撞位置的链表长度超过８个概率非常低，少于千万分之一。</strong></p>
<p><strong>源码说明：</strong></p>
<pre><code> * Because TreeNodes are about twice the size of regular nodes, we
 * use them only when bins contain enough nodes to warrant use
 * (see TREEIFY_THRESHOLD). And when they become too small (due to
 * removal or resizing) they are converted back to plain bins.  In
 * usages with well-distributed user hashCodes, tree bins are
 * rarely used.  Ideally, under random hashCodes, the frequency of
 * nodes in bins follows a Poisson distribution
 * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
 * parameter of about 0.5 on average for the default resizing
 * threshold of 0.75, although with a large variance because of
 * resizing granularity. Ignoring variance, the expected
 * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
 * factorial(k)). The first values are:
 *
 * 0:    0.60653066
 * 1:    0.30326533
 * 2:    0.07581633
 * 3:    0.01263606
 * 4:    0.00157952
 * 5:    0.00015795
 * 6:    0.00001316
 * 7:    0.00000094
 * 8:    0.00000006
 * more: less than 1 in ten million 
</code></pre><p><strong>扩展：</strong></p>
<p>为什么不一开始选择红黑树？</p>
<p>红黑树近乎于平衡二叉树，结构适合均匀分布节点，减少树的深度像链表长度情况。原因主要是插入效率上，红黑树增加节点很可能需要进行左旋，右旋，着色操作，这些时间效率并没有链表形式高。</p>

        <h5 id="4-HashMap的key选择"   >
          <a href="#4-HashMap的key选择" class="heading-link"><i class="fas fa-link"></i></a>4.HashMap的key选择</h5>
      <p>1）选择不可变的对象，比如字符串或int类型。</p>
<p>2）如果要用一个自定义实体类作为key：</p>
<p>①类添加final修饰符，保证类不被继承。</p>
<p>②保证所有成员变量必须私有，并且加上final修饰。</p>
<p>③不提供改变成员变量的方法，包括setter。</p>
<p>④通过构造器初始化所有成员，进行深拷贝(deep copy)。</p>

        <h5 id="5-String类中的hashcode计算"   >
          <a href="#5-String类中的hashcode计算" class="heading-link"><i class="fas fa-link"></i></a>5.String类中的hashcode计算</h5>
      <pre><code>public int hashCode() {
    int h = hash;
    if (h == 0 &amp;&amp; value.length &gt; 0) {
    char val[] = value;
        for (int i = 0; i &lt; value.length; i++) {
              h = 31 * h + val[i];
          }
          hash = h;
      }
      return h;
}
</code></pre><p>哈希计算公式：s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1]</p>

        <h3 id="四-横向扩展"   >
          <a href="#四-横向扩展" class="heading-link"><i class="fas fa-link"></i></a>四. 横向扩展</h3>
      
        <h5 id="1-HashMap出现线程问题"   >
          <a href="#1-HashMap出现线程问题" class="heading-link"><i class="fas fa-link"></i></a>1.HashMap出现线程问题</h5>
      <p>①多线程扩容，引起的死循环问题（jdk1.8中，死循环问题已经解决）。</p>
<p>②多线程put的时候可能导致元素丢失。</p>
<p>③put非null元素后get出来的却是null。</p>

        <h5 id="2-使用线程安全Map"   >
          <a href="#2-使用线程安全Map" class="heading-link"><i class="fas fa-link"></i></a>2.使用线程安全Map</h5>
      <p>①HashMap并不是线程安全，要实现线程安全可以用Collections.synchronizedMap(m)获取一个线程安全的HashMap。</p>
<p>②CurrentHashMap和HashTable是线程安全的。CurrentHashMap使用分段锁技术，要操作节点先获取段锁，在修改节点。</p>

        <h5 id="3-Android提倡使用ArrayMap"   >
          <a href="#3-Android提倡使用ArrayMap" class="heading-link"><i class="fas fa-link"></i></a>3.Android提倡使用ArrayMap</h5>
      <p>①ArrayMap数据结构是两个数组，一个存放hash值，另一个存放key和value。</p>
<p>②根据key的hash值利用二分查找在hash数组中找出index。</p>
<p>③根据index在key-value数组中对应位置查找，如果不相等认为冲突了，会以key为中心，分别上下展开，逐一查找。</p>
<p>优势，数据量少时（少于1000）相比HashMap更节省内存。劣势，删除和插入时效率要比HashMap要低。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/Rxjava/">Rxjava只看这一篇文章就够了</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/Rxjava/" data-flag-title="Rxjava只看这一篇文章就够了"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="0-简介"   >
          <a href="#0-简介" class="heading-link"><i class="fas fa-link"></i></a>0. 简介</h1>
      <p>RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。</p>
<p>RxJava 有以下三个基本的元素：</p>
<ol>
<li>被观察者（Observable）</li>
<li>观察者（Observer）</li>
<li>订阅（subscribe）</li>
</ol>
<p>下面来说说以上三者是如何协作的：</p>
<p>首先在 gradle 文件中添加依赖：</p>
<pre><code>implementation &#39;io.reactivex.rxjava2:rxjava:2.1.4&#39;
implementation &#39;io.reactivex.rxjava2:rxandroid:2.0.2&#39;
</code></pre><ol>
<li>创建被观察者：</li>
</ol>
<pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
});
</code></pre><ol>
<li>创建观察者：</li>
</ol>
<pre><code>Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
};
</code></pre><ol>
<li>订阅</li>
</ol>
<pre><code>observable.subscribe(observer);
</code></pre><p>这里其实也可以使用链式调用：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>被观察者发送的事件有以下几种，总结如下表：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>事件种类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>onNext()</td>
<td>发送该事件时，观察者会回调 onNext() 方法</td>
</tr>
<tr>
<td>onError()</td>
<td>发送该事件时，观察者会回调 onError() 方法，当发送该事件之后，其他事件将不会继续发送</td>
</tr>
<tr>
<td>onComplete()</td>
<td>发送该事件时，观察者会回调 onComplete() 方法，当发送该事件之后，其他事件将不会继续发送</td>
</tr>
</tbody></table></div>
<p>其实可以把 RxJava 比喻成一个做果汁，家里有很多种水果（要发送的原始数据），你想榨点水果汁喝一下，这时候你就要想究竟要喝什么水果汁呢？如果你想喝牛油果雪梨柠檬汁，那你就要把这三种水果混在一起榨汁（使用各种操作符变换你想发送给观察者的数据），榨完后，你就可以喝上你想要的果汁了（把处理好的数据发送给观察者）。</p>
<p>总结如下图：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="737" height="188"></svg>)</p>
<p>下面就来讲解 RxJava 各种常见的操作符。</p>

        <h1 id="1-创建操作符"   >
          <a href="#1-创建操作符" class="heading-link"><i class="fas fa-link"></i></a>1. 创建操作符</h1>
      <p>以下就是讲解创建被观察者的各种操作符。</p>

        <h2 id="1-1-create"   >
          <a href="#1-1-create" class="heading-link"><i class="fas fa-link"></i></a>1.1 create()</h2>
      
        <h4 id="方法预览："   >
          <a href="#方法预览：" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)
</code></pre>
        <h4 id="有什么用："   >
          <a href="#有什么用：" class="heading-link"><i class="fas fa-link"></i></a>有什么用：</h4>
      <p>创建一个被观察者</p>

        <h4 id="怎么用："   >
          <a href="#怎么用：" class="heading-link"><i class="fas fa-link"></i></a>怎么用：</h4>
      <pre><code>Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception {
        e.onNext(&quot;Hello Observer&quot;);
        e.onComplete();
    }
});
</code></pre><p>上面的代码非常简单，创建 ObservableOnSubscribe 并重写其 subscribe 方法，就可以通过 ObservableEmitter 发射器向观察者发送事件。</p>
<p>以下创建一个观察者，来验证这个被观察者是否成功创建。</p>
<pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(&quot;chan&quot;,&quot;=============onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        Log.d(&quot;chan&quot;,&quot;=============onComplete &quot;);
    }
};

observable.subscribe(observer);

</code></pre><p>打印结果：</p>
<pre><code>05-20 16:16:50.654 22935-22935/com.example.louder.rxjavademo D/chan: =============onNext Hello Observer
=============onComplete
</code></pre>
        <h2 id="1-2-just"   >
          <a href="#1-2-just" class="heading-link"><i class="fas fa-link"></i></a>1.2 just()</h2>
      
        <h4 id="方法预览：-1"   >
          <a href="#方法预览：-1" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; just(T item) 
......
public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10)
</code></pre>
        <h4 id="有什么用？"   >
          <a href="#有什么用？" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p>

        <h4 id="怎么用？"   >
          <a href="#怎么用？" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});

</code></pre><p>上面的代码直接使用链式调用，代码也非常简单，这里就不细说了，看看打印结果：</p>
<pre><code>05-20 16:27:26.938 23281-23281/? D/chan: =================onSubscribe
=================onNext 1
=================onNext 2
=================onNext 3
=================onComplete 
</code></pre>
        <h2 id="1-3-From-操作符"   >
          <a href="#1-3-From-操作符" class="heading-link"><i class="fas fa-link"></i></a>1.3 From 操作符</h2>
      
        <h2 id="1-3-1-fromArray"   >
          <a href="#1-3-1-fromArray" class="heading-link"><i class="fas fa-link"></i></a>1.3.1  fromArray()</h2>
      
        <h4 id="方法预览：-2"   >
          <a href="#方法预览：-2" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items)
</code></pre>
        <h4 id="有什么用？-1"   >
          <a href="#有什么用？-1" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p>

        <h4 id="怎么用？-1"   >
          <a href="#怎么用？-1" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Integer array[] = {1, 2, 3, 4};
Observable.fromArray(array)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});
</code></pre><p>代码和 just() 基本上一样，直接看打印结果：</p>
<pre><code>05-20 16:35:23.797 23574-23574/com.example.louder.rxjavademo D/chan: =================onSubscribe
=================onNext 1
=================onNext 2
=================onNext 3
=================onNext 4
=================onComplete 
</code></pre>
        <h2 id="1-3-2-fromCallable"   >
          <a href="#1-3-2-fromCallable" class="heading-link"><i class="fas fa-link"></i></a>1.3.2 fromCallable()</h2>
      
        <h4 id="方法预览：-3"   >
          <a href="#方法预览：-3" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier)
</code></pre>
        <h4 id="有什么用？-2"   >
          <a href="#有什么用？-2" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p>

        <h4 id="怎么用？-2"   >
          <a href="#怎么用？-2" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.fromCallable(new Callable &lt; Integer &gt; () {

    @Override
    public Integer call() throws Exception {
        return 1;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 13:01:43.009 6890-6890/? D/chan: ================accept 1
</code></pre>
        <h2 id="1-3-3-fromFuture"   >
          <a href="#1-3-3-fromFuture" class="heading-link"><i class="fas fa-link"></i></a>1.3.3 fromFuture()</h2>
      
        <h4 id="方法预览：-4"   >
          <a href="#方法预览：-4" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)
</code></pre>
        <h4 id="有什么用？-3"   >
          <a href="#有什么用？-3" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p>

        <h4 id="怎么用？-3"   >
          <a href="#怎么用？-3" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>FutureTask &lt; String &gt; futureTask = new FutureTask &lt; &gt; (new Callable &lt; String &gt; () {
    @Override
    public String call() throws Exception {
        Log.d(TAG, &quot;CallableDemo is Running&quot;);
        return &quot;返回结果&quot;;
    }
});

Observable.fromFuture(futureTask)
    .doOnSubscribe(new Consumer &lt; Disposable &gt; () {
    @Override
    public void accept(Disposable disposable) throws Exception {
        futureTask.run();
    }
})
.subscribe(new Consumer &lt; String &gt; () {
    @Override
    public void accept(String s) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + s);
    }
});
</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件，具体会在下面讲解。</p>
<p>打印结果：</p>
<pre><code>05-26 13:54:00.470 14429-14429/com.example.rxjavademo D/chan: CallableDemo is Running
================accept 返回结果
</code></pre>
        <h2 id="1-3-4-fromIterable"   >
          <a href="#1-3-4-fromIterable" class="heading-link"><i class="fas fa-link"></i></a>1.3.4 fromIterable()</h2>
      
        <h4 id="方法预览：-5"   >
          <a href="#方法预览：-5" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source)
</code></pre>
        <h4 id="有什么用？-4"   >
          <a href="#有什么用？-4" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>直接发送一个 List 集合数据给观察者</p>

        <h4 id="怎么用？-4"   >
          <a href="#怎么用？-4" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(0);
list.add(1);
list.add(2);
list.add(3);
Observable.fromIterable(list)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});
</code></pre><p>打印结果如下：</p>
<pre><code>05-20 16:43:28.874 23965-23965/? D/chan: =================onSubscribe
=================onNext 0
=================onNext 1
=================onNext 2
=================onNext 3
=================onComplete 

</code></pre>
        <h2 id="1-4-defer"   >
          <a href="#1-4-defer" class="heading-link"><i class="fas fa-link"></i></a>1.4 defer()</h2>
      
        <h4 id="方法预览：-6"   >
          <a href="#方法预览：-6" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)
</code></pre>
        <h4 id="有什么用？-5"   >
          <a href="#有什么用？-5" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p>

        <h4 id="怎么用？-5"   >
          <a href="#怎么用？-5" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>// i 要定义为成员变量
Integer i = 100;

Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; call() throws Exception {
        return Observable.just(i);
    }
});

i = 200;

Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
};

observable.subscribe(observer);

i = 300;

observable.subscribe(observer);
</code></pre><p>打印结果如下：</p>
<pre><code>05-20 20:05:01.443 26622-26622/? D/chan: ================onNext 200
================onNext 300
</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p>

        <h2 id="1-5-timer"   >
          <a href="#1-5-timer" class="heading-link"><i class="fas fa-link"></i></a>1.5 timer()</h2>
      
        <h4 id="方法预览：-7"   >
          <a href="#方法预览：-7" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) 
......
</code></pre>
        <h4 id="有什么用？-6"   >
          <a href="#有什么用？-6" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>当到指定时间后就会发送一个 0L 的值给观察者。</p>

        <h4 id="怎么用？-6"   >
          <a href="#怎么用？-6" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.timer(2, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;===============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-20 20:27:48.004 27204-27259/com.example.louder.rxjavademo D/chan: ===============onNext 0
</code></pre>
        <h2 id="1-6-interval"   >
          <a href="#1-6-interval" class="heading-link"><i class="fas fa-link"></i></a>1.6 interval()</h2>
      
        <h4 id="方法预览：-8"   >
          <a href="#方法预览：-8" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)
public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)
......
</code></pre>
        <h4 id="有什么用？-7"   >
          <a href="#有什么用？-7" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p>

        <h4 id="怎么用？-7"   >
          <a href="#怎么用？-7" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.interval(4, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-20 20:48:10.321 28723-28723/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-20 20:48:14.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 0
05-20 20:48:18.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 1
05-20 20:48:22.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-20 20:48:26.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-20 20:48:30.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-20 20:48:34.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 5
</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p>

        <h2 id="1-7-intervalRange"   >
          <a href="#1-7-intervalRange" class="heading-link"><i class="fas fa-link"></i></a>1.7 intervalRange()</h2>
      
        <h4 id="方法预览：-9"   >
          <a href="#方法预览：-9" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)
public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)
</code></pre>
        <h4 id="有什么用？-8"   >
          <a href="#有什么用？-8" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p>

        <h4 id="怎么用？-8"   >
          <a href="#怎么用？-8" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.intervalRange(2, 5, 2, 1, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 00:03:01.672 2504-2504/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-21 00:03:03.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-21 00:03:04.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-21 00:03:05.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-21 00:03:06.673 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 5
05-21 00:03:07.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 6
</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p>

        <h2 id="1-8-range"   >
          <a href="#1-8-range" class="heading-link"><i class="fas fa-link"></i></a>1.8 range()</h2>
      
        <h4 id="方法预览：-10"   >
          <a href="#方法预览：-10" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static Observable&lt;Integer&gt; range(final int start, final int count)
</code></pre>
        <h4 id="有什么用？-9"   >
          <a href="#有什么用？-9" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>同时发送一定范围的事件序列。</p>

        <h4 id="怎么用？-9"   >
          <a href="#怎么用？-9" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.range(2, 5)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 00:09:17.202 2921-2921/? D/chan: ==============onSubscribe 
==============onNext 2
==============onNext 3
==============onNext 4
==============onNext 5
==============onNext 6
</code></pre>
        <h2 id="1-9-rangeLong"   >
          <a href="#1-9-rangeLong" class="heading-link"><i class="fas fa-link"></i></a>1.9 rangeLong()</h2>
      
        <h4 id="方法预览：-11"   >
          <a href="#方法预览：-11" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static Observable&lt;Long&gt; rangeLong(long start, long count)
</code></pre>
        <h4 id="有什么用？-10"   >
          <a href="#有什么用？-10" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>作用与 range() 一样，只是数据类型为 Long</p>

        <h4 id="怎么用？-10"   >
          <a href="#怎么用？-10" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>用法与 range() 一样，这里就不再赘述了。</p>

        <h2 id="1-10-empty-amp-never-amp-error"   >
          <a href="#1-10-empty-amp-never-amp-error" class="heading-link"><i class="fas fa-link"></i></a>1.10 empty() &amp; never() &amp; error()</h2>
      
        <h4 id="方法预览：-12"   >
          <a href="#方法预览：-12" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; empty()
public static &lt;T&gt; Observable&lt;T&gt; never()
public static &lt;T&gt; Observable&lt;T&gt; error(final Throwable exception)
</code></pre>
        <h4 id="有什么用？-11"   >
          <a href="#有什么用？-11" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <ol>
<li>empty() ： 直接发送 onComplete() 事件</li>
<li>never()：不发送任何事件</li>
<li>error()：发送 onError() 事件</li>
</ol>

        <h4 id="怎么用？-11"   >
          <a href="#怎么用？-11" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.empty()
.subscribe(new Observer &lt; Object &gt; () {

    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe&quot;);
    }

    @Override
    public void onNext(Object o) {
        Log.d(TAG, &quot;==================onNext&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 14:06:11.881 15798-15798/com.example.rxjavademo D/chan: ==================onSubscribe
==================onComplete
</code></pre><p>换成 never() 的打印结果：</p>
<pre><code>05-26 14:12:17.554 16805-16805/com.example.rxjavademo D/chan: ==================onSubscribe
</code></pre><p>换成 error() 的打印结果：</p>
<pre><code>05-26 14:12:58.483 17817-17817/com.example.rxjavademo D/chan: ==================onSubscribe
==================onError java.lang.NullPointerException
</code></pre>
        <h1 id="2-转换操作符"   >
          <a href="#2-转换操作符" class="heading-link"><i class="fas fa-link"></i></a>2. 转换操作符</h1>
      
        <h2 id="2-1-map"   >
          <a href="#2-1-map" class="heading-link"><i class="fas fa-link"></i></a>2.1 map()</h2>
      
        <h4 id="方法预览：-13"   >
          <a href="#方法预览：-13" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)
</code></pre>
        <h4 id="有什么用？-12"   >
          <a href="#有什么用？-12" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>map 可以将被观察者发送的数据类型转变成其他的类型</p>

        <h4 id="怎么用？-12"   >
          <a href="#怎么用？-12" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>以下代码将 Integer 类型的数据转换成 String。</p>
<pre><code>Observable.just(1, 2, 3)
.map(new Function &lt; Integer, String &gt; () {
    @Override
    public String apply(Integer integer) throws Exception {
        return &quot;I&#39;m &quot; + integer;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.e(TAG, &quot;===================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.e(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 09:16:03.490 5700-5700/com.example.rxjavademo E/chan: ===================onSubscribe
===================onNext I&#39;m 1
===================onNext I&#39;m 2
===================onNext I&#39;m 3
</code></pre>
        <h2 id="2-2-flatMap"   >
          <a href="#2-2-flatMap" class="heading-link"><i class="fas fa-link"></i></a>2.2 flatMap()</h2>
      
        <h4 id="方法预览：-14"   >
          <a href="#方法预览：-14" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
......
</code></pre>
        <h4 id="有什么用？-13"   >
          <a href="#有什么用？-13" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。</p>

        <h4 id="怎么用？-13"   >
          <a href="#怎么用？-13" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。现在用一个例子来说明 flatMap() 的用法。</p>
<p>假设一个有一个 Person 类，这个类的定义如下：</p>
<pre><code>public class Person {

    private String name;
    private List&lt;Plan&gt; planList = new ArrayList&lt;&gt;();

    public Person(String name, List&lt;Plan&gt; planList) {
        this.name = name;
        this.planList = planList;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List&lt;Plan&gt; getPlanList() {
        return planList;
    }

    public void setPlanList(List&lt;Plan&gt; planList) {
        this.planList = planList;
    }

}
</code></pre><p>Person 类有一个 name 和 planList 两个变量，分别代表的是人名和计划清单。</p>
<p>Plan 类的定义如下：</p>
<pre><code>public class Plan {

    private String time;
    private String content;
    private List&lt;String&gt; actionList = new ArrayList&lt;&gt;();

    public Plan(String time, String content) {
        this.time = time;
        this.content = content;
    }

    public String getTime() {
        return time;
    }

    public void setTime(String time) {
        this.time = time;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public List&lt;String&gt; getActionList() {
        return actionList;
    }

    public void setActionList(List&lt;String&gt; actionList) {
        this.actionList = actionList;
    }
}
</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。 首先用 map() 来实现这个需求看看：</p>
<pre><code>Observable.fromIterable(personList)
.map(new Function &lt; Person, List &lt; Plan &gt;&gt; () {
    @Override
    public List &lt; Plan &gt; apply(Person person) throws Exception {
        return person.getPlanList();
    }
})
.subscribe(new Observer &lt; List &lt; Plan &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Plan &gt; plans) {
        for (Plan plan: plans) {
            List &lt; String &gt; planActionList = plan.getActionList();
            for (String action: planActionList) {
                Log.d(TAG, &quot;==================action &quot; + action);
            }
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。</p>
<p>现在看下使用 flatMap() 实现：</p>
<pre><code>Observable.fromIterable(personList)
.flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {
    @Override
    public ObservableSource &lt; Plan &gt; apply(Person person) {
        return Observable.fromIterable(person.getPlanList());
    }
})
.flatMap(new Function &lt; Plan, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Plan plan) throws Exception {
        return Observable.fromIterable(plan.getActionList());
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================action: &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p>

        <h2 id="2-3-concatMap"   >
          <a href="#2-3-concatMap" class="heading-link"><i class="fas fa-link"></i></a>2.3 concatMap()</h2>
      
        <h4 id="方法预览：-15"   >
          <a href="#方法预览：-15" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch)
</code></pre>
        <h4 id="有什么用？-14"   >
          <a href="#有什么用？-14" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>concatMap() 和 flatMap() 基本上是一样的，只不过 concatMap() 转发出来的事件是有序的，而 flatMap() 是无序的。</p>

        <h4 id="怎么用？-14"   >
          <a href="#怎么用？-14" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>还是使用上面 flatMap() 的例子来讲解，首先来试下 flatMap() 来验证发送的事件是否是无序的，代码如下：</p>
<pre><code>Observable.fromIterable(personList)
.flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {
    @Override
    public ObservableSource &lt; Plan &gt; apply(Person person) {
        if (&quot;chan&quot;.equals(person.getName())) {
            return Observable.fromIterable(person.getPlanList()).delay(10, TimeUnit.MILLISECONDS);
        }
        return Observable.fromIterable(person.getPlanList());
    }
})
.subscribe(new Observer &lt; Plan &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Plan plan) {
        Log.d(TAG, &quot;==================plan &quot; + plan.getContent());
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>为了更好的验证 flatMap 是无序的，使用了一个 delay() 方法来延迟，直接看打印结果：</p>
<pre><code>05-21 13:57:14.031 21616-21616/com.example.rxjavademo D/chan: ==================plan chan 上课
==================plan chan 写作业
==================plan chan 打篮球
05-21 13:57:14.041 21616-21641/com.example.rxjavademo D/chan: ==================plan Zede 开会
==================plan Zede 写代码
==================plan Zede 写文章
</code></pre><p>可以看到本来 Zede 的事件发送顺序是排在 chan 事件之前，但是经过延迟后， 这两个事件序列发送顺序互换了。</p>
<p>现在来验证下 concatMap() 是否是有序的，使用上面同样的代码，只是把 flatMap() 换成 concatMap()，打印结果如下：</p>
<pre><code>05-21 13:58:42.917 21799-21823/com.example.rxjavademo D/chan: ==================plan Zede 开会
==================plan Zede 写代码
==================plan Zede 写文章
==================plan chan 上课
==================plan chan 写作业
==================plan chan 打篮球
</code></pre><p>这就代表 concatMap() 转换后发送的事件序列是有序的了。</p>

        <h2 id="2-4-buffer"   >
          <a href="#2-4-buffer" class="heading-link"><i class="fas fa-link"></i></a>2.4 buffer()</h2>
      
        <h4 id="方法预览：-16"   >
          <a href="#方法预览：-16" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip)
......
</code></pre>
        <h4 id="有什么用？-15"   >
          <a href="#有什么用？-15" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p>

        <h4 id="怎么用？-15"   >
          <a href="#怎么用？-15" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>buffer 有两个参数，一个是 count，另一个 skip。count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素。这样说可能还是有点抽象，直接看代码：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.buffer(2, 1)
.subscribe(new Observer &lt; List &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Integer &gt; integers) {
        Log.d(TAG, &quot;================缓冲区大小： &quot; + integers.size());
        for (Integer i: integers) {
            Log.d(TAG, &quot;================元素： &quot; + i);
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 14:09:34.015 22421-22421/com.example.rxjavademo D/chan: ================缓冲区大小： 2
================元素： 1
================元素： 2
================缓冲区大小： 2
================元素： 2
================元素： 3
================缓冲区大小： 2
================元素： 3
================元素： 4
================缓冲区大小： 2
================元素： 4
================元素： 5
================缓冲区大小： 1
================元素： 5
</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p>

        <h2 id="2-5-groupBy"   >
          <a href="#2-5-groupBy" class="heading-link"><i class="fas fa-link"></i></a>2.5 groupBy()</h2>
      
        <h4 id="方法预览：-17"   >
          <a href="#方法预览：-17" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector)
</code></pre>
        <h4 id="有什么用？-16"   >
          <a href="#有什么用？-16" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p>

        <h4 id="怎么用？-16"   >
          <a href="#怎么用？-16" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(5, 2, 3, 4, 1, 6, 8, 9, 7, 10)
.groupBy(new Function &lt; Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer) throws Exception {
        return integer % 3;
    }
})
.subscribe(new Observer &lt; GroupedObservable &lt; Integer, Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;====================onSubscribe &quot;);
    }

    @Override
    public void onNext(GroupedObservable &lt; Integer, Integer &gt; integerIntegerGroupedObservable) {
        Log.d(TAG, &quot;====================onNext &quot;);
        integerIntegerGroupedObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;====================GroupedObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;====================GroupedObservable onNext  groupName: &quot; + integerIntegerGroupedObservable.getKey() + &quot; value: &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;====================GroupedObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;====================GroupedObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;====================onComplete &quot;);
    }
});
</code></pre><p>在 groupBy() 方法返回的参数是分组的名字，每返回一个值，那就代表会创建一个组，以上的代码就是将1~10的数据分成3组，来看看打印结果：</p>
<pre><code>05-26 14:38:02.062 21451-21451/com.example.rxjavademo D/chan: ====================onSubscribe 
05-26 14:38:02.063 21451-21451/com.example.rxjavademo D/chan: ====================onNext 
====================GroupedObservable onSubscribe     ====================GroupedObservable onNext  groupName: 2 value: 5
====================GroupedObservable onNext  groupName: 2 value: 2
====================onNext 
====================GroupedObservable onSubscribe 
====================GroupedObservable onNext  groupName: 0 value: 3
05-26 14:38:02.064 21451-21451/com.example.rxjavademo D/chan: ====================onNext 
====================GroupedObservable onSubscribe 
====================GroupedObservable onNext  groupName: 1 value: 4
====================GroupedObservable onNext  groupName: 1 value: 1
====================GroupedObservable onNext  groupName: 0 value: 6
====================GroupedObservable onNext  groupName: 2 value: 8
====================GroupedObservable onNext  groupName: 0 value: 9
====================GroupedObservable onNext  groupName: 1 value: 7
====================GroupedObservable onNext  groupName: 1 value: 10
05-26 14:38:02.065 21451-21451/com.example.rxjavademo D/chan: ====================GroupedObservable onComplete 
====================GroupedObservable onComplete 
====================GroupedObservable onComplete 
====================onComplete 
</code></pre><p>可以看到返回的结果中是有3个组的。</p>

        <h2 id="2-6-scan"   >
          <a href="#2-6-scan" class="heading-link"><i class="fas fa-link"></i></a>2.6 scan()</h2>
      
        <h4 id="方法预览：-18"   >
          <a href="#方法预览：-18" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator)
</code></pre>
        <h4 id="有什么用？-17"   >
          <a href="#有什么用？-17" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>将数据以一定的逻辑聚合起来。</p>

        <h4 id="怎么用？-17"   >
          <a href="#怎么用？-17" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4, 5)
.scan(new BiFunction &lt; Integer, Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer, Integer integer2) throws Exception {
        Log.d(TAG, &quot;====================apply &quot;);
        Log.d(TAG, &quot;====================integer &quot; + integer);
        Log.d(TAG, &quot;====================integer2 &quot; + integer2);
        return integer + integer2;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 14:45:27.784 22519-22519/com.example.rxjavademo D/chan: ====================accept 1
====================apply 
====================integer 1
====================integer2 2
====================accept 3
====================apply 
05-26 14:45:27.785 22519-22519/com.example.rxjavademo D/chan: ====================integer 3
====================integer2 3
====================accept 6
====================apply 
====================integer 6
====================integer2 4
====================accept 10
====================apply 
====================integer 10
====================integer2 5
====================accept 15
</code></pre>
        <h2 id="2-7-window"   >
          <a href="#2-7-window" class="heading-link"><i class="fas fa-link"></i></a>2.7 window()</h2>
      
        <h4 id="方法预览：-19"   >
          <a href="#方法预览：-19" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;Observable&lt;T&gt;&gt; window(long count)
......
</code></pre>
        <h4 id="有什么用？-18"   >
          <a href="#有什么用？-18" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p>

        <h4 id="怎么用？-18"   >
          <a href="#怎么用？-18" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4, 5)
.window(2)
.subscribe(new Observer &lt; Observable &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=====================onSubscribe &quot;);
    }

    @Override
    public void onNext(Observable &lt; Integer &gt; integerObservable) {
        integerObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;=====================integerObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;=====================integerObservable onNext &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;=====================integerObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;=====================integerObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=====================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 15:02:20.654 25838-25838/com.example.rxjavademo D/chan: =====================onSubscribe 
05-26 15:02:20.655 25838-25838/com.example.rxjavademo D/chan: =====================integerObservable onSubscribe 
05-26 15:02:20.656 25838-25838/com.example.rxjavademo D/chan: =====================integerObservable onNext 1
=====================integerObservable onNext 2
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 3
=====================integerObservable onNext 4
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 5
=====================integerObservable onComplete 
=====================onComplete 
</code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p>

        <h1 id="3-组合操作符"   >
          <a href="#3-组合操作符" class="heading-link"><i class="fas fa-link"></i></a>3. 组合操作符</h1>
      
        <h2 id="3-1-concat"   >
          <a href="#3-1-concat" class="heading-link"><i class="fas fa-link"></i></a>3.1 concat()</h2>
      
        <h4 id="方法预览：-20"   >
          <a href="#方法预览：-20" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
......
</code></pre>
        <h4 id="有什么用？-19"   >
          <a href="#有什么用？-19" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p>

        <h4 id="怎么用？-19"   >
          <a href="#怎么用？-19" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.concat(Observable.just(1, 2),
Observable.just(3, 4),
Observable.just(5, 6),
Observable.just(7, 8))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印如下：</p>
<pre><code>05-21 15:40:26.738 7477-7477/com.example.rxjavademo D/chan: ================onNext 1
================onNext 2
05-21 15:40:26.739 7477-7477/com.example.rxjavademo D/chan: ================onNext 3
================onNext 4
================onNext 5
================onNext 6
================onNext 7
================onNext 8
</code></pre>
        <h2 id="3-2-concatArray"   >
          <a href="#3-2-concatArray" class="heading-link"><i class="fas fa-link"></i></a>3.2 concatArray()</h2>
      
        <h4 id="方法预览：-21"   >
          <a href="#方法预览：-21" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource&lt;? extends T&gt;... sources)
</code></pre>
        <h4 id="有什么用？-20"   >
          <a href="#有什么用？-20" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>与 concat()  作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p>

        <h4 id="怎么用？-20"   >
          <a href="#怎么用？-20" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.concatArray(Observable.just(1, 2),
Observable.just(3, 4),
Observable.just(5, 6),
Observable.just(7, 8),
Observable.just(9, 10))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 15:47:18.581 9129-9129/com.example.rxjavademo D/chan: ================onNext 1
================onNext 2
================onNext 3
================onNext 4
================onNext 5
================onNext 6
================onNext 7
================onNext 8
================onNext 9
================onNext 10
</code></pre>
        <h2 id="3-3-merge"   >
          <a href="#3-3-merge" class="heading-link"><i class="fas fa-link"></i></a>3.3 merge()</h2>
      
        <h4 id="方法预览：-22"   >
          <a href="#方法预览：-22" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code> public static &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
......
</code></pre>
        <h4 id="有什么用？-21"   >
          <a href="#有什么用？-21" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>这个方法月 concat() 作用基本一样，知识 concat() 是串行发送事件，而 merge() 并行发送事件。</p>

        <h4 id="怎么用？-21"   >
          <a href="#怎么用？-21" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>现在来演示 concat() 和 merge() 的区别。</p>
<pre><code>Observable.merge(
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;A&quot; + aLong;
    }
}),
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;B&quot; + aLong;
    }
}))
    .subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;=====================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果如下：</p>
<pre><code>05-21 16:10:31.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B0
05-21 16:10:31.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:10:32.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:10:32.126 12801-12850/com.example.rxjavademo D/chan: =====================onNext B1
05-21 16:10:33.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:10:33.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B2
05-21 16:10:34.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:10:34.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B3
05-21 16:10:35.124 12801-12849/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:10:35.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B4
05-21 16:10:36.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A5
05-21 16:10:36.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B5
......
</code></pre><p>从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：</p>
<pre><code>05-21 16:17:52.352 14597-14621/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:17:53.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:17:54.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:17:55.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:17:56.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:17:57.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A5
......
</code></pre><p>从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。</p>
<p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者，这里就不再赘述了。</p>

        <h2 id="3-4-concatArrayDelayError-amp-mergeArrayDelayError"   >
          <a href="#3-4-concatArrayDelayError-amp-mergeArrayDelayError" class="heading-link"><i class="fas fa-link"></i></a>3.4 concatArrayDelayError() &amp; mergeArrayDelayError()</h2>
      
        <h4 id="方法预览：-23"   >
          <a href="#方法预览：-23" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
public static &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
</code></pre>
        <h4 id="有什么用？-22"   >
          <a href="#有什么用？-22" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 onError() 事件延迟到所有被观察者都发送完事件后再执行的话，就可以使用  concatArrayDelayError() 和 mergeArrayDelayError()</p>

        <h4 id="怎么用？-22"   >
          <a href="#怎么用？-22" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>首先使用 concatArray() 来验证一下发送 onError() 事件是否会中断其他被观察者发送事件，代码如下：</p>
<pre><code>Observable.concatArray(
Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onError(new NumberFormatException());
    }
}), Observable.just(2, 3, 4))
    .subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-21 16:38:59.725 17985-17985/com.example.rxjavademo D/chan: ===================onNext 1
===================onError 
</code></pre><p>从结果可以知道，确实中断了，现在换用 concatArrayDelayError()，代码如下：</p>
<pre><code>Observable.concatArrayDelayError(
Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onError(new NumberFormatException());
    }
}), Observable.just(2, 3, 4))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>打印结果如下：</p>
<pre><code>05-21 16:40:59.329 18199-18199/com.example.rxjavademo D/chan: ===================onNext 1
===================onNext 2
===================onNext 3
===================onNext 4
===================onError 
</code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用，这里不再赘述。</p>

        <h2 id="3-5-zip"   >
          <a href="#3-5-zip" class="heading-link"><i class="fas fa-link"></i></a>3.5 zip()</h2>
      
        <h4 id="方法预览：-24"   >
          <a href="#方法预览：-24" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper)
......
</code></pre>
        <h4 id="有什么用？-23"   >
          <a href="#有什么用？-23" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p>

        <h4 id="怎么用？-23"   >
          <a href="#怎么用？-23" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.zip(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS)
    .map(new Function&lt;Long, String&gt;() {
        @Override
        public String apply(Long aLong) throws Exception {
            String s1 = &quot;A&quot; + aLong;
            Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
            return s1;
        }}),
        Observable.intervalRange(1, 6, 1, 1, TimeUnit.SECONDS)
            .map(new Function&lt;Long, String&gt;() {
            @Override
            public String apply(Long aLong) throws Exception {
                String s2 = &quot;B&quot; + aLong;
                Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
                return s2;
            }
        }),
        new BiFunction&lt;String, String, String&gt;() {
            @Override
            public String apply(String s, String s2) throws Exception {
                String res = s + s2;
                return res;
            }
        })
.subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：</p>
<pre><code>05-22 09:10:39.952 5338-5338/com.example.rxjavademo D/chan: ===================onSubscribe 
05-22 09:10:40.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 09:10:40.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
===================onNext A1B1
05-22 09:10:41.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 09:10:41.954 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
===================onNext A2B2
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
05-22 09:10:42.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================onNext A3B3
05-22 09:10:43.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 09:10:43.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 09:10:43.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A4B4
05-22 09:10:44.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A5
05-22 09:10:44.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 09:10:44.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A5B5
===================onComplete 
</code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p>

        <h2 id="3-6-combineLatest-amp-combineLatestDelayError"   >
          <a href="#3-6-combineLatest-amp-combineLatestDelayError" class="heading-link"><i class="fas fa-link"></i></a>3.6 combineLatest() &amp;  combineLatestDelayError()</h2>
      
        <h4 id="方法预览：-25"   >
          <a href="#方法预览：-25" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner)
....... 
</code></pre>
        <h4 id="有什么用？-24"   >
          <a href="#有什么用？-24" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送，这样可能还是比较抽象，看看以下例子代码。</p>

        <h4 id="怎么用？-24"   >
          <a href="#怎么用？-24" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.combineLatest(
Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s1 = &quot;A&quot; + aLong;
        Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
        return s1;
    }
}),
Observable.intervalRange(1, 5, 2, 2, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s2 = &quot;B&quot; + aLong;
        Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
        return s2;
    }
}),
new BiFunction &lt; String, String, String &gt; () {@Override
    public String apply(String s, String s2) throws Exception {
        String res = s + s2;
        return res;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================最终接收到的事件 &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：</p>
<pre><code>05-22 11:41:20.859 15104-15104/? D/chan: ===================onSubscribe 
05-22 11:41:21.859 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 11:41:22.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 11:41:22.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
05-22 11:41:22.862 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1
05-22 11:41:23.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
===================最终接收到的事件 A3B1
05-22 11:41:24.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
05-22 11:41:24.861 15104-15128/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2
05-22 11:41:26.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 11:41:26.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3
05-22 11:41:28.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 11:41:28.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4
05-22 11:41:30.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 11:41:30.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5
===================onComplete 
</code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p>
<p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p>

        <h2 id="3-7-reduce"   >
          <a href="#3-7-reduce" class="heading-link"><i class="fas fa-link"></i></a>3.7 reduce()</h2>
      
        <h4 id="方法预览：-26"   >
          <a href="#方法预览：-26" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer)
</code></pre>
        <h4 id="有什么用？-25"   >
          <a href="#有什么用？-25" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</p>

        <h4 id="怎么用？-25"   >
          <a href="#怎么用？-25" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(0, 1, 2, 3)
.reduce(new BiFunction &lt; Integer, Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer, Integer integer2) throws Exception {
        int res = integer + integer2;
        Log.d(TAG, &quot;====================integer &quot; + integer);
        Log.d(TAG, &quot;====================integer2 &quot; + integer2);
        Log.d(TAG, &quot;====================res &quot; + res);
        return res;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;==================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 14:21:46.042 17775-17775/? D/chan: ====================integer 0
====================integer2 1
====================res 1
====================integer 1
====================integer2 2
====================res 3
====================integer 3
====================integer2 3
====================res 6
==================accept 6
</code></pre><p>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p>

        <h2 id="3-8-collect"   >
          <a href="#3-8-collect" class="heading-link"><i class="fas fa-link"></i></a>3.8 collect()</h2>
      
        <h4 id="方法预览：-27"   >
          <a href="#方法预览：-27" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector)
</code></pre>
        <h4 id="有什么用？-26"   >
          <a href="#有什么用？-26" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>将数据收集到数据结构当中。</p>

        <h4 id="怎么用？-26"   >
          <a href="#怎么用？-26" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4)
.collect(new Callable &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public ArrayList &lt; Integer &gt; call() throws Exception {
        return new ArrayList &lt; &gt; ();
    }
},
new BiConsumer &lt; ArrayList &lt; Integer &gt; , Integer &gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers, Integer integer) throws Exception {
        integers.add(integer);
    }
})
.subscribe(new Consumer &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers) throws Exception {
        Log.d(TAG, &quot;===============accept &quot; + integers);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 16:47:18.257 31361-31361/com.example.rxjavademo D/chan: ===============accept [1, 2, 3, 4]
</code></pre>
        <h2 id="3-9-startWith-amp-startWithArray"   >
          <a href="#3-9-startWith-amp-startWithArray" class="heading-link"><i class="fas fa-link"></i></a>3.9 startWith() &amp; startWithArray()</h2>
      
        <h4 id="方法预览：-28"   >
          <a href="#方法预览：-28" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; startWith(T item)
public final Observable&lt;T&gt; startWithArray(T... items)
</code></pre>
        <h4 id="有什么用？-27"   >
          <a href="#有什么用？-27" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p>

        <h4 id="怎么用？-27"   >
          <a href="#怎么用？-27" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(5, 6, 7)
.startWithArray(2, 3, 4)
.startWith(1)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 17:08:21.282 4505-4505/com.example.rxjavademo D/chan: ================accept 1
================accept 2
================accept 3
================accept 4
================accept 5
================accept 6
================accept 7
</code></pre>
        <h2 id="3-10-count"   >
          <a href="#3-10-count" class="heading-link"><i class="fas fa-link"></i></a>3.10 count()</h2>
      
        <h4 id="方法预览：-29"   >
          <a href="#方法预览：-29" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Single&lt;Long&gt; count()
</code></pre>
        <h4 id="有什么用？-28"   >
          <a href="#有什么用？-28" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>返回被观察者发送事件的数量。</p>

        <h4 id="怎么用？-28"   >
          <a href="#怎么用？-28" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3)
.count()
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;=======================aLong &quot; + aLong);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-22 20:41:25.025 14126-14126/? D/chan: =======================aLong 3
</code></pre>
        <h1 id="4-功能操作符"   >
          <a href="#4-功能操作符" class="heading-link"><i class="fas fa-link"></i></a>4. 功能操作符</h1>
      
        <h2 id="4-1-delay"   >
          <a href="#4-1-delay" class="heading-link"><i class="fas fa-link"></i></a>4.1 delay()</h2>
      
        <h4 id="方法预览：-30"   >
          <a href="#方法预览：-30" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; delay(long delay, TimeUnit unit)
</code></pre>
        <h4 id="有什么用？-29"   >
          <a href="#有什么用？-29" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>延迟一段事件发送事件。</p>

        <h4 id="怎么用？-29"   >
          <a href="#怎么用？-29" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3)
.delay(2, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=======================onSubscribe&quot;);
    }
});
</code></pre><p>这里延迟了两秒才发送事件，来看看打印结果：</p>
<pre><code>05-22 20:53:43.618 16880-16880/com.example.rxjavademo D/chan: =======================onSubscribe
05-22 20:53:45.620 16880-16906/com.example.rxjavademo D/chan: =======================onNext 1
05-22 20:53:45.621 16880-16906/com.example.rxjavademo D/chan: =======================onNext 2
=======================onNext 3
=======================onSubscribe
</code></pre><p>从打印结果可以看出 onSubscribe 回调2秒之后 onNext 才会回调。</p>

        <h2 id="4-2-doOnEach"   >
          <a href="#4-2-doOnEach" class="heading-link"><i class="fas fa-link"></i></a>4.2 doOnEach()</h2>
      
        <h4 id="方法预览：-31"   >
          <a href="#方法预览：-31" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification)
</code></pre>
        <h4 id="有什么用？-30"   >
          <a href="#有什么用？-30" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>Observable 每发送一件事件之前都会先回调这个方法。</p>

        <h4 id="怎么用？-30"   >
          <a href="#怎么用？-30" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        //      e.onError(new NumberFormatException());
        e.onComplete();
    }
})
.doOnEach(new Consumer &lt; Notification &lt; Integer &gt;&gt; () {
    @Override
    public void accept(Notification &lt; Integer &gt; integerNotification) throws Exception {
        Log.d(TAG, &quot;==================doOnEach &quot; + integerNotification.getValue());
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:07:05.547 19867-19867/? D/chan: ==================onSubscribe 
==================doOnEach 1
==================onNext 1
==================doOnEach 2
==================onNext 2
==================doOnEach 3
==================onNext 3
==================doOnEach null
==================onComplete 
</code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p>

        <h2 id="4-3-doOnNext"   >
          <a href="#4-3-doOnNext" class="heading-link"><i class="fas fa-link"></i></a>4.3 doOnNext()</h2>
      
        <h4 id="方法预览：-32"   >
          <a href="#方法预览：-32" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)
</code></pre>
        <h4 id="有什么用？-31"   >
          <a href="#有什么用？-31" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>Observable 每发送 onNext() 之前都会先回调这个方法。</p>

        <h4 id="怎么用？-31"   >
          <a href="#怎么用？-31" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnNext(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;==================doOnNext &quot; + integer);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:09:36.769 20020-20020/com.example.rxjavademo D/chan: ==================onSubscribe 
==================doOnNext 1
==================onNext 1
==================doOnNext 2
==================onNext 2
==================doOnNext 3
==================onNext 3
==================onComplete 
</code></pre>
        <h2 id="4-4-doAfterNext"   >
          <a href="#4-4-doAfterNext" class="heading-link"><i class="fas fa-link"></i></a>4.4 doAfterNext()</h2>
      
        <h4 id="方法预览：-33"   >
          <a href="#方法预览：-33" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext)
</code></pre>
        <h4 id="有什么用？-32"   >
          <a href="#有什么用？-32" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>Observable 每发送 onNext() 之后都会回调这个方法。</p>

        <h4 id="怎么用？-32"   >
          <a href="#怎么用？-32" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doAfterNext(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;==================doAfterNext &quot; + integer);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});

</code></pre><p>打印结果：</p>
<pre><code>05-23 09:15:49.215 20432-20432/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================doAfterNext 1
==================onNext 2
==================doAfterNext 2
==================onNext 3
==================doAfterNext 3
==================onComplete 
</code></pre>
        <h2 id="4-5-doOnComplete"   >
          <a href="#4-5-doOnComplete" class="heading-link"><i class="fas fa-link"></i></a>4.5 doOnComplete()</h2>
      
        <h4 id="方法预览：-34"   >
          <a href="#方法预览：-34" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnComplete(Action onComplete)
</code></pre>
        <h4 id="有什么用？-33"   >
          <a href="#有什么用？-33" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>Observable 每发送 onComplete() 之前都会回调这个方法。</p>

        <h4 id="怎么用？-33"   >
          <a href="#怎么用？-33" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnComplete(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnComplete &quot;);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:32:18.031 20751-20751/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================doOnComplete 
==================onComplete 
</code></pre>
        <h2 id="4-6-doOnError"   >
          <a href="#4-6-doOnError" class="heading-link"><i class="fas fa-link"></i></a>4.6 doOnError()</h2>
      
        <h4 id="方法预览：-35"   >
          <a href="#方法预览：-35" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)
</code></pre>
        <h4 id="有什么用？-34"   >
          <a href="#有什么用？-34" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>Observable 每发送 onError() 之前都会回调这个方法。</p>

        <h4 id="怎么用？-34"   >
          <a href="#怎么用？-34" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.doOnError(new Consumer &lt; Throwable &gt; () {
    @Override
    public void accept(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================doOnError &quot; + throwable);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:35:04.150 21051-21051/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================doOnError java.lang.NullPointerException
==================onError 

</code></pre>
        <h2 id="4-7-doOnSubscribe"   >
          <a href="#4-7-doOnSubscribe" class="heading-link"><i class="fas fa-link"></i></a>4.7 doOnSubscribe()</h2>
      
        <h4 id="方法预览：-36"   >
          <a href="#方法预览：-36" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe)
</code></pre>
        <h4 id="有什么用？-35"   >
          <a href="#有什么用？-35" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p>

        <h4 id="怎么用？-35"   >
          <a href="#怎么用？-35" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnSubscribe(new Consumer &lt; Disposable &gt; () {
    @Override
    public void accept(Disposable disposable) throws Exception {
        Log.d(TAG, &quot;==================doOnSubscribe &quot;);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:39:25.778 21245-21245/? D/chan: ==================doOnSubscribe 
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre>
        <h2 id="4-8-doOnDispose"   >
          <a href="#4-8-doOnDispose" class="heading-link"><i class="fas fa-link"></i></a>4.8 doOnDispose()</h2>
      
        <h4 id="方法预览：-37"   >
          <a href="#方法预览：-37" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnDispose(Action onDispose)
</code></pre>
        <h4 id="有什么用？-36"   >
          <a href="#有什么用？-36" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>当调用 Disposable 的 dispose() 之后回调该方法。</p>

        <h4 id="怎么用？-36"   >
          <a href="#怎么用？-36" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnDispose(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnDispose &quot;);
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    private Disposable d;

    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 09:55:48.122 22023-22023/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================doOnDispose 
</code></pre>
        <h2 id="4-9-doOnLifecycle"   >
          <a href="#4-9-doOnLifecycle" class="heading-link"><i class="fas fa-link"></i></a>4.9 doOnLifecycle()</h2>
      
        <h4 id="方法预览：-38"   >
          <a href="#方法预览：-38" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose)
</code></pre>
        <h4 id="有什么用？-37"   >
          <a href="#有什么用？-37" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。</p>

        <h4 id="怎么用？-37"   >
          <a href="#怎么用？-37" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>doOnLifecycle() 第二个参数的回调方法的作用与  doOnDispose() 是一样的，现在用下面的例子来讲解：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnLifecycle(new Consumer&lt;Disposable&gt;() {
    @Override
    public void accept(Disposable disposable) throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle accept&quot;);
    }
}, new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle Action&quot;);
    }
})
.doOnDispose(
    new Action() {
        @Override
        public void run() throws Exception {
            Log.d(TAG, &quot;==================doOnDispose Action&quot;);
        }
})
.subscribe(new Observer&lt;Integer&gt;() {
    private Disposable d;
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }

});
</code></pre><p>打印结果：</p>
<pre><code>05-23 10:20:36.345 23922-23922/? D/chan: ==================doOnLifecycle accept
==================onSubscribe 
==================onNext 1
==================doOnDispose Action
==================doOnLifecycle Action
</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。</p>
<p>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p>
<pre><code>05-23 10:32:20.014 24652-24652/com.example.rxjavademo D/chan: ==================doOnLifecycle accept
==================onSubscribe 
</code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p>

        <h2 id="4-10-doOnTerminate-amp-doAfterTerminate"   >
          <a href="#4-10-doOnTerminate-amp-doAfterTerminate" class="heading-link"><i class="fas fa-link"></i></a>4.10 doOnTerminate() &amp; doAfterTerminate()</h2>
      
        <h4 id="方法预览：-39"   >
          <a href="#方法预览：-39" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doOnTerminate(final Action onTerminate)
public final Observable&lt;T&gt; doAfterTerminate(Action onFinally)
</code></pre>
        <h4 id="有什么用？-38"   >
          <a href="#有什么用？-38" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p>

        <h4 id="怎么用？-38"   >
          <a href="#怎么用？-38" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
//      e.onError(new NullPointerException());
        e.onComplete();
    }
})
.doOnTerminate(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnTerminate &quot;);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }

});
</code></pre><p>打印结果：</p>
<pre><code>05-23 10:00:39.503 22398-22398/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
05-23 10:00:39.504 22398-22398/com.example.rxjavademo D/chan: ==================onNext 3
==================doOnTerminate 
==================onComplete 
</code></pre><p>doAfterTerminate 也是差不多，这里就不再赘述。</p>

        <h2 id="4-11-doFinally"   >
          <a href="#4-11-doFinally" class="heading-link"><i class="fas fa-link"></i></a>4.11 doFinally()</h2>
      
        <h4 id="方法预览：-40"   >
          <a href="#方法预览：-40" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; doFinally(Action onFinally)
</code></pre>
        <h4 id="有什么用？-39"   >
          <a href="#有什么用？-39" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>在所有事件发送完毕之后回调该方法。</p>

        <h4 id="怎么用？-39"   >
          <a href="#怎么用？-39" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 doFinally() 无论怎么样都会被回调，且都会在事件序列的最后。</p>
<p>现在用以下例子说明下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doFinally(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doFinally &quot;);
    }
})
.doOnDispose(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnDispose &quot;);
    }
})
.doAfterTerminate(new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doAfterTerminate &quot;);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    private Disposable d;
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 10:10:10.469 23196-23196/? D/chan: ==================onSubscribe 
05-23 10:10:10.470 23196-23196/? D/chan: ==================onNext 1
==================doOnDispose 
==================doFinally 
</code></pre><p>可以看到如果调用了 dispose() 方法，doAfterTerminate() 不会被回调。</p>
<p>现在试试把 dispose() 注释掉看看，看看打印结果：</p>
<pre><code>05-23 10:13:34.537 23439-23439/com.example.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
==================doAfterTerminate 
==================doFinally 
</code></pre><p>doAfterTerminate() 已经成功回调，doFinally() 还是会在事件序列的最后。</p>

        <h2 id="4-12-onErrorReturn"   >
          <a href="#4-12-onErrorReturn" class="heading-link"><i class="fas fa-link"></i></a>4.12 onErrorReturn()</h2>
      
        <h4 id="方法预览：-41"   >
          <a href="#方法预览：-41" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier)
</code></pre>
        <h4 id="有什么用？-40"   >
          <a href="#有什么用？-40" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p>

        <h4 id="怎么用？-40"   >
          <a href="#怎么用？-40" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorReturn(new Function&lt;Throwable, Integer&gt;() {
    @Override
    public Integer apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorReturn &quot; + throwable);
        return 404;
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 18:35:18.175 19239-19239/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorReturn java.lang.NullPointerException
==================onNext 404
==================onComplete 
</code></pre>
        <h2 id="4-13-onErrorResumeNext"   >
          <a href="#4-13-onErrorResumeNext" class="heading-link"><i class="fas fa-link"></i></a>4.13 onErrorResumeNext()</h2>
      
        <h4 id="方法预览：-42"   >
          <a href="#方法预览：-42" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction)
</code></pre>
        <h4 id="有什么用？-41"   >
          <a href="#有什么用？-41" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p>

        <h4 id="怎么用？-41"   >
          <a href="#怎么用？-41" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorResumeNext &quot; + throwable);
        return Observable.just(4, 5, 6);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 18:43:10.910 26469-26469/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorResumeNext java.lang.NullPointerException
==================onNext 4
==================onNext 5
==================onNext 6
==================onComplete 
</code></pre>
        <h2 id="4-14-onExceptionResumeNext"   >
          <a href="#4-14-onExceptionResumeNext" class="heading-link"><i class="fas fa-link"></i></a>4.14 onExceptionResumeNext()</h2>
      
        <h4 id="方法预览：-43"   >
          <a href="#方法预览：-43" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next)
</code></pre>
        <h4 id="有什么用？-42"   >
          <a href="#有什么用？-42" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p>

        <h4 id="怎么用？-42"   >
          <a href="#怎么用？-42" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>先来试试 onExceptionResumeNext() 是否能捕捉 Error。</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Error(&quot;404&quot;));
    }
})
.onExceptionResumeNext(new Observable&lt;Integer&gt;() {
    @Override
    protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
        observer.onNext(333);
        observer.onComplete();
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 22:23:08.873 1062-1062/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
05-23 22:23:08.874 1062-1062/com.example.louder.rxjavademo D/chan: ==================onNext 1
==================onNext 2
==================onNext 3
==================onError 
</code></pre><p>从打印结果可以知道，观察者收到 onError() 事件，证明 onErrorResumeNext() 不能捕捉 Error 事件。</p>
<p>将被观察者的 e.onError(new Error(“404”)) 改为 e.onError(new Exception(“404”))，现在看看是否能捕捉 Exception 事件：</p>
<pre><code>05-23 22:32:14.563 10487-10487/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 333
==================onComplete 
</code></pre><p>从打印结果可以知道，这个方法成功捕获 Exception 事件。</p>

        <h2 id="4-15-retry"   >
          <a href="#4-15-retry" class="heading-link"><i class="fas fa-link"></i></a>4.15 retry()</h2>
      
        <h4 id="方法预览：-44"   >
          <a href="#方法预览：-44" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; retry(long times)
......
</code></pre>
        <h4 id="有什么用？-43"   >
          <a href="#有什么用？-43" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p>

        <h4 id="怎么用？-43"   >
          <a href="#怎么用？-43" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Exception(&quot;404&quot;));
    }
})
.retry(2)
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 22:46:18.537 22239-22239/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
05-23 22:46:18.538 22239-22239/com.example.louder.rxjavademo D/chan: ==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 1
==================onNext 2
==================onNext 3
==================onError 
</code></pre>
        <h2 id="4-16-retryUntil"   >
          <a href="#4-16-retryUntil" class="heading-link"><i class="fas fa-link"></i></a>4.16 retryUntil()</h2>
      
        <h4 id="方法预览：-45"   >
          <a href="#方法预览：-45" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop)
</code></pre>
        <h4 id="有什么用？-44"   >
          <a href="#有什么用？-44" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>出现错误事件之后，可以通过此方法判断是否继续发送事件。</p>

        <h4 id="怎么用？-44"   >
          <a href="#怎么用？-44" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Exception(&quot;404&quot;));
    }
})
.retryUntil(new BooleanSupplier() {
    @Override
    public boolean getAsBoolean() throws Exception {
        if (i == 6) {
            return true;
        }
        return false;
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-23 22:57:32.905 23063-23063/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
05-23 22:57:32.906 23063-23063/com.example.louder.rxjavademo D/chan: ==================onNext 1
==================onNext 2
==================onNext 3
==================onError 

</code></pre>
        <h2 id="4-17-retryWhen"   >
          <a href="#4-17-retryWhen" class="heading-link"><i class="fas fa-link"></i></a>4.17 retryWhen()</h2>
      
        <h4 id="方法预览：-46"   >
          <a href="#方法预览：-46" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final void safeSubscribe(Observer&lt;? super T&gt; s)
</code></pre>
        <h4 id="有什么用？-45"   >
          <a href="#有什么用？-45" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</p>

        <h4 id="怎么用？-45"   >
          <a href="#怎么用？-45" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; String &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; String &gt; e) throws Exception {
        e.onNext(&quot;chan&quot;);
        e.onNext(&quot;ze&quot;);
        e.onNext(&quot;de&quot;);
        e.onError(new Exception(&quot;404&quot;));
        e.onNext(&quot;haha&quot;);
    }
})
.retryWhen(new Function &lt; Observable &lt; Throwable &gt; , ObservableSource &lt;? &gt;&gt; () {
    @Override
    public ObservableSource &lt;? &gt; apply(Observable &lt; Throwable &gt; throwableObservable) throws Exception {
        return throwableObservable.flatMap(new Function &lt; Throwable, ObservableSource &lt;? &gt;&gt; () {
            @Override
            public ObservableSource &lt;? &gt; apply(Throwable throwable) throws Exception {
                if(!throwable.toString().equals(&quot;java.lang.Exception: 404&quot;)) {
                    return Observable.just(&quot;可以忽略的异常&quot;);
                } else {
                    return Observable.error(new Throwable(&quot;终止啦&quot;));
                }
            }
        });
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e.toString());
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 09:13:25.622 28372-28372/com.example.rxjavademo D/chan: ==================onSubscribe 
05-24 09:13:25.623 28372-28372/com.example.rxjavademo D/chan: ==================onNext chan
==================onNext ze
==================onNext de
05-24 09:13:25.624 28372-28372/com.example.rxjavademo D/chan: ==================onError java.lang.Throwable: 终止啦
</code></pre><p>将 onError(new Exception(“404”)) 改为 onError(new Exception(“303”)) 看看打印结果：</p>
<pre><code>==================onNext chan
05-24 09:54:08.653 29694-29694/? D/chan: ==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
......
</code></pre><p>从结果可以看出，会不断重复发送消息。</p>

        <h2 id="4-18-repeat"   >
          <a href="#4-18-repeat" class="heading-link"><i class="fas fa-link"></i></a>4.18 repeat()</h2>
      
        <h4 id="方法预览：-47"   >
          <a href="#方法预览：-47" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; repeat(long times)
......
</code></pre>
        <h4 id="有什么用？-46"   >
          <a href="#有什么用？-46" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>重复发送被观察者的事件，times 为发送次数。</p>

        <h4 id="怎么用？-46"   >
          <a href="#怎么用？-46" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.repeat(2)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 11:33:29.565 8544-8544/com.example.rxjavademo D/chan: ===================onSubscribe 
===================onNext 1
===================onNext 2
===================onNext 3
===================onNext 1
===================onNext 2
===================onNext 3
05-24 11:33:29.565 8544-8544/com.example.rxjavademo D/chan: ===================onComplete 
</code></pre><p>从结果可以看出，该事件发送了两次。</p>

        <h2 id="4-19-repeatWhen"   >
          <a href="#4-19-repeatWhen" class="heading-link"><i class="fas fa-link"></i></a>4.19 repeatWhen()</h2>
      
        <h4 id="方法预览：-48"   >
          <a href="#方法预览：-48" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)
</code></pre>
        <h4 id="有什么用？-47"   >
          <a href="#有什么用？-47" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p>

        <h4 id="怎么用？-47"   >
          <a href="#怎么用？-47" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <p>这里分三种情况，如果新的被观察者返回 onComplete 或者 onError 事件，则旧的被观察者不会继续发送事件。如果被观察者返回其他事件，则会重复发送事件。</p>
<p>现在试验发送 onComplete 事件，代码如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.repeatWhen(new Function &lt; Observable &lt; Object &gt; , ObservableSource &lt;? &gt;&gt; () {
    @Override
    public ObservableSource &lt;? &gt; apply(Observable &lt; Object &gt; objectObservable) throws Exception {
        return Observable.empty();
    //  return Observable.error(new Exception(&quot;404&quot;));
    //  return Observable.just(4); null;
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 11:44:33.486 9379-9379/com.example.rxjavademo D/chan: ===================onSubscribe 
05-24 11:44:33.487 9379-9379/com.example.rxjavademo D/chan: ===================onComplete 
</code></pre><p>下面直接看看发送 onError 事件和其他事件的打印结果。</p>
<p>发送 onError 打印结果：</p>
<pre><code>05-24 11:46:29.507 9561-9561/com.example.rxjavademo D/chan: ===================onSubscribe 
05-24 11:46:29.508 9561-9561/com.example.rxjavademo D/chan: ===================onError 
</code></pre><p>发送其他事件的打印结果：</p>
<pre><code>05-24 11:48:35.844 9752-9752/com.example.rxjavademo D/chan: ===================onSubscribe 
===================onNext 1
===================onNext 2
===================onNext 3
===================onComplete 
</code></pre>
        <h2 id="4-20-subscribeOn"   >
          <a href="#4-20-subscribeOn" class="heading-link"><i class="fas fa-link"></i></a>4.20 subscribeOn()</h2>
      
        <h4 id="方法预览：-49"   >
          <a href="#方法预览：-49" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler)
</code></pre>
        <h4 id="有什么用？-48"   >
          <a href="#有什么用？-48" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。</p>

        <h4 id="怎么用？-48"   >
          <a href="#怎么用？-48" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
//.subscribeOn(Schedulers.newThread())
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>现在不调用 subscribeOn() 方法，来看看打印结果：</p>
<pre><code>05-26 10:40:42.246 21466-21466/? D/chan: ======================onSubscribe
05-26 10:40:42.247 21466-21466/? D/chan: =========================currentThread name: main
======================onNext 1
======================onNext 2
======================onNext 3
======================onComplete
</code></pre><p>可以看到打印被观察者的线程名字是主线程。</p>
<p>接着调用 subscribeOn(Schedulers.newThread()) 来看看打印结果：</p>
<pre><code>05-26 10:43:26.964 22530-22530/com.example.rxjavademo D/chan: ======================onSubscribe
05-26 10:43:26.966 22530-22569/com.example.rxjavademo D/chan: =========================currentThread name: RxNewThreadScheduler-1
05-26 10:43:26.967 22530-22569/com.example.rxjavademo D/chan: ======================onNext 1
======================onNext 2
======================onNext 3
======================onComplete
</code></pre><p>可以看到打印结果被观察者是在一条新的线程。</p>
<p>现在看看多次调用会不会有效，代码如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.subscribeOn(Schedulers.computation())
.subscribeOn(Schedulers.newThread())
.subscribe(new Observer &lt; Integer &gt; () {@Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:47:20.925 23590-23590/com.example.rxjavademo D/chan: ======================onSubscribe
05-26 10:47:20.930 23590-23629/com.example.rxjavademo D/chan: =========================currentThread name: RxComputationThreadPool-1
======================onNext 1
======================onNext 2
======================onNext 3
======================onComplete
</code></pre><p>可以看到第二次调动的 subscribeOn(Schedulers.newThread()) 并没有效果。</p>

        <h2 id="4-21-observeOn"   >
          <a href="#4-21-observeOn" class="heading-link"><i class="fas fa-link"></i></a>4.21 observeOn()</h2>
      
        <h4 id="方法预览：-50"   >
          <a href="#方法预览：-50" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler)
</code></pre>
        <h4 id="有什么用？-49"   >
          <a href="#有什么用？-49" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>指定观察者的线程，每指定一次就会生效一次。</p>

        <h4 id="怎么用？-49"   >
          <a href="#怎么用？-49" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3)
.observeOn(Schedulers.newThread())
.flatMap(new Function &lt; Integer, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception {
        Log.d(TAG, &quot;======================flatMap Thread name &quot; + Thread.currentThread().getName());
        return Observable.just(&quot;chan&quot; + integer);
    }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;======================onNext Thread name &quot; + Thread.currentThread().getName());
        Log.d(TAG, &quot;======================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:58:04.593 25717-25717/com.example.rxjavademo D/chan: ======================onSubscribe
05-26 10:58:04.594 25717-25753/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler-1
05-26 10:58:04.595 25717-25753/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler-1
======================flatMap Thread name RxNewThreadScheduler-1
05-26 10:58:04.617 25717-25717/com.example.rxjavademo D/chan: ======================onNext Thread name main
======================onNext chan1
======================onNext Thread name main
======================onNext chan2
======================onNext Thread name main
======================onNext chan3
05-26 10:58:04.618 25717-25717/com.example.rxjavademo D/chan: ======================onComplete
</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p>
<p>下表总结了 RxJava 中的调度器：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>调度器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Schedulers.computation( )</td>
<td>用于使用计算任务，如事件循环和回调处理</td>
</tr>
<tr>
<td>Schedulers.immediate( )</td>
<td>当前线程</td>
</tr>
<tr>
<td>Schedulers.io( )</td>
<td>用于 IO 密集型任务，如果异步阻塞 IO 操作。</td>
</tr>
<tr>
<td>Schedulers.newThread( )</td>
<td>创建一个新的线程</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>Android 的 UI 线程，用于操作 UI。</td>
</tr>
</tbody></table></div>

        <h1 id="5-过滤操作符"   >
          <a href="#5-过滤操作符" class="heading-link"><i class="fas fa-link"></i></a>5. 过滤操作符</h1>
      
        <h2 id="5-1-filter"   >
          <a href="#5-1-filter" class="heading-link"><i class="fas fa-link"></i></a>5.1 filter()</h2>
      
        <h4 id="方法预览：-51"   >
          <a href="#方法预览：-51" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)
</code></pre>
        <h4 id="有什么用？-50"   >
          <a href="#有什么用？-50" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。</p>

        <h4 id="怎么用？-50"   >
          <a href="#怎么用？-50" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code> Observable.just(1, 2, 3)
    .filter(new Predicate &lt; Integer &gt; () {
        @Override
        public boolean test(Integer integer) throws Exception {
            return integer &lt; 2;
        }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>以上代码只有小于2的事件才会发送，来看看打印结果：</p>
<pre><code>05-24 22:57:32.562 12776-12776/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onComplete 
</code></pre>
        <h2 id="5-2-ofType"   >
          <a href="#5-2-ofType" class="heading-link"><i class="fas fa-link"></i></a>5.2 ofType()</h2>
      
        <h4 id="方法预览：-52"   >
          <a href="#方法预览：-52" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz)
</code></pre>
        <h4 id="有什么用？-51"   >
          <a href="#有什么用？-51" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>可以过滤不符合该类型事件</p>

        <h4 id="怎么用？-51"   >
          <a href="#怎么用？-51" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, &quot;chan&quot;, &quot;zhide&quot;)
.ofType(Integer.class)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 23:04:24.752 13229-13229/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
05-24 23:04:24.753 13229-13229/? D/chan: ==================onComplete 
</code></pre>
        <h2 id="5-3-skip"   >
          <a href="#5-3-skip" class="heading-link"><i class="fas fa-link"></i></a>5.3 skip()</h2>
      
        <h4 id="方法预览：-53"   >
          <a href="#方法预览：-53" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; skip(long count)
.......
</code></pre>
        <h4 id="有什么用？-52"   >
          <a href="#有什么用？-52" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>跳过正序某些事件，count 代表跳过事件的数量</p>

        <h4 id="怎么用？-52"   >
          <a href="#怎么用？-52" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3)
.skip(2)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 23:13:50.448 13831-13831/? D/chan: ==================onSubscribe 
05-24 23:13:50.449 13831-13831/? D/chan: ==================onNext 3
==================onComplete 
</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件，这里就不再讲解了。</p>

        <h2 id="5-4-distinct"   >
          <a href="#5-4-distinct" class="heading-link"><i class="fas fa-link"></i></a>5.4 distinct()</h2>
      
        <h4 id="方法预览：-54"   >
          <a href="#方法预览：-54" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; distinct() 
</code></pre>
        <h4 id="有什么用"   >
          <a href="#有什么用" class="heading-link"><i class="fas fa-link"></i></a>有什么用?</h4>
      <p>过滤事件序列中的重复事件。</p>

        <h4 id="怎么用"   >
          <a href="#怎么用" class="heading-link"><i class="fas fa-link"></i></a>怎么用?</h4>
      <pre><code>Observable.just(1, 2, 3, 3, 2, 1)
.distinct()
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果:</p>
<pre><code>05-24 23:19:44.334 14206-14206/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre>
        <h2 id="5-5-distinctUntilChanged"   >
          <a href="#5-5-distinctUntilChanged" class="heading-link"><i class="fas fa-link"></i></a>5.5 distinctUntilChanged()</h2>
      
        <h4 id="方法预览：-55"   >
          <a href="#方法预览：-55" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; distinctUntilChanged()
</code></pre>
        <h4 id="有什么用？-53"   >
          <a href="#有什么用？-53" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>过滤掉连续重复的事件</p>

        <h4 id="怎么用-1"   >
          <a href="#怎么用-1" class="heading-link"><i class="fas fa-link"></i></a>怎么用?</h4>
      <pre><code>Observable.just(1, 2, 3, 3, 2, 1)
.distinctUntilChanged()
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果:</p>
<pre><code>05-24 23:22:35.985 14424-14424/com.example.louder.rxjavademo D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 2
==================onNext 1
==================onComplete 
</code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p>

        <h2 id="5-6-take"   >
          <a href="#5-6-take" class="heading-link"><i class="fas fa-link"></i></a>5.6 take()</h2>
      
        <h4 id="方法预览：-56"   >
          <a href="#方法预览：-56" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; take(long count)
......
</code></pre>
        <h4 id="有什么用-1"   >
          <a href="#有什么用-1" class="heading-link"><i class="fas fa-link"></i></a>有什么用?</h4>
      <p>控制观察者接收的事件的数量。</p>

        <h4 id="怎么用-2"   >
          <a href="#怎么用-2" class="heading-link"><i class="fas fa-link"></i></a>怎么用?</h4>
      <pre><code>Observable.just(1, 2, 3, 4, 5)
.take(3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-24 23:28:32.899 14704-14704/? D/chan: ==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情，这里就不再讲解了，大家可以自己试试。</p>

        <h2 id="5-7-debounce"   >
          <a href="#5-7-debounce" class="heading-link"><i class="fas fa-link"></i></a>5.7 debounce()</h2>
      
        <h4 id="方法预览：-57"   >
          <a href="#方法预览：-57" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit)
......
</code></pre>
        <h4 id="有什么用？-54"   >
          <a href="#有什么用？-54" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p>

        <h4 id="怎么用？-53"   >
          <a href="#怎么用？-53" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        Thread.sleep(900);
        e.onNext(2);
    }
})
.debounce(1, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-25 20:39:10.512 17441-17441/com.example.rxjavademo D/chan: ===================onSubscribe 
05-25 20:39:12.413 17441-17478/com.example.rxjavademo D/chan: ===================onNext 2
</code></pre><p>可以看到事件1并没有发送出去，现在将间隔时间改为1000，看看打印结果：</p>
<pre><code>05-25 20:42:10.874 18196-18196/com.example.rxjavademo D/chan: ===================onSubscribe 
05-25 20:42:11.875 18196-18245/com.example.rxjavademo D/chan: ===================onNext 1
05-25 20:42:12.875 18196-18245/com.example.rxjavademo D/chan: ===================onNext 2
</code></pre><p>throttleWithTimeout() 与此方法的作用一样，这里就不再赘述了。</p>

        <h2 id="5-8-firstElement-amp-amp-lastElement"   >
          <a href="#5-8-firstElement-amp-amp-lastElement" class="heading-link"><i class="fas fa-link"></i></a>5.8 firstElement() &amp;&amp; lastElement()</h2>
      
        <h5 id="方法预览：-58"   >
          <a href="#方法预览：-58" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h5>
      <pre><code>public final Maybe&lt;T&gt; firstElement()
public final Maybe&lt;T&gt; lastElement()
</code></pre>
        <h4 id="有什么用？-55"   >
          <a href="#有什么用？-55" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p>

        <h4 id="怎么用？-54"   >
          <a href="#怎么用？-54" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4)
.firstElement()
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================firstElement &quot; + integer);
    }
});

Observable.just(1, 2, 3, 4)
.lastElement()
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================lastElement &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-25 20:47:22.189 19909-19909/? D/chan: ====================firstElement 1
====================lastElement 4
</code></pre>
        <h2 id="5-9-elementAt-amp-elementAtOrError"   >
          <a href="#5-9-elementAt-amp-elementAtOrError" class="heading-link"><i class="fas fa-link"></i></a>5.9 elementAt() &amp; elementAtOrError()</h2>
      
        <h4 id="方法预览：-59"   >
          <a href="#方法预览：-59" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Maybe&lt;T&gt; elementAt(long index)
public final Single&lt;T&gt; elementAtOrError(long index)
</code></pre>
        <h4 id="有什么用？-56"   >
          <a href="#有什么用？-56" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p>

        <h4 id="怎么用？-55"   >
          <a href="#怎么用？-55" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4)
.elementAt(0)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-25 20:56:22.266 23346-23346/com.example.rxjavademo D/chan: ====================accept 1
</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。</p>
<p>替换 elementAt() 为 elementAtOrError()，代码如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.elementAtOrError(5)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>io.reactivex.exceptions.OnErrorNotImplementedException
at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java: 704)
at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java: 701)
at io.reactivex.internal.observers.ConsumerSingleObserver.onError(ConsumerSingleObserver.java: 47)
at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onComplete(ObservableElementAtSingle.java: 117)
at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java: 110)
at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java: 36)
at io.reactivex.Observable.subscribe(Observable.java: 10903)
at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java: 37)
at io.reactivex.Single.subscribe(Single.java: 2707)
at io.reactivex.Single.subscribe(Single.java: 2693)
at io.reactivex.Single.subscribe(Single.java: 2664)
at com.example.rxjavademo.MainActivity.onCreate(MainActivity.java: 103)
at android.app.Activity.performCreate(Activity.java: 6942)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java: 1126)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java: 2880)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java: 2988)
at android.app.ActivityThread. - wrap14(ActivityThread.java)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java: 1631)
at android.os.Handler.dispatchMessage(Handler.java: 102)
at android.os.Looper.loop(Looper.java: 154)
at android.app.ActivityThread.main(ActivityThread.java: 6682)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: 1520)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java: 1410)
Caused by: java.util.NoSuchElementException
at io.reactivex.internal.operators.observable.ObservableElementAtSingle$ElementAtObserver.onComplete(ObservableElementAtSingle.java: 117) 
at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java: 110) 
at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java: 36) 
at io.reactivex.Observable.subscribe(Observable.java: 10903) 
at io.reactivex.internal.operators.observable.ObservableElementAtSingle.subscribeActual(ObservableElementAtSingle.java: 37) 
at io.reactivex.Single.subscribe(Single.java: 2707) 
at io.reactivex.Single.subscribe(Single.java: 2693) 
at io.reactivex.Single.subscribe(Single.java: 2664) 
at com.example.rxjavademo.MainActivity.onCreate(MainActivity.java: 103) 
at android.app.Activity.performCreate(Activity.java: 6942) 
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java: 1126) 
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java: 2880) 
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java: 2988) 
at android.app.ActivityThread. - wrap14(ActivityThread.java) 
at android.app.ActivityThread$H.handleMessage(ActivityThread.java: 1631) 
at android.os.Handler.dispatchMessage(Handler.java: 102) 
at android.os.Looper.loop(Looper.java: 154) 
at android.app.ActivityThread.main(ActivityThread.java: 6682) 
at java.lang.reflect.Method.invoke(Native Method) 
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java: 1520) 
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java: 1410) 
</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p>

        <h1 id="6-条件操作符"   >
          <a href="#6-条件操作符" class="heading-link"><i class="fas fa-link"></i></a>6. 条件操作符</h1>
      
        <h2 id="6-1-all"   >
          <a href="#6-1-all" class="heading-link"><i class="fas fa-link"></i></a>6.1 all()</h2>
      
        <h4 id="方法预览：-60"   >
          <a href="#方法预览：-60" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; ambWith(ObservableSource&lt;? extends T&gt; other)
</code></pre>
        <h4 id="有什么用？-57"   >
          <a href="#有什么用？-57" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p>

        <h4 id="怎么用？-56"   >
          <a href="#怎么用？-56" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4)
.all(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 5;
    }
})
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;==================aBoolean &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:39:51.644 1482-1482/com.example.rxjavademo D/chan: ==================aBoolean true
</code></pre>
        <h2 id="6-2-takeWhile"   >
          <a href="#6-2-takeWhile" class="heading-link"><i class="fas fa-link"></i></a>6.2 takeWhile()</h2>
      
        <h4 id="方法预览：-61"   >
          <a href="#方法预览：-61" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)
</code></pre>
        <h4 id="有什么用？-58"   >
          <a href="#有什么用？-58" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送。</p>

        <h4 id="怎么用？-57"   >
          <a href="#怎么用？-57" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4)
.takeWhile(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:43:14.634 3648-3648/com.example.rxjavademo D/chan: ========================integer 1
========================integer 2
</code></pre>
        <h2 id="6-3-skipWhile"   >
          <a href="#6-3-skipWhile" class="heading-link"><i class="fas fa-link"></i></a>6.3 skipWhile()</h2>
      
        <h4 id="方法预览：-62"   >
          <a href="#方法预览：-62" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate)
</code></pre>
        <h4 id="有什么用？-59"   >
          <a href="#有什么用？-59" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p>

        <h4 id="怎么用？-58"   >
          <a href="#怎么用？-58" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4)
.skipWhile(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:47:32.653 4861-4861/com.example.rxjavademo D/chan: ========================integer 3
========================integer 4
</code></pre>
        <h2 id="6-4-takeUntil"   >
          <a href="#6-4-takeUntil" class="heading-link"><i class="fas fa-link"></i></a>6.4 takeUntil()</h2>
      
        <h4 id="方法预览：-63"   >
          <a href="#方法预览：-63" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate
</code></pre>
        <h4 id="有什么用？-60"   >
          <a href="#有什么用？-60" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p>

        <h4 id="怎么用？-59"   >
          <a href="#怎么用？-59" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3, 4, 5, 6)
.takeUntil(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &gt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 09:55:12.918 7933-7933/com.example.rxjavademo D/chan: ========================integer 1
========================integer 2
05-26 09:55:12.919 7933-7933/com.example.rxjavademo D/chan: ========================integer 3
========================integer 4
</code></pre>
        <h2 id="6-5-skipUntil"   >
          <a href="#6-5-skipUntil" class="heading-link"><i class="fas fa-link"></i></a>6.5 skipUntil()</h2>
      
        <h4 id="方法预览：-64"   >
          <a href="#方法预览：-64" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final &lt;U&gt; Observable&lt;T&gt; skipUntil(ObservableSource&lt;U&gt; other)
</code></pre>
        <h4 id="有什么用？-61"   >
          <a href="#有什么用？-61" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。</p>

        <h4 id="怎么用？-60"   >
          <a href="#怎么用？-60" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS)
.skipUntil(Observable.intervalRange(6, 5, 3, 1, TimeUnit.SECONDS))
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;========================onSubscribe &quot;);
    }

    @Override
    public void onNext(Long along) {
        Log.d(TAG, &quot;========================onNext &quot; + along);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;========================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;========================onComplete &quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:08:50.574 13023-13023/com.example.rxjavademo D/chan: ========================onSubscribe 
05-26 10:08:53.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 4
05-26 10:08:54.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 5
========================onComplete 
</code></pre><p>从结果可以看出，skipUntil() 里的 Observable 并不会发送事件给观察者。</p>

        <h2 id="6-6-sequenceEqual"   >
          <a href="#6-6-sequenceEqual" class="heading-link"><i class="fas fa-link"></i></a>6.6 sequenceEqual()</h2>
      
        <h4 id="方法预览：-65"   >
          <a href="#方法预览：-65" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)
......
</code></pre>
        <h4 id="有什么用？-62"   >
          <a href="#有什么用？-62" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>判断两个  Observable 发送的事件是否相同。</p>

        <h4 id="怎么用？-61"   >
          <a href="#怎么用？-61" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.sequenceEqual(Observable.just(1, 2, 3),
Observable.just(1, 2, 3))
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:11:45.975 14157-14157/? D/chan: ========================onNext true
</code></pre>
        <h2 id="6-7-contains"   >
          <a href="#6-7-contains" class="heading-link"><i class="fas fa-link"></i></a>6.7 contains()</h2>
      
        <h4 id="方法预览：-66"   >
          <a href="#方法预览：-66" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Single&lt;Boolean&gt; contains(final Object element)
</code></pre>
        <h4 id="有什么用？-63"   >
          <a href="#有什么用？-63" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p>

        <h4 id="怎么用？-62"   >
          <a href="#怎么用？-62" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.just(1, 2, 3)
.contains(3)
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:14:23.522 15085-15085/com.example.rxjavademo D/chan: ========================onNext true
</code></pre>
        <h2 id="6-8-isEmpty"   >
          <a href="#6-8-isEmpty" class="heading-link"><i class="fas fa-link"></i></a>6.8 isEmpty()</h2>
      
        <h4 id="方法预览：-67"   >
          <a href="#方法预览：-67" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Single&lt;Boolean&gt; isEmpty()
</code></pre>
        <h4 id="有什么用？-64"   >
          <a href="#有什么用？-64" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>判断事件序列是否为空。</p>

        <h4 id="怎么用？-63"   >
          <a href="#怎么用？-63" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onComplete();
    }
})
.isEmpty()
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + aBoolean);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:17:16.725 16109-16109/com.example.rxjavademo D/chan: ========================onNext true
</code></pre>
        <h2 id="6-9-amb"   >
          <a href="#6-9-amb" class="heading-link"><i class="fas fa-link"></i></a>6.9 amb()</h2>
      
        <h4 id="方法预览：-68"   >
          <a href="#方法预览：-68" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public static &lt;T&gt; Observable&lt;T&gt; amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)
</code></pre>
        <h4 id="有什么用？-65"   >
          <a href="#有什么用？-65" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃。</p>

        <h4 id="怎么用？-64"   >
          <a href="#怎么用？-64" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>ArrayList &lt; Observable &lt; Long &gt;&gt; list = new ArrayList &lt; &gt; ();

list.add(Observable.intervalRange(1, 5, 2, 1, TimeUnit.SECONDS));
list.add(Observable.intervalRange(6, 5, 0, 1, TimeUnit.SECONDS));

Observable.amb(list)
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;========================aLong &quot; + aLong);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:21:29.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 6
05-26 10:21:30.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 7
05-26 10:21:31.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 8
05-26 10:21:32.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 9
05-26 10:21:33.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 10
</code></pre>
        <h2 id="6-10-defaultIfEmpty"   >
          <a href="#6-10-defaultIfEmpty" class="heading-link"><i class="fas fa-link"></i></a>6.10 defaultIfEmpty()</h2>
      
        <h4 id="方法预览：-69"   >
          <a href="#方法预览：-69" class="heading-link"><i class="fas fa-link"></i></a>方法预览：</h4>
      <pre><code>public final Observable&lt;T&gt; defaultIfEmpty(T defaultItem)
</code></pre>
        <h4 id="有什么用？-66"   >
          <a href="#有什么用？-66" class="heading-link"><i class="fas fa-link"></i></a>有什么用？</h4>
      <p>如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值。</p>

        <h4 id="怎么用？-65"   >
          <a href="#怎么用？-65" class="heading-link"><i class="fas fa-link"></i></a>怎么用？</h4>
      <pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onComplete();
    }
})
.defaultIfEmpty(666)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + integer);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>05-26 10:26:56.376 19249-19249/com.example.rxjavademo D/chan: ========================onNext 666
</code></pre><p>RxJava 常见的使用方式都已经介绍的差不多，相信大家如果都掌握这些操作符的用法的话，那么使用 RxJava 将不会再是难题了。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/view3/">一文彻底了解Android自定义控件3</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/view3/" data-flag-title="一文彻底了解Android自定义控件3"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="Android自定控件的步骤"   >
          <a href="#Android自定控件的步骤" class="heading-link"><i class="fas fa-link"></i></a>Android自定控件的步骤</h3>
      <p>为什么自定义控件要步骤化呢？因为很多新手同学，根据产品的要求做一些控件时，无从下手。</p>
<p>有了步骤以后，就可以按套路走了，再也不用害怕了。</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877ef78f4537d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h3 id="判断控件类型"   >
          <a href="#判断控件类型" class="heading-link"><i class="fas fa-link"></i></a>判断控件类型</h3>
      <p>首先我们要判断这个控件是属于自定义控件里的哪种类型，如果不知道分类的话，同学们可以看这篇文章<code>自定义控件分类</code></p>

        <h3 id="获取相关的属性"   >
          <a href="#获取相关的属性" class="heading-link"><i class="fas fa-link"></i></a>获取相关的属性</h3>
      <p>其实这玩意在自定义控件里叫自定义属性。什么是属性呢？</p>
<p>来我们看，android控件原有的属性：</p>
<p>比如说我们的LinearLayout</p>
<pre><code>&lt;LinearLayout
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_marginBottom=&quot;41px&quot;
        android:orientation=&quot;horizontal&quot;&gt;
&lt;/LinearLayout&gt;</code></pre><p>这里面的属性就有origintation,layout_width,layout_height…. 而origintation是LinearLayout特有的，而其他的则是View都有的</p>
<p>那么我们在写自己的控件时，有些值，也是通过xml里的属性进行配置的，所以我们要有自定义属性。</p>
<p>自定义控件里如何自定义属性呢？</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877f3cbbdbf4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877f63897a169?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>自定义属性步骤：</p>
<ol>
<li>声明属性</li>
</ol>
<p>在<code>res</code>的<code>values</code>目录下的<code>attrs.xml</code>文件中(没有就自己新建一个)，使用<code>declare-styleable</code>标签自定义属性。</p>
<p>在attrs.xml里进行声明，其实都行，都是resourse，举例：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;!--属性集合--&gt;
    &lt;declare-styleable name=&quot;SearchView&quot; &gt;
        &lt;!--hint--&gt;
        &lt;attr name=&quot;hint&quot; format=&quot;string&quot;/&gt;
        &lt;!--搜索图标  可以通过typedArray.getResourceId获取资源id--&gt;
        &lt;attr name=&quot;search_ico&quot; format=&quot;reference&quot; /&gt;
        &lt;!--清空图标--&gt;
        &lt;attr name=&quot;clear_ico&quot; format=&quot;reference&quot; /&gt;
        &lt;!--语音图标--&gt;
        &lt;attr name=&quot;voice_ico&quot; format=&quot;reference&quot; /&gt;
        &lt;!--输入类型--&gt;
        &lt;attr name=&quot;input_type&quot;&gt;
            &lt;!--value值只能是int类型的  所以获取时通过typeArray.getInt获取--&gt;
            &lt;enum name=&quot;text&quot; value=&quot;0&quot;/&gt;
            &lt;enum name=&quot;passwordText&quot; value=&quot;1&quot;/&gt;
        &lt;/attr&gt;

        &lt;attr name=&quot;gravity&quot;&gt;
            &lt;!--区别于enum  enum只能选择一个  flag可以多选 如：left|top--&gt;
            &lt;flag name=&quot;left&quot; value=&quot;0&quot; /&gt;
            &lt;flag name=&quot;top&quot; value=&quot;1&quot; /&gt;
            &lt;flag name=&quot;center&quot; value=&quot;2&quot; /&gt;
            &lt;flag name=&quot;right&quot; value=&quot;3&quot; /&gt;
            &lt;flag name=&quot;bottom&quot; value=&quot;4&quot; /&gt;
        &lt;/attr&gt;
    &lt;/declare-styleable&gt;

&lt;/resources&gt;</code></pre><p>其中<code>declare-styleable</code>标签代表一个属性集合，<strong><code>name</code>属性要与自定义的控件同名</strong>。 <code>attr</code>则是每条属性了，<code>name</code>是属性值，<code>format</code>是指定属性类型,目前可支持11种类型：</p>
<blockquote>
<ul>
<li>reference:引用资源</li>
<li>string:字符串</li>
<li>Color：颜色</li>
<li>boolean：布尔值</li>
<li>dimension：尺寸值</li>
<li>float：浮点型</li>
<li>integer：整型</li>
<li>fraction：百分数</li>
<li>enum：枚举类型</li>
<li>flag：位或运算</li>
</ul>
</blockquote>
<ol>
<li>布局文件中使用</li>
</ol>
<p>首先需要加上一个命名空间<code>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</code> 然后直接利用这个命名空间设置属性即可</p>
<pre><code>&lt;com.searchview.SearchView
      android:id=&quot;@+id/searchView&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;50dp&quot;
      android:layout_marginEnd=&quot;8dp&quot;
      android:layout_marginStart=&quot;8dp&quot;
      android:layout_marginTop=&quot;8dp&quot;
      app:hint=&quot;aaa&quot;
      app:search_ico=&quot;@drawable/ic_search&quot;
      app:layout_constraintEnd_toEndOf=&quot;parent&quot;
      app:layout_constraintStart_toStartOf=&quot;parent&quot;
      app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</code></pre>
        <h3 id="测量"   >
          <a href="#测量" class="heading-link"><i class="fas fa-link"></i></a>测量</h3>
      <p>测量是重点要掌握的，如果是ViewGroup则测量自己(设置自己大小，因为ViewGroup也可以是子view呀)跟设置期望孩子的大小。</p>
<p>如果是View则需要测量自己（设置自己大小）</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877fa2caab751?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>这两个参数要理解</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877fc3870f585?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877fee3eb06bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h3 id="自定义控件的本质"   >
          <a href="#自定义控件的本质" class="heading-link"><i class="fas fa-link"></i></a>自定义控件的本质</h3>
      <p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172878027202327b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/view2/">一文彻底了解Android自定义控件2</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/view2/" data-flag-title="一文彻底了解Android自定义控件2"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>经过前面对Android自定义控件初步了解以后，我们接下来就在前面的基础上更加深入了解所谓的Android自定义控件！</p>

        <h3 id="AndroidView体系"   >
          <a href="#AndroidView体系" class="heading-link"><i class="fas fa-link"></i></a>AndroidView体系</h3>
      <p>在学习自定义控件之前，我们先了解一下Android的View体系</p>
<p>打开Android Studio –&gt; ctrl+N –&gt; 输入View</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877a33009dc05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>这样子，我们就找到了View这个类了！</p>

        <h3 id="View的继承关系"   >
          <a href="#View的继承关系" class="heading-link"><i class="fas fa-link"></i></a>View的继承关系</h3>
      <p>进到View这个类里， 选中类名，按ctrl+H，显示类的继承关系：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877ae65a73b28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>我们可以看到一些熟悉的控件，比如说<code>ProgressBar</code>,<code>ImageView</code>,<code>TextView</code></p>
<p>所以我们得到如下的继承关系:</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877b2585e8c53?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>继续打开<code>ViewGroup</code></p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877b6011de279?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>所以我们是又可以得到以下这张关系转图：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877b8beacb583?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>

        <h3 id="View和ViewGrop的区别"   >
          <a href="#View和ViewGrop的区别" class="heading-link"><i class="fas fa-link"></i></a>View和ViewGrop的区别</h3>
      <p>先看ViewGroup，就是View组的意思是吧！也就是说，ViewGrop里面有很多子View，用于管理/摆放子View的View就叫ViewGroup。</p>
<p>什么是View呢？严格上来说，都是View，为什么呢？有了前面的定义，ViewGroup里面的全是View，因为你是View-Group呀！而ViewGrop里也可以方ViewGrop，所以说，ViewGroup也可以认为是View。比如说LinearLayout里面还可以放LinearLayout吧！</p>
<p>但是通常来说，我们说自定义View指的是定那些需要自己绘制的控件，重点是绘制，比如说时钟呀，波浪效果这些…View里面不再摆放其他的子View，我们把这种称为View</p>
<p>而ViewGroup，则是用于控制View的摆放，比如说LinearLayout，让子View成线性摆放，RelativeLayout让子View以相对的位置进行摆放..</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>对于Android的View体系，了解继承关系，知道怎么区分是View，什么是ViewGroup即可。View注重的是绘制内容，ViewGropu注重子View的摆放。</p>
<p>有了这些基础知识，我们后面写自定义控件就可以步骤化了。第一步就是要判断你写的这个控件属于ViewGrop还是View.</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/view1/">一文彻底了解Android自定义控件1</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/view1/" data-flag-title="一文彻底了解Android自定义控件1"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="AndroidView体系"   >
          <a href="#AndroidView体系" class="heading-link"><i class="fas fa-link"></i></a>AndroidView体系</h3>
      <p>了解android的View体系，才知道后面我们步骤写Android自定义控件做准备。</p>
<p>要明白<code>View</code>和<code>ViewGroup</code>。</p>
<p>要能判断常用的控件是属于<code>View</code>还是<code>ViewGrop</code>，接着才有自己要写的控件属于<code>View</code>还是<code>ViewGroup</code>。</p>
<p>为什么呢？</p>
<p>因为自定义<code>View</code>跟自定义<code>ViewGroup</code>的步骤，套路不一样。</p>

        <h3 id="Android自定义控件类型"   >
          <a href="#Android自定义控件类型" class="heading-link"><i class="fas fa-link"></i></a>Android自定义控件类型</h3>
      <p>Android自定义控件呢，我们可以分为三类：</p>
<ul>
<li>自定义View（包括对现有View的修改）;</li>
<li>自定义ViewGrop（包括对现有ViewGroup的修改）;</li>
<li>自定义ViewGrop;</li>
</ul>

        <h3 id="自定义组合控件例子"   >
          <a href="#自定义组合控件例子" class="heading-link"><i class="fas fa-link"></i></a>自定义组合控件例子</h3>
      <p>自定义组合控件，其实就是把多个现在有控件整合在一起，把复杂的操作封装起来，把简单的操作暴露出去。</p>
<p>比如说我们要做以下这个控件：</p>
<p><img   src="http://user-gold-cdn.xitu.io/2020/6/6/172877873e858952?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style=""  alt="img"></p>
<p>当然可以重头开始绘制，从无到有。</p>
<p>我们也可以使用两个<code>button</code> + 一个<code>TextView</code>或者<code>EditText</code>组合起来。</p>
<p>然后把复杂的逻辑封装起来，比如说，上限和下限的判断，比如说增加梯度，比如说阀值，达到一定的值会改变颜色之类的。这些复杂的操作封装起来。对外只暴露数据变会的回调通知和设置数值/获取数值的方法即可。</p>
<p>别人拿到你的控件，不关心怎么实现，只关心使用即可。</p>

        <h3 id="自定义View例子"   >
          <a href="#自定义View例子" class="heading-link"><i class="fas fa-link"></i></a>自定义View例子</h3>
      <p>自定义View，什么是View，从控件的角度来理解，我们可以这样判断。如果控件里没有孩子的，没有子View的，就是View，比如说<code>Button</code>,<code>TextView</code>,<code>ProgressBar</code>,<code>ImageView</code>,这些都是<code>View</code>.</p>

        <h3 id="自定义ViewGroup例子"   >
          <a href="#自定义ViewGroup例子" class="heading-link"><i class="fas fa-link"></i></a>自定义ViewGroup例子</h3>
      <p>自定义ViewGrop，什么是ViewGroup,用来包含孩子的，控制子View的摆放的，是容器。ViewGrop里还可以包含着ViewGroup和View。比如说，LinearLayout,RetiveLayout,RecyclerView,ListView,ViewPager…这些都是ViewGrop。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/12/multitype/">Android 复杂的列表视图新写法 MultiType</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/2020/06/12/multitype/" data-flag-title="Android 复杂的列表视图新写法 MultiType"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id="Android-复杂的列视图新写法-MultiType"   >
          <a href="#Android-复杂的列视图新写法-MultiType" class="heading-link"><i class="fas fa-link"></i></a>Android 复杂的列视图新写法 MultiType</h1>
      
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a>前言</h1>
      <p>在开发我的 <strong><span class="exturl"><a class="exturl__link"   href="https://github.com/drakeet/TimeMachine"  target="_blank" rel="noopener">TimeMachine</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong> 时，我有一个复杂的聊天页面，于是我设计了我的类型池系统，它是完全解耦的，因此我能够轻松将它抽离出来分享，并给它取名为 <strong>MultiType</strong>.</p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/06/12/multitype/"><span class="post-readmore__text">Read More</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="http://q1.qlogo.cn/g?b=qq&amp;nk=2391624941&amp;s=640" alt="avatar"></div><p class="sidebar-ov-author__text">人亦有言，举棋不定</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">25</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Apocalypse</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'GpGkfBlXUXHdzTB4tqH7SPnb-gzGzoHsz',
    appKey: 'FihoucantYlc5U1FQ9BzkO3l',
    notify: true,
    verify: true,
    placeholder: 'Just go go',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: '' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.0.1"></script><script src="/js/stun-boot.js?v=2.0.1"></script><script src="/js/scroll.js?v=2.0.1"></script><script src="/js/header.js?v=2.0.1"></script><script src="/js/sidebar.js?v=2.0.1"></script></body></html>